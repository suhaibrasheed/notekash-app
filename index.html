<!DOCTYPE html>
<html lang="en" data-theme="sepia">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">

    <title>Smart AI Notes & Flashcards</title>
    <meta name="description"
        content="Master any subject with NoteKash. The best free offline note-taking app with built-in spaced repetition flashcards, AI co-pilot, visual mind maps, and active recall tools. Build your second brain today especially for UPSC exams.">
    <meta name="keywords"
        content="flashcard note taking app, spaced repetition app, AI note taker, active recall tool, offline second brain, free study app, visual knowledge graph, NoteKash">
    <meta name="author" content="NoteKash Team">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://notekash.com/" />
    <meta property="og:title" content="NoteKash - Turn Notes into Knowledge">
    <meta property="og:description"
        content="Stop forgetting what you read. Use NoteKash to turn notes into flashcards instantly with AI. Offline, Private, and Powerful.">
    <meta property="og:image" content="https://notekash.com/icons/social-preview.png">
    <meta property="og:url" content="https://notekash.com/">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="NoteKash">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="NoteKash | AI Flashcard Note App">
    <meta name="twitter:description"
        content="Write notes, generate flashcards automatically, and master your studies with Spaced Repetition. Try NoteKash for free.">
    <meta name="twitter:image" content="https://notekash.com/icons/social-preview.png">

    <link rel="manifest" href="manifest.json">

    <meta name="theme-color" content="#704214">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="apple-touch-icon" href="icons/icon-512x512.png">
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@graph": [
        {
          "@type": "SoftwareApplication",
          "name": "NoteKash",
          "operatingSystem": "Web, Android, iOS, Windows, Mac",
          "applicationCategory": "ProductivityApplication",
          "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
          },
          "description": "A powerful offline note-taking app that integrates spaced repetition flashcards, AI assistance, and visual mapping for effective learning.",
          "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "4.9",
            "ratingCount": "150"
          },
          "featureList": "Spaced Repetition System (SRS), AI Flashcard Generation, Offline First, Visual Mind Maps, Markdown Support"
        },
        {
          "@type": "Organization",
          "name": "NoteKash",
          "url": "https://notekash.com",
          "logo": "https://notekash.com/icons/icon-512x512.png",
          "sameAs": [
            "https://twitter.com/notekash",
            "https://github.com/notekash"
          ]
        }
      ]
    }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.10/pdfmake.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.10/vfs_fonts.min.js"></script>

    <link
        href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Satisfy&family=Pacifico&family=Lobster&family=Patrick+Hand&family=Shadows+Into+Light&family=Great+Vibes&family=Dancing+Script&family=Caveat:wght@400;700&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script type="module" src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mozilla/readability@0.5.0/Readability.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />
    <script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KGXNNGWKEX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-KGXNNGWKEX');
    </script>

    <style>
        .seo-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* --- Selection Highlight --- */
        ::selection {
            background-color: #ff0055;
            color: #ffffff;
            text-shadow:
                0 0 8px rgba(255, 0, 85, 0.4),
                0 1px 2px rgba(0, 0, 0, 0.3);
        }

        ::-webkit-selection {
            background-color: #ff0055;
            color: #ffffff;
            text-shadow:
                0 0 8px rgba(255, 0, 85, 0.4),
                0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* ==========================================================================
         1. STYLES & THEMING (v2 SUPERTAGS UPDATE)
         ========================================================================== */
        :root {
            /* --- Base & Layout --- */
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e9ecef;
            --bg-primary-rgb: 248, 249, 250;
            --bg-secondary-rgb: 255, 255, 255;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --text-tertiary: #adb5bd;
            --text-on-primary: #ffffff;
            --border-color: #dee2e6;
            --primary-color: #0d9488;
            --primary-color-hover: #0f766e;
            --primary-color-rgb: 74, 85, 104;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --danger-color: #dc3545;
            --danger-color-hover: #b02a37;
            --success-color: #198754;
            --warning-color: #ffc107;
            --text-warning: #000;
            --font-body: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            --font-serif: Georgia, 'Times New Roman', Times, serif;
            --font-display: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --spacing-unit: 8px;
            --border-radius: 8px;
            --border-radius-lg: 16px;
            --transition-fast: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --article-font-family: Georgia, serif;
            --article-font-size: 1.15rem;
            --article-line-height: 1.7;
            --ui-opacity: 1.0;
            --blur-intensity: 8px;

            /* --- Light Theme Colors --- */
            --hl-1-bg: #fef08a;
            --hl-1-border: #facc15;
            --hl-2-bg: #dcfce7;
            --hl-2-border: #4ade80;
            --hl-3-bg: #dceffc;
            --hl-3-border: #38bdf8;
            --hl-4-bg: #ffd6d6;
            --hl-4-border: #f87171;
            --hl-5-bg: #fae8ff;
            --hl-5-border: #e879f9;
            --hl-6-bg: #dcdcff;
            --hl-6-border: #828ffe;
            --hl-7-bg: #fae8ff;
            --hl-7-border: #c026d3;
            /* SuperTag Rendered */
            --hl-text: #1f2937;
            --text-red: #D32F2F;
            --text-green: #26902c;
            --text-blue: #0f72d5;
            --text-magenta: #c026d3;
            --text-orange: #f97316;
            --text-teal: #1eb4dd;
            --text-slate: #c5a019;
            /* --- Category, SM2 & Hub Colors --- */
            /* --- A. Unified Text Color (Light Theme) --- */
            --category-pill-text: #1f2937;
            /* --- B. Indexed Background Palette (Light Theme) --- */
            --cat-color-0-bg: #f3f4f6;
            --cat-color-1-bg: #a7f3d0;
            --cat-color-2-bg: #fed7aa;
            --cat-color-3-bg: #c7d2fe;
            --cat-color-4-bg: #bfdbfe;
            --cat-color-5-bg: #fecaca;
            --cat-color-6-bg: #bae6fd;
            --cat-color-7-bg: #d9f99d;
            --cat-color-8-bg: #fef08a;
            --cat-color-9-bg: #e9d5ff;
            --cat-color-10-bg: #fbcfe8;
            --cat-color-11-bg: #e2e8f0;
            --cat-color-12-bg: #d1d5db;
            --cat-color-13-bg: #fda4af;
            --cat-color-14-bg: #86efac;
            --cat-color-15-bg: #fbbf24;
            --cat-color-16-bg: #a5b4fc;
            --cat-color-17-bg: #f472b6;
            --cat-color-18-bg: #99f6e4;
            --cat-color-19-bg: #fde68a;
            --action-button-gradient: linear-gradient(135deg, #14b8a6, #0d9488);



            --sm2-red: #a3002e;
            --sm2-orange: #f87355;
            --sm2-purple: #a855f7;
            --sm2-skyblue: #43c1f8;
            --sm2-green: #22c55e;
            --sm2-unrated: #adb5bd;
            --text-on-sm2: #ffffff;
            --priority-high: #dc3545;
            --priority-medium: #0d6efd;
            --priority-low: #198754;
            --pomo-color-1: #ef4444;
            --pomo-color-2: #f97316;
            --pomo-color-3: #f59e0b;
            --pomo-color-4: #eab308;
            --pomo-color-5: #84cc16;
            --pomo-color-6: #22c55e;
            --pomo-color-7: #10b981;
            --pomo-color-8: #14b8a6;
            --pomo-color-9: #06b6d4;
            --pomo-color-10: #3b82f6;
            --pomo-color-11: #6366f1;
            --pomo-color-12: #8b5cf6;
            --cycle-color-1: #3b82f6;
            --cycle-color-2: #16a34a;
            --cycle-color-3: #f97316;
            --cycle-color-4: #8b5cf6;
            --break-color: #0891b2;
            --heat-0: var(--bg-tertiary);
            --heat-1: #6c757d;
            --heat-2: #ef4444;
            --heat-3: #f97316;
            --heat-4: #8b5cf6;
            --heat-5: #3b82f6;
            --heat-6: #22c55e;

            /* --- Flashcard Base --- */
            --cloze-bg: rgba(187, 247, 208, 0.5);
            --cloze-border: #28a745;
            --cloze-revealed-text: #388E3C;
            --cloze-hidden-text: #D32F2F;

            /* --- Visual Map Base --- */
            --node-text-color: #343a40;
            --node-category: #fd7e14;
            --node-tag: #0d6efd;
            --node-article: #198754;
            --node-orphan: #6c757d;
            --node-article-duplicate: #20c997;
            --search-highlight-bg: #f59e0b;
            --mindmap-snippet-bg: #fef08a;
            --mindmap-snippet-border: #facc15;
            /* --- Read Counter Progression --- */
            --rc-0-gray: #adb5bd;
            --rc-1-red: #d90429;
            --rc-2-orange: #f46d43;
            --rc-3-pink: #ec4899;
            --rc-4-purple: #a855f7;
            --rc-5-indigo: #6366f1;
            --rc-6-teal: #14b8a6;
            --rc-7-green-light: #a3e635;
            --rc-8-green-med: #22c55e;
            --rc-9-green-bright: #15803d;
            --rc-10-green-best: #059669;
            /* --- Mindmap Palettes Light --- */
            --mindmap-c1-root: #d00000;
            --mindmap-c1-child-bg: #ffcdd2;
            --mindmap-c1-child-text: #212529;
            --mindmap-c2-root: #4361ee;
            --mindmap-c2-child-bg: #e3f2fd;
            --mindmap-c2-child-text: #212529;
            --mindmap-c3-root: #55a630;
            --mindmap-c3-child-bg: #e8f5e9;
            --mindmap-c3-child-text: #212529;
            --mindmap-c4-root: #f77f00;
            --mindmap-c4-child-bg: #fff3e0;
            --mindmap-c4-child-text: #212529;
            --mindmap-c5-root: #7209b7;
            --mindmap-c5-child-bg: #f3e5f5;
            --mindmap-c5-child-text: #212529;
            --mindmap-c6-root: #00897b;
            --mindmap-c6-child-bg: #e0f2f1;
            --mindmap-c6-child-text: #212529;
            --mindmap-c7-root: #d81b60;
            --mindmap-c7-child-bg: #f8bbd0;
            --mindmap-c7-child-text: #212529;
            --mindmap-c8-root: #039be5;
            --mindmap-c8-child-bg: #b3e5fc;
            --mindmap-c8-child-text: #212529;
            --mindmap-c9-root: #e65100;
            --mindmap-c9-child-bg: #ffccbc;
            --mindmap-c9-child-text: #212529;
            --mindmap-c10-root: #5e35b1;
            --mindmap-c10-child-bg: #d1c4e9;
            --mindmap-c10-child-text: #212529;
            --mindmap-c11-root: #37474f;
            --mindmap-c11-child-bg: #cfd8dc;
            --mindmap-c11-child-text: #212529;
            --mindmap-c12-root: #c2185b;
            --mindmap-c12-child-bg: #f48fb1;
            --mindmap-c12-child-text: #212529;
            --mindmap-c13-root: #00796b;
            --mindmap-c13-child-bg: #b2dfdb;
            --mindmap-c13-child-text: #212529;
            --mindmap-c14-root: #afb42b;
            --mindmap-c14-child-bg: #f0f4c3;
            --mindmap-c14-child-text: #212529;
            --mindmap-c15-root: #f57c00;
            --mindmap-c15-child-bg: #ffe0b2;
            --mindmap-c15-child-text: #212529;

            /* --- Sticky Notes Light --- */
            --sticky-light-default-bg: #ffffff;
            --sticky-light-default-text: #212529;
            --sticky-light-crimson-bg: #fee2e2;
            --sticky-light-crimson-text: #7f1d1d;
            --sticky-light-tangerine-bg: #ffedd5;
            --sticky-light-tangerine-text: #7c2d12;
            --sticky-light-sunflower-bg: #fef9c3;
            --sticky-light-sunflower-text: #713f12;
            --sticky-light-lime-bg: #ecfccb;
            --sticky-light-lime-text: #365314;
            --sticky-light-forest-bg: #dcfce7;
            --sticky-light-forest-text: #14532d;
            --sticky-light-azure-bg: #e0f2fe;
            --sticky-light-azure-text: #0c4a6e;
            --sticky-light-indigo-bg: #e0e7ff;
            --sticky-light-indigo-text: #312e81;
            --sticky-light-amethyst-bg: #f5d0fe;
            --sticky-light-amethyst-text: #6b21a8;
            --sticky-light-lavender-bg: #f3e8ff;
            --sticky-light-lavender-text: #581c87;
            --sticky-light-fuchsia-bg: #fce7f3;
            --sticky-light-fuchsia-text: #831843;
            --sticky-light-blush-bg: #fff1f2;
            --sticky-light-blush-text: #9f1239;
            --sticky-light-terracotta-bg: #fae8ff;
            --sticky-light-terracotta-text: #701a75;
            --sticky-light-teal-bg: #d6feec;
            --sticky-light-teal-text: #115e59;
            --sticky-light-slate-bg: #f1f5f9;
            --sticky-light-slate-text: #1e293b;
            --sticky-light-olive-bg: #f7fee7;
            --sticky-light-olive-text: #3f6212;


            /* Textile Color Styles (Light Theme) */
            --textile-bg-1: rgba(243, 232, 255, 0.85);
            --textile-border-1: #a855f7;
            --textile-text-1: #7c3aed;
            --textile-bg-2: rgba(220, 252, 231, 0.85);
            --textile-border-2: #22c55e;
            --textile-text-2: #16a34a;
            --textile-bg-3: rgba(254, 249, 195, 0.85);
            --textile-border-3: #eab308;
            --textile-text-3: #a16207;
            --textile-bg-4: rgba(254, 226, 226, 0.85);
            --textile-border-4: #f87171;
            --textile-text-4: #dc2626;
            --textile-bg-5: rgba(224, 242, 254, 0.85);
            --textile-border-5: #38bdf8;
            --textile-text-5: #0284c7;
            --textile-bg-6: rgba(255, 237, 213, 0.85);
            --textile-border-6: #fb923c;
            --textile-text-6: #ea580c;
            --textile-bg-7: rgba(243, 244, 246, 0.85);
            --textile-border-7: #9ca3af;
            --textile-text-7: #4b5563;
            --textile-bg-8: rgba(254, 202, 202, 0.85);
            --textile-border-8: #ef4444;
            --textile-text-8: #b91c1c;
            --textile-bg-9: rgba(199, 210, 254, 0.85);
            --textile-border-9: #6366f1;
            --textile-text-9: #4f46e5;


            /* --- NEW: Unified Article Font System --- */
            :is(.library-title, .card-title, .article-title-input, .focus-mode-title,
                .snippet, .flashcard-tile-content, .study-card-content-box,
                .focus-mode-body, .result-text, .sticky-note-content,
                .mindmap-node .node-html-content,
                .nk-text-tile-content, .nk-accordion-title, .nk-accordion-content,
                .nk-timeline-title, .nk-timeline-date, .nk-mcq-question, .nk-mcq-option-text,
                .article-metadata-bar, .card-footer, [placeholder],
                .category-chip, .flashcard-view-header .btn, .tag-item,
                .node-text,
                .sticky-note-header h5,
                .upsell-content, .upsell-cta, .premium-cta-text,
                .tag-modal h3,
                .tag-modal-article-title,
                .task-title, .pomodoro-task-title, .notification-header, .notification-message,
                .ascension-modal .witty-gradient-text) {
                font-family: var(--article-font-family);
            }

            :is(#library-view,
                #flashcard-view,
                #tags-view,
                #category-view,
                .pomodoro-meta,
                .ascension-modal) :is(.btn, .category-chip, .tag-item, .ascension-card) {
                font-family: var(--article-font-family);
            }

            /*  UI Font Override System */
            :is(.btn, .text-input, select,
                .modal-content h3, .ascension-card-name,
                .ascension-card-duration, .ascension-features,
                .license-form-grid label,
                header, .article-controls, .stage-mode-controls) {
                font-family: var(--font-body);
            }

            flashcard-tile-content {
                font-size: calc(var(--article-font-size) * 0.9);
            }

            .node-text {
                font-size: calc(var(--article-font-size) * 0.6);
            }

            .snippet {
                font-size: calc(var(--article-font-size) * 0.95);
            }

            .sticky-note-content {
                font-size: calc(var(--article-font-size) * 0.6);
            }


        }

        [data-theme="dark"] {
            --bg-primary: #0D1117;
            --bg-secondary: #161B22;
            --bg-tertiary: #21262D;
            --bg-primary-rgb: 13, 17, 23;
            --bg-secondary-rgb: 22, 27, 34;
            --text-primary: #e7e5cf;
            --text-secondary: #8B949E;
            --text-tertiary: #6E7681;
            --border-color: #30363D;
            --primary-color: #E0B453;
            --primary-color-hover: #F7C96D;
            --primary-color-rgb: 88, 166, 255;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            --danger-color: #f87171;
            --danger-color-hover: #ef4444;
            --success-color: #22c55e;
            --warning-color: #f59e0b;
            --hl-text: #f9fafb;
            --hl-1-bg: #503C11;
            --hl-1-border: #daa724;
            --hl-2-bg: #1c492e;
            --hl-2-border: #1ebb58;
            --hl-3-bg: #161c93;
            --hl-3-border: #307df7;
            --hl-4-bg: #7f1d1d;
            --hl-4-border: #cc3737;
            --hl-5-bg: #581c87;
            --hl-5-border: #9347da;
            --hl-6-bg: #0c5876;
            --hl-6-border: #0b8fcd;
            --hl-7-bg: #701a75;
            --hl-7-border: #d946ef;
            --text-red: #ff4830;
            --text-green: #2cfb3e;
            --text-blue: #906eff;
            --text-magenta: #e84fff;
            --text-orange: #ff9934;
            --text-teal: #0effef;
            --text-slate: #fcf006;
            --cat-tags: #f8f9fa;
            --cat-science: #22d3ee;
            --cat-society: #a78bfa;
            --cat-history: #fb923c;
            --cat-geography: #34d399;
            --cat-opinion: #1c65aa;
            --cat-misc: #90a4ae;
            --cloze-bg: rgba(22, 101, 52, 0.4);
            --cloze-border: #28a745;
            --cloze-revealed-text: #6ee7b7;
            --cloze-hidden-text: #fca5a5;
            --sm2-unrated: #6b7280;
            --priority-high: #f87171;
            --priority-medium: #60a5fa;
            --priority-low: #34d399;
            --cycle-color-1: #60a5fa;
            --cycle-color-2: #34d399;
            --cycle-color-3: #fb923c;
            --cycle-color-4: #a78bfa;
            --break-color: #22d3ee;
            --heat-0: #374151;
            --heat-1: #9ca3af;
            --heat-2: #f87171;
            --heat-3: #fb923c;
            --heat-4: #a78bfa;
            --heat-5: #60a5fa;
            --heat-6: #34d399;
            /* --- A. Unified Text Color (Dark Theme) --- */
            --category-pill-text: #f0f6fc;
            /* --- B. Indexed Background Palette (Dark Theme) --- */
            --cat-color-0-bg: #4b5563;
            --cat-color-1-bg: #059669;
            --cat-color-2-bg: #b45309;
            --cat-color-3-bg: #6d28d9;
            --cat-color-4-bg: #2563eb;
            --cat-color-5-bg: #be123c;
            --cat-color-6-bg: #0e7490;
            --cat-color-7-bg: #4d7c0f;
            --cat-color-8-bg: #d97706;
            --cat-color-9-bg: #a21caf;
            --cat-color-10-bg: #7e22ce;
            --cat-color-11-bg: #1e40af;
            --cat-color-12-bg: #374151;
            --cat-color-13-bg: #991b1b;
            --cat-color-14-bg: #166534;
            --cat-color-15-bg: #9a3412;
            --cat-color-16-bg: #4338ca;
            --cat-color-17-bg: #9d174d;
            --cat-color-18-bg: #0f766e;
            --cat-color-19-bg: #b45309;
            --action-button-gradient: linear-gradient(45deg, #E0B453, #E6845E, #C159A1);


            /* --- Visual Map Dark --- */
            --node-text-color: #c9d1d9;
            --node-category: #f59e0b;
            --node-tag: #58a6ff;
            --node-article: #2ea043;
            --node-orphan: #8B949E;
            --node-article-duplicate: #39d353;
            --mindmap-snippet-bg: #4d441d;
            --mindmap-snippet-border: #a16207;

            /* --- Read Counter Progression --- */
            --rc-0-gray: #6b7280;
            --rc-1-red: #f87171;
            --rc-2-orange: #fb923c;
            --rc-3-pink: #f472b6;
            --rc-4-purple: #c084fc;
            --rc-5-indigo: #818cf8;
            --rc-6-teal: #2dd4bf;
            --rc-7-green-light: #bef264;
            --rc-8-green-med: #4ade80;
            --rc-9-green-bright: #22c55e;
            --rc-10-green-best: #34d399;
            /* --- Mindmap Palettes Dark --- */
            --mindmap-c1-root: #ff4d6d;
            --mindmap-c1-child-bg: #4d1924;
            --mindmap-c1-child-text: #f0f6fc;
            --mindmap-c2-root: #58a6ff;
            --mindmap-c2-child-bg: #1d3c5a;
            --mindmap-c2-child-text: #f0f6fc;
            --mindmap-c3-root: #39d353;
            --mindmap-c3-child-bg: #1a4d4a;
            --mindmap-c3-child-text: #f0f6fc;
            --mindmap-c4-root: #f59e0b;
            --mindmap-c4-child-bg: #6b320a;
            --mindmap-c4-child-text: #f0f6fc;
            --mindmap-c5-root: #c37aff;
            --mindmap-c5-child-bg: #3a2a5a;
            --mindmap-c5-child-text: #f0f6fc;
            --mindmap-c6-root: #48e9d9;
            --mindmap-c6-child-bg: #0a5246;
            --mindmap-c6-child-text: #f0f6fc;
            --mindmap-c7-root: #f06292;
            --mindmap-c7-child-bg: #5c1a35;
            --mindmap-c7-child-text: #f0f6fc;
            --mindmap-c8-root: #4fc3f7;
            --mindmap-c8-child-bg: #014664;
            --mindmap-c8-child-text: #f0f6fc;
            --mindmap-c9-root: #ff9800;
            --mindmap-c9-child-bg: #663c00;
            --mindmap-c9-child-text: #f0f6fc;
            --mindmap-c10-root: #9575cd;
            --mindmap-c10-child-bg: #322550;
            --mindmap-c10-child-text: #f0f6fc;
            --mindmap-c11-root: #90a4ae;
            --mindmap-c11-child-bg: #2c3336;
            --mindmap-c11-child-text: #f0f6fc;
            --mindmap-c12-root: #ec407a;
            --mindmap-c12-child-bg: #5d1930;
            --mindmap-c12-child-text: #f0f6fc;
            --mindmap-c13-root: #26a69a;
            --mindmap-c13-child-bg: #003d36;
            --mindmap-c13-child-text: #f0f6fc;
            --mindmap-c14-root: #d4e157;
            --mindmap-c14-child-bg: #525722;
            --mindmap-c14-child-text: #f0f6fc;
            --mindmap-c15-root: #ffa726;
            --mindmap-c15-child-bg: #66420f;
            --mindmap-c15-child-text: #f0f6fc;

            /* --- Sticky Notes Dark --- */
            --sticky-dark-default-bg: #1D2229;
            --sticky-dark-default-text: #f0f6fc;
            --sticky-dark-crimson-bg: #450a0a;
            --sticky-dark-crimson-text: #fecaca;
            --sticky-dark-tangerine-bg: #431407;
            --sticky-dark-tangerine-text: #ffedd5;
            --sticky-dark-sunflower-bg: #422006;
            --sticky-dark-sunflower-text: #fef08a;
            --sticky-dark-lime-bg: #1a2e05;
            --sticky-dark-lime-text: #d9f99d;
            --sticky-dark-forest-bg: #062813;
            --sticky-dark-forest-text: #dcfce7;
            --sticky-dark-azure-bg: #082f49;
            --sticky-dark-azure-text: #e0f2fe;
            --sticky-dark-indigo-bg: #1e1b4b;
            --sticky-dark-indigo-text: #c7d2fe;
            --sticky-dark-amethyst-bg: #2e1046;
            --sticky-dark-amethyst-text: #f5d0fe;
            --sticky-dark-lavender-bg: #3b0764;
            --sticky-dark-lavender-text: #f3e8ff;
            --sticky-dark-fuchsia-bg: #500724;
            --sticky-dark-fuchsia-text: #fbcfe8;
            --sticky-dark-blush-bg: #581c22;
            --sticky-dark-blush-text: #fff1f2;
            --sticky-dark-terracotta-bg: #4a044e;
            --sticky-dark-terracotta-text: #fae8ff;
            --sticky-dark-teal-bg: #042f2e;
            --sticky-dark-teal-text: #ccfbf1;
            --sticky-dark-slate-bg: #334155;
            --sticky-dark-slate-text: #f1f5f9;
            --sticky-dark-olive-bg: #1c3202;
            --sticky-dark-olive-text: #e7f5d0;





            /*  Textile Color Styles (Dark Theme) */
            --textile-bg-1: rgba(46, 16, 70, 0.75);
            --textile-border-1: #c084fc;
            --textile-text-1: #d8b4fe;
            --textile-bg-2: rgba(22, 51, 34, 0.75);
            --textile-border-2: #4ade80;
            --textile-text-2: #86efac;
            --textile-bg-3: rgba(66, 32, 6, 0.75);
            --textile-border-3: #facc15;
            --textile-text-3: #fde047;
            --textile-bg-4: rgba(69, 10, 10, 0.75);
            --textile-border-4: #f87171;
            --textile-text-4: #fca5a5;
            --textile-bg-5: rgba(30, 41, 59, 0.75);
            --textile-border-5: #38bdf8;
            --textile-text-5: #7dd3fc;
            --textile-bg-6: rgba(67, 20, 7, 0.75);
            --textile-border-6: #f97316;
            --textile-text-6: #fdba74;
            --textile-bg-7: rgba(55, 65, 81, 0.75);
            --textile-border-7: #9ca3af;
            --textile-text-7: #d1d5db;
            --textile-bg-8: rgba(69, 10, 10, 0.75);
            --textile-border-8: #ef4444;
            --textile-text-8: #fca5a5;
            --textile-bg-9: rgba(30, 27, 75, 0.75);
            --textile-border-9: #818cf8;
            --textile-text-9: #a5b4fc;


        }

        [data-theme="sepia"] {
            --bg-primary: #f4e9d8;
            --bg-secondary: #fbf0d9;
            --bg-tertiary: #e9dbbf;
            --bg-primary-rgb: 244, 233, 216;
            --bg-secondary-rgb: 251, 240, 217;
            --text-primary: #5b4636;
            --text-secondary: #7a6a57;
            --border-color: #dcd0b3;
            --primary-color: #8c6d46;
            --primary-color-hover: #73552a;
            --primary-color-rgb: 140, 109, 70;
            --shadow: 0 2px 8px rgba(91, 70, 54, 0.1);
            --danger-color: #c76a6a;
            --danger-color-hover: #a14949;
            --hl-text: #2c2a1a;
            --hl-1-bg: #fde68a;
            --hl-1-border: #eab308;
            --hl-2-bg: #bbf7d0;
            --hl-2-border: #15803d;
            --hl-3-bg: #c4ddfc;
            --hl-3-border: #1d4ed8;
            --hl-4-bg: #fecaca;
            --hl-4-border: #ef4444;
            --hl-5-bg: #e9d5ff;
            --hl-5-border: #8b27e3;
            --hl-6-bg: #a3eff9;
            --hl-6-border: #07bada;
            --hl-7-bg: #f3e8ff;
            --hl-7-border: #a855f7;
            --text-red: #ab0404;
            --text-green: #15803d;
            --text-blue: #2563eb;
            --text-magenta: #9333ea;
            --text-orange: #dc7208;
            --text-teal: #0693be;
            --text-slate: #c59b1e;
            --cloze-bg: rgba(204, 238, 204, 0.5);
            --cloze-border: #28a745;
            --cloze-revealed-text: #166534;
            --cloze-hidden-text: #c2410c;
            --sm2-unrated: #101010;
            --sticky-sepia-default: #fbf0d9;
            /* --- A. Unified Text Color (Sepia Theme) --- */
            --category-pill-text: #442d1e;
            --cat-color-0-bg: #d7ccc8;
            --cat-color-1-bg: #a5d6a7;
            --cat-color-2-bg: #ffcc80;
            --cat-color-3-bg: #b39ddb;
            --cat-color-4-bg: #90caf9;
            --cat-color-5-bg: #ef9a9a;
            --cat-color-6-bg: #80deea;
            --cat-color-7-bg: #c5e1a5;
            --cat-color-8-bg: #ffe082;
            --cat-color-9-bg: #ce93d8;
            --cat-color-10-bg: #f48fb1;
            --cat-color-11-bg: #b0bec5;
            --cat-color-12-bg: #a1887f;
            --cat-color-13-bg: #ef5350;
            --cat-color-14-bg: #66bb6a;
            --cat-color-15-bg: #ffa726;
            --cat-color-16-bg: #7986cb;
            --cat-color-17-bg: #ec407a;
            --cat-color-18-bg: #26a69a;
            --cat-color-19-bg: #ffca28;
            --action-button-gradient: linear-gradient(45deg, #8c6d46, #704214);

            /* Textile Color Styles (Sepia Theme) */
            --textile-bg-1: rgba(235, 220, 205, 0.9);
            --textile-border-1: #a855f7;
            --textile-text-1: #6b21a8;
            --textile-bg-2: rgba(220, 240, 220, 0.9);
            --textile-border-2: #16a34a;
            --textile-text-2: #15803d;
            --textile-bg-3: rgba(254, 243, 199, 0.9);
            --textile-border-3: #d97706;
            --textile-text-3: #92400e;
            --textile-bg-4: rgba(252, 220, 220, 0.9);
            --textile-border-4: #dc2626;
            --textile-text-4: #b91c1c;
            --textile-bg-5: rgba(219, 234, 254, 0.9);
            --textile-border-5: #2563eb;
            --textile-text-5: #1d4ed8;
            --textile-bg-6: rgba(254, 230, 200, 0.9);
            --textile-border-6: #ea580c;
            --textile-text-6: #c2410c;
            --textile-bg-7: rgba(231, 229, 228, 0.9);
            --textile-border-7: #78716c;
            --textile-text-7: #44403c;
            --textile-bg-8: rgba(254, 210, 210, 0.9);
            --textile-border-8: #dc2626;
            --textile-text-8: #991b1b;
            --textile-bg-9: rgba(224, 220, 252, 0.9);
            --textile-border-9: #4f46e5;
            --textile-text-9: #3730a3;

        }

        [data-theme="sepia"] .sticky-note-tile.color-default {
            background-color: var(--sticky-sepia-default);
        }

        /* Hover effect over icons */
        [data-theme="light"] header .btn-icon {
            color: #6c757d;
            transition: color 0.2s ease-in-out;
        }

        [data-theme="light"] header .btn-icon:hover {
            color: var(--primary-color);
        }

        [data-theme="dark"] header .btn-icon {
            color: #9ca3af;
            transition: color 0.2s ease-in-out;
        }

        [data-theme="dark"] header .btn-icon:hover {
            color: var(--primary-color);
        }

        [data-theme="sepia"] header .btn-icon {
            color: #9a6729;
            transition: color 0.2s ease-in-out;
        }

        [data-theme="sepia"] header .btn-icon:hover {
            color: #af6000;
        }


        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background-color: var(--border-color);
            border-radius: 10px;
            border: 2px solid var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--text-secondary);
        }

        :root.zero-opacity-active[data-theme="light"] .modal-backdrop .ui-card,
        :root.zero-opacity-active[data-theme="sepia"] .modal-backdrop .ui-card {
            --text-primary: #f8f9fa;
            --text-secondary: #adb5bd;
            --border-color: #495057;
            --primary-color: #79B8FF;
        }

        :root.zero-opacity-active[data-theme="light"] .modal-backdrop .ui-card .text-input,
        :root.zero-opacity-active[data-theme="sepia"] .modal-backdrop .ui-card .text-input {
            background-color: rgba(0, 0, 0, 0.2);
            border-color: var(--border-color);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(5px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes growInFromCenter {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes slideOutRight {
            from {
                opacity: 1;
                transform: translateX(0);
            }

            to {
                opacity: 0.5;
                transform: translateX(40px);
            }
        }

        .task-item.exiting {
            animation: slideOutRight 0.4s ease-out forwards;
        }

        @keyframes confetti-blast {
            0% {
                opacity: 1;
                transform: translateY(0) rotate(0deg);
            }

            100% {
                opacity: 0;
                transform: translateY(100px) rotate(360deg);
            }
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .spin {
            animation: spin 1s linear infinite;
        }

        #app-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background-size: cover;
            background-position: center;
            transition: background-image 0.5s ease-in-out;
        }

        body.image-theme-active {
            --bg-primary: transparent;
        }

        .ui-card {
            background-color: rgba(var(--bg-secondary-rgb), var(--ui-opacity));
            backdrop-filter: blur(var(--blur-intensity));
            -webkit-backdrop-filter: blur(var(--blur-intensity));
            transition: background-color 0.2s, backdrop-filter 0.2s;
            border-radius: var(--border-radius);
        }

        #the-line-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            z-index: 10000;
            background-color: var(--bg-tertiary);
        }

        #the-line {
            width: 100%;
            height: 100%;
            background-color: var(--primary-color);
            transform-origin: left;
            transform: scaleX(0);
            transition: transform 0.2s linear;
        }

        * {
            box-sizing: border-box;
        }

        [data-theme="light"] #the-line {
            background: linear-gradient(90deg, #FF8C42 0%, #FFD05A 35%, #00A896 55%, #A2E869 75%, #05A387 100%);
        }

        [data-theme="dark"] #the-line {
            background: linear-gradient(90deg, #E0B453 0%, #E6845E 50%, #C159A1 100%);
        }

        [data-theme="sepia"] #the-line {
            background: linear-gradient(90deg, #8c6d46 0%, #C2A582 50%, #704214 100%);
        }


        html {
            scroll-behavior: smooth;
        }

        .view.active {
            padding: 1rem;
        }

        .article-grid {
            gap: calc(var(--spacing-unit) * 2.5);
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: calc(var(--spacing-unit) * 4);
        }

        .view {
            display: none;
        }

        .view.active {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }

        .header-main-actions,
        .header-overflow-actions,
        .header-fixed-actions {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* SPLIT SCREEN STYLES  */
        #split-screen-overlay {
            display: none;
            position: fixed;
            top: 48px;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 900;
            background: var(--bg-primary);
        }

        #split-screen-overlay.active {
            display: flex;
            flex-direction: row;
            gap: 0;
        }

        @media (max-width: 612px) {
            #split-screen-overlay.active {
                flex-direction: column;
            }
        }

        .split-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--bg-primary);
            border: none;
            margin: 0;
        }

        .split-panel:first-child {
            border-right: 1px solid var(--border-color);
        }

        @media (max-width: 612px) {
            .split-panel {
                min-height: 0;
            }

            .split-panel:first-child {
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }
        }

        .split-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            height: 28px;
            min-height: 28px;
            flex-shrink: 0;
            gap: 8px;
        }

        .split-panel-header select {
            padding: 2px 20px 2px 6px;
            border: none;
            border-radius: 4px;
            background: transparent;
            color: var(--text-primary);
            font-size: 0.75rem;
            cursor: pointer;
            font-weight: 600;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 4px center;
            max-width: 100px;
        }

        .split-panel-header select:hover {
            background-color: var(--bg-tertiary);
        }

        .split-panel-header select:focus {
            outline: none;
            background-color: var(--bg-tertiary);
        }

        .split-panel-label {
            font-size: 0.65rem;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
            opacity: 0.7;
        }

        .split-panel-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .split-panel-content iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: var(--bg-primary);
        }

        .split-resize-handle {
            background: transparent;
            cursor: ew-resize;
            width: 5px;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
        }

        .split-resize-handle::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;
            width: 1px;
            background: var(--border-color);
            transform: translateX(-50%);
        }

        .split-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 32px;
            background: var(--text-tertiary);
            border-radius: 2px;
            opacity: 0.4;
            transition: all 0.2s ease;
        }

        @media (max-width: 612px) {
            .split-resize-handle {
                cursor: ns-resize;
                width: auto;
                height: 5px;
            }

            .split-resize-handle::before {
                top: 50%;
                bottom: auto;
                left: 0;
                right: 0;
                width: auto;
                height: 1px;
                transform: translateY(-50%);
            }

            .split-resize-handle::after {
                width: 32px;
                height: 3px;
            }
        }

        .split-resize-handle:hover::after,
        .split-resize-handle.dragging::after {
            opacity: 1;
            background: var(--primary-color);
            width: 4px;
            height: 48px;
        }

        @media (max-width: 612px) {

            .split-resize-handle:hover::after,
            .split-resize-handle.dragging::after {
                width: 48px;
                height: 4px;
            }
        }

        .split-view-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100%;
            padding: 1.5rem 1rem;
            text-align: center;
            background: linear-gradient(145deg, var(--bg-primary) 0%, color-mix(in srgb, var(--primary-color) 5%, var(--bg-primary)) 100%);
            overflow-y: auto;
            overflow-x: hidden;
        }

        @media (max-width: 612px) {
            .split-view-selector {
                padding: 1rem 0.75rem;
                min-height: 100%;
            }
        }

        .split-view-selector h3 {
            margin: 0 0 0.5rem 0;
            color: var(--text-primary);
            font-size: 1.25rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color, var(--primary-color-hover)));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .split-view-selector p {
            color: var(--text-secondary);
            margin: 0 0 1.5rem 0;
            font-size: 0.9rem;
        }

        /* In-panel search input - enhanced */
        .split-search-container {
            width: 100%;
            max-width: 340px;
            margin-bottom: 1.5rem;
            position: relative;
        }

        .split-search-input {
            width: 100%;
            padding: 14px 18px 14px 44px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            color: var(--text-primary);
            font-size: 0.95rem;
            transition: all 0.25s ease;
        }

        .split-search-input::placeholder {
            color: var(--text-tertiary);
        }

        .split-search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            background: var(--bg-primary);
            box-shadow: 0 0 0 4px color-mix(in srgb, var(--primary-color) 15%, transparent),
                0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .split-search-container svg {
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            color: var(--text-tertiary);
            pointer-events: none;
        }

        /* Search results dropdown - enhanced */
        .split-search-results {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            max-height: 280px;
            overflow-y: auto;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
            z-index: 10;
        }

        .split-search-results:empty {
            display: none;
        }

        .split-search-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px 16px;
            cursor: pointer;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
            transition: background 0.15s ease;
        }

        .split-search-item:last-child {
            border-bottom: none;
        }

        .split-search-item:hover {
            background: color-mix(in srgb, var(--primary-color) 8%, transparent);
        }

        .split-search-empty {
            color: var(--text-tertiary);
            text-align: center;
            padding: 20px 16px;
            font-size: 0.85rem;
        }

        .split-search-text {
            display: flex;
            flex-direction: column;
            gap: 3px;
            min-width: 0;
            flex: 1;
        }

        .split-search-text strong {
            font-size: 0.9rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .split-search-item small {
            color: var(--text-tertiary);
            font-size: 0.75rem;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-clamp: 2;
            overflow: hidden;
        }

        /* View grid - 2 columns, vibrant tiles */
        .split-view-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 14px;
            width: 100%;
            max-width: 340px;
        }

        @media (max-width: 612px) {
            .split-view-grid {
                gap: 10px;
                max-width: 100%;
                padding: 0 4px;
            }
        }

        .split-view-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 28px 18px;
            background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            min-height: 110px;
            position: relative;
            overflow: hidden;
        }

        @media (max-width: 612px) {
            .split-view-option {
                padding: 18px 10px;
                gap: 8px;
                min-height: 85px;
            }

            .split-view-option svg {
                width: 28px;
                height: 28px;
            }

            .split-view-option span {
                font-size: 0.8rem;
            }
        }

        .split-view-option::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, color-mix(in srgb, var(--primary-color) 10%, transparent), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* --- VIDEO EMBEDS --- */
        .nk-video-embed {
            position: relative;
            cursor: default;
            outline: none;
            transition: box-shadow 0.2s;
        }

        .nk-video-embed:focus,
        .nk-video-embed:focus-within {
            box-shadow: 0 0 0 3px var(--primary-color) !important;
        }

        .nk-video-delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 28px;
            height: 28px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            z-index: 20;
            font-size: 14px;
        }

        .nk-video-embed:hover .nk-video-delete-btn,
        .nk-video-embed:focus .nk-video-delete-btn,
        .nk-video-embed:focus-within .nk-video-delete-btn {
            opacity: 1;
        }

        .nk-video-delete-btn:hover {
            background: #ef4444;
            border-color: #ef4444;
            transform: scale(1.1);
        }

        /* --- NEW: Video Alignment Control --- */
        .nk-video-align-btn {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 28px;
            height: 28px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            z-index: 20;
            font-size: 14px;
        }

        .nk-video-embed:hover .nk-video-align-btn,
        .nk-video-embed:focus .nk-video-align-btn,
        .nk-video-embed:focus-within .nk-video-align-btn {
            opacity: 1;
            transform: scale(1.1);
        }

        /* Newspaper Mode (Float Left) */
        .nk-video-embed.align-left {
            float: left !important;
            margin: 0 1.5rem 1rem 0 !important;
            max-width: 100% !important;
            clear: left;
        }

        /* --- MAP EMBEDS --- */
        .nk-map-embed {
            position: relative;
            cursor: default;
            outline: none;
            transition: transform 0.2s cubic-bezier(0.2, 0.8, 0.2, 1), box-shadow 0.2s ease;
            resize: both;
            overflow: hidden;
            min-width: 300px;
            min-height: 200px;
            max-width: 100%;
        }

        .nk-map-embed:hover {
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.18) !important;
        }

        .nk-map-embed:focus,
        .nk-map-embed:focus-within {
            box-shadow: 0 0 0 3px var(--primary-color), 0 12px 40px rgba(0, 0, 0, 0.2) !important;
        }

        /* Theater Mode (Viewport Fullscreen) */
        .nk-map-embed.is-viewport-fullscreen {
            position: fixed !important;
            top: 20px !important;
            left: 20px !important;
            right: 20px !important;
            bottom: 20px !important;
            width: calc(100vw - 40px) !important;
            height: calc(100vh - 40px) !important;
            max-width: none !important;
            max-height: none !important;
            z-index: 10000 !important;
            margin: 0 !important;
            border-radius: 12px !important;
            background: var(--bg-primary);
            box-shadow: 0 0 0 100vmax rgba(0, 0, 0, 0.85) !important;
            /* Dim background */
        }

        .nk-map-embed.is-viewport-fullscreen .nk-map-controls {
            opacity: 1 !important;
            /* Always show controls in fullscreen */
        }

        /* Control Bar Container */
        .nk-map-controls {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 20;
        }

        .nk-map-embed:hover .nk-map-controls,
        .nk-map-embed:focus .nk-map-controls,
        .nk-map-embed:focus-within .nk-map-controls {
            opacity: 1;
        }

        /* Individual Control Buttons */
        .nk-map-btn {
            width: 32px;
            height: 32px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: all 0.2s ease;
        }

        .nk-map-btn:hover {
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            transform: translateY(-2px);
        }

        /* Special style for Delete button */
        .nk-map-btn.is-delete:hover {
            background: #ef4444;
            color: #fff;
            border-color: #ef4444;
            transform: translateY(-2px) rotate(90deg);
        }

        /* Hide controls in Read Mode */
        .read-mode .nk-map-controls {
            display: flex;
            pointer-events: auto;
            z-index: 50;
        }

        .read-mode .nk-map-controls .nk-map-btn {
            display: none;
            pointer-events: auto;
            cursor: pointer;
        }

        .read-mode .nk-map-controls .nk-map-btn:first-child {
            display: flex;
        }



        .split-view-option:hover {
            border-color: var(--primary-color);
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.18),
                0 0 0 1px color-mix(in srgb, var(--primary-color) 30%, transparent);
        }

        .split-view-option:hover::before {
            opacity: 1;
        }

        .split-view-option:active {
            transform: translateY(-2px) scale(1.01);
        }

        .split-view-option svg {
            width: 36px;
            height: 36px;
            color: var(--primary-color);
            transition: transform 0.3s ease;
            position: relative;
            z-index: 1;
        }

        .split-view-option:hover svg {
            transform: scale(1.1);
        }

        .split-view-option span {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            position: relative;
            z-index: 1;
        }

        /* Compact close button */
        .split-close-btn {
            background: transparent;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: var(--text-tertiary);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .split-close-btn:hover {
            background: var(--danger-color);
            color: var(--text-on-primary);
        }

        /* Header button active state */
        #split-screen-btn.split-active {
            color: var(--primary-color);
            background: color-mix(in srgb, var(--primary-color) 15%, transparent);
            border-radius: var(--border-radius);
        }

        /* Hide header in split iframe mode */
        body.split-iframe-mode header {
            display: none !important;
        }

        body.split-iframe-mode main {
            height: 100vh !important;
        }

        body.split-iframe-mode #the-line-container {
            display: none;
        }

        /* Compact toolbar for split iframe mode (use mobile-like layout) */
        body.split-iframe-mode .article-controls {
            max-width: 100%;
            left: 0;
            right: 0;
            bottom: 0;
            transform: none;
            border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0;
            padding: 6px 8px;
            gap: 4px;
        }

        body.split-iframe-mode .article-controls .controls-wrapper {
            flex-wrap: nowrap;
            overflow-x: auto;
            gap: 3px;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }

        body.split-iframe-mode .article-controls .controls-wrapper::-webkit-scrollbar {
            display: none;
        }

        body.split-iframe-mode .article-controls .btn-icon {
            min-width: 32px;
            min-height: 32px;
            width: 32px;
            height: 32px;
            flex-shrink: 0;
        }

        body.split-iframe-mode .article-controls .btn-icon svg {
            width: 14px;
            height: 14px;
        }

        body.split-iframe-mode .article-controls .control-divider {
            display: none;
        }

        body.split-iframe-mode .article-controls .btn-gradient-text {
            display: none;
        }


        .hidden {
            display: none !important;
        }

        .btn {
            padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5);
            border-radius: var(--border-radius);
            border: 1px solid transparent;
            font-weight: 500;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--primary-color-hover);
            transform: translateY(-1px);
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: var(--text-on-primary);
        }

        .btn-danger:hover {
            background-color: var(--danger-color-hover);
        }

        .btn-secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: color-mix(in srgb, var(--border-color) 50%, var(--bg-tertiary));
        }

        .btn-icon {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-icon i {
            font-size: 18px;
        }

        header .btn-icon svg {
            width: 26px;
            height: 26px;
            stroke-width: 2px;
            fill: none;
            stroke: currentColor;
        }

        .btn-icon:hover {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-icon.btn-primary {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
        }

        .btn-icon.btn-primary:hover:not(:disabled) {
            background-color: var(--primary-color-hover);
        }

        .text-input {
            width: 100%;
            padding: 10px 14px;
            font-size: 0.9rem;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .text-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }

        .text-input:read-only {
            background-color: var(--bg-tertiary);
        }

        .btn-icon.is-disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .category-pill {
            padding: 4px 12px;
            border-radius: 9999px;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--category-pill-text);
            display: inline-flex;
            align-items: center;
            white-space: nowrap;
            transition: background-color 0.2s ease-in-out;
        }


        #install-pwa-btn {
            display: none;
        }

        .welcome-container {
            text-align: center;
            max-width: 600px;
            margin: 5rem auto;
            padding: 2rem;
        }

        .welcome-actions {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .library-main {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .library-title {
            font-family: var(--font-display);
            font-size: 3rem;
            text-align: center;
            margin: 0;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .library-header a {
            text-decoration: none;
            color: inherit;
        }

        [data-theme="light"] .library-title {
            background: linear-gradient(45deg, #FF8C42, #FFD05A, #00A896, #A2E869, #05A387);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        [data-theme="dark"] .library-title {
            background: linear-gradient(45deg, #E0B453, #E6845E, #C159A1);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        [data-theme="sepia"] .library-title,
        .focus-mode-title {
            background: linear-gradient(45deg, #8c6d46, #704214);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .search-and-filter-bar {
            display: flex;
            gap: 1.25rem;
            align-items: center;
        }

        .search-bar-container {
            position: relative;
            flex-grow: 1;
        }

        #search-input,
        #flashcard-search-input,
        #tag-search-input {
            width: 100%;
            padding: 12px 16px 12px 40px;
            font-size: 1rem;
            border-radius: 9999px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        #search-input:focus,
        #flashcard-search-input:focus,
        #tag-search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }

        .search-bar-container svg {
            position: absolute;
            top: 50%;
            left: 12px;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }

        #search-hint {
            font-size: 0.8rem;
            color: var(--text-secondary);
            height: 1.2em;
            text-align: left;
            padding-left: 8px;
            margin-top: 4px;
        }

        .category-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-top: -6px;
            align-items: center;
        }

        .category-chip {
            padding: 4px 12px;
            border-radius: 18px;
            font-size: 0.9rem;
            font-weight: 600;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .category-chip:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow);
            filter: brightness(1.1);
        }

        /* NEW: Unified styling for All, Tags, & Flash buttons (Gradient Text) */
        .category-action-btn {
            background: var(--action-button-gradient);
            color: #FFFFFF;
            -webkit-text-fill-color: initial;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 0, 0, 0.15);
            font-weight: 700;
            transition: all 0.2s ease-in-out;
        }

        .category-action-btn:hover {
            border-color: rgba(0, 0, 0, 0.25);
            box-shadow: 0 0 15px rgba(var(--primary-color-rgb), 0.4);
            filter: brightness(1.1);
            transform: translateY(-2px);
        }

        /*  Active Flashcard Category Pill*/
        #flashcard-view .category-filters .category-chip {
            transition: all 0.2s ease-in-out;
        }

        #flashcard-view .category-filters .category-chip.active {
            transform: scale(1.05);
            box-shadow: 0 0 12px 2px color-mix(in srgb, var(--primary-color) 40%, transparent);
            border: 1.5px solid var(--primary-color);
        }

        #flashcard-view .category-filters .category-chip.active[onclick*="'All'"] {
            background-color: var(--primary-color) !important;
            color: var(--text-on-primary) !important;
        }

        /* Unify all category filter button heights */
        .category-filters .category-chip,
        .category-filters .category-pill {
            padding: 8px 14px;
            font-size: 1rem;
            height: auto;
        }


        #article-grid-container {
            position: relative;
            min-height: 40vh;
        }

        .article-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: calc(var(--spacing-unit) * 2);
        }

        .article-card {
            padding: calc(var(--spacing-unit) * 2);
            border-left: 5px solid transparent;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s, background-color 0.2s;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            content-visibility: auto;
            contain-intrinsic-size: 1px 300px;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .article-card:hover,
        .article-card:focus-visible {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            outline: 2px solid var(--border-color);
            outline-offset: 2px;
        }

        .article-card:focus {
            outline: none;
        }

        /* --- New Library Search Interaction Styles --- */
        .article-card.search-highlight-card {
            border-left-width: 6px;
            border-left-color: rgba(var(--primary-color-rgb), 0.8) !important;
        }

        .article-card.search-selected-card {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 0 15px 3px rgba(var(--primary-color-rgb), 0.5);
            border: 3px solid var(--primary-color) !important;
            border-left-width: 5px !important;
        }

        .card-category-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.80rem;
            font-weight: 700;
        }

        .library-premium-card .card-category-badge {
            align-self: flex-start;
            margin-bottom: 3px;
        }

        .card-header-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        /* FIX: Ensure Category Pill and Heart Icon stay apart on Desktop, even for single cards */
        body:not(.mobile-view) .card-header-info .category-pill {
            margin-right: auto;
        }

        .card-read-count-badge {
            padding: 4px 10px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-on-sm2);
            flex-shrink: 0;
        }

        .card-title {
            margin: 0 0 auto;
            font-family: var(--font-serif);
            font-size: 1.2rem;
        }

        .card-footer {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 3.5px;
            justify-content: space-between;
            width: 100%;
        }

        .card-tag-chip {
            background-color: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        .card-word-count,
        .card-date {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .article-view-wrapper {
            display: flex;
            justify-content: center;
            font-family: var(--article-font-family);
            font-size: var(--article-font-size);
            position: relative;
        }

        .article-container {
            width: 100%;
            max-width: 95vw;
            padding: 2rem 2rem 20vh 2rem;
        }

        body.fullscreen-active .article-container {
            max-width: 100%;
            padding: 1rem
        }

        .article-title-input {
            font-size: 1.75em;
            font-weight: 700;
            font-family: var(--font-serif);
            width: 100%;
            border: none;
            background: transparent;
            padding: 0;
            margin-bottom: 0;
            color: var(--text-primary);
            outline: none;
            border-left: 3px solid transparent;
            padding-left: 0.3em;
            transition: border-color 0.3s;
        }

        .article-title-input:focus {
            border-left-color: var(--primary-color);
        }

        .title-divider {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 1.5rem 0;
        }

        #article-content {
            line-height: var(--article-line-height);
            outline: none;
            min-height: 200px;
            overflow-x: auto;
        }

        #article-content p {
            margin-block-start: 0.5em;
            margin-block-end: 0.5em;
        }

        #article-content h2 {
            font-size: 1.5em;
            margin-top: 2em;
            margin-bottom: 1em;
        }

        #article-content blockquote {
            border-left: 3px solid var(--primary-color);
            margin-left: 0;
            padding-left: 1.5em;
            color: var(--text-secondary);
            font-style: italic;
        }

        #article-content hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 2em 0;
        }

        body.write-mode #article-content {
            border-left: 2px solid var(--border-color);
            padding-left: 1em;
            transition: border-color 0.3s;
            scroll-padding-top: 30px;
        }

        #article-content :is(p, span, div, li, td, th blockquote):not([class*="highlight-"]):not(.rendered-tag):not(.text-magenta):not(.text-green):not(.text-blue):not(.text-red):not([style]):not([data-user-font]) {
            font-family: inherit !important;
            font-size: inherit !important;
            line-height: inherit !important;
            background-color: transparent !important;
        }

        #article-content :is(h1, h2, h3, h4, h5, h6) {
            font-family: var(--font-display) !important;
            font-size: revert !important;
            line-height: 1.3 !important;
        }

        body.write-mode #article-content:focus-within {
            border-left-color: var(--primary-color);
        }

        #article-content[contenteditable=true].is-empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            pointer-events: none;
        }

        #article-content.drag-over {
            outline: 2px dashed var(--primary-color);
            outline-offset: 8px;
            background-color: rgba(var(--primary-color-rgb), 0.1);
        }

        #article-content table {
            width: 100% !important;
            border-collapse: separate;
            border-spacing: 0;
            margin: 1.5em 0;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            overflow: hidden;
            table-layout: auto;
        }

        #article-content th,
        #article-content td {
            border-bottom: 1px solid var(--border-color);
            padding: 12px 16px;
            text-align: left;
            vertical-align: top;
            position: relative;
        }

        #article-content td {
            border-left: 1px solid var(--border-color);
        }

        #article-content td:first-child,
        #article-content th:first-child {
            border-left: none;
        }

        #article-content th {
            background-color: rgba(var(--primary-color-rgb), 0.07);
            font-weight: 600;
        }

        #article-content tr:last-child td {
            border-bottom: none;
        }

        #article-content td:focus-within,
        #article-content th:focus-within {
            background-color: var(--bg-tertiary);
            position: relative;
            z-index: 1;
            outline: 2px solid var(--primary-color);
        }

        #article-content .tile-box-table {
            border: none;
            margin: 1em 0;
            width: auto;
            display: inline-block;
        }

        #article-content .tile-cell {
            font-weight: bold;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
        }

        #article-content ul.bullet-square {
            list-style-type: square;
        }

        #article-content ul.bullet-triangle {
            list-style-type: ' ';
        }

        #article-content ul.bullet-empty-circle {
            list-style-type: circle;
        }

        #article-content ul.bullet-hyphen {
            list-style-type: '- ';
        }

        ol[type="a"] {
            list-style-type: lower-alpha;
        }

        ul.bullet-empty-circle {
            list-style-type: circle;
        }

        body.write-mode #article-content.is-empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            pointer-events: none;
            position: absolute;
        }

        body.write-mode #article-content:focus-within {
            border-left-color: var(--primary-color);
        }

        /* --- Checkbox Alignment Fix --- */
        #article-content input[type="checkbox"] {
            vertical-align: middle;
            margin-right: 0.5em;
            position: relative;
            top: 0px;
            cursor: pointer;
            width: 1.1em;
            height: 1.1em;
            accent-color: var(--primary-color);
        }

        /* Clipped Image Border in Read Mode */
        body.read-mode #article-content {
            padding: 0 0.5em;
        }

        #article-content[contenteditable=true].is-empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            pointer-events: none;
        }

        #article-content a {
            color: var(--primary-color);
            text-decoration: underline;
            text-decoration-color: color-mix(in srgb, var(--primary-color) 60%, transparent);
            transition: color 0.2s ease-in-out, text-decoration-color 0.2s ease-in-out;
        }

        #article-content a:hover {
            color: var(--primary-color-hover);
            text-decoration-color: var(--primary-color-hover);
        }



        .article-metadata-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95rem;
            color: var(--text-secondary);
            margin-top: 1rem;
            margin-bottom: -1rem;
            transition: opacity 0.3s;
        }

        .article-view-wrapper[class*="ambiance-"] .article-metadata-bar {
            color: var(--text-primary);
        }

        body.fullscreen-active .article-metadata-bar {
            display: none;
        }

        [class^="highlight-"] {
            padding: 0.1em 0.3em;
            margin: 0 -0.1em;
            border-radius: 4px;
            color: var(--hl-text);
            border-bottom: 2px solid;
        }

        .highlight-1 {
            background-color: var(--hl-1-bg);
            border-color: var(--hl-1-border);
        }

        .highlight-2 {
            background-color: var(--hl-2-bg);
            border-color: var(--hl-2-border);
        }

        .highlight-3 {
            background-color: var(--hl-3-bg);
            border-color: var(--hl-3-border);
        }

        .highlight-4 {
            background-color: var(--hl-4-bg);
            border-color: var(--hl-4-border);
        }

        .highlight-5 {
            background-color: var(--hl-5-bg);
            border-color: var(--hl-5-border);
        }

        .highlight-6 {
            background-color: var(--hl-6-bg);
            border-color: var(--hl-6-border);
        }

        .highlight-7 {
            background-color: var(--hl-7-bg);
            border-color: var(--hl-7-border);
        }

        /* SuperTag Rendered */
        .text-red {
            color: var(--text-red);
        }

        .text-green {
            color: var(--text-green);
        }

        .text-blue {
            color: var(--text-blue);
        }

        .text-magenta {
            color: var(--text-magenta);
        }

        /* SuperTag Suggestion */
        .text-orange {
            color: var(--text-orange);
        }

        .text-teal {
            color: var(--text-teal);
        }

        .text-slate {
            color: var(--text-slate);
        }

        .text-underline {
            text-decoration: underline;
        }

        .rendered-tag {
            cursor: pointer;
            background: linear-gradient(120deg, var(--hl-7-bg) 0%, color-mix(in srgb, var(--hl-7-bg) 92%, var(--hl-7-border) 8%) 100%);
            padding: 0.2em 0.55em;
            margin: 0 0.1em;
            border-radius: 6px;
            border: 1.5px solid color-mix(in srgb, var(--hl-7-border) 60%, transparent 40%);
            box-shadow: 0 1px 3px rgba(192, 38, 211, 0.08),
                inset 0 0 0 1px rgba(192, 38, 211, 0.1);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .rendered-tag::after {
            content: '';
            position: absolute;
            inset: -1px;
            border-radius: 6px;
            padding: 1px;
            background: linear-gradient(135deg, var(--hl-7-border), transparent 60%);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            opacity: 0.4;
            pointer-events: none;
        }

        .rendered-tag:hover {
            background: linear-gradient(120deg,
                    color-mix(in srgb, var(--hl-7-bg) 88%, var(--hl-7-border) 12%) 0%,
                    color-mix(in srgb, var(--hl-7-bg) 85%, var(--hl-7-border) 15%) 100%);
            border-color: color-mix(in srgb, var(--hl-7-border) 75%, transparent 25%);
            box-shadow: 0 2px 8px rgba(192, 38, 211, 0.15),
                0 1px 3px rgba(192, 38, 211, 0.1),
                inset 0 0 0 1px rgba(192, 38, 211, 0.15);
            transform: translateY(-0.5px);
        }

        .rendered-tag:hover::after {
            opacity: 0.6;
        }

        .tag-suggestion {
            color: var(--text-magenta);
            border-bottom: 2px dotted var(--text-magenta);
            padding: 0.1em 0.3em;
            margin: 0 -0.1em;
            border-radius: 4px;
            cursor: pointer;
        }

        #category-view .rendered-tag,
        .focus-mode-body .rendered-tag,
        #mindmap-view .rendered-tag {
            display: none !important;
        }


        mark.mindmap-snippet {
            background-color: var(--mindmap-snippet-bg);
            border-bottom: 2px solid var(--mindmap-snippet-border);
        }

        #article-content img {
            max-width: 100%;
            height: auto;
            border-radius: var(--border-radius);
            cursor: pointer;
        }

        .image-container {
            position: relative;
            display: inline-block;
        }

        /* Whiteboard Embed - Re-editable indicator */
        .image-container.wb-embed::before {
            content: '';
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-primary, #fff);
            border-radius: 50%;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 10;
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
        }

        .image-container.wb-embed:hover::before {
            opacity: 1;
            transform: scale(1);
        }

        .image-container.wb-embed.selected::before {
            opacity: 1;
            transform: scale(1);
            background: var(--primary-color);
        }

        /* Modern rounded corners for all images */
        .image-container img {
            border-radius: 16px;
            transition: border-radius 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
        }

        .image-container:hover img {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
        }

        .image-container.align-left {
            float: left;
            margin-right: 1.5em;
            margin-bottom: 0.5em;
            max-width: 50%;
        }

        .image-container.align-right {
            float: right;
            margin-left: 1.5em;
            margin-bottom: 0.5em;
            max-width: 50%;
        }

        .image-container.align-center {
            display: block;
            width: fit-content;
            text-align: center;
            margin: 1em auto;
        }

        .image-container.align-center img {
            display: inline-block;
        }

        .resize-handle {
            position: absolute;
            width: 15px;
            height: 15px;
            background: var(--primary-color);
            border: 2px solid var(--bg-secondary);
            border-radius: 50%;
            display: none;
            z-index: 100;
            pointer-events: auto;
        }

        .resize-handle-se {
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
        }

        .image-container.selected .resize-handle {
            display: block;
            z-index: 100;
        }

        .nk-visual-flashcard.selected .resize-handle {
            display: block;
            z-index: 100;
        }

        .nk-visual-flashcard.selected {
            cursor: default;
        }

        .image-container.selected img {
            outline: 2px solid var(--primary-color);
        }

        .nk-visual-flashcard.selected .nk-vfc-inner {
            outline: 2px solid var(--primary-color);
            border-radius: 16px;
        }

        /* --- NEW --- Command Palette Preview Indicator */
        .article-container.is-in-preview-mode {
            outline: 6px dashed var(--danger-color);
            outline-offset: 3px;
        }

        /* --- NEW --- Image Highlighting & Mind Map Styling */
        #article-content .image-container.highlighted-image img {
            box-shadow: 0 0 0 2px var(--bg-secondary), 0 0 0 4px var(--primary-color);
            filter: contrast(105%);
            border-radius: var(--border-radius);
            transition: all 0.3s ease;
        }

        #article-content .image-container.highlighted-image.selected img {
            box-shadow: 0 0 0 3px var(--bg-secondary), 0 0 0 6px var(--primary-color), 0 0 15px 6px rgba(var(--primary-color-rgb), 0.6);
            outline: none;
        }

        /* --- NEW --- Image Highlighting & Mind Map Styling */
        #article-content .image-container.highlighted-image img {
            box-shadow: 0 0 0 2px var(--bg-secondary), 0 0 0 4px var(--primary-color);
            filter: contrast(105%);
            border-radius: var(--border-radius);
            transition: all 0.3s ease;
        }

        #article-content .image-container.highlighted-image.selected img {
            box-shadow: 0 0 0 3px var(--bg-secondary), 0 0 0 6px var(--primary-color), 0 0 15px 6px rgba(var(--primary-color-rgb), 0.6);
            outline: none;
        }

        .mindmap-node .node-html-content img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            border-radius: calc(var(--border-radius-lg) - 2px);
            display: block;
        }

        .mindmap-node.image-node .node-html-content {
            padding: 3.5px;
        }

        /* --- External Image Styles --- */
        .image-container.image-external {
            position: relative;
        }

        .image-container.image-external::after {
            content: '';
            position: absolute;
            top: 6px;
            right: 6px;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 3px 7px;
            border-radius: 6px;
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.2s ease;
        }

        .image-container.image-external.selected::after {
            opacity: 0.75;
        }

        .image-container.image-load-error img {
            display: none;
        }

        .image-container.image-load-error::before {
            content: ' Image failed to load';
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 80px;
            min-width: 150px;
            background: var(--bg-tertiary);
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius);
            color: var(--text-secondary);
            font-size: 0.85rem;
            padding: 12px;
        }


        /* --- NEW: Image Caption System (v2.0 ) --- */
        .image-container {
            --caption-align-items: flex-end;
        }

        .image-container[data-caption-align="top"] {
            --caption-align-items: flex-start;
        }

        .image-container[data-caption-align="middle"] {
            --caption-align-items: center;
        }

        .image-container[data-caption-align="bottom"] {
            --caption-align-items: flex-end;
        }

        .image-caption {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: var(--caption-align-items);
            justify-content: center;
            font-family: var(--font-body);
            font-size: 0.95rem;
            line-height: 1.4;
            padding: 12px;
            text-align: center;
            outline: none;
            max-height: 100%;
            overflow-y: auto;
            background-color: transparent;
            pointer-events: none;
            transition: all 0.2s ease;
            box-sizing: border-box;
            color: #ffffff;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 5px rgba(0, 0, 0, 0.7);
        }

        /* === THE 15 CURATED CAPTION THEMES === */
        .image-container[data-caption-theme="sharp-light"] .image-caption {
            color: #ffffff;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .image-container[data-caption-theme="sharp-dark"] .image-caption {
            color: #111111;
            text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .image-container[data-caption-theme="forest"] .image-caption {
            color: #14532d;
            text-shadow: 0 1px 3px rgba(6, 40, 19, 0.9);
        }

        .image-container[data-caption-theme="navy"] .image-caption {
            color: #1e3a8a;
            text-shadow: 0 1px 3px rgba(23, 37, 84, 0.9);
        }

        .image-container[data-caption-theme="maroon"] .image-caption {
            color: #cb1c52;
            text-shadow: 0 1px 3px rgba(76, 5, 25, 0.9);
        }

        .image-container[data-caption-theme="chocolate"] .image-caption {
            color: #431407;
            text-shadow: 0 1px 3px rgba(30, 7, 0, 0.95);
        }

        .image-container[data-caption-theme="charcoal"] .image-caption {
            color: #334155;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .image-container[data-caption-theme="sunbeam"] .image-caption {
            color: #fef08a;
            text-shadow: 0 1px 4px rgba(120, 53, 15, 0.85);
        }

        .image-container[data-caption-theme="aqua"] .image-caption {
            color: #7dd3fc;
            text-shadow: 0 1px 4px rgba(8, 47, 73, 0.9);
        }

        .image-container[data-caption-theme="lime"] .image-caption {
            color: #a3e635;
            text-shadow: 0 1px 3px rgba(24, 59, 0, 0.9);
        }

        .image-container[data-caption-theme="rose"] .image-caption {
            color: #fecaca;
            text-shadow: 0 1px 4px rgba(88, 28, 135, 0.8);
        }

        .image-container[data-caption-theme="lavender"] .image-caption {
            color: #e0e7ff;
            text-shadow: 0 1px 4px rgba(49, 46, 129, 0.8);
        }

        .image-container[data-caption-theme="soft-glow"] .image-caption {
            color: #ffffff;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
        }

        .image-container[data-caption-theme="letterpress"] .image-caption {
            color: #e2e8f0;
            text-shadow: 0 -1px 1px rgba(0, 0, 0, 0.7);
        }

        .image-container[data-caption-theme="gold-leaf"] .image-caption {
            color: #fffbeb;
            text-shadow: 0 0 8px #f59e0b, 0 0 12px rgba(245, 158, 11, 0.5);
        }

        .image-caption[contenteditable="true"] {
            background-color: rgba(0, 0, 0, 0.65);
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.7);
            pointer-events: auto;
            cursor: text;
            color: #ffffff !important;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5) !important;
        }

        .image-caption:empty:not([contenteditable="true"])::before {
            content: '';
        }

        .image-caption:empty[contenteditable="true"]::before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }




        /*  Image Lightbox Styles --- */
        .lightbox-image-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease-out;
            cursor: grab;
        }

        .lightbox-image {
            max-width: 95vw;
            max-height: 90vh;
            object-fit: contain;
            user-select: none;
            -webkit-user-drag: none;
        }

        .lightbox-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            background-color: rgba(var(--bg-secondary-rgb), 0.8);
            backdrop-filter: blur(8px);
            padding: 0.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
        }

        .lightbox-controls .btn-icon {
            background-color: var(--bg-secondary);
        }

        .tags-view-container {
            padding: 1.5rem;
        }

        .tag-cloud {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }

        .tag-item {
            cursor: pointer;
            background-color: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 6px 14px;
            border-radius: 16px;
            transition: all 0.2s;
            font-size: 0.9rem;
            font-weight: 500;
            border: 1px solid var(--border-color);
        }

        .tag-item:hover {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            transform: scale(1.05);
            border-color: transparent;
        }

        .article-tags-display {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        body.fullscreen-active .article-tags-display {
            display: none;
        }

        .tag-modal-article-title {
            font-weight: bold;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tag-modal-article-title:hover {
            background-color: var(--bg-tertiary);
        }

        .tag-modal-body {
            max-height: 60vh;
            overflow-y: auto;
            padding: 4px;
        }

        /* === Modern Settings UI Overhaul === */
        .settings-nav {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 0.5rem;
            border: none;
        }

        .settings-nav-item {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 12px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            color: var(--text-secondary);
            text-decoration: none;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            position: relative;
            overflow: hidden;
        }

        .settings-nav-item i {
            font-size: 1.1em;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: all 0.25s ease;
            z-index: 2;
        }

        .settings-nav-item span {
            z-index: 2;
        }

        .settings-nav-item:hover:not(.locked) {
            color: var(--text-on-primary);
            transform: scale(1.03);
            box-shadow: 0 4px 15px -5px rgba(var(--primary-color-rgb), 0.5);
        }

        .settings-nav-item:hover:not(.locked) i {
            color: var(--text-on-primary);
        }

        .settings-nav-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--action-button-gradient);
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .settings-nav-item:hover:not(.locked)::before {
            left: 0;
        }

        .settings-nav-item.locked {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .settings-nav-item.locked::after {
            content: '';
            margin-left: auto;
            font-size: 1em;
            z-index: 2;
        }

        #modal-container .modal-content {
            background: linear-gradient(145deg, var(--bg-primary), var(--bg-secondary));
            border: 1px solid var(--border-color);
        }

        /* === Modern Form Element Styling (Sub-Settings) === */
        .modal-content h3 {
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1.5rem;
        }

        .modal-content .settings-section:first-of-type {
            border-top: none;
            margin-top: 0;
            padding-top: 0;
        }

        .modal-content .settings-section h4 {
            color: var(--primary-color);
            font-weight: 600;
            font-size: 1rem;
            border-bottom: none;
            text-transform: none;
            letter-spacing: 0;
        }

        /*  Modern Buttons with a "3D" Feel */
        .modal-content .btn-secondary {
            font-weight: 600;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            border-bottom-width: 3px;
            box-shadow: var(--shadow-sm);
            transition: all 0.15s ease-out;
        }

        .modal-content .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 0 12px -2px color-mix(in srgb, var(--primary-color) 40%, transparent);
            border-color: color-mix(in srgb, var(--primary-color) 50%, var(--border-color));
            background-color: var(--bg-secondary);
        }

        .modal-content .btn-secondary:active:not(:disabled) {
            transform: translateY(1px);
            border-bottom-width: 1px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /*  Modern Dropdowns (Select) */
        .modal-content select.btn-secondary {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%236c757d' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.1em;
            padding-right: 2.5rem;
            text-align: left;
        }

        /* Modern Sliders (Range Inputs) */
        .modal-content input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            outline: none;
            transition: background 0.2s;
        }

        .modal-content input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid var(--bg-secondary);
            box-shadow: var(--shadow);
            transition: transform 0.2s ease;
        }

        .modal-content input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .modal-content input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid var(--bg-secondary);
            box-shadow: var(--shadow);
        }

        /* Modern Toggle Switches */
        .modal-content .toggle-switch {
            border-radius: 9999px;
            width: 48px;
            height: 26px;
        }

        .modal-content .toggle-switch::before {
            width: 20px;
            height: 20px;
            top: 2px;
            left: 2px;
            box-shadow: var(--shadow-sm);
        }

        .modal-content .toggle-switch.active::before {
            transform: translateX(22px);
        }

        /* ELEGANT FLOATING TOOLBAR  */
        .article-controls {
            position: fixed;
            bottom: 0.8rem;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            display: flex;
            justify-content: center;
            gap: 0;
            /* Refined Glassmorphism */
            background-color: rgba(var(--bg-secondary-rgb), var(--ui-opacity));
            backdrop-filter: blur(var(--blur-intensity));
            -webkit-backdrop-filter: blur(var(--blur-intensity));

            padding: 4px;
            border-radius: 9999px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);

            z-index: 1001;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .toolbar-wrapper.vertical .control-divider {
            width: 80%;
            height: 1px;
            margin: 4px auto;
        }

        .controls-wrapper {
            display: none;
            align-items: center;
            gap: 4px;
        }

        /* --- NEW: Consistent Slider Control Styling --- */
        .slider-control-wrapper {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .slider-control-wrapper input[type="range"] {
            flex-grow: 1;
        }

        .slider-control-wrapper span {
            min-width: 50px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        /* --- Polished Button Styles within the Toolbar --- */
        .article-controls .btn-icon {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: transparent;
            color: var(--text-secondary);
            transition: all 0.2s ease-in-out;
        }

        .article-controls .btn-icon:hover {
            transform: scale(1.1);
            background-color: var(--bg-tertiary);
            color: var(--primary-color);
        }

        /* --- Style for Primary Actions (Edit, Save) --- */
        .article-controls .btn-icon.btn-primary {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            box-shadow: 0 2px 8px -2px rgba(var(--primary-color-rgb), 0.7);
        }

        .article-controls .btn-icon.btn-primary:hover {
            background-color: var(--primary-color-hover);
            color: var(--text-on-primary);
        }

        /* Mobile-specific adjustments for the floating bar */
        body.mobile-view .article-controls {
            max-width: 95vw;
            bottom: 0.5rem;
            padding: 4px;
        }


        body.read-mode .read-mode-controls,
        body.write-mode .write-mode-controls {
            display: flex;
        }

        .control-divider {
            width: 1px;
            height: 20px;
            background-color: var(--border-color);
        }

        .read-count-badge {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            color: var(--text-on-sm2);
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            background: var(--sm2-level-3);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-family: var(--font-secondary);
        }

        .read-count-badge:hover {
            transform: scale(1.1);
        }

        .controls-wrapper {
            gap: 8px;
        }

        /* --- Modern Category Dropdown Design --- */
        #category-selector {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-color: var(--bg-tertiary);
            /* Subtle background */
            color: var(--text-primary);
            border: 1px solid transparent;
            border-radius: 999px;
            /* Pill shape */
            padding: 0 34px 0 16px;
            height: 36px;
            font-size: 0.9rem;
            font-family: var(--font-primary);
            font-weight: 500;
            cursor: pointer;
            /* Custom Chevron Arrow */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 14px;
            transition: all 0.2s ease;
            min-width: 130px;
            white-space: nowrap;
            text-overflow: ellipsis;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        #category-selector:hover {
            background-color: var(--bg-primary);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            transform: translateY(-1px);
        }

        #category-selector:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(var(--primary-color-rgb), 0.15);
        }

        /* Dark mode adjustment for arrow (optional, assuming stroke is hex) */
        @media (prefers-color-scheme: dark) {
            #category-selector {
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23aaa' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            }
        }


        .done-btn-animated {
            animation: heart-pop 0.8s ease-in-out;
        }

        @keyframes heart-pop {
            0% {
                transform: scale(1);
            }

            25% {
                transform: scale(1.4);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        body.fullscreen-active header,
        body.fullscreen-active .article-controls {
            transform: translateY(100%);
            opacity: 0;
            pointer-events: none;
        }

        body.fullscreen-active header {
            display: none;
        }

        #focus-mode-toggle {
            position: fixed;
            bottom: 1.1rem;
            right: 1.5rem;
            z-index: 1002;
            display: none;
            animation: fadeIn 0.3s;
        }

        body.fullscreen-active #focus-mode-toggle {
            display: block;
        }

        #focus-mode-toggle.exit-active {
            animation: slow-pulse 4s infinite;
        }

        @keyframes slow-pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.8;
            }

            50% {
                transform: scale(1.05);
                opacity: 1;
            }
        }

        .category-summary-card {
            padding: 16px;
            margin-bottom: 16px;
        }

        .category-summary-card h3 {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .snippet {
            font-size: 0.95rem;
            color: var(--text-secondary);
            border-left: 3px solid var(--border-color);
            padding-left: 12px;
            margin: 3px 0;
            cursor: default;
            line-height: 1.5;
        }

        .snippet:hover {
            background-color: var(--bg-tertiary);
        }

        .context-menu {
            position: absolute;
            z-index: 1005;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            border: 1px solid var(--border-color);
        }

        .context-menu button {
            background: none;
            border: none;
            text-align: left;
            padding: 8px 12px;
            width: 100%;
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .context-menu button:hover {
            background-color: var(--bg-tertiary);
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            justify-items: center;
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .empty-state svg {
            display: block;
            width: 64px;
            height: 64px;
            margin: 0 auto 1rem auto;
            opacity: 0.7;
        }

        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 99999;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
        }

        .toast {
            background-color: #333;
            color: white;
            padding: 12px 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.4s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 1rem;
            line-height: 1.4;
            max-width: 350px;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.error {
            background-color: var(--danger-color);
        }

        .toast.success {
            background-color: var(--success-color);
        }

        .toast.warning {
            background-color: var(--warning-color);
            color: var(--text-warning);
        }

        .toast small {
            opacity: 0.9;
            font-size: 0.9em;
        }



        #confetti-toast-container {
            position: fixed;
            z-index: 100000;
            pointer-events: none;
        }

        .confetti {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: var(--primary-color);
            opacity: 0;
            animation: confetti-blast 0.8s ease-out forwards;
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            animation: fadeIn 0.5s ease;
            backdrop-filter: blur(8px);
        }

        .modal-content {
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            box-shadow: var(--shadow-lg);
            animation: fadeIn 0.3s ease;
        }

        .modal-content h3 {
            margin-top: 0;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 1rem;
        }

        .productivity-modal {
            max-width: 700px;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 85vh;
            max-height: 700px;
        }

        .task-filters {
            display: grid;
            grid-template-columns: repeat(5, minmax(0, 1fr));
            gap: 10px;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-primary);
            flex-shrink: 0;
        }

        .task-filters::-webkit-scrollbar {
            display: none;
        }

        .task-filters {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .task-filters .btn {
            padding: 8px 4px;
            font-size: 0.85rem;
            width: 100%;
            height: 38px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-radius: 10px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--text-secondary);
            background-color: transparent;
            border: 1px solid transparent;
        }

        .task-filters .btn:hover {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .task-filters .btn.active {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            border-color: var(--primary-color);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transform: translateY(-1px);
        }

        .task-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 12px;
            scrollbar-gutter: stable;
        }

        .task-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: var(--border-radius);
            transition: var(--transition-fast);
            background-color: var(--bg-secondary);
            border-left: 4px solid transparent;
        }

        .task-item:hover {
            background-color: var(--bg-tertiary);
            transform: scale(1.01);
        }

        .task-item[data-priority="high"] {
            border-left-color: var(--priority-high);
        }

        .task-item[data-priority="medium"] {
            border-left-color: var(--priority-medium);
        }

        .task-item[data-priority="low"] {
            border-left-color: var(--priority-low);
        }

        .task-item.completed {
            border-left-color: var(--success-color);
            opacity: 0.8;
        }

        .task-item.completed .task-title {
            text-decoration: line-through;
            color: var(--success-color);
            text-decoration-color: var(--success-color);
        }

        .task-checkbox {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
            accent-color: var(--primary-color);
        }

        .task-title {
            flex-grow: 1;
            margin-right: 8px;
            white-space: normal;
            word-break: break-word;
            font-size: calc(var(--article-font-size) * 0.9);
        }

        .task-item.is-backlog {
            border-left-color: var(--danger-color) !important;
        }

        .task-item.is-backlog .task-title {
            color: var(--danger-color);
            font-weight: 500;
        }

        .task-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            flex-wrap: wrap;
        }

        .task-meta .due-date.overdue {
            color: var(--danger-color);
            font-weight: 500;
        }

        .task-meta .btn-icon {
            width: 32px;
            height: 32px;
        }

        .task-meta .btn-icon svg {
            width: 18px;
            height: 18px;
        }

        .task-meta .btn-danger {
            color: var(--danger-color);
        }

        .task-meta .btn-danger:hover {
            color: var(--danger-color-hover);
            background-color: color-mix(in srgb, var(--danger-color) 15%, transparent);
        }

        .pomo-counter-display {
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 500;
            font-size: 0.8rem;
            background-color: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 12px;
        }

        .pomo-counter-display svg {
            width: 14px;
            height: 14px;
            color: var(--primary-color);
        }

        .task-composer {
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin-bottom: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .composer-input-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .composer-actions-row {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .composer-meta-buttons {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        #composer-date-input {
            border: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            text-align: center;
            font-weight: 500;
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        #composer-date-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--primary-color);
        }

        .priority-btn {
            border: none;
            color: var(--text-on-primary);
            font-size: 0.85rem;
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 6px;
            font-weight: 500;
        }

        .priority-btn.high {
            background-color: var(--priority-high);
        }

        .priority-btn.medium {
            background-color: var(--priority-medium);
        }

        .priority-btn.low {
            background-color: var(--priority-low);
        }

        #category-select {
            font-size: 0.85rem;
            padding: 6px 10px;
            border-radius: 6px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-weight: 500;
        }

        #pomo-goal-btn {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
        }

        #pomo-goal-btn svg {
            width: 16px;
            height: 16px;
            color: var(--primary-color);
        }

        #add-task-btn {
            width: 32px;
            height: 32px;
            padding-bottom: 8px;
            border-radius: 50%;
            flex-shrink: 0;
            font-size: 1.5rem;
            font-weight: 400;
            line-height: 1.2;
        }

        .pomodoro-section {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .pomodoro-display {
            position: relative;
            padding: 10px;
            border-radius: 12px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        .pomodoro-progress-frame {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .progress-segment {
            position: absolute;
            background-color: var(--pomo-color-1);
            transition: background-color 0.5s ease;
        }

        .progress-top {
            top: 0;
            left: 0;
            height: 6px;
            border-radius: 6px 6px 0 0;
        }

        /* --- MODERN ZEN HUB SEPARATOR --- */
        .hub-separator {
            height: 8px;
            width: 96%;
            margin: 0 auto;
            background: var(--bg-tertiary);
            border: 1.8px solid var(--border-color);
            border-radius: 20px;

            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;

            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 10;
            user-select: none;
            overflow: hidden;
            opacity: 0.9;
            box-shadow: 0 0 6px -1px var(--primary-color-alpha, rgba(100, 100, 255, 0.2));

        }

        /* "Shimmer" Scanline Effect */
        .hub-separator::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s ease;
            pointer-events: none;
        }

        .hub-separator:hover::before {
            left: 100%;
            transition: left 0.8s ease;
        }

        .hub-separator:hover {
            opacity: 1;
            height: 8px;
            background: var(--primary-color);
            box-shadow: 0 0 12px var(--primary-color-alpha, rgba(99, 102, 241, 0.4));
            border-color: transparent;
        }

        .hub-separator:active {
            transform: scaleX(0.98);
            opacity: 0.9;
        }

        /* Removed .hub-separator-handle styles entirely for minimalism */

        /* Modes */
        .productivity-modal.mode-tasks .pomodoro-section {
            display: none !important;
        }

        .productivity-modal.mode-tasks .task-area {
            flex-grow: 1;
            padding-bottom: 2rem;
        }

        .productivity-modal.mode-pomo .task-filters,
        .productivity-modal.mode-pomo .task-area {
            display: none !important;
        }

        .productivity-modal.mode-pomo .pomodoro-section {
            flex-grow: 1;
            justify-content: center;
            border-top: none;
            padding-bottom: 4rem;
        }

        .productivity-modal.mode-pomo .pomodoro-display {
            width: 80%;
            max-width: 400px;
            padding: 2rem;
        }

        .productivity-modal.mode-pomo .pomodoro-time-display {
            font-size: 5rem;
        }

        /* Visual Polish for Modal */
        .productivity-modal {
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2), 0 0 0 1px var(--border-color);
            border-radius: 16px;
            overflow: hidden;
            background: var(--bg-primary);
            transition: height 0.3s ease;
        }


        .progress-right {
            top: 0;
            right: 0;
            width: 6px;
            border-radius: 0 6px 6px 0;
        }

        .progress-bottom {
            bottom: 0;
            right: 0;
            height: 6px;
            border-radius: 0 0 6px 6px;
        }

        .progress-left {
            bottom: 0;
            left: 0;
            width: 6px;
            border-radius: 6px 0 0 6px;
        }

        .pomodoro-time-display {
            font-size: 3rem;
            font-weight: 700;
            line-height: 1;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .pomodoro-task-title {
            font-weight: 500;
            margin-top: 4px;
            transition: color 0.5s ease;
            max-width: 250px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pomodoro-meta {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 8px;
        }

        .pomodoro-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        #pomodoro-settings-popup {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            background-color: var(--bg-secondary);
            box-shadow: var(--shadow-lg);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            z-index: 1;
            animation: slideUp 0.2s;
        }

        .cycle-pill {
            color: white;
            font-weight: 600;
            font-size: 0.75rem;
            padding: 3px 10px;
            border-radius: 16px;
            transition: background-color 0.3s ease;
        }

        .cycle-pill[data-cycle="1"] {
            background-color: var(--cycle-color-1);
        }

        .cycle-pill[data-cycle="2"] {
            background-color: var(--cycle-color-2);
        }

        .cycle-pill[data-cycle="3"] {
            background-color: var(--cycle-color-3);
        }

        .cycle-pill[data-cycle="4"] {
            background-color: var(--cycle-color-4);
        }

        .break-pill {
            background-color: var(--break-color);
            color: white;
            font-weight: 600;
            font-size: 0.75rem;
            padding: 3px 10px;
            border-radius: 16px;
        }

        .todo-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: var(--danger-color);
            color: white;
            font-size: 10px;
            font-weight: bold;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-section {
            margin-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            padding-top: 1.5rem;
        }

        .settings-section:first-child {
            margin-top: 0;
            border-top: none;
            padding-top: 0;
        }

        .settings-section h4 {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 0;
            margin-bottom: 1rem;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }

        .settings-label {
            display: flex;
            flex-direction: column;
        }

        .settings-label b {
            font-weight: 500;
        }

        .settings-label small {
            color: var(--text-secondary);
            font-size: 0.85rem;
            word-break: break-all;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 1rem;
            align-items: center;
        }

        .settings-grid label {
            font-weight: 500;
            justify-self: start;
        }

        .settings-grid .control-span {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .toggle-switch {
            width: 50px;
            height: 28px;
            background: var(--bg-tertiary);
            border-radius: 14px;
            position: relative;
            cursor: pointer;
            border: 1px solid var(--border-color);
        }

        .toggle-switch::before {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 3px;
            transition: transform 0.2s;
        }

        .toggle-switch.active {
            background: var(--primary-color);
        }

        .toggle-switch.active::before {
            transform: translateX(21px);
        }

        .sync-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--danger-color);
            transition: background-color 0.3s;
        }

        .sync-status-dot.active {
            background-color: var(--success-color);
        }

        #custom-theme-controls {
            margin-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            padding-top: 1.5rem;
            display: none;
        }

        .modal-content.is-custom-theme #custom-theme-controls {
            display: block;
        }

        .guide-content {
            display: none;
            margin-top: 1rem;
            max-height: 40vh;
            overflow-y: auto;
            padding: 1rem;
            background-color: var(--bg-primary);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
        }

        .guide-content code {
            background-color: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }

        .guide-content ol,
        .guide-content ul {
            padding-left: 20px;
        }

        .guide-content li {
            margin-bottom: 0.8rem;
        }

        /* ELEGANT FLOATING TOOLBAR  */
        .toolbar-wrapper {
            display: flex;
            gap: 4px;
            align-items: center;
            padding: 6px;
            background: linear-gradient(145deg, rgba(var(--bg-secondary-rgb), 0.7), rgba(var(--bg-primary-rgb), 0.6));
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 9999px;
            box-shadow: var(--shadow-lg), inset 0 1px 1px rgba(255, 255, 255, 0.1);
            border: 1px solid color-mix(in srgb, var(--border-color) 60%, transparent);
        }

        .toolbar-wrapper.vertical {
            flex-direction: column;
            width: auto;
            border-radius: var(--border-radius-lg);
        }

        .toolbar-drag-handle {
            cursor: move;
            color: var(--text-secondary);
            padding: 0 4px;
            opacity: 0.6;
            display: flex;
            align-items: center;
            transition: color 0.3s ease, opacity 0.3s ease;
        }

        .toolbar-drag-handle.locked {
            color: var(--primary-color);
            opacity: 1;
        }

        #selection-toolbar .btn-icon {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            transition: all 0.2s ease-in-out;
        }

        #selection-toolbar .btn-icon:hover {
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-tertiary));
            color: var(--primary-color);
            transform: scale(1.15);
            box-shadow: 0 0 8px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }

        #selection-toolbar .highlight-btn {
            width: 28px !important;
            height: 28px !important;
        }

        #ai-magic-btn {
            color: var(--primary-color);
            animation: copilot-glow 4s infinite alternate ease-in-out;

        }

        #ai-magic-btn:hover {
            animation-play-state: paused;
        }

        /* Changes for Bullet */
        .list-toolbar-group {
            position: relative;
        }

        .list-popover {
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-bottom: 8px;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            padding: 4px;
            z-index: 1002;
            display: flex;
            visibility: hidden;
            opacity: 0;
            transform: translateX(-50%) translateY(5px);
            transition: all 0.2s ease-out 0.5s;
            transition-property: visibility, opacity, transform;
        }

        .list-toolbar-group:hover .list-popover {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            transition-delay: 0s;
        }

        /* --- NEW: Compact Image Toolbar Styles --- */
        #image-toolbar .toolbar-wrapper {
            padding: 4px;
        }

        #image-toolbar .btn-icon {
            width: 36px;
            height: 36px;
        }

        /* Changes for Toolbar B,I,U */
        .format-toolbar-group {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .format-popover {
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-bottom: 8px;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            padding: 4px;
            z-index: 1002;
            display: flex;
            visibility: hidden;
            opacity: 0;
            transform: translateX(-50%) translateY(5px);
            transition: visibility 0s linear 0.5s, opacity 0.2s ease-out 0.5s, transform 0.2s ease-out 0.5s;
        }

        .format-toolbar-group:hover .format-popover {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            transition-delay: 0s;
        }

        .format-popover .btn-icon {
            font-size: 1.2rem;
        }

        /* --- Insert Group Styles (Duplicated from Format Group) --- */
        .insert-toolbar-group {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .insert-popover {
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-bottom: 8px;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            padding: 4px;
            z-index: 1002;
            display: flex;
            visibility: hidden;
            opacity: 0;
            transform: translateX(-50%) translateY(5px);
            transition: visibility 0s linear 0.5s, opacity 0.2s ease-out 0.5s, transform 0.2s ease-out 0.5s;
        }

        .insert-toolbar-group:hover .insert-popover {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            transition-delay: 0s;
        }

        .insert-popover .btn-icon {
            font-size: 1.2rem;
        }

        /* --- Color Picker Styles --- */
        .color-picker-group {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .color-picker-popover {
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-bottom: 12px;
            background-color: var(--bg-secondary);
            border-radius: 24px;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            padding: 6px;
            z-index: 1002;
            display: flex;
            gap: 6px;
            visibility: hidden;
            opacity: 0;
            transform: translateX(-50%) translateY(5px);
            /* Wait 0.3s before hiding visibility to allow safe mouse traversal */
            transition: visibility 0s linear 0.3s, opacity 0.2s ease-out, transform 0.2s ease-out;
            pointer-events: none;
        }

        /* Bridge the gap to prevent hover loss - Increased size */
        .color-picker-popover::after {
            content: '';
            position: absolute;
            bottom: -30px;
            left: -10%;
            width: 120%;
            height: 30px;
            background: transparent;
        }

        /* Hover State */
        .color-picker-group:hover .color-picker-popover {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            transition-delay: 0s;
            pointer-events: auto;
        }

        /* Click/Pinned State */
        .color-picker-popover.show {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            transition-delay: 0s;
            pointer-events: auto;
        }


        .color-circle-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid transparent;
            /* default border */
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            position: relative;
        }

        .color-circle-btn:hover {
            transform: scale(1.2);
            z-index: 1;
            border-color: var(--border-color);
        }

        .color-circle-btn.active {
            border-color: var(--text-primary);
            box-shadow: 0 0 0 2px var(--bg-secondary), 0 0 0 4px var(--primary-color);
        }



        /* Changes for Checkbox */
        .nk-checkbox-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin: 0.5em 0;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .nk-checkbox-wrapper:hover .nk-checkbox-box {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px var(--bg-tertiary);
        }

        /* Unchecked State - Consistent with Text */
        .nk-checkbox-wrapper .nk-checkbox-box {
            width: 18px;
            height: 18px;
            border: 2px solid var(--text-primary);
            border-radius: 6px;
            margin-right: 12px;
            margin-top: 5px;
            /* Centralizes with first line of text */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            background-color: transparent;
        }

        /* Checked State - Premium Green Theme */
        .nk-checkbox-wrapper[data-checked="true"] .nk-checkbox-box {
            background-color: var(--text-green);
            border-color: var(--text-green);
            box-shadow: none;
            opacity: 1;
        }

        .nk-checkbox-text {
            outline: none;
            flex-grow: 1;
            transition: all 0.3s ease;
            color: var(--text-primary);
            line-height: 1.6;
        }

        /* Use Theme-Sensitive Green for Text when Checked */
        .nk-checkbox-wrapper[data-checked="true"] .nk-checkbox-text {
            color: var(--text-green);
            text-decoration: line-through;
            text-decoration-color: var(--text-green);
            opacity: 0.8;
            transition: color 0.2s ease;
        }


        #new-article-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            gap: 3px;
            border-radius: var(--border-radius);
            flex-shrink: 0;
        }

        @keyframes subtle-glow {

            0%,
            100% {
                box-shadow: 0 0 4px rgba(96, 165, 250, 0);
            }

            50% {
                box-shadow: 0 0 12px rgba(96, 165, 250, 0.5);
            }
        }


        @keyframes subtle-glow-dark {

            0%,
            100% {
                box-shadow: 0 0 4px rgba(147, 197, 253, 0);
            }

            50% {
                box-shadow: 0 0 12px rgba(147, 197, 253, 0.4);
            }
        }



        @keyframes subtle-glow-sepia {

            0%,
            100% {
                box-shadow: 0 0 4px rgba(140, 109, 70, 0);
            }

            50% {
                box-shadow: 0 0 12px rgba(140, 109, 70, 0.5);
            }
        }

        .shortcut-modal-content kbd {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: monospace;
        }

        .cloze-flashcard {
            background-color: var(--cloze-bg);
            border-bottom: 2px dotted var(--cloze-border);
            padding: 0 4px;
            border-radius: 4px;
            display: inline;
            box-decoration-break: clone;
            -webkit-box-decoration-break: clone;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .flashcard-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .flashcard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .flashcard-tile {
            perspective: 1000px;
            background-color: transparent;
            min-height: 165px;
            border-left: 5px solid;
            border-radius: var(--border-radius);
            cursor: pointer;
            content-visibility: auto;
            contain-intrinsic-size: 1px 300px;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .flashcard-tile-flipper {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.7s ease-in-out;
            transform-style: preserve-3d;
        }

        .flashcard-tile.is-flipped .flashcard-tile-flipper {
            transform: rotateY(180deg);
        }

        .flashcard-tile-face {
            width: 100%;
            height: 100%;
            position: absolute;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            padding: 1rem;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .flashcard-tile-back {
            transform: rotateY(180deg);
        }

        .flashcard-tile-content {
            font-size: 0.95rem;
            line-height: 1.45;
            flex-grow: 1;
            overflow-y: auto;
            position: relative;
            scrollbar-width: none;
            padding-bottom: 30px;
        }

        .flashcard-tile-content::-webkit-scrollbar {
            display: none;
        }

        .flashcard-tile-footer {
            position: absolute;
            bottom: 8px;
            right: 8px;

            background-color: rgba(var(--bg-secondary-rgb), 0.75);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
            border-radius: var(--border-radius);
            padding: 2px;

            opacity: 0;
            transform: translateY(5px);
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;

            display: flex;
            align-items: center;
            gap: 0;
            z-index: 1;

            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .flashcard-tile:hover .flashcard-tile-front .flashcard-tile-footer {
            opacity: 1;
            transform: translateY(0);
        }

        .flashcard-tile.is-flipped:hover .flashcard-tile-back .flashcard-tile-footer {
            opacity: 1;
            transform: translateY(0);
        }

        .flashcard-tile-footer .btn-icon {
            width: 28px;
            height: 28px;
            color: var(--text-secondary);
            transition: transform 0.15s ease-out, color 0.15s ease-out;
        }

        .flashcard-tile-footer .btn-icon:hover {
            color: var(--primary-color);
            transform: scale(1.15);
        }


        /* --- New Flashcard Search Interaction Styles --- */
        .flashcard-tile.search-highlight-card {
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.5);
        }

        .flashcard-tile.search-selected-card {
            transform: scale(1.03);
            box-shadow: 0 0 15px 3px rgba(var(--primary-color-rgb), 0.6);
            border-left-color: var(--primary-color) !important;
        }

        @media (max-width: 612px) {
            .flashcard-tile-footer {
                opacity: 1;
                transform: none;
                background: transparent;
                backdrop-filter: none;
                -webkit-backdrop-filter: none;
                box-shadow: none;
                border: none;
                padding: 0;
                gap: 4px;
            }

            .flashcard-tile-content {
                padding-bottom: 1px;
                -webkit-mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
                mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
            }

            .flashcard-tile-footer .btn-icon {
                width: 28px;
                height: 28px;
                border-radius: 50%;
                background-color: rgba(var(--bg-secondary-rgb), 0.8);
                box-shadow: var(--shadow-sm);
                border: 1px solid var(--border-color);
            }

            .flashcard-tile-footer .btn-icon:hover {
                color: var(--text-secondary);
                transform: none;
                background-color: rgba(var(--bg-secondary-rgb), 0.8);
            }
        }



        .study-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10001;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            padding-bottom: 120px;
        }

        .study-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-size: cover;
            background-position: center;
        }

        .study-content-container {
            width: 100%;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 1200px;
        }

        .study-card {
            width: 100%;
            height: 100%;
            max-height: 80vh;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.7s ease-in-out;
            cursor: pointer;
        }

        .study-card.is-flipped {
            transform: rotateY(180deg);
        }

        .study-card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .study-card-back {
            transform: rotateY(180deg);
        }

        .study-card-content-box {
            width: 100%;
            max-width: 90ch;
            max-height: 100%;
            overflow-y: auto;
            padding: 2rem;
            background-color: var(--bg-secondary);
            border: 3px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: var(--study-card-font-size, 2.1rem);
            line-height: 1.5;
            font-family: var(--font-serif);
            text-align: left;
            transition: border-color 0.3s ease;
        }

        .cloze-hidden {
            color: var(--cloze-hidden-text);
            font-weight: bold;
        }

        .cloze-revealed-wrapper {
            background-color: var(--cloze-bg);
            border-radius: 4px;
            padding: 0.1em 0.3em;
            margin: 0 -0.1em;
        }

        .cloze-revealed {
            color: var(--cloze-revealed-text);
            font-weight: bold;
        }

        .study-controls-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            background-color: rgba(var(--bg-primary-rgb), 0.8);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .study-progress-bar {
            width: 100%;
            max-width: 400px;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
        }

        /* --- Minimal Toolbar for Split Screen / Small Devices --- */
        @media (max-height: 600px),
        (max-width: 500px) {
            .study-controls-container {
                padding: 6px 12px;
                gap: 6px;
                background-color: rgba(var(--bg-primary-rgb), 0.96);
                backdrop-filter: blur(12px);
                border-top: 1px solid var(--border-color);
            }

            .study-progress-bar {
                height: 4px;
                margin-bottom: 2px;
                max-width: 100%;
                border-radius: 2px;
            }

            .study-controls {
                width: 100%;
                justify-content: center;
            }

            .study-controls .srs-rating-group {
                gap: 6px;
                width: 100%;
                justify-content: center;
            }

            .btn-study-rating {
                padding: 6px 0;
                width: 100%;
                max-width: 70px;
                font-size: 0.75rem;
                border-radius: 8px;
                height: 36px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            body.mobile-view .study-view,
            .study-view {
                padding-bottom: 70px !important;
            }
        }

        .study-progress-bar::-webkit-progress-bar {
            background-color: var(--bg-tertiary);
        }

        .study-progress-bar::-webkit-progress-value {
            background-color: var(--primary-color);
            transition: width 0.3s ease;
        }

        .study-progress-wrapper {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            width: 100%;
            max-width: 400px;
        }

        .study-progress-wrapper .study-progress-bar {
            flex-grow: 1;
        }

        .study-progress-wrapper .study-progress-counter {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-variant-numeric: tabular-nums;
            white-space: nowrap;
        }

        /* === POLISHED FLASHCARD BUTTONS  === */
        .study-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 700px;
            gap: 0.25rem;
        }

        .study-nav-and-ratings {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .study-controls .srs-rating-group {
            display: flex;
            gap: 0.5rem;
        }

        /* Base style for the new "frosted glass" buttons */
        .btn-study-rating {
            border: 1px solid rgba(255, 255, 255, 0.3);
            background-color: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 9999px;
            padding: 0.75rem 1.25rem;
            font-size: 0.95rem;
            color: var(--text-on-primary);
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease-in-out;
        }

        .btn-study-rating:hover:not(:disabled) {
            transform: translateY(-2px) scale(1.05);
            background-color: rgba(255, 255, 255, 0.25);
        }

        .btn-again:hover:not(:disabled) {
            box-shadow: 0 0 15px 2px var(--sm2-red);
        }

        .btn-hard:hover:not(:disabled) {
            box-shadow: 0 0 15px 2px var(--sm2-orange);
        }

        .btn-good:hover:not(:disabled) {
            box-shadow: 0 0 15px 2px var(--sm2-skyblue);
        }

        .btn-easy:hover:not(:disabled) {
            box-shadow: 0 0 15px 2px var(--sm2-green);
        }

        .btn-hold:hover:not(:disabled) {
            box-shadow: 0 0 15px 2px var(--sm2-purple);
        }

        /* The 'pop' animation on click is preserved */
        .btn-study-rating.btn-popped {
            animation: btn-pop 0.8s ease;
        }

        @keyframes btn-pop {

            0%,
            100% {
                transform: scale(1);
            }

            20% {
                transform: scale(1.2);
            }

            40% {
                transform: scale(0.95);
            }

            60% {
                transform: scale(1.1);
            }
        }

        .btn-again,
        .btn-hard,
        .btn-hold,
        .btn-good,
        .btn-easy {
            background: none;
        }

        .study-controls .btn-icon-nav,
        .study-controls .btn-exit-study {
            width: 35px;
            height: 35px;
            padding: 3px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: var(--transition-fast);
            box-sizing: border-box;
        }

        /* Individual styles for appearance */
        .study-controls .btn-icon-nav {
            background-color: transparent;
            border: none;
            color: var(--text-secondary);
        }

        .study-controls .btn-exit-study {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        /* Hover states remain the same */
        .study-controls .btn-icon-nav:hover:not(:disabled) {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .study-controls .btn-exit-study:hover:not(:disabled) {
            background-color: color-mix(in srgb, var(--danger-color) 10%, var(--bg-tertiary));
            color: var(--danger-color);
            border-color: color-mix(in srgb, var(--danger-color) 40%, var(--border-color));
        }

        .study-controls .btn-icon-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .mcq-controls-right-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        /* Mobile Responsiveness */
        @media (max-width: 680px) {
            .study-controls {
                flex-wrap: wrap;
                justify-content: space-between;
                align-items: center;
                gap: 6px;
            }

            .study-controls .srs-rating-group {
                order: 1;
                width: 100%;
                gap: 4px;
            }

            .btn-study-rating {
                flex-grow: 1;
                padding: 0.75rem 0.5rem;
                font-size: 0.85rem;
            }

            .study-nav-and-ratings,
            .mcq-controls-right-group {
                order: 2;
            }

            .study-controls .btn-icon-nav,
            .study-controls .btn-exit-study {
                width: 35px;
                height: 35px;
            }
        }

        .study-card-content-box.rated-again {
            border-color: var(--sm2-red);
            animation: glow-red 1.5s ease;
        }

        .study-card-content-box.rated-hard {
            border-color: var(--sm2-orange);
            animation: glow-orange 1.5s ease;
        }

        .study-card-content-box.rated-hold {
            border-color: var(--sm2-purple);
            animation: glow-purple 1.5s ease;
        }

        .study-card-content-box.rated-good {
            border-color: var(--sm2-skyblue);
            animation: glow-skyblue 1.5s ease;
        }

        .study-card-content-box.rated-easy {
            border-color: var(--sm2-green);
            animation: glow-green 1.5s ease;
        }

        @keyframes glow-red {

            0%,
            100% {
                box-shadow: 0 0 0px var(--sm2-red);
            }

            50% {
                box-shadow: 0 0 20px var(--sm2-red);
            }
        }

        @keyframes glow-orange {

            0%,
            100% {
                box-shadow: 0 0 0px var(--sm2-orange);
            }

            50% {
                box-shadow: 0 0 20px var(--sm2-orange);
            }
        }

        @keyframes glow-purple {

            0%,
            100% {
                box-shadow: 0 0 0px var(--sm2-purple);
            }

            50% {
                box-shadow: 0 0 20px var(--sm2-purple);
            }
        }

        @keyframes glow-skyblue {

            0%,
            100% {
                box-shadow: 0 0 0px var(--sm2-skyblue);
            }

            50% {
                box-shadow: 0 0 20px var(--sm2-skyblue);
            }
        }

        @keyframes glow-green {

            0%,
            100% {
                box-shadow: 0 0 0px var(--sm2-green);
            }

            50% {
                box-shadow: 0 0 20px var(--sm2-green);
            }
        }

        .btn-again {
            background: linear-gradient(45deg, #C70039, #900C3F);
        }

        .btn-hard {
            background: linear-gradient(45deg, #FF5733, #FF8D1A);
        }

        .btn-hold {
            background: linear-gradient(45deg, var(--sm2-purple), #c084fc);
        }

        .btn-good {
            background: linear-gradient(45deg, var(--sm2-skyblue), #7dd3fc);
        }

        .btn-easy {
            background: linear-gradient(45deg, var(--sm2-green), #4ade80);
        }





        /* CATEGORY SECTIONAL DESIGN */
        /* --- A. The New View Container & Controls (No Change) --- */
        .category-view-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .category-controls-hub {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .category-controls-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .export-dropdown-container {
            position: relative;
            display: inline-block;
        }

        .export-dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            z-index: 10;
            display: none;
            flex-direction: column;
            gap: 4px;
            padding: 4px;
            width: 160px;
        }

        .export-dropdown-menu.show {
            display: flex;
        }

        .export-dropdown-menu .btn {
            width: 100%;
            justify-content: flex-start;
        }

        /* --- B. The "Sectional Card" Component --- */
        .sectional-card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            padding: 1.25rem 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            transition: all 0.2s ease-in-out;
            box-shadow: var(--shadow-sm);
            content-visibility: auto;
            contain-intrinsic-size: 1px 300px;
        }

        .sectional-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow);
            border-color: var(--primary-color);
        }

        .sectional-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .sectional-card-title {
            font-size: 1.25rem;
            font-weight: 600;
            cursor: pointer;
            flex-grow: 1;
        }

        .sectional-card-body {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .snippet {
            font-size: 1.1rem;
            color: var(--text-secondary);
            border-left: 3px solid var(--border-color);
            padding-left: 8px;
            margin: 0;
            cursor: default;
        }

        .sectional-card-body .snippet .image-container,
        .focus-mode-body .snippet .image-container {
            position: relative;
            display: block;
            overflow: hidden;
            border-radius: var(--border-radius-lg);
            width: 100%;
            padding-top: 56.25%;
            background-color: var(--bg-tertiary);
        }

        .sectional-card-body .snippet .image-container img,
        .focus-mode-body .snippet .image-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            object-fit: cover;
            object-position: center;
        }

        /*  Professional styling for the image caption overlay */
        .snippet .image-caption {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
            color: white;
            padding: 0.2rem;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 500;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            border-bottom-left-radius: var(--border-radius-lg);
            border-bottom-right-radius: var(--border-radius-lg);
        }

        /* --- C. The Highlight Toggle Effect --- */
        .category-view-container.hide-snippet-colors .snippet [class*="highlight-"],
        .category-view-container.hide-snippet-colors .snippet [class*="text-"],
        .focus-mode-body.hide-snippet-colors .snippet [class*="highlight-"],
        .focus-mode-body.hide-snippet-colors .snippet [class*="text-"] {
            background-color: transparent !important;
            border-color: transparent !important;
            color: var(--text-primary) !important;
            transition: all 0.3s ease-in-out;
        }


        /* --- D. Layout Toggle Button (No Change) --- */
        .layout-toggle-btn {
            display: flex;
            background-color: var(--bg-tertiary);
            padding: 4px;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
        }

        .layout-toggle-btn .btn-icon {
            width: 36px;
            height: 32px;
            border-radius: 6px;
            color: var(--text-secondary);
        }

        .layout-toggle-btn .btn-icon.active {
            background-color: var(--bg-secondary);
            color: var(--primary-color);
            box-shadow: var(--shadow-sm);
        }

        /* --- E. Masonry Grid Layout --- */
        @media (min-width: 612px) {
            .category-view-container.grid-mode-active .sectional-card-container {
                column-count: 2;
                column-gap: 0.6rem;
            }

            .category-view-container.grid-mode-active .sectional-card {
                break-inside: avoid;
                margin-bottom: 0.6rem;
                width: 100%;
            }
        }

        @media (min-width: 1200px) {
            .category-view-container.grid-mode-active .sectional-card-container {
                column-count: 3;
            }
        }

        .category-view-container.grid-mode-active .sectional-card img {
            max-width: 100%;
            height: auto;
            border-radius: var(--border-radius);
        }



        /* --- F. Immersive Focus Mode (v2 FINAL POLISH) --- */
        .focus-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: var(--bg-primary);
            z-index: 20000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            animation: fadeIn 0.3s ease;
        }

        .focus-mode-content {
            width: 100%;
            max-width: 95vw;
            height: 100%;
            display: flex;
            flex-direction: column;
            text-align: center;
        }

        .focus-mode-title {
            font-weight: 700;
            margin-bottom: 0.25rem;
            padding-bottom: 0.25rem;
            font-size: 1.4rem;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            flex-shrink: 0;
        }

        @media (max-width: 612px) {
            .focus-mode-title {
                font-size: clamp(1.25rem, 6vw, 1.1rem);
                margin-bottom: 0.25rem;
                padding-bottom: 0.25rem;
            }
        }

        .focus-mode-body {
            display: flex;
            flex-direction: column;
            gap: 4px;
            text-align: left;
            overflow-y: auto;
            overflow-x: hidden;
            /* Changed from visible to hidden to prevent horiz scroll */
            padding: 0.5rem;
            font-size: var(--focus-mode-font-size, 1.1rem);
            padding-bottom: 120px;
            scroll-padding-bottom: 120px;
            max-width: 100%;
            /* Ensure it doesn't overflow */
        }

        /* --- SIGMA MODE: FULL WIDTH --- */
        .focus-mode-overlay.sigma-mode-article .focus-mode-body {
            padding: 0;
            max-width: 100%;
            width: 100%;
        }

        /* Prevent selection during laser mode */
        .laser-active,
        .laser-active * {
            user-select: none;
            -webkit-user-select: none;
            cursor: none !important;
        }

        .focus-mode-overlay.sigma-mode-article .focus-mode-body>* {
            max-width: 100% !important;
            box-sizing: border-box;
            padding-left: 3rem;
            padding-right: 3rem;
        }

        /* Style the scrollbar to be less obtrusive and match the app's theme. */
        .focus-mode-body::-webkit-scrollbar {
            width: 10px;
        }

        .focus-mode-body::-webkit-scrollbar-track {
            background: transparent;
        }

        .focus-mode-body::-webkit-scrollbar-thumb {
            background-color: var(--border-color);
            border-radius: 10px;
            border: 2px solid var(--bg-primary);
        }

        .focus-mode-body::-webkit-scrollbar-thumb:hover {
            background-color: var(--text-secondary);
        }

        .focus-mode-body .snippet {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent;
            padding: 1px, 3px, 1px, 3px;
            border-radius: var(--border-radius);
            line-height: 1.5;
        }

        .focus-mode-body .nk-accordion {
            margin: 0.25rem 0;
            box-shadow: none;
        }

        .focus-mode-body .nk-accordion:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow-sm);
        }

        .focus-mode-body .snippet,
        .focus-mode-body .nk-text-tile-content,
        .focus-mode-body .nk-mcq-question,
        .focus-mode-body .nk-timeline-title,
        .focus-mode-body .nk-timeline-date,
        .focus-mode-body .nk-accordion-title,
        .focus-mode-body .nk-accordion-content {
            font-size: inherit;
        }

        .focus-mode-body .nk-text-tile {
            display: flex;
            width: 100%;
            max-width: 100%;
            margin: 0;
        }

        .focus-mode-body .snippet:focus,
        .focus-mode-body .snippet:hover {
            outline: none;
            border-color: var(--primary-color);
            background-color: var(--bg-tertiary);
        }

        .focus-mode-body .snippet.is-hidden {
            border: 2px dashed var(--border-color);
            background-color: transparent;
        }

        .focus-mode-body .snippet.is-hidden>* {
            opacity: 0.05;
            pointer-events: none;
        }

        .focus-mode-body .snippet.is-hidden:focus,
        .focus-mode-body .snippet.is-hidden:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--primary-color);
            box-shadow: 0 0 12px rgba(var(--primary-color-rgb), 0.4);
        }

        .focus-mode-controls {
            position: fixed;
            bottom: 0.75rem;
            left: 1.5rem;
            transform: none;
            display: flex;
            gap: 8px;
            padding: 6px 10px;
            border-radius: 24px;
            background-color: rgba(var(--bg-secondary-rgb), 0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(var(--border-color-rgb), 0.5);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
        }

        .focus-mode-controls .btn-icon,
        .focus-mode-controls .toggle-switch {
            width: 34px;
            height: 34px;
            background-color: var(--bg-primary);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        .focus-mode-controls .btn-icon svg {
            width: 16px;
            height: 16px;
            stroke-width: 2;
        }

        .focus-mode-controls .btn-icon:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            background-color: var(--bg-tertiary);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        /* Styles for the new immersive mode toggle */
        .focus-mode-overlay.controls-hidden .focus-mode-controls {
            background: transparent;
            border-color: transparent;
            box-shadow: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .focus-mode-overlay.controls-hidden .focus-mode-controls>*:not(.immersive-toggle-btn) {
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
            transition: all 0.2s ease-out;
        }

        .immersive-toggle-btn {
            transition: all 0.2s ease-in-out;
        }

        .focus-mode-overlay.controls-hidden .immersive-toggle-btn {
            opacity: 0.5;
            animation: slow-pulse 4s infinite;
        }

        .focus-mode-overlay.controls-hidden .immersive-toggle-btn:hover {
            opacity: 1;
        }

        .focus-mode-overlay.controls-hidden .stage-mode-controls {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Hide Co-pilot in Immersive Mode */
        body:has(.focus-mode-overlay.controls-hidden) #kash-copilot-toggle {
            opacity: 0 !important;
            pointer-events: none !important;
            transition: opacity 0.2s ease-out;
        }

        /* Top-right exit button for Immersive Mode */
        #immersive-exit-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 32px;
            height: 32px;
            background: rgba(var(--bg-secondary-rgb), 0.4);
            backdrop-filter: blur(4px);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20002;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            color: var(--text-secondary);
        }

        #immersive-exit-btn:hover {
            background: rgba(var(--bg-secondary-rgb), 0.8);
            transform: scale(1.1);
            color: var(--primary-color);
        }

        .focus-mode-overlay.controls-hidden #immersive-exit-btn {
            opacity: 1;
            pointer-events: auto;
        }

        /* Prevent default blue outline and add custom theme-sensitive 3D effect */
        .focus-mode-body:focus,
        .focus-mode-body:focus-visible {
            outline: none;
            box-shadow: inset 0 0 0 2px var(--primary-color), inset 0 0 20px 5px rgba(var(--primary-color-rgb), 0.15);
        }

        /* --- G. Stage Presentation Mode ("Smart Scroll") --- */
        .focus-mode-overlay.stage-mode-active .focus-mode-body {
            scroll-behavior: smooth;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .focus-mode-overlay.stage-mode-active .focus-mode-body::-webkit-scrollbar {
            display: none;
        }

        .focus-mode-overlay.stage-mode-active .focus-mode-controls {
            display: none;
        }

        .focus-mode-overlay.stage-mode-active .snippet {
            opacity: 0.3;
            transition: opacity 0.4s ease-in-out;
        }

        .focus-mode-overlay.stage-mode-active .snippet.is-visible {
            opacity: 1.0;
        }

        .stage-mode-controls {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 5px 8px;
            border-radius: var(--border-radius-lg);
            background-color: rgba(var(--bg-secondary-rgb), 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            z-index: 20001;
        }

        /*  Only show controls on hover if annotation isn't active */
        .focus-mode-overlay.stage-mode-active:not(.annotation-active):hover .stage-mode-controls,
        .focus-mode-overlay.stage-mode-active .stage-mode-controls:hover {
            opacity: 1;
        }

        .focus-mode-overlay.stage-mode-active {
            padding: 1rem 2vw;
        }

        /* --- H. Stage Mode Articulator & Toolbar Upgrades --- */
        .focus-mode-overlay.articulator-active .focus-mode-body {
            scroll-snap-type: none !important;
            overflow-y: auto !important;
        }

        .focus-mode-overlay.articulator-active .snippet {
            opacity: 1 !important;
            transform: none !important;
            filter: none !important;
        }



        /* More Menu */
        .stage-more-menu-container {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .stage-more-popup {
            position: absolute;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            background-color: rgba(var(--bg-secondary-rgb), 0.9);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            padding: 0.5rem;
            display: flex;
            flex-direction: row;
            gap: 0.5rem;
            box-shadow: var(--shadow-xl);
            opacity: 0;
            pointer-events: none;
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 20002;
            min-width: max-content;
        }

        /* FIX: Restrict hover behavior to devices that support it, to prevent sticky hover on mobile */
        @media (hover: hover) {
            .stage-more-menu-container:hover .stage-more-popup {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
                pointer-events: all;
            }
        }

        .stage-more-menu-container.active .stage-more-popup {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: all;
        }

        .stage-more-popup::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 6px;
            border-style: solid;
            border-color: rgba(var(--bg-secondary-rgb), 0.9) transparent transparent transparent;
        }

        .stage-mode-controls .btn-icon,
        .stage-mode-controls .toggle-switch {
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stage-mode-controls .btn-icon svg {
            width: 20px;
            height: 20px;
        }


        .stage-snippet-counter {
            font-weight: 500;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
            user-select: none;
            padding: 0 4px;
        }

        .stage-progress-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .progress-dot {
            width: 9px;
            height: 9px;
            background-color: var(--border-color);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .progress-dot:hover {
            transform: scale(1.3);
        }

        /* Hide image tool when not in image annotation mode */
        #whiteboard-overlay:not(.has-bg-image) .wb-image-only {
            display: none;
        }

        .progress-dot.active {
            background-color: var(--primary-color);
            transform: scale(1.4);
        }

        /* --- Mobile Responsive Presentation Mode Controls --- */
        @media (max-width: 612px) {

            /* Stage Mode Mobile Fixes - Compact Layout */
            .stage-mode-controls {
                max-width: calc(100vw - 1rem);
                padding: 6px 10px;
                gap: 4px;
                bottom: 0.75rem;
                left: 50%;
                transform: translateX(-50%);
                flex-wrap: nowrap;
                overflow: visible;
                /* Don't cut off More Options popup */
            }

            .stage-mode-controls .btn-icon,
            .stage-mode-controls .toggle-switch {
                width: 32px;
                height: 32px;
                min-width: 32px;
                flex-shrink: 0;
            }

            .stage-mode-controls .btn-icon svg {
                width: 16px;
                height: 16px;
            }

            .stage-mode-controls .control-divider {
                margin: 0 3px;
                height: 20px;
            }

            /* Hide these on mobile - they'll be in More Options */
            .stage-mode-controls>.premium-feature-locked,
            .stage-mode-controls>#teleprompter-toggle-btn,
            .stage-mode-controls>button[title*="Highlight"] {
                display: none !important;
            }

            /* Ensure More Options container is visible and well-positioned */
            .stage-mode-controls .stage-more-menu-container {
                position: static;
            }

            .stage-mode-controls .stage-more-popup {
                bottom: calc(100% + 10px);
                right: auto;
                left: 50%;
                transform: translateX(-50%);
                min-width: auto;
                display: flex;
                flex-wrap: wrap;
                gap: 6px;
                padding: 10px;
                justify-content: center;
                max-width: calc(100vw - 2rem);
            }

            .stage-more-popup::after {
                display: none;
            }

            /* Focus Mode Controls Mobile Fixes */
            .focus-mode-controls {
                left: 50%;
                transform: translateX(-50%);
                max-width: calc(100vw - 1rem);
                padding: 6px 10px;
                gap: 4px;
            }

            .focus-mode-controls .btn-icon,
            .focus-mode-controls .toggle-switch {
                width: 32px;
                height: 32px;
                min-width: 32px;
            }

            .focus-mode-controls .btn-icon svg {
                width: 15px;
                height: 15px;
            }

            /* Hide Co-pilot toggle in Presentation Mode to prevent overlap */
            body:has(.focus-mode-overlay) #kash-copilot-toggle {
                display: none !important;
            }

            /* Ensure focus mode content doesn't overflow */
            .focus-mode-content {
                max-width: 100vw;
                padding: 0 0.5rem;
            }

            .focus-mode-body {
                padding-bottom: 80px;
            }

            /* Mobile Teleprompter Resizer - Make it more accessible */
            body.mobile-view #teleprompter-resizer {
                height: 16px !important;
                background: linear-gradient(90deg, transparent, var(--border-color), transparent);
            }

            body.mobile-view #teleprompter-resizer::before {
                content: '';
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 40px;
                height: 4px;
                background: var(--primary-color);
                border-radius: 2px;
                opacity: 0.6;
            }

            body.mobile-view #teleprompter-resizer:hover::before,
            body.mobile-view #teleprompter-resizer.is-resizing::before {
                opacity: 1;
                width: 60px;
            }

            /* Smart blur disabled styling */
            .focus-mode-overlay.stage-mode-active .focus-mode-body.smart-blur-disabled .snippet,
            .focus-mode-overlay.stage-mode-active .focus-mode-body.smart-blur-disabled .nk-mcq-block,
            .focus-mode-overlay.stage-mode-active .focus-mode-body.smart-blur-disabled .nk-accordion,
            .focus-mode-overlay.stage-mode-active .focus-mode-body.smart-blur-disabled .nk-text-tile {
                opacity: 1.0 !important;
            }

            /* Category Header Mobile Responsive */
            .category-header {
                flex-wrap: wrap;
                gap: 8px;
            }

            .category-header .header-controls {
                width: 100%;
                justify-content: flex-start;
                flex-wrap: wrap;
                gap: 6px;
            }

            .category-header .btn-icon {
                width: 32px;
                height: 32px;
                min-width: 32px;
            }

            /* Show mobile-only options in the More Options popup on mobile */
            .stage-more-popup .mobile-only-option {
                display: flex !important;
            }
        }

        /* Hide mobile-only options on desktop - they're already visible in toolbar */
        @media (min-width: 613px) {
            .stage-more-popup .mobile-only-option {
                display: none !important;
            }
        }

        /* Smart blur styles - applies on all screen sizes */
        .focus-mode-overlay.stage-mode-active .focus-mode-body.smart-blur-disabled .snippet,
        .focus-mode-overlay.stage-mode-active .focus-mode-body.smart-blur-disabled .nk-mcq-block,
        .focus-mode-overlay.stage-mode-active .focus-mode-body.smart-blur-disabled .nk-accordion,
        .focus-mode-overlay.stage-mode-active .focus-mode-body.smart-blur-disabled .nk-text-tile {
            opacity: 1.0 !important;
        }

        /* ==========================================================================
           STAGE & ARTICLE MODE - Images, Videos, and Maps Fix
           ========================================================================== */

        /* --- IMAGES: Remove float/alignment in Stage modes - display centered block --- */
        /* Stage mode needs large centered images */
        .focus-mode-overlay.stage-mode-active .image-container.align-left,
        .focus-mode-overlay.stage-mode-active .image-container.align-right {
            float: none !important;
            margin-left: auto !important;
            margin-right: auto !important;
            max-width: 85vw !important;
            display: block !important;
            clear: both !important;
        }

        /* Stage Presentation Mode - Reset ratio-based image container for proper display */
        .focus-mode-overlay.stage-mode-active .snippet .image-container {
            padding-top: 0 !important;
            height: auto;
            max-height: 65vh;
            display: block;
            overflow: visible;
            max-width: 85vw;
            margin: 1rem auto;
        }

        .focus-mode-overlay.stage-mode-active .snippet .image-container img {
            position: relative !important;
            width: auto !important;
            height: auto !important;
            max-width: 85vw !important;
            max-height: 60vh;
            object-fit: contain !important;
            object-position: center;
            border-radius: var(--border-radius-lg);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            display: block;
            margin: 0 auto;
        }

        /* ==========================================================================
           SIGMA ARTICLE MODE - Mimic Read Mode Layout Exactly
           The key difference: preserve natural content flow (tables, inline elements, etc.)
           ========================================================================== */

        /* Sigma Article Mode - Standalone images (NOT inside tables) get article styling */
        .focus-mode-overlay.sigma-mode-article .snippet>.image-container,
        .focus-mode-overlay.sigma-mode-article .snippet>p>.image-container {
            padding-top: 0 !important;
            height: auto;
            max-height: none;
            display: block;
            margin: 1.5rem auto;
            max-width: 85vw;
        }

        .focus-mode-overlay.sigma-mode-article .snippet>.image-container img,
        .focus-mode-overlay.sigma-mode-article .snippet>p>.image-container img {
            position: relative !important;
            width: auto !important;
            height: auto !important;
            max-width: 85vw !important;
            max-height: 75vh;
            object-fit: contain !important;
            object-position: center;
            border-radius: var(--border-radius-lg);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            display: block;
            margin: 0 auto;
        }

        /* Sigma Article Mode - Images inside tables MUST behave like read mode */
        /* Higher specificity to override any other rules */
        .focus-mode-overlay.sigma-mode-article .snippet table .image-container,
        .focus-mode-overlay.sigma-mode-article table .image-container,
        .focus-mode-overlay.sigma-mode-article td .image-container,
        .focus-mode-overlay.sigma-mode-article th .image-container {
            display: inline-block !important;
            max-width: 100% !important;
            padding-top: 0 !important;
            height: auto !important;
            margin: 0.5rem auto !important;
            float: none !important;
            clear: none !important;
        }

        .focus-mode-overlay.sigma-mode-article .snippet table .image-container img,
        .focus-mode-overlay.sigma-mode-article table .image-container img,
        .focus-mode-overlay.sigma-mode-article td .image-container img,
        .focus-mode-overlay.sigma-mode-article th .image-container img {
            position: relative !important;
            max-width: 100% !important;
            max-height: 300px !important;
            width: auto !important;
            height: auto !important;
            object-fit: contain !important;
            border-radius: var(--border-radius) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12) !important;
            display: block !important;
            margin: 0 auto !important;
        }

        /* Sigma Article Mode - Aligned images not in tables */
        /* But aligned images IN tables should stay in place */
        .focus-mode-overlay.sigma-mode-article table .image-container.align-left,
        .focus-mode-overlay.sigma-mode-article table .image-container.align-right,
        .focus-mode-overlay.sigma-mode-article td .image-container.align-left,
        .focus-mode-overlay.sigma-mode-article td .image-container.align-right {
            float: none !important;
            display: inline-block !important;
            max-width: 100% !important;
            margin: 0.5rem auto !important;
        }

        /* Ensure standalone images (not in snippets) also display correctly */
        .focus-mode-overlay.stage-mode-active .focus-mode-body>.image-container,
        .focus-mode-overlay.sigma-mode-article .focus-mode-body>.image-container {
            display: block;
            padding: 1rem;
            max-height: 70vh;
            max-width: 85vw;
            margin: 1rem auto;
        }

        .focus-mode-overlay.stage-mode-active .focus-mode-body>.image-container img,
        .focus-mode-overlay.sigma-mode-article .focus-mode-body>.image-container img {
            max-width: 85vw;
            max-height: 65vh;
            object-fit: contain;
            border-radius: var(--border-radius-lg);
            display: block;
            margin: 0 auto;
        }

        /* --- TABLES: Exact Replica of Read Mode for Sigma Article Mode --- */
        .focus-mode-overlay.sigma-mode-article .article-content-wrapper table {
            width: 100% !important;
            border-collapse: separate;
            border-spacing: 0;
            margin: 1.5em 0;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            overflow: hidden;
            table-layout: auto;
            background-color: transparent;
        }

        .focus-mode-overlay.sigma-mode-article .article-content-wrapper th,
        .focus-mode-overlay.sigma-mode-article .article-content-wrapper td {
            border-bottom: 1px solid var(--border-color);
            padding: 12px 16px;
            text-align: left;
            vertical-align: top;
            position: relative;
            color: inherit;
        }

        .focus-mode-overlay.sigma-mode-article .article-content-wrapper td {
            border-left: 1px solid var(--border-color);
        }

        .focus-mode-overlay.sigma-mode-article .article-content-wrapper td:first-child,
        .focus-mode-overlay.sigma-mode-article .article-content-wrapper th:first-child {
            border-left: none;
        }

        .focus-mode-overlay.sigma-mode-article .article-content-wrapper th {
            background-color: rgba(var(--primary-color-rgb), 0.07);
            font-weight: 600;
        }

        .focus-mode-overlay.sigma-mode-article .article-content-wrapper tr:last-child td {
            border-bottom: none;
        }

        /* --- VIDEOS: Fix Blank Screens & Alignment --- */

        /* 1. Presentation/Stage Mode (Strict Center) - Not Article Mode */
        .focus-mode-overlay.stage-mode-active:not(.sigma-mode-article) .nk-video-embed {
            float: none !important;
            margin: 1.5rem auto !important;
            max-width: 85vw !important;
            display: block !important;
            clear: both !important;
            aspect-ratio: 16 / 9;
            height: auto !important;
            min-height: 200px;
            /* Prevent collapse */
        }

        .focus-mode-overlay.stage-mode-active:not(.sigma-mode-article) .nk-video-embed iframe {
            margin: 0 auto;
            display: block;
        }

        /* 2. Global Video Fix (Ensure dimensions to prevent blankness) */
        .focus-mode-overlay .nk-video-embed iframe {
            width: 100%;
            height: auto;
            min-height: 250px;
            max-width: 100%;
        }

        /* 3. Sigma Article Mode - Enforce Read Mode Behavior & Interaction */
        .focus-mode-overlay.sigma-mode-article .nk-video-embed,
        .focus-mode-overlay.sigma-mode-article .nk-video-embed iframe {
            pointer-events: auto !important;
        }

        /* --- MAPS: Make maps work properly in Stage & Article modes --- */
        .focus-mode-overlay.stage-mode-active .nk-map-embed,
        .focus-mode-overlay.sigma-mode-article .nk-map-embed {
            margin: 1.5rem auto !important;
            max-width: 85vw !important;
            display: block !important;
        }

        .focus-mode-overlay.stage-mode-active .nk-map-embed iframe,
        .focus-mode-overlay.sigma-mode-article .nk-map-embed iframe {
            max-width: 85vw;
            display: block;
            margin: 0 auto;
        }

        /* Ensure maps are interactive in Article mode */
        .focus-mode-overlay.sigma-mode-article .nk-map-embed,
        .focus-mode-overlay.sigma-mode-article .nk-map-embed iframe,
        .focus-mode-overlay.sigma-mode-article .nk-map-embed .nk-map-controls {
            pointer-events: auto !important;
        }

        /* ==========================================================================
           STAGE MODE INNOVATIONS - Bento Layouts, Build Animations, 2D Transitions
           ========================================================================== */

        /* --- Innovation 1: Bento Slide Layouts --- */
        .focus-mode-overlay.stage-mode-active .stage-bento-split {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr;
            gap: 1.5rem;
            width: 100%;
            max-width: 95vw;
            min-height: 60vh;
            align-items: start;
            padding: 2rem;
            box-sizing: border-box;
        }

        .focus-mode-overlay.stage-mode-active .stage-bento-split>*:first-child {
            grid-column: 1 / -1;
            text-align: center;
        }

        .focus-mode-overlay.stage-mode-active .stage-bento-split .image-container {
            width: 100%;
            height: auto;
            max-height: 50vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: var(--border-radius-lg);
        }

        .focus-mode-overlay.stage-mode-active .stage-bento-split .image-container img {
            max-width: 100%;
            max-height: 50vh;
            object-fit: contain;
            border-radius: var(--border-radius);
        }

        .focus-mode-overlay.stage-mode-active .stage-bento-split-alt {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr;
            gap: 1.5rem;
            width: 100%;
            max-width: 95vw;
            min-height: 60vh;
            align-items: start;
            padding: 2rem;
            box-sizing: border-box;
        }

        .focus-mode-overlay.stage-mode-active .stage-bento-split-alt>*:first-child {
            grid-column: 1 / -1;
            text-align: center;
        }

        /* Alternate layout: Text on left, Image on right */
        .focus-mode-overlay.stage-mode-active .stage-bento-split-alt .bento-text-content {
            order: 1;
        }

        .focus-mode-overlay.stage-mode-active .stage-bento-split-alt .image-container {
            order: 2;
            width: 100%;
            height: auto;
            max-height: 50vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: var(--border-radius-lg);
        }

        /* Hero Image Slide - Full width image with centered positioning */
        .focus-mode-overlay.stage-mode-active .stage-hero-image {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 70vh;
            padding: 2rem;
            box-sizing: border-box;
        }

        .focus-mode-overlay.stage-mode-active .stage-hero-image .image-container {
            max-width: 85vw;
            max-height: 75vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .focus-mode-overlay.stage-mode-active .stage-hero-image .image-container img {
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            border-radius: var(--border-radius-lg);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        /* Mobile responsiveness for Bento layouts */
        @media (max-width: 768px) {

            .focus-mode-overlay.stage-mode-active .stage-bento-split,
            .focus-mode-overlay.stage-mode-active .stage-bento-split-alt {
                grid-template-columns: 1fr;
                gap: 1rem;
                padding: 1rem;
            }

            .focus-mode-overlay.stage-mode-active .stage-bento-split-alt .bento-text-content,
            .focus-mode-overlay.stage-mode-active .stage-bento-split-alt .image-container {
                order: unset;
            }
        }

        /* --- Innovation 2: List Build Animations --- */
        .focus-mode-overlay.stage-mode-active li.stage-build-hidden {
            opacity: 0;
            transform: translateY(12px);
            pointer-events: none;
        }

        .focus-mode-overlay.stage-mode-active li.stage-build-visible {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 0.45s cubic-bezier(0.25, 0.1, 0.25, 1.0),
                transform 0.45s cubic-bezier(0.25, 0.1, 0.25, 1.0);
        }

        /* Ensure list items have proper spacing during animation */
        .focus-mode-overlay.stage-mode-active ul,
        .focus-mode-overlay.stage-mode-active ol {
            overflow: visible;
        }

        .focus-mode-overlay.stage-mode-active li {
            transition: opacity 0.45s cubic-bezier(0.25, 0.1, 0.25, 1.0),
                transform 0.45s cubic-bezier(0.25, 0.1, 0.25, 1.0);
        }

        /* --- Innovation 3: 2D Camera Transitions --- */
        .stage-camera-viewport {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .stage-camera-canvas {
            position: absolute;
            top: 0;
            left: 0;
            will-change: transform;
            transition: transform 0.7s cubic-bezier(0.25, 0.1, 0.25, 1.0);
        }

        .stage-camera-slide {
            position: absolute;
            width: 100vw;
            height: calc(100vh - 100px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 2rem;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Disable default scrolling when 2D camera is active */
        .focus-mode-overlay.stage-mode-active.stage-camera-active .focus-mode-body {
            overflow: hidden !important;
            scroll-behavior: auto !important;
        }

        /* Slide positioning uses CSS custom properties set by JS */
        .stage-camera-slide {
            left: calc(var(--slide-x, 0) * 100vw);
            top: calc(var(--slide-y, 0) * (100vh - 100px));
        }

        /* Smooth camera pan indicator for user feedback */
        .focus-mode-overlay.stage-mode-active.stage-camera-active .stage-camera-canvas::after {
            content: '';
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 4px;
            background: linear-gradient(90deg,
                    transparent 0%,
                    var(--primary-color) 50%,
                    transparent 100%);
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .focus-mode-overlay.stage-mode-active.stage-camera-active.is-transitioning .stage-camera-canvas::after {
            opacity: 0.6;
        }

        /* --- Sigma Article Mode: Navigation Transition Effect --- */
        /* Subtle fade-pulse effect for presentation-like feel during scroll navigation */
        .focus-mode-overlay.sigma-mode-article .focus-mode-body {
            transition: opacity 0.25s ease-out;
        }

        .focus-mode-overlay.sigma-mode-article.article-nav-transitioning .focus-mode-body {
            opacity: 0.6;
        }

        /* Progress indicator for Article mode navigation */
        .focus-mode-overlay.sigma-mode-article::after {
            content: '';
            position: fixed;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(var(--primary-color-rgb), 0.15) 0%, transparent 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: width 0.35s ease-out, height 0.35s ease-out, opacity 0.35s ease-out;
            z-index: 9999;
        }

        .focus-mode-overlay.sigma-mode-article.article-nav-transitioning::after {
            width: 200px;
            height: 200px;
            opacity: 1;
        }

        /* Smooth scroll with enhanced easing for article mode */
        .focus-mode-overlay.sigma-mode-article .focus-mode-body {
            scroll-behavior: smooth;
        }

        /* Stage Mode Timer - Premium 3D & Aesthetic */
        .stage-timer-widget {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(var(--bg-secondary-rgb), 0.75);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1.5px solid rgba(var(--primary-color-rgb), 0.25);
            border-radius: 22px;
            padding: 1.1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            box-shadow:
                0 8px 16px -4px rgba(0, 0, 0, 0.1),
                0 4px 8px -2px rgba(0, 0, 0, 0.06),
                inset 0 0 0 1px rgba(255, 255, 255, 0.15),
                0 0 0 0 rgba(var(--primary-color-rgb), 0);
            z-index: 10001;
            width: 135px;
            height: 135px;
            color: var(--text-primary);
            transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1),
                box-shadow 0.3s ease,
                transform 0.2s ease;
            cursor: grab;
            overflow: hidden;
            user-select: none;
        }

        .stage-timer-widget:hover {
            transform: translateY(-3px) scale(1.03);
            background: rgba(var(--bg-secondary-rgb), 0.95);
            box-shadow:
                0 12px 28px -6px rgba(var(--primary-color-rgb), 0.3),
                0 8px 16px -4px rgba(0, 0, 0, 0.15),
                inset 0 0 0 1px rgba(255, 255, 255, 0.2),
                0 0 20px rgba(var(--primary-color-rgb), 0.15);
            border-color: rgba(var(--primary-color-rgb), 0.5);
        }

        /* SVG Progress Bar */
        .stage-timer-progress-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: visible;
        }

        .stage-timer-progress-bg {
            fill: none;
            stroke: rgba(var(--text-primary-rgb), 0.1);
            stroke-width: 4;
        }

        .stage-timer-progress-fg {
            fill: none;
            stroke: var(--primary-color);
            stroke-width: 4;
            stroke-linecap: round;
            stroke-dasharray: 283;
            stroke-dashoffset: 0;
            transition: stroke-dashoffset 1s linear, stroke 0.3s ease;
            transform-origin: 50% 50%;
        }

        .stage-timer-widget.critical .stage-timer-progress-fg {
            stroke: var(--danger-color);
            filter: drop-shadow(0 0 4px rgba(var(--danger-color-rgb), 0.5));
        }

        .stage-timer-widget.critical .stage-timer-display-visual,
        .stage-timer-widget.critical .stage-timer-input {
            color: var(--danger-color);
        }

        .stage-timer-widget.running {
            border-color: var(--primary-color);
            border-width: 2px;
            box-shadow:
                0 12px 32px -8px rgba(var(--primary-color-rgb), 0.4),
                0 0 0 1px rgba(var(--primary-color-rgb), 0.4);
            background: rgba(var(--bg-secondary-rgb), 0.98);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            animation: timer-pulse-soft 3s ease-in-out infinite;
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        .stage-timer-widget.finished {
            border-color: var(--danger-color);
            border-width: 2px;
            background: rgba(var(--bg-secondary-rgb), 0.95);
            box-shadow:
                0 12px 32px -8px rgba(var(--danger-color-rgb), 0.5),
                0 0 0 1px rgba(var(--danger-color-rgb), 0.5);
            animation: timer-finished-glow 2s ease-in-out infinite;
        }

        .stage-timer-widget.finished .stage-timer-status {
            opacity: 1 !important;
            transform: translateY(0) !important;
        }

        .stage-timer-widget.finished .stage-timer-progress-fg {
            stroke: var(--danger-color);
            stroke-dashoffset: 283;
        }

        .stage-timer-widget.finished .stage-timer-display-visual,
        .stage-timer-widget.finished .stage-timer-label,
        .stage-timer-widget.finished .stage-timer-status,
        .stage-timer-widget.finished .stage-timer-input {
            color: var(--danger-color) !important;
            text-shadow: 0 2px 10px rgba(var(--danger-color-rgb), 0.25);
        }

        .stage-timer-widget.running .stage-timer-label {
            opacity: 0;
            transform: translateY(-5px);
            pointer-events: none;
        }

        .stage-timer-widget .stage-timer-label {
            transition: all 0.3s ease;
        }

        /* 3D Visual Display Container */
        .stage-timer-display-visual {
            display: none;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 4rem;
            font-weight: 800;
            line-height: 1;
            color: var(--primary-color);
            text-align: center;
            width: 100%;
            height: 64px;
            perspective: 800px;
            transform-style: preserve-3d;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            letter-spacing: -0.02em;
            font-variant-numeric: tabular-nums;
        }

        .stage-timer-widget.running .stage-timer-display-visual {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Hide generic input when running */
        .stage-timer-widget.running .stage-timer-input {
            display: none;
        }

        /* Digit Animation - Smooth 3D Flip */
        .stage-timer-digit {
            display: inline-block;
            animation: digit-flip-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.25);
            backface-visibility: hidden;
            transform-origin: center bottom;
        }

        @keyframes digit-flip-in {
            0% {
                opacity: 0;
                transform: rotateX(-90deg) translateY(20px) scale(0.9);
            }

            100% {
                opacity: 1;
                transform: rotateX(0deg) translateY(0) scale(1);
            }
        }

        @keyframes timer-pulse-soft {

            0%,
            100% {
                box-shadow:
                    0 12px 32px -8px rgba(var(--primary-color-rgb), 0.4),
                    0 0 0 1px rgba(var(--primary-color-rgb), 0.4);
                transform: scale(1);
            }

            50% {
                box-shadow:
                    0 15px 40px -8px rgba(var(--primary-color-rgb), 0.5),
                    0 0 0 1px rgba(var(--primary-color-rgb), 0.6);
                transform: scale(1.02);
            }
        }

        @keyframes timer-finished-glow {

            0%,
            100% {
                transform: scale(1);
                box-shadow:
                    0 12px 32px -8px rgba(var(--danger-color-rgb), 0.5),
                    0 0 0 2px rgba(var(--danger-color-rgb), 0.6);
            }

            50% {
                transform: scale(1.03);
                box-shadow:
                    0 15px 40px -8px rgba(var(--danger-color-rgb), 0.6),
                    0 0 0 3px rgba(var(--danger-color-rgb), 0.4);
            }
        }

        .stage-timer-widget.hidden {
            display: none;
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
        }

        .stage-timer-label {
            font-size: 0.65rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
            color: var(--text-secondary);
        }

        .stage-timer-input {
            font-family: var(--font-display), sans-serif;
            font-size: 4rem;
            font-weight: 800;
            line-height: 1;
            font-variant-numeric: tabular-nums;
            color: var(--text-primary);
            background: transparent;
            border: none;
            text-align: center;
            width: 100%;
            outline: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            /* Pointer to indicate clickable */
            transition: opacity 0.2s ease, text-shadow 0.2s ease;
        }

        .stage-timer-input:hover {
            color: var(--primary-color);
        }

        .stage-timer-widget:active {
            cursor: grabbing;
        }

        .stage-timer-input::selection {
            background: rgba(var(--primary-color-rgb), 0.2);
            color: var(--primary-color);
        }

        /* Remove arrows from number input */
        .stage-timer-input::-webkit-outer-spin-button,
        .stage-timer-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .stage-timer-status {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
            opacity: 0;
            transform: translateY(5px);
            transition: all 0.2s ease;
            height: 1rem;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .stage-timer-widget:hover .stage-timer-status,
        .stage-timer-widget.running .stage-timer-status {
            opacity: 1;
            transform: translateY(0);
        }

        /* Ring around timer - Visual only */
        .stage-timer-ring {
            position: absolute;
            top: -3px;
            left: -3px;
            width: calc(100% + 6px);
            height: calc(100% + 6px);
            pointer-events: none;
            border-radius: 24px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .stage-timer-widget.running .stage-timer-ring {
            opacity: 0;
        }

        .stage-timer-widget.finished .stage-timer-ring {
            opacity: 0.9;
            background: conic-gradient(from 0deg,
                    var(--danger-color),
                    rgba(var(--danger-color-rgb), 0.4),
                    transparent,
                    rgba(var(--danger-color-rgb), 0.4),
                    var(--danger-color));
            animation: timer-ring-rotate 2s linear infinite;
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            padding: 2.5px;
        }

        @keyframes timer-ring-rotate {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .laser-pointer {
            position: fixed;
            width: 15px;
            height: 15px;
            background-color: rgba(255, 20, 20, 0.8);
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 15px 5px rgba(255, 20, 20, 0.5);
            pointer-events: none;
            z-index: 99999;
            transform: translate(-50%, -50%);
            transition: transform 0.05s ease-out;
            display: none;
        }

        .focus-mode-body .is-visible.spotlight {
            opacity: 1 !important;
            transform: scale(1.03);
            box-shadow: 0 0 25px rgba(var(--primary-color-rgb), 0.5);
        }

        /* NEW: Style for keyboard-navigated spotlight */
        @keyframes glow-focus {
            from {
                box-shadow: 0 0 4px -2px var(--primary-color);
            }

            to {
                box-shadow: 0 0 13px 2.5px color-mix(in srgb, var(--primary-color) 60%, transparent);
            }
        }

        .focus-mode-body .spotlight-key-focus,
        .focus-mode-body .snippet:focus,
        .focus-mode-body .snippet:hover,
        .focus-mode-body .nk-mcq-block.spotlight-key-focus,
        .focus-mode-body .nk-mcq-block:focus,
        .focus-mode-body .nk-accordion.spotlight-key-focus,
        .focus-mode-body .nk-accordion:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--primary-color), 0 4px 12px rgba(0, 0, 0, 0.15);
            animation: glow-focus 4.5s infinite alternate;
            border-color: var(--primary-color) !important;
        }

        .focus-mode-body .spotlight-key-focus,
        .focus-mode-body .snippet:focus,
        .focus-mode-body .snippet:hover {
            border: 2px solid var(--primary-color) !important;
            animation: glow-focus 4.5s infinite alternate;
        }

        /* --- NEW: Cinematic Effects --- */
        .focus-mode-overlay.cinematic-active .focus-mode-body .snippet.is-visible,
        .focus-mode-overlay.cinematic-active .focus-mode-body .nk-mcq-block.is-visible,
        .focus-mode-overlay.cinematic-active .focus-mode-body .nk-accordion.is-visible {
            opacity: 0.20;
            transform: translateY(10px) scaleY(1) scaleX(1);
            transition: opacity 0.4s ease-out, transform 0.4s ease-out, box-shadow 0.4s ease-out;
        }

        .focus-mode-overlay.cinematic-active .focus-mode-body .snippet.is-revealing,
        .focus-mode-overlay.cinematic-active .focus-mode-body .nk-mcq-block.is-revealing,
        .focus-mode-overlay.cinematic-active .focus-mode-body .nk-accordion.is-revealing {
            opacity: 1;
            transform: translateY(0) scaleY(1.03) scaleX(1.01);
            box-shadow: 0 8px 20px -5px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .reveal-word {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .reveal-word.visible {
            opacity: 1;
        }

        /* Ken Burns effect for images remains, but is now more subtle */
        @keyframes ken-burns {
            0% {
                transform: scale(1.0) translate(0, 0);
            }

            100% {
                transform: scale(1.05) translate(1%, -1%);
            }
        }

        /* The Ken Burns animation now only applies to the snippet being revealed */
        .focus-mode-overlay.cinematic-active .snippet.is-revealing .image-container {
            overflow: hidden;
        }

        .focus-mode-overlay.cinematic-active .snippet.is-revealing .image-container img {
            animation: ken-burns 20s ease-in-out infinite alternate;
        }

        /* --- NEW: Blackout Screen --- */
        #blackout-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 20002;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }

        .focus-mode-overlay.blackout-active #blackout-screen {
            opacity: 1;
            pointer-events: auto;
        }

        /* --- NEW: Spotlight Effect --- */
        .focus-mode-body.spotlight-active .snippet.is-visible:not(.spotlight),
        .focus-mode-body.spotlight-active .nk-mcq-block.is-visible:not(.spotlight) {
            opacity: 0.1 !important;
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
        }

        .focus-mode-body .is-visible.spotlight {
            opacity: 1 !important;
            transform: scale(1.03);
            box-shadow: 0 0 25px rgba(var(--primary-color-rgb), 0.5);
        }

        /* --- NEW: Live Annotation --- */
        .focus-mode-body {
            position: relative;
        }

        #annotation-canvas {
            position: absolute;
            top: 0;
            left: 0;
            max-width: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .focus-mode-overlay.annotation-active #annotation-canvas {
            pointer-events: auto;
            cursor: crosshair;
        }

        .stage-mode-controls .btn-icon.annotation-btn.active {
            color: var(--text-on-primary);
            background-color: var(--primary-color);
        }

        /* --- UPGRADED: Teleprompter Mode (for Stage Mode) --- */
        .focus-mode-overlay.teleprompter-active {
            flex-direction: row;
            padding: 0;
        }

        #teleprompter-sidebar {
            position: relative;
            width: 30%;
            height: 100%;
            flex-shrink: 0;
            background-color: rgba(var(--bg-secondary-rgb), 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 3rem 0.3rem 1.5rem 0.6rem;
            font-family: var(--font-serif);
            font-size: var(--teleprompter-font-size, 1.1rem);
            line-height: 1.6;
            animation: fadeIn 0.3s ease-out;
            z-index: 20002;
            white-space: normal;
            word-wrap: break-word;
            overflow-wrap: break-word;
            color: var(--text-primary);
            mask-image: linear-gradient(to bottom,
                    transparent 0%,
                    black 15%,
                    black 85%,
                    transparent 100%);
            scroll-behavior: smooth;
        }

        /* --- NEW: Aesthetic Teleprompter Scrollbar --- */
        #teleprompter-sidebar::-webkit-scrollbar {
            width: 8px;
        }

        #teleprompter-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #teleprompter-sidebar::-webkit-scrollbar-thumb {
            background-color: var(--border-color);
            border-radius: 4px;
            border: 2px solid transparent;
            background-clip: content-box;
        }

        #teleprompter-sidebar::-webkit-scrollbar-thumb:hover {
            background-color: var(--primary-color);
        }

        #teleprompter-sidebar blockquote {
            margin-left: 0.25em;
            padding-left: 0.5em;
            border-left: 3px solid var(--border-color);
            font-style: italic;
        }

        /* --- NEW: "Smart" Text Highlight Logic --- */
        #teleprompter-sidebar :is(h1, h2, h3, h4, h5, h6, b, strong, [class*="highlight-"], [class*="text-"]) {
            color: var(--primary-color) !important;
            font-weight: 600 !important;
            background: none !important;
            border: none !important;
        }

        /* Hide complex blocks from the simple teleprompter view */
        #teleprompter-sidebar .nk-mcq-block,
        #teleprompter-sidebar .nk-timeline-block,
        #teleprompter-sidebar .chart-container,
        #teleprompter-sidebar .nk-accordion,
        #teleprompter-sidebar .nk-textile-deck,
        #teleprompter-sidebar .nk-audio-player,
        #teleprompter-sidebar .pdf-attachment-pill,
        #teleprompter-sidebar .image-container {
            display: none;
        }

        /* Ensure clean text flow */
        #teleprompter-sidebar p,
        #teleprompter-sidebar li {
            font-size: inherit !important;
            line-height: inherit !important;
            color: inherit !important;
        }

        #teleprompter-sidebar ul,
        #teleprompter-sidebar ol {
            padding-left: 1.5em;
        }

        #teleprompter-sidebar ul ul,
        #teleprompter-sidebar ol ol,
        #teleprompter-sidebar ol ul,
        #teleprompter-sidebar ul ol {
            padding-left: 0.25em;
            margin-left: 0;
            list-style-type: square !important;
        }

        .focus-mode-overlay.teleprompter-active .focus-mode-content {
            width: 70%;
            flex-grow: 1;
        }

        .focus-mode-overlay.teleprompter-active .stage-mode-controls {
            left: 65%;
        }

        .focus-mode-overlay.teleprompter-active #annotation-toolbar {
            left: 65%;
        }

        /* ---  Mobile Teleprompter (Bottom Bar) --- */
        body.mobile-view .focus-mode-overlay.teleprompter-active {
            flex-direction: column;
        }

        body.mobile-view .focus-mode-overlay.teleprompter-active .focus-mode-content {
            order: 1;
            width: 100%;
            height: 70%;
        }

        body.mobile-view #teleprompter-sidebar {
            order: 2;
            width: 100%;
            height: 30%;
            border-right: none;
            border-top: 1px solid var(--border-color);
        }

        body.mobile-view .focus-mode-overlay.teleprompter-active .stage-mode-controls,
        body.mobile-view .focus-mode-overlay.teleprompter-active #annotation-toolbar {
            left: 50%;
            bottom: 30%;
            margin-bottom: 0.5rem;
            transform: translateX(-50%);
        }

        /* --- NEW: Teleprompter-Specific Controls (V2 Design) --- */
        #teleprompter-controls {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            z-index: 10;
            display: none;
            align-items: center;
            gap: 4px;
            padding: 4px;
            background-color: rgba(var(--bg-secondary-rgb), 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow);
        }

        /* Only show the controls when the teleprompter is active */
        .focus-mode-overlay.teleprompter-active #teleprompter-controls {
            display: flex;
        }

        #teleprompter-controls .btn-icon {
            width: 32px;
            height: 32px;
            background-color: var(--bg-tertiary);
        }

        /* --- NEW: Teleprompter Resizer Handle --- */
        #teleprompter-resizer {
            position: absolute;
            z-index: 15;
            background-color: transparent;
            transition: background-color 0.2s ease-in-out;
        }

        #teleprompter-resizer:hover,
        #teleprompter-resizer.is-resizing {
            background-color: var(--primary-color);
            opacity: 0.7;
        }

        /* Desktop (Vertical Handle) */
        body:not(.mobile-view) #teleprompter-resizer {
            top: 0;
            bottom: 0;
            left: 100%;
            width: 8px;
            cursor: col-resize;
            transform: translateX(-50%);
        }

        /* Mobile (Horizontal Handle) */
        body.mobile-view #teleprompter-resizer {
            left: 0;
            right: 0;
            top: 0;
            height: 16px;
            cursor: row-resize;
            transform: translateY(-50%);
        }


        /* --- NEW: Annotation Toolbar Styles --- */
        #annotation-toolbar {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background-color: rgba(var(--bg-secondary-rgb), 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-lg);
            z-index: 20004;
            animation: slideUp 0.3s ease;
        }

        #annotation-toolbar .tool-btn.active {
            background-color: var(--bg-tertiary);
            color: var(--primary-color);
        }

        #annotation-toolbar .color-pick {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        #annotation-toolbar .color-pick:hover {
            transform: scale(1.1);
        }

        #annotation-toolbar .color-pick.active {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-color) 60%, transparent);
        }

        #annotation-toolbar .btn-icon {
            width: 32px;
            height: 32px;
        }


        /* WHITEBOARD v3 - FULLSCREEN WITH BOTTOM TOOLBAR  */
        #whiteboard-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 25000;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        #whiteboard-overlay.active {
            display: flex;
            animation: wbFadeIn 0.2s ease-out;
        }

        @keyframes wbFadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* Card - Near fullscreen */
        #whiteboard-card {
            width: 100%;
            max-width: 1400px;
            height: 100%;
            max-height: 100%;
            background: var(--bg-secondary);
            border-radius: 20px;
            box-shadow: 0 0 80px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            animation: wbSlideIn 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        /* Fullscreen override for Stage Mode Screenshot */
        #whiteboard-overlay.is-fullscreen #whiteboard-card {
            max-width: 100% !important;
            border-radius: 0 !important;
            box-shadow: none !important;
        }

        @keyframes wbSlideIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Canvas area - MAXIMUM SPACE */
        #whiteboard-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--bg-primary);
            border-radius: 12px 12px 0 0;
            margin: 0.75rem 0.75rem 0 0.75rem;
        }

        /* Background variants */
        .wb-bg-sepia {
            background-color: #f8f1e3 !important;
            background-image: none !important;
        }

        .wb-bg-paper {
            background-color: #f7f5f0 !important;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100' height='100' filter='url(%23noise)' opacity='0.5'/%3E%3C/svg%3E") !important;
        }

        #whiteboard-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            touch-action: none;
            transform-origin: center center;
            z-index: 20;
        }

        /* Background image layer for screenshots - sits BELOW text boxes */
        #whiteboard-bg-image {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        }

        /* Access items behind canvas when in Select Mode */
        .wb-tool-select #whiteboard-canvas {
            pointer-events: none;
        }

        /* Connector lines layer */
        #whiteboard-connectors {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 18;
        }


        /* Text boxes - PREMIUM GLASSMORPHISM DESIGN */
        .wb-text-box {
            position: absolute;
            padding: 14px 18px;
            background: linear-gradient(135deg,
                    rgba(var(--bg-secondary-rgb, 255, 255, 255), 0.85) 0%,
                    rgba(var(--bg-secondary-rgb, 255, 255, 255), 0.65) 100%);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 2px solid var(--primary-color);
            border-radius: 16px;
            cursor: move;
            user-select: none;
            min-width: 120px;
            font-family: var(--font-body);
            font-size: 16px;
            color: var(--text-primary);
            box-shadow:
                0 4px 20px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset,
                0 1px 3px rgba(0, 0, 0, 0.05);
            z-index: 15;
            display: flex;
            align-items: center;
            justify-content: flex-start;
        }

        .wb-text-box.active {
            z-index: 16;
        }

        .wb-text-box.dragging {
            z-index: 100;
        }


        /* LAYER 2: IMAGES (Bottom) */
        .wb-image-box {
            position: absolute;
            min-width: 50px;
            min-height: 50px;
            box-sizing: border-box;
            border: 2px solid transparent;
            border-radius: 12px;
            cursor: grab;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5;
            pointer-events: none;
            transition: box-shadow 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                border-color 0.2s ease;
        }

        .wb-image-box.active {
            z-index: 6;
            border-color: var(--primary-color);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .wb-image-box:hover {
            border-color: var(--primary-color);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .wb-image-box.dragging {
            cursor: grabbing !important;
            opacity: 0.95;
            transform: scale(1.02);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        .wb-image-box.dragging .wb-image-move-handle {
            cursor: grabbing;
            transform: scale(1.2);
        }

        .wb-image-box img {
            width: 100%;
            height: 100%;
            pointer-events: none;
            border-radius: 12px;
            object-fit: fill;
            display: block;
        }

        .wb-image-delete-handle {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            opacity: 0.6;
            transition: all 0.2s;
            z-index: 20;
            transform: scale(0.9);
            pointer-events: auto;
        }

        .wb-image-delete-handle:hover {
            transform: scale(1.1);
            background: #dc2626;
            opacity: 1;
        }

        /* Move Handle (Blue Dot - Top Left) */
        .wb-image-move-handle {
            position: absolute;
            top: -10px;
            left: -10px;
            width: 24px;
            height: 24px;
            background: var(--primary-color);
            color: white;
            border-radius: 50%;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            opacity: 0.6;
            transition: all 0.2s;
            z-index: 20;
            transform: scale(0.9);
            pointer-events: auto;
        }

        .wb-image-move-handle::after {
            content: '';
            font-size: 14px;
        }

        .wb-image-move-handle:hover {
            transform: scale(1.1);
            opacity: 1;
        }

        /* Resize Handle (Bottom Right) */
        .wb-image-resize-handle {
            position: absolute;
            bottom: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: white;
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            cursor: nwse-resize;
            opacity: 0.6;
            pointer-events: auto;
            transition: opacity 0.2s, transform 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .wb-image-resize-handle:hover {
            transform: scale(1.2);
            opacity: 1;
        }

        .wb-image-box.active .wb-image-delete-handle,
        .wb-image-box.active .wb-image-move-handle,
        .wb-image-box.active .wb-image-resize-handle {
            opacity: 1;
            transform: scale(1);
        }

        .wb-image-box.wb-spawn {
            animation: wbSpawnCard 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }



        .wb-text-box:hover {
            transform: translateY(-2px);
            box-shadow:
                0 4px 12px var(--wb-text-shadow-color),
                0 8px 24px var(--wb-text-shadow-color),
                0 0 0 1px var(--wb-text-inset-light) inset;
        }

        .wb-text-box.active {
            transform: translateY(-1px);
            box-shadow:
                0 4px 16px var(--wb-text-shadow-active),
                0 8px 32px var(--wb-text-shadow-active),
                0 0 24px rgba(var(--primary-color-rgb, 100, 100, 255), 0.12),
                0 0 0 1px rgba(255, 255, 255, 0.25) inset;
            border-color: var(--primary-color);
            border-width: 2.5px;
        }


        /* TEXT BOX STYLES - 4 DISTINCT & BEAUTIFUL VARIATIONS */



        .wb-text-box[data-box-style="filled"] {
            background: var(--primary-color);
            border: none;
            padding: 15px 18px;
            box-shadow:
                0 3px 12px rgba(0, 0, 0, 0.18),
                0 6px 24px rgba(0, 0, 0, 0.12),
                0 -2px 6px rgba(255, 255, 255, 0.2) inset,
                0 3px 8px rgba(0, 0, 0, 0.25) inset;
        }

        .wb-text-box[data-box-style="filled"] .wb-text-content {
            color: #ffffff !important;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
        }

        .wb-text-box[data-box-style="filled"]:hover {
            box-shadow:
                0 5px 18px rgba(0, 0, 0, 0.22),
                0 10px 36px rgba(0, 0, 0, 0.18),
                0 -2px 6px rgba(255, 255, 255, 0.25) inset,
                0 3px 8px rgba(0, 0, 0, 0.3) inset;
            transform: translateY(-3px);
        }

        .wb-text-box[data-box-style="glass"] {
            background: rgba(var(--primary-color-rgb, 100, 100, 255), 0.15);
            backdrop-filter: blur(28px) saturate(200%);
            -webkit-backdrop-filter: blur(28px) saturate(200%);
            border: 2px solid rgba(var(--primary-color-rgb, 100, 100, 255), 0.4);
            padding: 14px 18px;
            box-shadow:
                0 3px 18px rgba(var(--primary-color-rgb, 100, 100, 255), 0.1),
                0 6px 36px rgba(0, 0, 0, 0.08),
                0 0 0 1.5px rgba(255, 255, 255, 0.2) inset;
        }

        .wb-text-box[data-box-style="glass"]:hover {
            background: rgba(var(--primary-color-rgb, 100, 100, 255), 0.22);
            border-color: rgba(var(--primary-color-rgb, 100, 100, 255), 0.6);
            box-shadow:
                0 5px 24px rgba(var(--primary-color-rgb, 100, 100, 255), 0.15),
                0 10px 48px rgba(0, 0, 0, 0.1),
                0 0 0 1.5px rgba(255, 255, 255, 0.3) inset;
            transform: translateY(-2px);
        }

        .wb-text-box[data-box-style="minimal"] {
            background: transparent;
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            border: none;
            padding: 12px 16px;
            box-shadow:
                0 1px 10px rgba(0, 0, 0, 0.08),
                0 2px 6px rgba(0, 0, 0, 0.05);
        }

        .wb-text-box[data-box-style="minimal"]::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 18px;
            background: linear-gradient(145deg,
                    var(--wb-text-default-bg) 0%,
                    var(--wb-text-default-bg-2) 100%);
            opacity: 0.15;
            z-index: -1;
        }

        .wb-text-box[data-box-style="minimal"]:hover {
            box-shadow:
                0 2px 14px rgba(0, 0, 0, 0.1),
                0 4px 10px rgba(0, 0, 0, 0.07);
            transform: translateY(-1px);
        }

        .wb-text-box[data-box-style="minimal"]:hover::before {
            opacity: 0.28;
        }

        .wb-text-box[data-box-style="minimal"] .wb-text-content {
            text-decoration: underline;
            text-decoration-thickness: 2px;
            text-underline-offset: 3px;
        }

        .wb-text-box.connecting {
            animation: wbPulseGlow 1.2s ease-in-out infinite;
        }

        @keyframes wbPulseGlow {

            0%,
            100% {
                box-shadow:
                    0 4px 20px rgba(0, 0, 0, 0.1),
                    0 0 0 0 rgba(var(--primary-color-rgb, 100, 100, 255), 0.5);
            }

            50% {
                box-shadow:
                    0 4px 20px rgba(0, 0, 0, 0.1),
                    0 0 0 12px rgba(var(--primary-color-rgb, 100, 100, 255), 0);
            }
        }

        .wb-text-box .wb-text-content {
            outline: none;
            min-width: 80px;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.4;
            overflow: visible;
            padding: 0;
            margin: 0;
            min-height: 1.4em;
            display: flex;
            align-items: center;
        }

        /* Text box controls bar - Premium floating toolbar */
        .wb-text-controls {
            position: absolute;
            top: -44px;
            left: 50%;
            transform: translateX(-50%) translateY(8px);
            display: flex;
            gap: 4px;
            background: linear-gradient(135deg,
                    rgba(var(--bg-tertiary-rgb, 40, 40, 50), 0.95) 0%,
                    rgba(var(--bg-tertiary-rgb, 40, 40, 50), 0.85) 100%);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-radius: 12px;
            padding: 5px 6px;
            opacity: 0;
            visibility: hidden;
            transition:
                opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                visibility 0.2s,
                transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 8px 24px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.08) inset;
        }

        .wb-text-box.active .wb-text-controls {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .wb-text-controls button {
            width: 30px;
            height: 30px;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.15s;
        }

        .wb-text-controls button:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .wb-text-controls button.active {
            background: var(--primary-color);
            color: white;
        }

        .wb-text-controls button.danger:hover {
            background: var(--danger-color);
            color: white;
        }

        .wb-text-controls .wb-ctrl-divider {
            width: 1px;
            background: var(--border-color);
            margin: 4px 2px;
        }

        /* Resize handle */
        .wb-text-box .wb-text-resize {
            position: absolute;
            bottom: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: se-resize;
            opacity: 0;
            transition: opacity 0.15s;
            border: 2px solid var(--bg-secondary);
        }

        .wb-text-box:hover .wb-text-resize,
        .wb-text-box.active .wb-text-resize {
            opacity: 1;
        }

        /* Connector dot - single larger dot for elegant connections */
        .wb-connector-dot {
            position: absolute;
            right: -9px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            background: var(--primary-color);
            border: 2px solid var(--bg-secondary);
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease, background 0.15s ease;
            z-index: 15;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .wb-text-box:hover .wb-connector-dot,
        .wb-text-box.active .wb-connector-dot {
            opacity: 1;
        }

        .wb-connector-dot:hover {
            transform: translateY(-50%) scale(1.15);
            background: var(--text-green);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        /* Active connector state - shows line preview */
        .wb-connector-preview {
            stroke: var(--primary-color);
            stroke-width: 2;
            stroke-dasharray: 6, 4;
            fill: none;
            pointer-events: none;
        }

        /* Spawn animation for text boxes */
        @keyframes wbSpawnCard {
            from {
                transform: scale(0.7);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .wb-text-box.wb-spawn {
            animation: wbSpawnCard 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Dragging state - Premium tactile feedback */
        .wb-text-box.dragging {
            cursor: grabbing !important;
            opacity: 0.92;
            transform: scale(1.02) rotate(0.5deg);
            box-shadow:
                0 20px 50px -10px rgba(0, 0, 0, 0.25),
                0 8px 20px rgba(0, 0, 0, 0.1),
                0 0 0 2px rgba(var(--primary-color-rgb, 100, 100, 255), 0.3);
            z-index: 1000;
            transition: none;
        }


        /* BOTTOM TOOLBAR - ALL CONTROLS */
        #whiteboard-toolbar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            flex-wrap: wrap;
            position: relative;
            width: 100%;
            box-sizing: border-box;
        }

        #whiteboard-toolbar::-webkit-scrollbar {
            display: none;
        }

        /* Cancel button (left) - Uniform size */
        .wb-action-cancel {
            position: relative;
            width: 38px;
            height: 38px;
            border: none;
            background: var(--bg-tertiary);
            border-radius: 12px;
            cursor: pointer;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 20;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .wb-action-cancel:hover {
            background: var(--danger-color);
            color: white;
            transform: scale(1.05);
        }

        /* Add button (right) - Uniform size */
        .wb-action-add {
            position: relative;
            width: 38px;
            height: 38px;
            border: none;
            background: var(--primary-color);
            border-radius: 12px;
            cursor: pointer;
            color: white;
            display: flex !important;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(var(--primary-color-rgb, 100, 100, 255), 0.4);
            z-index: 20;
        }

        .wb-action-add:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(var(--primary-color-rgb, 100, 100, 255), 0.4);
        }

        /* Add dropdown container */
        .wb-add-dropdown {
            position: absolute;
            right: 1rem;
        }

        .wb-add-dropdown .wb-action-add {
            position: relative;
            right: auto;
        }

        /* Add dropdown menu */
        .wb-add-menu {
            position: absolute;
            bottom: 100%;
            right: 0;
            margin-bottom: 8px;
            background: linear-gradient(135deg,
                    rgba(var(--bg-tertiary-rgb, 40, 40, 50), 0.95) 0%,
                    rgba(var(--bg-tertiary-rgb, 40, 40, 50), 0.88) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 14px;
            padding: 6px;
            min-width: 180px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px) scale(0.95);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 12px 40px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.08) inset;
            z-index: 1001;
        }

        .wb-add-dropdown.open .wb-add-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        .wb-add-option {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 10px 12px;
            border: none;
            background: transparent;
            border-radius: 10px;
            cursor: pointer;
            color: var(--text-primary);
            text-align: left;
            transition: all 0.15s;
        }

        .wb-add-option:hover {
            background: rgba(var(--primary-color-rgb, 100, 100, 255), 0.15);
        }

        .wb-add-option svg {
            color: var(--primary-color);
            flex-shrink: 0;
        }

        .wb-add-option span {
            font-size: 14px;
            font-weight: 500;
            display: block;
        }

        .wb-add-option small {
            font-size: 11px;
            color: var(--text-tertiary);
            display: block;
            margin-top: 1px;
        }

        /* LIVE WHITEBOARD BLOCK */
        .whiteboard-block {
            position: relative;
            margin: 1rem 0;
            padding: 0;
            border-radius: var(--border-radius-lg, 12px);
            border: 2px solid var(--border-color);
            background: var(--bg-secondary);
            overflow: hidden;
            transition: all 0.2s;
        }

        .whiteboard-block:hover {
            border-color: var(--primary-color);
            box-shadow: 0 4px 20px rgba(var(--primary-color-rgb, 100, 100, 255), 0.15);
        }

        .whiteboard-block-canvas {
            width: 100%;
            display: block;
            background: var(--bg-primary);
        }

        .whiteboard-block-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0);
            opacity: 0;
            transition: all 0.2s;
        }

        .whiteboard-block:hover .whiteboard-block-overlay {
            opacity: 1;
            background: rgba(0, 0, 0, 0.3);
        }

        .whiteboard-block-edit {
            padding: 12px 20px;
            border: none;
            background: var(--primary-color);
            color: white;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .whiteboard-block-edit:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .whiteboard-block-badge {
            position: absolute;
            top: 8px;
            left: 8px;
            padding: 4px 10px;
            background: rgba(var(--primary-color-rgb, 100, 100, 255), 0.9);
            color: white;
            font-size: 11px;
            font-weight: 600;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
            backdrop-filter: blur(8px);
        }

        /* Tool groups - centered */
        .wb-tool-group {
            display: flex;
            align-items: center;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 4px;
            gap: 2px;
        }

        .wb-tool-btn {
            width: 38px;
            height: 38px;
            padding: 0;
            border: none;
            background: transparent;
            border-radius: 10px;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wb-tool-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .wb-tool-btn.active {
            background: var(--primary-color);
            color: white;
        }

        .wb-tool-btn:active {
            transform: scale(0.92);
        }

        /* More Menu Container */
        .wb-more-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        /* More Menu Dropdown */
        .wb-more-menu {
            position: absolute;
            bottom: 110%;
            right: 0;
            left: auto;
            transform: translateY(10px);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 8px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s cubic-bezier(0.165, 0.84, 0.44, 1);
            z-index: 100;
            width: max-content;
        }


        .wb-more-container:hover .wb-more-menu,
        .wb-more-container.active .wb-more-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* Triangle pointer */
        .wb-more-menu::after {
            content: '';
            position: absolute;
            top: 100%;
            right: 13px;
            left: auto;
            margin-left: 0;
            border-width: 6px;
            border-style: solid;
            border-color: var(--bg-secondary) transparent transparent transparent;
        }

        /* Color swatches */
        .wb-color-group {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 8px;
        }

        .wb-color-swatch {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
            position: relative;
        }

        .wb-color-swatch:hover {
            transform: scale(1.2);
        }

        .wb-color-swatch.active {
            transform: scale(1.1);
            box-shadow: 0 0 0 3px var(--bg-tertiary), 0 0 0 5px currentColor;
        }

        /* Divider */
        .wb-divider {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 6px;
            opacity: 0.4;
        }

        /* Zoom controls */
        .wb-zoom-group {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 4px 10px;
        }

        .wb-zoom-group input[type="range"] {
            width: 70px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--border-color);
            border-radius: 2px;
            cursor: pointer;
        }

        .wb-zoom-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
        }

        .wb-zoom-display {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-muted);
            min-width: 32px;
            text-align: center;
        }


        /* OCCLUSION TAPE BOX */

        .wb-tape-box {
            position: absolute;
            min-width: 40px;
            min-height: 20px;
            border-radius: 12px;
            background: linear-gradient(135deg,
                    rgba(251, 191, 36, 0.92) 0%,
                    rgba(245, 158, 11, 0.92) 100%);
            box-shadow:
                0 4px 12px rgba(245, 158, 11, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border: 1px solid rgba(217, 119, 6, 0.4);
            cursor: pointer;
            transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                box-shadow 0.2s;
            z-index: 50;
            user-select: none;
        }

        .wb-tape-box:hover {
            box-shadow:
                0 6px 16px rgba(245, 158, 11, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
            transform: translateY(-1px);
        }

        /* Revealed state - faded to show content underneath */
        .wb-tape-box.revealed {
            opacity: 0.25;
            pointer-events: auto;
            box-shadow:
                0 2px 6px rgba(245, 158, 11, 0.15),
                0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .wb-tape-box.revealed:hover {
            opacity: 0.4;
        }

        /* Active/Selected state */
        .wb-tape-box.active {
            box-shadow:
                0 0 0 2px var(--primary-color),
                0 6px 16px rgba(245, 158, 11, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.15);
            z-index: 100;
        }

        /* Dragging state */
        .wb-tape-box.dragging {
            opacity: 0.95;
            transform: scale(1.02);
            box-shadow:
                0 10px 30px rgba(245, 158, 11, 0.45),
                0 6px 12px rgba(0, 0, 0, 0.2);
            cursor: grabbing;
            z-index: 200;
        }

        /* Tape delete button - subtle, small */
        .wb-tape-delete {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            background: rgba(0, 0, 0, 0.55);
            color: white;
            border: 1.5px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            font-size: 10px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.15s;
            z-index: 10;
            backdrop-filter: blur(4px);
        }

        .wb-tape-box:hover .wb-tape-delete,
        .wb-tape-box.active .wb-tape-delete {
            opacity: 0.85;
            transform: scale(1);
        }

        .wb-tape-delete:hover {
            opacity: 1;
            background: rgba(220, 38, 38, 0.9);
            transform: scale(1.1);
        }

        /* Tape resize handle */
        .wb-tape-resize {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .wb-tape-resize::before {
            content: '';
            position: absolute;
            bottom: 4px;
            right: 4px;
            width: 8px;
            height: 8px;
            border-right: 2px solid rgba(255, 255, 255, 0.7);
            border-bottom: 2px solid rgba(255, 255, 255, 0.7);
        }

        .wb-tape-box:hover .wb-tape-resize,
        .wb-tape-box.active .wb-tape-resize {
            opacity: 1;
        }

        /* Spawn animation */
        .wb-tape-box.wb-spawn {
            animation: tapeSpawn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes tapeSpawn {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Drawing preview (temporary) */
        .wb-tape-preview {
            position: absolute;
            border: 2px dashed rgba(245, 158, 11, 0.8);
            background: rgba(251, 191, 36, 0.2);
            border-radius: 10px;
            pointer-events: none;
            z-index: 1000;
        }

        /* IMAGE OCCLUSION FLASHCARD STYLES           */
        /* Tile badge for Visual Flashcards */
        .vfc-badge {
            position: absolute;
            bottom: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            background: rgba(139, 92, 246, 0.9);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            opacity: 0.85;
        }

        .vfc-tile-image {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 80px;
        }

        /* Study View for Image Occlusion cards */
        .study-vfc-image {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            min-height: 200px;
        }

        .study-vfc-image img {
            max-width: 100%;
            max-height: 70vh;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            object-fit: contain;
        }

        .study-vfc-label {
            margin-top: 16px;
            padding: 8px 16px;
            background: rgba(245, 158, 11, 0.15);
            border-radius: 20px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-weight: 500;
        }

        .image-occlusion-type {
            display: flex;
            justify-content: center;
            align-items: center;
        }


        /* VISUAL FLASHCARD COMPONENT (ARTICLE) */

        .nk-visual-flashcard {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 700px;
            perspective: 1200px;
            cursor: pointer;
            margin: 1rem 0;
        }

        .nk-vfc-inner {
            position: relative;
            width: 100%;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
        }

        .nk-visual-flashcard.flipped .nk-vfc-inner {
            transform: rotateY(180deg);
        }

        .nk-vfc-front,
        .nk-vfc-back {
            width: 100%;
            backface-visibility: hidden;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.12);
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }

        .nk-vfc-front {
            position: relative;
        }

        .nk-vfc-back {
            position: absolute;
            top: 0;
            left: 0;
            transform: rotateY(180deg);
        }

        .nk-vfc-front img,
        .nk-vfc-back img {
            width: 100%;
            height: auto;
            display: block;
        }

        /* Edit button for Visual Flashcard */
        .nk-vfc-edit-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s, box-shadow 0.2s;
            color: var(--text-secondary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .nk-visual-flashcard:hover .nk-vfc-edit-btn {
            opacity: 1;
        }

        .nk-vfc-edit-btn:hover {
            background: var(--primary-color);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        .nk-visual-flashcard.flipped .nk-vfc-edit-btn {
            display: none;
        }

        /* RESPONSIVE */
        @media (max-width: 612px) {
            #whiteboard-overlay {
                padding: 0.5rem;
            }

            #whiteboard-card {
                border-radius: 12px;
            }

            #whiteboard-canvas-container {
                margin: 0.5rem 0.5rem 0 0.5rem;
                border-radius: 8px 8px 0 0;
            }

            #whiteboard-toolbar {
                padding: 0.6rem;
                gap: 0.4rem;
            }

            .wb-tool-btn {
                width: 32px;
                height: 32px;
            }

            /* Reset media queries that might interfere */
            .wb-action-cancel,
            .wb-action-add {
                width: 36px;
                height: 36px;
                position: relative;
                margin: 0;
                top: auto;
                left: auto;
                right: auto;
                transform: none;
            }

            .wb-color-swatch {
                width: 18px;
                height: 18px;
            }

            .wb-zoom-group {
                display: none;
            }

            .wb-text-box {
                font-size: 14px;
                padding: 8px 10px;
            }
        }

        @media (max-width: 480px) {
            .wb-tool-group {
                padding: 3px;
            }

            .wb-tool-btn {
                width: 28px;
                height: 28px;
            }

            .wb-color-group {
                gap: 4px;
                padding: 0 4px;
            }

            .wb-color-swatch {
                width: 16px;
                height: 16px;
            }

            .wb-divider {
                margin: 0 4px;
            }
        }

        #whiteboard-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-primary);
            z-index: 20001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }

        .focus-mode-overlay.whiteboard-active #whiteboard-screen {
            opacity: 1;
        }

        /* FIX: Hide main stage controls when annotating to avoid clutter */
        .focus-mode-overlay.annotation-active .stage-mode-controls {
            /* Fix: Keep controls visible and interactive in annotation mode */
            opacity: 1;
            pointer-events: auto;
            z-index: 20;
            /* Ensure above canvas */
        }

        /* --- NEW: Interactive Cloze for Focus Mode --- */
        .focus-cloze {
            display: inline-block;
            cursor: pointer;
            background-color: var(--cloze-bg);
            border-bottom: 2px dotted var(--cloze-border);
            padding: 2px 4px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .focus-cloze:hover {
            background-color: color-mix(in srgb, var(--cloze-border) 30%, var(--cloze-bg));
        }

        /* By default, the revealed text is hidden */
        .focus-cloze .focus-cloze-revealed {
            display: none;
            color: var(--cloze-revealed-text);
            font-weight: bold;
        }

        /* The placeholder [...] is shown by default */
        .focus-cloze .focus-cloze-hidden {
            display: inline;
            color: var(--cloze-hidden-text);
            font-weight: bold;
        }

        /* When the 'revealed' class is added, swap visibility */
        .focus-cloze.revealed .focus-cloze-revealed {
            display: inline;
        }

        .focus-cloze.revealed .focus-cloze-hidden {
            display: none;
        }

        /* --- NEW: Presentation/Reader Ambiance Themes --- */
        /* Gallery 1: High-Energy Brights */
        .ambiance-lime-ink {
            --bg-primary: #dfffbf;
            --bg-primary-rgb: 223, 255, 191;
            --text-primary: #1a1a1a;
            --primary-color: #007bff;
        }

        .ambiance-goldenrod-pad {
            --bg-primary: #ffea7f;
            --bg-primary-rgb: 255, 234, 127;
            --text-primary: #0d3b66;
            --primary-color: #e11d48;
        }

        .ambiance-mint-chip {
            --bg-primary: #e6fff1;
            --bg-primary-rgb: 230, 255, 241;
            --text-primary: #3e2723;
            --primary-color: #71ffaf;
        }

        .ambiance-aqua-sky {
            --bg-primary: #cffafe;
            --bg-primary-rgb: 207, 250, 254;
            --text-primary: #0c2d48;
            --primary-color: #f97316;
        }

        .ambiance-peach-sorbet {
            --bg-primary: #ffeadb;
            --bg-primary-rgb: 255, 234, 219;
            --text-primary: #5c001f;
            --primary-color: #14b8a6;
        }

        .ambiance-powder-snow {
            --bg-primary: #f9fafb;
            --bg-primary-rgb: 249, 250, 251;
            --text-primary: #000000;
            --primary-color: #3b82f6;
        }

        /* Gallery 2: Sophisticated Darks */
        .ambiance-terminal {
            --bg-primary: #000000;
            --bg-primary-rgb: 0, 0, 0;
            --text-primary: #ffc107;
            --primary-color: #23e000;
        }

        .ambiance-crimson-night {
            --bg-primary: #5c0000;
            --bg-primary-rgb: 92, 0, 0;
            --text-primary: #fdf6e3;
            --primary-color: #d4af37;
        }

        .ambiance-royal-indigo {
            --bg-primary: #2c005c;
            --bg-primary-rgb: 44, 0, 92;
            --text-primary: #ffffff;
            --primary-color: #e83e8c;
        }

        .ambiance-emerald-tablet {
            --bg-primary: #013220;
            --bg-primary-rgb: 1, 50, 32;
            --text-primary: #fff2c5;
            --primary-color: #858585;
        }

        .ambiance-obsidian-ruby {
            --bg-primary: #720072;
            --bg-primary-rgb: 27, 23, 23;
            --text-primary: #fff0f5;
            --primary-color: #1b1717;
        }

        .ambiance-blueprint {
            --bg-primary: #0c2d48;
            --bg-primary-rgb: 12, 45, 72;
            --text-primary: #afeeee;
            --primary-color: #103e65;
        }

        .ambiance-midnight-sun {
            --bg-primary: #222222;
            --bg-primary-rgb: 34, 34, 34;
            --text-primary: #ffa467;
            --primary-color: #2fabe4;
        }

        /* Gallery 3: Natural & Earthy Tones */
        .ambiance-evergreen {
            --bg-primary: #f5f5dc;
            --bg-primary-rgb: 245, 245, 220;
            --text-primary: #004225;
            --primary-color: #cc5500;
        }

        .ambiance-clay-sky {
            --bg-primary: #f0a6dd;
            --bg-primary-rgb: 233, 150, 122;
            --text-primary: #2c3e50;
            --primary-color: #e7d748;
        }

        .ambiance-sandstone-agave {
            --bg-primary: #f0e6d2;
            --bg-primary-rgb: 240, 230, 210;
            --text-primary: #354e3c;
            --primary-color: #5c4033;
        }

        .ambiance-stone-moss {
            --bg-primary: #dddddd;
            --bg-primary-rgb: 211, 211, 211;
            --text-primary: #1e172a;
            --primary-color: #483d8b;
        }

        .ambiance-mahogany {
            --bg-primary: #3d0c02;
            --bg-primary-rgb: 61, 12, 2;
            --text-primary: #f3e5ab;
            --primary-color: #ffbf00;
        }

        .ambiance-riverbed {
            --bg-primary: #2e2b29;
            --bg-primary-rgb: 74, 68, 65;
            --text-primary: #c2c1ba;
            --primary-color: #008080;
        }

        .ambiance-matrix {
            --bg-primary: #000000;
            --bg-primary-rgb: 0, 0, 0;
            --text-primary: #00FF41;
            --primary-color: #00eb3c;
        }

        /* Gallery 4: Monochromatic & Minimalist */
        .ambiance-rosewater {
            --bg-primary: #fff0f5;
            --bg-primary-rgb: 255, 240, 245;
            --text-primary: #720072;
            --primary-color: #dc143c;
        }

        .ambiance-azure-depth {
            --bg-primary: #003153;
            --bg-primary-rgb: 0, 49, 83;
            --text-primary: #e0ffff;
            --primary-color: #7a7a7a;
        }

        .ambiance-olive-grove {
            --bg-primary: #3d402e;
            --bg-primary-rgb: 61, 64, 46;
            --text-primary: #c9c5ac;
            --primary-color: #cfb53b;
        }

        .ambiance-sterling {
            --bg-primary: #e0e0e0;
            --bg-primary-rgb: 224, 224, 224;
            --text-primary: #2c3840;
            --primary-color: #b22222;
        }

        .ambiance-greyscale {
            --bg-primary: #f0f0f0;
            --bg-primary-rgb: 240, 240, 240;
            --text-primary: #333333;
            --primary-color: #000000;
        }

        /* This rule makes sure the themes apply correctly in all four contexts */
        .focus-mode-overlay[class*="ambiance-"],
        #pdf-viewer-container[class*="ambiance-"],
        .article-view-wrapper[class*="ambiance-"],
        .study-view[class*="ambiance-"] {
            --bg-secondary: var(--bg-primary);
            --bg-tertiary: color-mix(in srgb, var(--text-primary) 10%, var(--bg-primary));
            --border-color: color-mix(in srgb, var(--text-primary) 20%, var(--bg-primary));
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out;
        }

        /* Scoped overrides for themed views */
        .focus-mode-overlay[class*="ambiance-"] .focus-mode-title,
        .article-view-wrapper[class*="ambiance-"] .article-title-input {
            background: none;
            -webkit-background-clip: unset;
            -webkit-text-fill-color: unset;
            color: var(--text-primary);
        }

        .article-view-wrapper[class*="ambiance-"] .article-container.ui-card {
            background-color: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            box-shadow: none;
            border: none;
        }

        .sectional-card-body .snippet:has(.nk-text-tile),
        .focus-mode-body .snippet:has(.nk-text-tile) {
            padding: 0;
            background: none;
        }

        /* This rule makes sure the themes apply correctly in all four contexts */
        .focus-mode-overlay[class*="ambiance-"],
        #pdf-viewer-container[class*="ambiance-"],
        .article-view-wrapper[class*="ambiance-"],
        .study-view[class*="ambiance-"] {
            --bg-secondary: var(--bg-primary);
            --bg-tertiary: color-mix(in srgb, var(--text-primary) 10%, var(--bg-primary));
            --border-color: color-mix(in srgb, var(--text-primary) 20%, var(--bg-primary));
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out;
        }

        /* Scoped overrides for themed views */
        .focus-mode-overlay[class*="ambiance-"] .focus-mode-title,
        .article-view-wrapper[class*="ambiance-"] .article-title-input {
            background: none;
            -webkit-background-clip: unset;
            -webkit-text-fill-color: unset;
            color: var(--text-primary);
        }

        .article-view-wrapper[class*="ambiance-"] .article-container.ui-card {
            background-color: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            box-shadow: none;
            border: none;
        }



        /* --- H. Vertical Timeline Layout (AESTHETIC REDESIGN) --- */
        .sectional-card-container.is-timeline {
            position: relative;
            padding-left: 5rem;
            /* Space for the timeline decorations */
        }

        /* The central vertical line */
        .sectional-card-container.is-timeline::before {
            content: '';
            position: absolute;
            left: 2.5rem;
            /* Position in the middle of the padding */
            transform: translateX(-50%);
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: var(--border-color);
        }

        .timeline-entry {
            position: relative;
            margin-bottom: 1rem;
            /* Tighter spacing between timeline entries */
            opacity: 0;
            transform: translateY(20px);
            animation: slideUpFadeIn 0.5s ease-out forwards;
        }

        @keyframes slideUpFadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* The decorative marker dot */
        .timeline-marker {
            position: absolute;
            left: -2.5rem;
            /* RATIONALE: Aligns the center of the marker with the center of the card's title area */
            top: 2rem;
            transform: translate(-50%, -50%);
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background-color: var(--bg-secondary);
            border: 3px solid var(--primary-color);
            z-index: 1;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: var(--shadow);
        }

        /* FIX #3: Hover effect for the marker */
        .timeline-entry:hover .timeline-marker {
            transform: translate(-50%, -50%) scale(1.25);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary-color-hover);
        }

        /* FIX #3: Date text styled to be inside the marker */
        .timeline-date {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.1;
        }



        /* --- DEFINITIVE: Classic Bordered Accordion Styles (v2) --- */
        .nk-accordion {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            margin: 1.5em 0;
            background-color: var(--bg-secondary);
            transition: var(--transition-fast);
            overflow: hidden;
        }

        .nk-accordion:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow);
        }

        .nk-accordion-trigger {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            width: 100%;
            padding: 1rem 1.25rem;
            background-color: color-mix(in srgb, var(--border-color) 25%, var(--bg-tertiary));
            border: none;
            cursor: pointer;
            font-family: inherit;
            font-size: inherit;
            color: var(--text-primary);
            text-align: left;
        }

        .nk-accordion-trigger:hover {
            background-color: color-mix(in srgb, var(--border-color) 40%, var(--bg-tertiary));
        }

        .nk-accordion-title {
            flex-grow: 1;
            outline: none;
        }

        .nk-accordion-title:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            pointer-events: none;
        }

        .nk-accordion-chevron {
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            stroke: currentColor;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body.read-mode .nk-accordion-chevron {
            display: none;
            /* Hides chevron in read mode as requested */
        }

        .nk-accordion-content {
            padding: 1rem 1.25rem;
            border-top: 1px solid var(--border-color);
            outline: none;
            transition: max-height 0.4s ease-in-out, opacity 0.3s ease-in-out, padding 0.4s ease-in-out;
        }

        .nk-accordion-content:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            pointer-events: none;
        }

        [data-state="closed"]>.nk-accordion-content {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
            border-top-color: transparent;
            overflow: hidden;
        }

        [data-state="open"]>.nk-accordion-content {
            max-height: 1000px;
            opacity: 1;
        }

        [data-state="open"]>.nk-accordion-trigger .nk-accordion-chevron {
            transform: rotate(180deg);
        }

        .nk-accordion-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        body.read-mode .nk-accordion-controls {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        body.read-mode .nk-accordion:hover .nk-accordion-controls {
            opacity: 1;
        }

        .nk-accordion-control-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nk-accordion-control-btn:hover {
            background-color: var(--bg-tertiary);
        }

        .nk-accordion-control-btn.active {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
        }

        .nk-accordion-hint-editor {
            padding: 0.75rem 1.25rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-primary);
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .nk-accordion-hint-content {
            outline: none;
        }

        .nk-accordion-hint-content:empty::before {
            content: attr(data-placeholder);
            font-style: italic;
        }

        .study-card-content-box img {
            max-width: 100%;
            height: auto;
            border-radius: var(--border-radius);
            margin-top: 1rem;
        }

        .flashcard-tile-content img {
            display: block;
            max-height: 60px;
            width: 100%;
            object-fit: contain;
            border-radius: var(--border-radius);
            margin-top: 2px;
        }

        .reversible-indicator {
            font-size: 0.8rem;
            color: var(--primary-color);
            margin-left: 8px;
        }

        .study-hint-container {
            margin-top: 1.5rem;
            font-size: 1rem;
            font-family: var(--font-body);
        }

        .study-hint-content {
            margin-top: 0.5rem;
            padding: 1rem;
            background-color: var(--bg-tertiary);
            border-radius: var(--border-radius);
            color: var(--text-secondary);
            font-style: italic;
            animation: fadeIn 0.3s ease;
        }

        body.read-mode .nk-accordion-controls {
            opacity: 0;
            /* Hide controls by default in read mode */
            transition: opacity 0.2s ease-in-out;
        }

        body.read-mode .nk-accordion:hover .nk-accordion-controls {
            opacity: 1;
            /* Show controls on hover */
        }

        body.study-mode-active header,
        body.study-mode-active #app-background,
        body.study-mode-active main {
            display: none;
        }

        .zen-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-primary);
            z-index: 20000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s;
            padding: 2.5rem;
            text-align: center;
        }

        .zen-timer {
            font-size: clamp(8rem, 20vw, 15rem);
            font-weight: 700;
            line-height: 1;
            text-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }

        .zen-meta-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .zen-pills-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .zen-pills-row .cycle-pill {
            margin-right: 20px;
        }

        .zen-pills-row>div {
            min-width: 80px;
            text-align: center;
            justify-content: center;
            display: inline-flex;
            align-items: center;
            transform: scale(1.2);
        }

        .zen-task-title {
            font-size: clamp(1.5rem, 3.5vw, 2.2rem);
            margin: 0;
            font-weight: 500;
            transition: color 0.5s ease;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            max-width: 90vw;
            line-height: 1.3;
            white-space: normal;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 1.5rem;
        }

        .zen-bottom-controls {
            position: absolute;
            bottom: 2rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .zen-progress-frame .progress-segment {
            height: 12px;
            width: 12px;
        }

        .stats-dashboard-view {
            padding: 1.5rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .stats-header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 2rem;
        }

        .stats-header h1 {
            font-family: var(--font-display);
            font-size: 2.5rem;
            margin: 0;
        }

        .stats-section-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin: 2.5rem 0 1rem 0;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            gap: 1rem;
        }

        .stat-card {
            background: linear-gradient(to right bottom, var(--bg-secondary), var(--bg-tertiary));
            padding: 1.25rem;
            border-radius: var(--border-radius-lg);
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .stat-card-value {
            font-size: 2rem;
            font-weight: 700;
            line-height: 1.2;
            color: var(--primary-color);
        }

        .stat-card-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 0.75rem;
        }

        .category-section-container {
            background-color: var(--bg-primary);
            padding: 0.5rem 1.5rem 1.5rem 1.5rem;
            border-radius: var(--border-radius-lg);
            margin-top: 1rem;
        }

        .category-grid .category-card {
            padding: 0.85rem 1.15rem;
        }

        .category-grid .category-pill {
            padding: 6px 12px;
            font-size: 0.9rem;
        }

        .category-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--bg-secondary);
            padding: 1rem 1.25rem;
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            transition: var(--transition-fast);
        }

        .category-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .category-card-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .category-card-value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .heatmap-container {
            padding: 1rem;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            margin-top: 1rem;
        }

        .heatmap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .heatmap-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
        }

        .heatmap-day {
            width: 100%;
            aspect-ratio: 1;
            background-color: var(--heat-0);
            border-radius: 4px;
            transition: transform 0.2s;
            cursor: pointer;
        }

        .heatmap-day.empty {
            background-color: transparent;
            border: 1px dashed var(--border-color);
            cursor: default;
        }

        .heatmap-day:not(.empty):hover {
            transform: scale(1.1);
        }

        .heatmap-day.level-1 {
            background-color: var(--heat-1);
        }

        .heatmap-day.level-2 {
            background-color: var(--heat-2);
        }

        .heatmap-day.level-3 {
            background-color: var(--heat-3);
        }

        .heatmap-day.level-4 {
            background-color: var(--heat-4);
        }

        .heatmap-day.level-5 {
            background-color: var(--heat-5);
        }

        .heatmap-day.level-6 {
            background-color: var(--heat-6);
        }

        .quiz-result-card {
            max-width: 450px;
            text-align: center;
        }

        .quiz-score-display {
            font-size: 4rem;
            font-weight: 700;
            margin: 1.5rem 0;
            background: linear-gradient(45deg, var(--primary-color), var(--primary-color-hover));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .quiz-motivational-quote {
            font-size: 1.2rem;
            font-style: italic;
            color: var(--text-secondary);
        }

        .btn-quiz {
            border: 1px solid transparent;
            transition: all 0.2s ease-in-out;
        }

        .btn-quiz:hover:not(:disabled) {
            border-color: var(--primary-color);
            box-shadow: 0 0 8px 1px color-mix(in srgb, var(--primary-color) 40%, transparent);
        }

        .quiz-stats-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
        }

        .streak-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
            flex-wrap: wrap;
            width: 100%;
        }

        .streak-display.daily {
            width: clamp(130px, 15vw, 160px);
            height: clamp(130px, 15vw, 160px);
            border-radius: 50%;
            background: var(--bg-secondary);
            border: 5px solid var(--primary-color);
            /* Simplified */
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1), inset 0 3px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 1rem;
            cursor: default;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .streak-display.daily:hover {
            transform: translateY(-5px) scale(1.05);
        }

        .streak-value {
            font-size: clamp(2.8rem, 8vw, 4rem);
            font-weight: 700;
            line-height: 1;
            color: var(--primary-color);
            /* Simplified */
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.2);
        }

        .streak-label {
            font-size: clamp(0.7rem, 2vw, 0.8rem);
            font-weight: 600;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .weekly-streak-calendar {
            display: flex;
            align-items: center;
            justify-content: space-around;
            background-color: var(--bg-tertiary);
            border-radius: var(--border-radius-lg);
            padding: clamp(0.5rem, 2vw, 0.75rem);
            height: clamp(110px, 15vw, 140px);
            flex-grow: 1;
            max-width: clamp(320px, 40vw, 450px);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
            border: 2px solid var(--primary-color);
            transition: all 0.3s ease;
        }

        .week-day {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: clamp(34px, 5.5vw, 50px);
            gap: 0.25rem;
        }

        .day-letter {
            font-size: clamp(0.7rem, 1.5vw, 0.85rem);
            font-weight: 600;
            color: var(--text-secondary);
        }

        .date-number {
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease-in-out;
            font-size: clamp(1.1rem, 2.5vw, 1.4rem);
            width: clamp(32px, 5vw, 42px);
            height: clamp(32px, 5vw, 42px);
        }

        .week-day.today .date-number {
            box-shadow: 0 0 0 2px var(--primary-color);
        }

        .week-day.completed .date-number {
            background-color: var(--primary-color);
            color: var(--text-on-primary, #fff);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }


        .sub-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            width: 100%;
        }

        .stat-card-value {
            font-size: clamp(1.2rem, 3.5vw, 2rem);
            word-break: break-all;
        }

        @media (max-width: 612px) {
            .streak-container {
                flex-direction: column;
                gap: 1.5rem;
            }

            .weekly-streak-calendar {
                width: 100%;
                max-width: none;
                height: auto;
                padding: 0.5rem;
            }
        }



        @media (max-width: 640px) {
            .task-filters {
                display: flex;
                overflow-x: auto;
            }

            .task-filters .btn {
                width: auto;
                flex-shrink: 0;
            }

            .productivity-modal {
                height: 90vh;
                max-height: 90vh;
            }

            .pomodoro-time-display {
                font-size: 2.5rem;
            }

            .pomodoro-controls .btn-icon {
                transform: scale(0.9);
            }

            .stats-dashboard-view {
                padding: 1rem;
            }

            .stats-header h1 {
                font-size: 2rem;
            }
        }

        .custom-checkbox-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .custom-checkbox-container input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        .custom-checkbox {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: transparent;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            transition: all 0.3s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .custom-checkbox-container:hover .custom-checkbox {
            border-color: var(--primary-color);
        }

        .custom-checkbox-container input:checked~.custom-checkbox {
            background-color: var(--success-color);
            border-color: var(--success-color);
        }

        .custom-checkbox-container input:checked~.custom-checkbox .check-icon {
            opacity: 1;
            transform: scale(1);
        }

        .task-item.is-backlog:not(.completed) .custom-checkbox {
            background-color: var(--danger-color);
            border-color: var(--danger-color);
        }

        .task-item.is-backlog:not(.completed) .custom-checkbox .cross-icon {
            opacity: 1;
            transform: scale(1);
            color: white;
        }

        .task-item.is-backlog.completed .custom-checkbox {
            background-color: var(--success-color);
            border-color: var(--success-color);
        }

        .task-item.is-backlog.completed .custom-checkbox .cross-icon {
            opacity: 0;
        }



        /* --- Canvas Focus Mode (Line Button) --- */
        .canvas-focus-line {
            width: 100%;
            height: 5.5px;
            background-color: var(--border-color);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .canvas-focus-line:hover {
            background-color: var(--primary-color);
            height: 8px;
        }

        /* When focus mode is active */
        body.canvas-focus-mode header,
        body.canvas-focus-mode #visual-map-controls,
        body.canvas-focus-mode #mindmap-controls {
            display: none;
        }

        body.canvas-focus-mode #visual-map-view.active,
        body.canvas-focus-mode #mindmap-view.active {
            padding: 0;
            gap: 0;
        }

        body.canvas-focus-mode .canvas-focus-line {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 20;
            border-radius: 0;
        }

        /*  VISUALIZATION STYLES  */

        html,
        body {
            height: 100vh;
            /* fallback */
            height: 100dvh;
            /* Modern unit */
            margin: 0;
            overflow: hidden;
        }

        body {
            display: flex;
            flex-direction: column;
            font-family: var(--article-font-family), var(--font-body);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.2s, color 0.2s;
        }

        header {
            flex-shrink: 0;
            /* Prevent the header from shrinking */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 calc(var(--spacing-unit) * 1.2);
            border-bottom: 1px solid var(--border-color);
            height: 48px;
            z-index: 1000;
            background-color: rgba(var(--bg-primary-rgb), var(--ui-opacity));
            backdrop-filter: blur(var(--blur-intensity));
            -webkit-backdrop-filter: blur(var(--blur-intensity));
            transition: background-color 0.2s, backdrop-filter 0.2s;
        }

        main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow-y: auto;
            min-height: 0;
        }

        /* When a map is active, its parent (main) should not scroll */
        main:has(#visual-map-view.active),
        main:has(#mindmap-view.active) {
            overflow-y: hidden;
        }

        /* --- General View Styles (No changes needed here) --- */
        #visual-map-view.active,
        #mindmap-view.active {
            display: flex;
            flex-direction: column;
            flex: 1 1 auto;
            min-height: 0;
            overflow: hidden;
            padding: 3px calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 1.5);
            gap: calc(var(--spacing-unit) * 0.35);
        }

        /* KEEP THIS RULE */
        #visual-map-controls,
        #mindmap-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-wrap: wrap;
            padding: 0;
            margin-bottom: 0;
            flex-shrink: 0;
            min-height: 40px;
            position: relative;
            z-index: 2;
            pointer-events: auto;
        }

        /* Replace with this code */
        #visual-map-container,
        #mindmap-container {
            position: relative;
            flex: 1 1 auto;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--bg-secondary);
            cursor: grab;
            outline: none;
            transition: background-color 0.2s;
            margin: 0;
            overflow: hidden;
        }

        #visual-map-container>svg,
        #mindmap-container>svg {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        .control-group {
            display: flex;
            align-items: center;
            flex-direction: row;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .control-btn {
            background: transparent;
            border: none;
            padding: 8px 10px;
            cursor: pointer;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            border-left: 1px solid var(--border-color);
        }

        .control-btn:first-child {
            border-left: none;
        }

        .control-btn:hover {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .control-btn.active {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
        }

        .control-btn svg {
            width: 16px;
            height: 16px;
            stroke-width: 2;
        }

        /* --- NEW: Export Popover Styles --- */
        .control-group-popover {
            position: relative;
            display: flex;
        }

        .popover-menu {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            margin-bottom: 10px;
            display: flex;
            gap: 4px;
            padding: 6px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out, visibility 0s 0.2s;
            z-index: 10;
        }

        .control-group-popover:hover .popover-menu,
        .control-group-popover.popover-active .popover-menu {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
            transition-delay: 0s;
        }

        .popover-menu .btn-icon {
            background-color: var(--bg-tertiary);
        }



        .search-input-wrapper {
            position: relative;
        }

        .search-results-list {
            position: absolute;
            top: 100%;
            left: 0;
            width: 250px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            margin-top: 4px;
            box-shadow: var(--shadow-lg);
        }

        .search-results-list ul {
            list-style: none;
            padding: 4px;
            margin: 0;
        }

        .search-results-list li a {
            display: block;
            padding: 6px 8px;
            border-radius: 4px;
            text-decoration: none;
            color: var(--text-primary);
            font-size: 0.9em;
        }

        .search-results-list li a:hover,
        .search-results-list li a.active {
            background-color: var(--bg-tertiary);
        }

        .search-input {
            border: none;
            padding: 8px 12px;
            outline: none;
            background-color: transparent;
            width: 180px;
            color: var(--text-primary);
        }

        #visual-map-container:active,
        #mindmap-container:active {
            cursor: grabbing;
        }

        .node-group {
            cursor: pointer;
        }

        .node-group.dragging {
            cursor: grabbing;
        }

        .node-group.selected>.node-main-body {
            stroke: var(--primary-color);
            stroke-width: 3px;
        }

        .node-highlight {
            pointer-events: none;
        }

        .node-text.lod-hidden {
            display: none;
        }

        .search-highlight {
            fill: var(--search-highlight-bg) !important;
            font-weight: 600;
        }

        .faded {
            opacity: 0.15;
            transition: opacity 0.5s ease-in-out;
        }

        .node-group:not(.faded),
        .link:not(.faded) {
            transition: opacity 0.5s ease-in-out;
        }

        .mindmap-node {
            cursor: pointer;
        }

        .mindmap-node.dragging {
            cursor: grabbing;
        }

        .mindmap-link {
            fill: none;
            stroke-width: 2.5px;
            opacity: 0.8;
            cursor: pointer;
        }

        .mindmap-node rect {
            stroke-width: 1.5px;
            rx: var(--border-radius-lg);
            ry: var(--border-radius-lg);
            filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
        }

        .mindmap-node:hover rect {
            transform: translateY(-2px);
            filter: drop-shadow(0 8px 12px rgba(0, 0, 0, 0.15));
        }

        .mindmap-search-highlight rect {
            stroke: var(--search-highlight-bg) !important;
            stroke-width: 3px;
        }

        .mindmap-node .node-html-content {
            font-family: var(--font-body);
            font-size: 12px;
            line-height: 1.5;
            text-align: center;
            padding: 10px 14px 15px;
            height: 100%;
            overflow: hidden;
            scroll-behavior: smooth;
            word-wrap: break-word;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mindmap-node.mindmap-root .node-html-content {
            font-weight: 600;
            font-size: 14px;
        }

        .mindmap-node .node-html-content.has-custom-scroll {
            mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
        }

        .mindmap-node .has-custom-scroll {
            align-items: flex-start;
            justify-content: flex-start;
            text-align: left;
        }

        .node-content-wrapper {
            position: relative;
            height: 100%;
            width: 100%;
        }

        .mindmap-node .scroll-button-line {
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 200px;
            height: 5px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 3px;
            cursor: pointer;
            opacity: 0.50;
            transition: opacity 0.2s, background-color 0.2s;
            z-index: 10;
        }

        .mindmap-node .scroll-button-line:hover {
            opacity: 1;
        }

        [data-theme="light"] .mindmap-child .scroll-button-line {
            background-color: rgba(0, 0, 0, 0.3);
        }

        .mindmap-link.faded {
            opacity: 0.25;
        }

        .mindmap-node.faded rect {
            opacity: 0.8;
        }

        .mindmap-node.faded foreignObject {
            opacity: 0.08;
        }

        /* FIX: Position the sticky note layer correctly above the SVG */
        #visual-map-container>#sticky-note-layer {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }

        #sticky-note-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
            transform-origin: 0 0;
        }

        /* === FINAL POLISHED STICKY NOTE REDESIGN (v8.83) === */
        .sticky-note-tile {
            position: absolute;
            display: flex;
            flex-direction: column;
            border-radius: var(--border-radius-lg);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.07), 0 1px 3px rgba(0, 0, 0, 0.05);
            min-width: 180px;
            min-height: 140px;
            max-width: 50vw;
            max-height: 70vh;
            pointer-events: all;
            cursor: move;
            transition: box-shadow 0.2s, border-color 0.3s, background-color 0.3s, color 0.3s, width 0.25s ease-in-out, height 0.25s ease-in-out;
            transform-origin: top left;
            border: 1px solid;
            border-color: color-mix(in srgb, currentColor 40%, transparent);
            overflow: hidden;
            color: var(--text-primary);
        }

        [data-theme="dark"] .sticky-note-tile {
            color: #f0f6fc;
        }


        /* Light Theme (Default) Application */
        .sticky-note-tile.color-default {
            background-color: var(--sticky-light-default-bg);
            color: var(--sticky-light-default-text);
        }

        .sticky-note-tile.color-crimson {
            background-color: var(--sticky-light-crimson-bg);
            color: var(--sticky-light-crimson-text);
        }

        .sticky-note-tile.color-tangerine {
            background-color: var(--sticky-light-tangerine-bg);
            color: var(--sticky-light-tangerine-text);
        }

        .sticky-note-tile.color-sunflower {
            background-color: var(--sticky-light-sunflower-bg);
            color: var(--sticky-light-sunflower-text);
        }

        .sticky-note-tile.color-lime {
            background-color: var(--sticky-light-lime-bg);
            color: var(--sticky-light-lime-text);
        }

        .sticky-note-tile.color-forest {
            background-color: var(--sticky-light-forest-bg);
            color: var(--sticky-light-forest-text);
        }

        .sticky-note-tile.color-azure {
            background-color: var(--sticky-light-azure-bg);
            color: var(--sticky-light-azure-text);
        }

        .sticky-note-tile.color-indigo {
            background-color: var(--sticky-light-indigo-bg);
            color: var(--sticky-light-indigo-text);
        }

        .sticky-note-tile.color-amethyst {
            background-color: var(--sticky-light-amethyst-bg);
            color: var(--sticky-light-amethyst-text);
        }

        .sticky-note-tile.color-lavender {
            background-color: var(--sticky-light-lavender-bg);
            color: var(--sticky-light-lavender-text);
        }

        .sticky-note-tile.color-fuchsia {
            background-color: var(--sticky-light-fuchsia-bg);
            color: var(--sticky-light-fuchsia-text);
        }

        .sticky-note-tile.color-blush {
            background-color: var(--sticky-light-blush-bg);
            color: var(--sticky-light-blush-text);
        }

        .sticky-note-tile.color-terracotta {
            background-color: var(--sticky-light-terracotta-bg);
            color: var(--sticky-light-terracotta-text);
        }

        .sticky-note-tile.color-teal {
            background-color: var(--sticky-light-teal-bg);
            color: var(--sticky-light-teal-text);
        }

        .sticky-note-tile.color-slate {
            background-color: var(--sticky-light-slate-bg);
            color: var(--sticky-light-slate-text);
        }

        .sticky-note-tile.color-olive {
            background-color: var(--sticky-light-olive-bg);
            color: var(--sticky-light-olive-text);
        }

        /* Dark Theme Overrides */
        [data-theme="dark"] .sticky-note-tile.color-default {
            background-color: var(--sticky-dark-default-bg);
            color: var(--sticky-dark-default-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-crimson {
            background-color: var(--sticky-dark-crimson-bg);
            color: var(--sticky-dark-crimson-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-tangerine {
            background-color: var(--sticky-dark-tangerine-bg);
            color: var(--sticky-dark-tangerine-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-sunflower {
            background-color: var(--sticky-dark-sunflower-bg);
            color: var(--sticky-dark-sunflower-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-lime {
            background-color: var(--sticky-dark-lime-bg);
            color: var(--sticky-dark-lime-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-forest {
            background-color: var(--sticky-dark-forest-bg);
            color: var(--sticky-dark-forest-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-azure {
            background-color: var(--sticky-dark-azure-bg);
            color: var(--sticky-dark-azure-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-indigo {
            background-color: var(--sticky-dark-indigo-bg);
            color: var(--sticky-dark-indigo-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-amethyst {
            background-color: var(--sticky-dark-amethyst-bg);
            color: var(--sticky-dark-amethyst-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-lavender {
            background-color: var(--sticky-dark-lavender-bg);
            color: var(--sticky-dark-lavender-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-fuchsia {
            background-color: var(--sticky-dark-fuchsia-bg);
            color: var(--sticky-dark-fuchsia-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-blush {
            background-color: var(--sticky-dark-blush-bg);
            color: var(--sticky-dark-blush-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-terracotta {
            background-color: var(--sticky-dark-terracotta-bg);
            color: var(--sticky-dark-terracotta-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-teal {
            background-color: var(--sticky-dark-teal-bg);
            color: var(--sticky-dark-teal-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-slate {
            background-color: var(--sticky-dark-slate-bg);
            color: var(--sticky-dark-slate-text);
        }

        [data-theme="dark"] .sticky-note-tile.color-olive {
            background-color: var(--sticky-dark-olive-bg);
            color: var(--sticky-dark-olive-text);
        }

        @keyframes spawn-card {
            from {
                transform: scale(0.5);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .sticky-note-tile.spawn {
            animation: spawn-card 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .sticky-note-tile:hover,
        .sticky-note-tile.dragging {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.15), 0 0 1px rgba(0, 0, 0, 0.1);
            border-color: var(--primary-color);
        }

        .sticky-note-header {
            padding: 6px 10px;
            flex-shrink: 0;
            border-bottom: 1px solid;
            border-bottom-color: color-mix(in srgb, currentColor 30%, transparent);
            background-color: color-mix(in srgb, currentColor 8%, transparent);
        }

        .sticky-note-header h5 {
            margin: 0;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            font-size: calc(var(--article-font-size) * 0.7);
        }

        .sticky-note-header h5:hover {
            text-decoration: underline;
        }

        .sticky-note-content {
            flex-grow: 1;
            padding: 10px 12px;
            padding-bottom: 38px;
            overflow-y: auto;
            overflow-x: hidden;
            font-family: var(--font-serif);
            line-height: 1.6;
            font-size: calc(var(--article-font-size) * 0.65);
        }

        /* Content Parsing Rules (Unchanged) */
        .sticky-note-content * {
            line-height: 1.6 !important;
            font-weight: normal !important;
            margin: 0 0 5px 0 !important;
            color: inherit !important;
            background: transparent !important;
            all: unset;
            display: block;
        }

        .sticky-note-content b,
        .sticky-note-content strong {
            font-weight: bold !important;
        }

        .sticky-note-content i,
        .sticky-note-content em {
            font-style: italic !important;
        }

        .sticky-note-content u {
            text-decoration: underline !important;
        }

        .sticky-note-content ul,
        .sticky-note-content ol {
            list-style-position: inside !important;
            padding-left: 8px !important;
        }

        .sticky-note-content li {
            display: list-item !important;
        }

        .sticky-note-content .rendered-tag,
        .sticky-note-content .mindmap-snippet,
        .sticky-note-content [class*="highlight-"] {
            font-weight: 600 !important;
            padding: 1px 3px;
            border-radius: 3px;
            display: inline;
            border-bottom: 2px solid;
        }

        .sticky-note-content .rendered-tag {
            background-color: var(--hl-7-bg) !important;
            border-color: var(--hl-7-border) !important;
        }

        .sticky-note-content .mindmap-snippet,
        .sticky-note-content [class*="highlight-"] {
            background-color: var(--mindmap-snippet-bg) !important;
            border-color: var(--mindmap-snippet-border) !important;
        }

        .sticky-note-content>*:first-child {
            margin-top: 0 !important;
        }

        .sticky-note-content>*:last-child {
            margin-bottom: 0 !important;
        }

        .sticky-note-content::-webkit-scrollbar {
            width: 8px;
        }

        .sticky-note-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .sticky-note-content::-webkit-scrollbar-thumb {
            background-color: transparent;
            border-radius: 4px;
        }

        .sticky-note-content:hover::-webkit-scrollbar-thumb {
            background-color: color-mix(in srgb, currentColor 60%, transparent);
        }

        .sticky-note-content::-webkit-scrollbar-thumb:active {
            background-color: color-mix(in srgb, currentColor 80%, transparent);
        }

        /* Polished Floating Controls */
        .sticky-note-controls {
            position: absolute;
            bottom: 8px;
            right: 8px;
            display: flex;
            align-items: center;
            gap: 0px;
            padding: 0px;
            border-radius: var(--border-radius);
            background-color: rgba(var(--bg-secondary-rgb), 0.75);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
            opacity: 0;
            transform: translateY(5px);
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
            z-index: 10;
        }

        .sticky-note-tile:hover .sticky-note-controls,
        .sticky-note-tile.dragging .sticky-note-controls {
            opacity: 1;
            transform: translateY(0);
        }

        .sticky-note-controls .btn-icon {
            width: 28px;
            height: 28px;
            color: var(--text-secondary);
            background-color: transparent;
            transition: transform 0.15s ease-out, color 0.15s ease-out;
        }

        .sticky-note-controls .btn-icon:hover {
            color: var(--primary-color);
            background-color: color-mix(in srgb, var(--border-color) 40%, transparent);
            transform: scale(1.15);
        }


        /* --- NoteKash AI Magic Module (Co-Pilot)- */
        .ai-magic-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(var(--bg-primary-rgb), 0.5) 0%, rgba(var(--bg-primary-rgb), 0.8) 100%);
            z-index: 10001;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            animation: fadeIn 0.3s ease;
        }

        @keyframes copilot-border-glow {
            from {
                border-color: color-mix(in srgb, var(--primary-color) 25%, transparent);
                box-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.35),
                    0 0 8px -2px color-mix(in srgb, var(--primary-color) 30%, transparent);
            }

            to {
                border-color: color-mix(in srgb, var(--primary-color) 65%, transparent);
                box-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.35),
                    0 0 25px 4px color-mix(in srgb, var(--primary-color) 25%, transparent);
            }
        }

        .ai-magic-modal {
            width: 100%;
            max-width: 720px;
            height: 85vh;
            max-height: 600px;
            display: flex;
            flex-direction: column;

            background-color: rgba(var(--bg-secondary-rgb), 0.6);
            background-image:
                radial-gradient(at 0% 0%, color-mix(in srgb, var(--primary-color) 15%, transparent) 0px, transparent 50%),
                radial-gradient(at 100% 100%, color-mix(in srgb, var(--cat-color-3-bg) 20%, transparent) 0px, transparent 50%);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1.5px solid;
            border-radius: 20px;
            box-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.35),
                inset 0 1px 1px rgba(255, 255, 255, 0.1);
            animation: growInFromCenter 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                copilot-border-glow 5s infinite alternate ease-in-out;
            overflow: hidden;
        }

        .ai-magic-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            background-color: rgba(var(--bg-primary-rgb), 0.7);
            text-align: center;
        }

        .ai-magic-title {
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 0.3px;
            margin-bottom: 0.75rem;
            padding: 0.25rem 0;
            background-image: none;
            background-clip: unset;
            -webkit-background-clip: unset;
            -webkit-text-fill-color: unset;
            color: var(--primary-color);
        }


        .ai-magic-prompt-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 4px 4px 4px 12px;
            transition: all 0.2s ease-in-out;
        }

        #ai-magic-prompt-input {
            width: 100%;
            font-size: 0.95rem;
            border: none;
            background: transparent;
            color: var(--text-primary);
            outline: none;
            flex-grow: 1;
            resize: none;
        }

        #ai-magic-prompt-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }

        .ai-magic-prompt-container:focus-within {
            border-color: var(--primary-color);
            background-color: var(--bg-secondary);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-color) 25%, transparent),
                inset 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        #ai-magic-command-list {
            overflow-y: auto;
            flex-grow: 1;
            padding: 1rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 0.75rem;
        }

        #ai-magic-command-list.compact-grid {
            justify-content: start;
            grid-template-columns: repeat(auto-fit, 180px);
        }

        .ai-magic-command-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: var(--border-radius);
            background: linear-gradient(145deg, rgba(var(--bg-primary-rgb), 0.4), rgba(var(--bg-primary-rgb), 0.7));
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 1px solid var(--border-color);
            position: relative;
        }

        .ai-magic-command-item:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: color-mix(in srgb, var(--primary-color) 70%, var(--border-color));
            background: linear-gradient(145deg, rgba(var(--bg-secondary-rgb), 0.7), rgba(var(--bg-primary-rgb), 0.9));
            box-shadow: 0 0 20px 5px color-mix(in srgb, var(--primary-color) 15%, transparent);
        }

        .ai-magic-command-item.selected {
            transform: translateY(-4px) scale(1.03);
            background-color: var(--bg-primary);
            border-color: var(--primary-color);
            box-shadow: 0 0 20px -5px color-mix(in srgb, var(--primary-color) 40%, transparent);
        }

        .ai-magic-command-item.selected::after {
            content: '';
            position: absolute;
            right: 8px;
            top: 8px;
            font-size: 0.9rem;
            color: var(--primary-color);
            font-weight: bold;
        }

        .ai-magic-command-item .command-icon {
            width: 36px;
            height: 36px;
            font-size: 1.3rem;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-color);
            background-color: var(--bg-tertiary);
            border-radius: 8px;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .ai-magic-command-item .command-text {
            overflow: hidden;
        }

        .ai-magic-command-item .command-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .ai-magic-separator {
            grid-column: 1 / -1;
            height: 1px;
            background-color: var(--border-color);
            margin: 4px 0;
            opacity: 0.6;
        }

        #ai-magic-prompt-send {
            flex-shrink: 0;
            background: var(--action-button-gradient);
            border: 1px solid rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        #ai-magic-prompt-send:hover {
            transform: scale(1.1);
            box-shadow: 0 0 12px color-mix(in srgb, var(--primary-color) 40%, transparent);
        }

        #ai-magic-prompt-send:active {
            transform: scale(0.95);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
            transition-duration: 0.1s;
        }

        #ai-magic-prompt-send svg {
            transform: translateX(1px);
        }

        /* ---Premium AI Upsell Card --- */
        .ai-upsell-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            padding: 2rem 1.5rem;
            height: 100%;
            box-sizing: border-box;
            justify-content: center;
            animation: fadeIn 0.5s ease-out 0.1s backwards;
            border-radius: var(--border-radius-lg);
            background:
                linear-gradient(rgba(var(--bg-secondary-rgb), 0.8), rgba(var(--bg-secondary-rgb), 0.8)) padding-box,
                linear-gradient(145deg, var(--primary-color), color-mix(in srgb, var(--primary-color) 40%, transparent)) border-box;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .ai-upsell-card .badge-icon {
            margin-bottom: 1.5rem;
            transform: scale(1.15);
        }

        .ai-upsell-card h4 {
            font-family: var(--font-display);
            font-size: 1.5rem;
            margin: 0 0 0.75rem 0;
            background-image: var(--action-button-gradient);
            background-size: 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        [data-theme="dark"] .ai-upsell-card h4 {
            background-image: linear-gradient(45deg, #E0B453, #E6845E);
        }

        .ai-upsell-card p {
            color: var(--text-secondary);
            max-width: 400px;
            line-height: 1.6;
            font-size: 1rem;
            margin: 0 0 2rem 0;
        }

        .ai-upsell-card .btn-primary {
            padding: 0.8rem 2rem;
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 0 25px -5px color-mix(in srgb, var(--primary-color) 50%, transparent);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .ai-upsell-card .witty-gradient-text {
            font-size: 1rem;
            font-style: italic;
            opacity: 0.85;
        }




        /* --- Command Palette --- */
        #command-palette {
            position: absolute;
            z-index: 10002;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            width: 380px;
            max-height: 400px;
            padding: 0;
            display: flex;
            flex-direction: column;
            overflow: visible;
        }

        #command-palette-input-wrapper {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        #command-palette-input {
            width: 100%;
            padding: 8px 12px;
            font-size: 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            outline: none;
        }

        #command-palette-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }

        #command-palette-list {
            padding: 4px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .command-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
        }

        .command-item.selected {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
        }

        .command-item-icon {
            width: 32px;
            height: 32px;
            font-size: 1rem;
            flex-shrink: 0;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
        }

        .command-item.selected .command-item-icon {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .command-item-text {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .command-item-title {
            font-weight: 500;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .command-item-desc {
            font-size: 0.8rem;
            opacity: 0.7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .command-item.selected .command-item-desc {
            color: var(--text-on-primary);
        }


        /* Command Palette Preview Side-Pane (Premium Glass - Compact) */
        .nk-command-palette-preview {
            position: absolute;
            left: 100%;
            top: 0;
            width: 260px;
            min-height: 80px;
            max-height: 300px;
            background: rgba(255, 255, 255, 0.90);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-left: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
            margin-left: 12px;
            padding: 14px;
            z-index: 10000;
            opacity: 0;
            transform: translateX(-10px) scale(0.98);
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: hidden;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        [data-theme="dark"] .nk-command-palette-preview {
            background: rgba(30, 30, 35, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.6);
        }

        .nk-preview-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-bottom: 6px;
            /* Reduced padding */
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0;
        }

        .nk-preview-badge {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 700;
            color: var(--primary-color);
            background: color-mix(in srgb, var(--primary-color) 10%, transparent);
            padding: 2px 6px;
            border-radius: 8px;
        }

        .nk-preview-title {
            font-family: var(--article-font-family);
            font-size: 0.90rem;
            /* Same size as content */
            font-weight: 700;
            /* Bold title */
            color: var(--text-primary);
            line-height: 1.3;
            margin: 0;
            padding-top: 2px;
        }

        .nk-preview-content {
            font-size: 0.85rem;
            font-weight: 400;
            color: var(--text-secondary);
            line-height: 1.5;
            display: -webkit-box;
            -webkit-line-clamp: 6;
            -webkit-box-orient: vertical;
            overflow: hidden;
            font-family: var(--article-font-family);
        }


        .nk-preview-content.is-snippet {
            font-size: 0.85rem;
            font-weight: 500;
            font-style: normal;
            color: var(--text-primary);
            border-left: 3px solid var(--primary-color);
            padding-left: 10px;
            margin: 2px 0;
            opacity: 0.9;
        }

        .nk-preview-hint {
            font-size: 0.7rem;
            color: var(--text-tertiary);
            margin-top: auto;
            text-align: right;
            padding-top: 6px;
            border-top: 1px solid var(--border-color);
        }

        /* --- Styled Task Button in Editor --- */
        .nk-task-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, var(--primary-color), color-mix(in srgb, var(--primary-color), black 10%));
            color: white !important;
            padding: 4px 12px 4px 10px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
            text-decoration: none !important;
            margin: 2px 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
            transition: transform 0.1s;
            user-select: none;
            cursor: pointer;
            vertical-align: middle;
        }

        .nk-task-link:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .nk-task-link:active {
            transform: translateY(0);
        }

        .nk-task-link::after {
            content: "";
            /* Play icon hint */
            font-size: 0.7em;
            opacity: 0.7;
            margin-left: 4px;
        }

        .nk-command-palette-preview.visible {
            opacity: 1;
            transform: translateX(0) scale(1);
            pointer-events: auto;
        }

        [data-theme="sepia"] .nk-command-palette-preview {
            background: rgba(251, 240, 217, 0.90);
            border-color: rgba(93, 64, 55, 0.15);
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
            gap: 4px;
            padding: 8px;
            max-height: 400px;
            overflow-y: auto;
        }

        .emoji-grid-item {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.15s ease;
            background-color: var(--bg-tertiary);
            user-select: none;
        }

        .emoji-grid-item:hover {
            background-color: var(--bg-secondary);
            transform: scale(1.1);
        }

        .emoji-grid-item.selected {
            background-color: var(--primary-color);
            transform: scale(1.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .emoji-grid-item i {
            font-size: 1.5rem;
        }

        .nk-stat-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background-color: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 4px 10px;
            border-radius: 16px;
            font-size: 0.85rem;
            font-family: var(--font-body);
            font-weight: 500;
            border: 1px solid var(--border-color);
            cursor: default;
            user-select: none;
            margin: 0 4px;
        }

        .nk-stat-badge i {
            font-size: 0.85em;
            line-height: 1;
        }


        /* --- Timeline Block (Pixel-Perfect Alignment) --- */
        .nk-timeline-block {
            position: relative;
            padding: 2rem 0 0;
            margin: 2rem auto;
            max-width: 90ch;
        }

        /* MOBILE PREVIEW FIX */
        @media (max-width: 800px) {
            .nk-command-palette-preview {
                left: 0 !important;
                right: 0 !important;
                top: 100% !important;
                width: 100% !important;
                min-width: unset !important;
                margin-left: 0 !important;
                margin-top: 10px;
                transform: translateY(10px) scale(0.98);
            }

            .nk-command-palette-preview.visible {
                transform: translateY(0) scale(1);
            }
        }

        .nk-timeline-block::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            bottom: 25px;
            transform: translateX(-50%);
            width: 4px;
            background: linear-gradient(to bottom,
                    color-mix(in srgb, var(--primary-color) 80%, transparent),
                    var(--border-color),
                    var(--primary-color));
            border-radius: 4px;
        }

        .nk-timeline-entry {
            position: relative;
            width: 50%;
            padding: 0 45px;
            margin-bottom: 25px;
        }

        .nk-timeline-entry:nth-child(odd) {
            left: 0;
            text-align: right;
        }

        .nk-timeline-entry:nth-child(even) {
            left: 50%;
            text-align: left;
        }

        /* The new solid dot icon, now perfectly centered horizontally and vertically. */
        .nk-timeline-entry::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border: none;
            background-color: var(--primary-color);
            top: 27px;
            transform: translateY(-50%);
            border-radius: 50%;
            z-index: 1;
            transition: transform 0.2s ease-out;
        }

        /* FIX: Positioning the icon by exactly half its width (-8px) guarantees its center is on the timeline. */
        .nk-timeline-entry:nth-child(odd)::after {
            right: -8px;
        }

        .nk-timeline-entry:nth-child(even)::after {
            left: -8px;
        }

        .nk-timeline-entry:hover::after {
            transform: scale(1.2) translateY(-50%);
        }

        .nk-timeline-content {
            padding: 1.25rem;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow);
            border-top: 4px solid var(--primary-color);
            position: relative;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }

        .nk-timeline-content:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-lg);
        }

        /* The arrow, now perfectly aligned with the dot icon. */
        .nk-timeline-content::before {
            content: " ";
            height: 0;
            position: absolute;
            top: 27px;
            transform: translateY(-50%);
            width: 0;
            z-index: 1;
            border: medium solid var(--border-color);
        }

        .nk-timeline-entry:nth-child(odd) .nk-timeline-content::before {
            right: -15px;
            border-width: 10px 0 10px 15px;
            border-color: transparent transparent transparent var(--border-color);
        }

        .nk-timeline-entry:nth-child(even) .nk-timeline-content::before {
            left: -15px;
            border-width: 10px 15px 10px 0;
            border-color: transparent var(--border-color) transparent transparent;
        }

        .nk-timeline-date {
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
            font-size: 0.9em;
            outline: none;
            opacity: 0.9;
        }

        .nk-timeline-title {
            font-weight: 500;
            font-size: 1.05em;
            outline: none;
        }

        /* The add button styling remains the same as the last fix. */
        .nk-timeline-add {
            text-align: center;
            position: relative;
            padding-bottom: 1rem;
        }

        .nk-timeline-add button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 4px solid var(--bg-secondary);
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            font-size: 0;
            line-height: 1;
            cursor: pointer;
            transition: all 0.2s ease-out;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
        }

        .nk-timeline-add button:hover {
            background-color: var(--primary-color-hover);
            transform: scale(1.1);
            box-shadow: var(--shadow-lg);
            font-size: 1.8rem;
        }

        .focus-mode-overlay .nk-timeline-block {
            max-width: 100%;
            margin-left: 0;
            margin-right: 0;
            padding-left: 1rem;
            padding-right: 1rem;
        }


        /* --- NEW: MCQ Block Styles (Feature #2) --- */
        .nk-mcq-block {
            position: relative;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--primary-color);
            border-radius: 10px;
            padding: 1.25rem 1.5rem;
            margin: 1.5em 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            transition: box-shadow 0.3s ease, border-color 0.3s ease;
            font-family: inherit;
            font-size: inherit;
        }

        /* Subtle hover effect in read mode */
        body.read-mode .nk-mcq-block:not([data-answered="true"]):hover,
        .focus-mode-overlay .nk-mcq-block:not([data-answered="true"]):hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            border-color: var(--primary-color);
        }

        /* Answered state - elegant checkmark badge */
        .nk-mcq-block[data-answered="true"] {
            border-left-color: var(--success-color);
        }

        .nk-mcq-block[data-answered="true"][data-user-incorrect="true"] {
            border-left-color: var(--danger-color);
        }

        /* Question text - inherit from article settings */
        .nk-mcq-question {
            font-weight: 600;
            font-size: 1.05em;
            margin-bottom: 1rem;
            margin-right: 40px;
            outline: none;
            line-height: 1.6;
            color: var(--text-primary);
            font-family: inherit;
        }

        .nk-mcq-question:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            font-weight: normal;
            opacity: 0.6;
        }

        /* MCQ Toolbar (write mode) - appears on hover */
        .nk-mcq-toolbar {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        body.write-mode .nk-mcq-block:hover .nk-mcq-toolbar {
            opacity: 1;
        }

        .nk-mcq-toolbar button {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nk-mcq-toolbar button:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--primary-color);
        }

        .nk-mcq-toolbar .nk-mcq-delete-block:hover {
            color: var(--danger-color);
            border-color: var(--danger-color);
            background: color-mix(in srgb, var(--danger-color) 10%, var(--bg-secondary));
        }

        .nk-mcq-toolbar .nk-mcq-copy-block:hover {
            color: var(--success-color);
            border-color: var(--success-color);
            background: color-mix(in srgb, var(--success-color) 10%, var(--bg-secondary));
        }

        /* Hide toolbar in read mode and focus mode */
        body.read-mode .nk-mcq-toolbar,
        .focus-mode-overlay .nk-mcq-toolbar,
        .study-card-content-box .nk-mcq-toolbar {
            display: none;
        }


        .nk-mcq-options {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }

        .nk-mcq-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .nk-mcq-option-radio {
            width: 24px;
            height: 24px;
            border: 2.5px solid var(--border-color);
            border-radius: 50%;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            background: var(--bg-secondary);
        }

        .nk-mcq-option-radio:hover {
            border-color: var(--primary-color);
            transform: scale(1.1);
        }

        .nk-mcq-option-text {
            flex-grow: 1;
            outline: none;
            padding: 10px 14px;
            border-radius: 8px;
            border: 1px solid transparent;
            transition: all 0.2s ease;
            background: var(--bg-tertiary);
            min-height: 22px;
            /* Inherit font from MCQ block */
            font-family: inherit;
            font-size: 0.95em;
            line-height: 1.5;
        }

        .nk-mcq-option-text:focus-within {
            border-color: var(--primary-color);
            background-color: var(--bg-secondary);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 12%, transparent);
        }

        .nk-mcq-option-text:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            opacity: 0.5;
        }

        /* --- Rich Media Options: Image Support --- */
        .nk-mcq-option-text img {
            max-height: 100px;
            max-width: 100%;
            object-fit: contain;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            margin: 4px 0;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }

        .nk-mcq-option-text img:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        }

        /* Larger images in presentation/focus mode */
        .focus-mode-overlay .nk-mcq-option-text img {
            max-height: 150px;
        }

        /* --- Image Layout in MCQ --- */
        .nk-mcq-option-text:has(img) {
            flex-grow: 0;
            width: fit-content;
            padding: 4px;
            margin-right: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 0;
            min-height: auto;
        }

        /* Remove margins from the image itself when in this compact mode */
        .nk-mcq-option-text:has(img) img {
            margin: 0;
            display: block;
        }

        .nk-mcq-delete-option {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            font-size: 1.25rem;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nk-mcq-option:hover .nk-mcq-delete-option {
            opacity: 0.5;
        }

        .nk-mcq-delete-option:hover {
            opacity: 1;
            color: var(--danger-color);
            background: color-mix(in srgb, var(--danger-color) 10%, transparent);
        }


        /* --- Write Mode Specific Styles --- */
        body.write-mode .nk-mcq-option[data-is-correct="true"] .nk-mcq-option-radio {
            background: linear-gradient(135deg, var(--success-color), color-mix(in srgb, var(--success-color), #000 10%));
            border-color: var(--success-color);
            box-shadow: 0 2px 8px color-mix(in srgb, var(--success-color) 40%, transparent);
        }

        body.write-mode .nk-mcq-option[data-is-correct="true"] .nk-mcq-option-radio::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 0.75rem;
            color: white;
            font-weight: bold;
            transform: translate(-50%, -50%);
        }

        body.write-mode .nk-mcq-option[data-is-correct="true"] .nk-mcq-option-text {
            border-color: color-mix(in srgb, var(--success-color) 40%, transparent);
            background: color-mix(in srgb, var(--success-color) 8%, var(--bg-secondary));
        }

        /* --- Read Mode Specific Styles --- */
        body.read-mode .nk-mcq-add-option,
        body.read-mode .nk-mcq-delete-option,
        body.read-mode .nk-mcq-option-radio,
        .focus-mode-overlay .nk-mcq-add-option {
            display: none;
        }

        body.read-mode .nk-mcq-option {
            padding: 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--bg-secondary);
            position: relative;
            overflow: hidden;
        }

        body.read-mode .nk-mcq-option::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 8px;
            width: 18px;
            height: 18px;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            transform: translateY(-50%);
            background: var(--bg-tertiary);
            transition: all 0.25s ease;
        }

        body.read-mode .nk-mcq-option .nk-mcq-option-text {
            padding-left: 28px;
        }

        body.read-mode .nk-mcq-block:not([data-answered="true"]) .nk-mcq-option:hover {
            border-color: var(--primary-color);
            background: color-mix(in srgb, var(--primary-color) 6%, var(--bg-secondary));
            transform: translateX(4px);
        }

        body.read-mode .nk-mcq-block:not([data-answered="true"]) .nk-mcq-option:hover::before {
            border-color: var(--primary-color);
            background: color-mix(in srgb, var(--primary-color) 20%, var(--bg-tertiary));
        }

        body.read-mode .nk-mcq-block[data-answered="true"] .nk-mcq-option {
            cursor: default;
        }

        /* Premium Correct Answer Style */
        body.read-mode .nk-mcq-option.correct {
            border: 2.5px solid var(--success-color);
            color: var(--text-primary);
            background: linear-gradient(135deg,
                    color-mix(in srgb, var(--success-color) 12%, var(--bg-secondary)),
                    color-mix(in srgb, var(--success-color) 6%, var(--bg-secondary)));
            animation: mcqCorrectPulse 0.5s ease;
        }

        body.read-mode .nk-mcq-option.correct::before {
            content: '';
            border-color: var(--success-color);
            background: var(--success-color);
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        body.read-mode .nk-mcq-option.correct::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, color-mix(in srgb, var(--success-color) 8%, transparent), transparent);
            animation: shimmer 1.5s ease-out;
        }

        /* Premium Incorrect Answer Style */
        body.read-mode .nk-mcq-option.incorrect {
            border: 2.5px solid var(--danger-color);
            color: var(--text-primary);
            background: linear-gradient(135deg,
                    color-mix(in srgb, var(--danger-color) 10%, var(--bg-secondary)),
                    color-mix(in srgb, var(--danger-color) 4%, var(--bg-secondary)));
            animation: mcqIncorrectShake 0.5s ease;
        }

        body.read-mode .nk-mcq-option.incorrect::before {
            content: '';
            border-color: var(--danger-color);
            background: var(--danger-color);
            color: white;
            font-size: 0.85rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes mcqCorrectPulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
                box-shadow: 0 0 20px color-mix(in srgb, var(--success-color) 40%, transparent);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes mcqIncorrectShake {

            0%,
            100% {
                transform: translateX(0);
            }

            20% {
                transform: translateX(-6px);
            }

            40% {
                transform: translateX(6px);
            }

            60% {
                transform: translateX(-4px);
            }

            80% {
                transform: translateX(4px);
            }
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        /* --- MCQ Study Card Font Size Fix --- */
        .study-card-content-box.mcq-type {
            font-size: var(--study-card-font-size, 1.5rem);
            line-height: 1.6;
        }

        /* FOCUS/PRESENTATION MODE MCQ STYLING*/

        /* Hide radios and delete buttons in presentation mode */
        .focus-mode-overlay .nk-mcq-block .nk-mcq-option-radio,
        .focus-mode-overlay .nk-mcq-block .nk-mcq-delete-option {
            display: none;
        }

        /* Remove inner background from option text - let the option container handle it */
        .focus-mode-overlay .nk-mcq-block .nk-mcq-option-text {
            padding: 0;
            padding-left: 36px;
            background: transparent;
            border: none;
        }

        /* Option container - clean card style */
        .focus-mode-overlay .nk-mcq-block .nk-mcq-option {
            padding: 16px 20px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--bg-secondary);
            position: relative;
        }

        /* Radio pseudo-element - positioned properly */
        .focus-mode-overlay .nk-mcq-block .nk-mcq-option::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 16px;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            transform: translateY(-50%);
            background: var(--bg-tertiary);
            transition: all 0.25s ease;
        }

        /* Hover state before answering */
        .focus-mode-overlay .nk-mcq-block:not([data-answered="true"]) .nk-mcq-option:hover {
            border-color: var(--primary-color);
            background: color-mix(in srgb, var(--primary-color) 8%, var(--bg-secondary));
            transform: translateX(6px);
        }

        .focus-mode-overlay .nk-mcq-block:not([data-answered="true"]) .nk-mcq-option:hover::before {
            border-color: var(--primary-color);
            background: color-mix(in srgb, var(--primary-color) 25%, var(--bg-tertiary));
        }

        /* Disable pointer after answering */
        .focus-mode-overlay .nk-mcq-block[data-answered="true"] .nk-mcq-option {
            cursor: default;
        }

        /* Correct answer styling */
        .focus-mode-overlay .nk-mcq-block .nk-mcq-option.correct {
            border: 2.5px solid var(--success-color);
            background: linear-gradient(135deg,
                    color-mix(in srgb, var(--success-color) 12%, var(--bg-secondary)),
                    color-mix(in srgb, var(--success-color) 6%, var(--bg-secondary)));
            animation: mcqCorrectPulse 0.5s ease;
        }

        .focus-mode-overlay .nk-mcq-block .nk-mcq-option.correct::before {
            content: '';
            border-color: var(--success-color);
            background: var(--success-color);
            color: white;
            font-size: 0.8rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Incorrect answer styling */
        .focus-mode-overlay .nk-mcq-block .nk-mcq-option.incorrect {
            border: 2.5px solid var(--danger-color);
            background: linear-gradient(135deg,
                    color-mix(in srgb, var(--danger-color) 10%, var(--bg-secondary)),
                    color-mix(in srgb, var(--danger-color) 4%, var(--bg-secondary)));
            animation: mcqIncorrectShake 0.5s ease;
        }

        .focus-mode-overlay .nk-mcq-block .nk-mcq-option.incorrect::before {
            content: '';
            border-color: var(--danger-color);
            background: var(--danger-color);
            color: white;
            font-size: 1rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* ============================================
           STUDY FLASHCARD MODE MCQ STYLING
           ============================================ */

        /* Hide radios, delete buttons, and toolbar in study card mode */
        .study-card-content-box .nk-mcq-block .nk-mcq-option-radio,
        .study-card-content-box .nk-mcq-block .nk-mcq-delete-option,
        .study-card-content-box .nk-mcq-block .nk-mcq-toolbar {
            display: none;
        }

        /* Remove inner background from option text in study cards */
        .study-card-content-box .nk-mcq-block .nk-mcq-option-text {
            padding: 0;
            padding-left: 28px;
            background: transparent;
            border: none;
        }

        /* Option container - clean card style for study mode */
        .study-card-content-box .nk-mcq-block .nk-mcq-option {
            padding: 14px 18px 14px 14px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--bg-secondary);
            position: relative;
            display: flex;
            align-items: center;
        }

        /* Radio pseudo-element for study cards */
        .study-card-content-box .nk-mcq-block .nk-mcq-option::before {
            content: '';
            flex-shrink: 0;
            position: relative;
            top: auto;
            left: auto;
            width: 18px;
            height: 18px;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            transform: none;
            background: var(--bg-tertiary);
            transition: all 0.25s ease;
        }

        /* Hover state for study cards */
        .study-card-content-box .nk-mcq-block:not([data-answered="true"]) .nk-mcq-option:hover {
            border-color: var(--primary-color);
            background: color-mix(in srgb, var(--primary-color) 8%, var(--bg-secondary));
        }

        .study-card-content-box .nk-mcq-block:not([data-answered="true"]) .nk-mcq-option:hover::before {
            border-color: var(--primary-color);
            background: color-mix(in srgb, var(--primary-color) 25%, var(--bg-tertiary));
        }

        /* Disable pointer after answering in study cards */
        .study-card-content-box .nk-mcq-block[data-answered="true"] .nk-mcq-option {
            cursor: default;
        }

        /* Correct answer for study cards */
        .study-card-content-box .nk-mcq-block .nk-mcq-option.correct {
            border: 2px solid var(--success-color);
            background: color-mix(in srgb, var(--success-color) 10%, var(--bg-secondary));
        }

        .study-card-content-box .nk-mcq-block .nk-mcq-option.correct::before {
            content: '';
            border-color: var(--success-color);
            background: var(--success-color);
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Incorrect answer for study cards */
        .study-card-content-box .nk-mcq-block .nk-mcq-option.incorrect {
            border: 2px solid var(--danger-color);
            background: color-mix(in srgb, var(--danger-color) 8%, var(--bg-secondary));
        }

        .study-card-content-box .nk-mcq-block .nk-mcq-option.incorrect::before {
            content: '';
            border-color: var(--danger-color);
            background: var(--danger-color);
            color: white;
            font-size: 0.9rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Hide add option and explanation styling overrides for study cards */
        .study-card-content-box .nk-mcq-block .nk-mcq-add-option {
            display: none;
        }

        /* Study card MCQ block simplified styling */
        .study-card-content-box .nk-mcq-block {
            border-left: none;
            background: transparent;
            box-shadow: none;
            padding: 0;
            margin: 0;
        }


        /*PREMIUM "INSIGHT CARD" EXPLANATION - Glassmorphic Reveal Effect*/
        .nk-mcq-explanation {
            /* Hidden state - ready for spring animation */
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transform: translateY(-12px);
            transition:
                max-height 0.5s cubic-bezier(0.34, 1.56, 0.64, 1),
                opacity 0.4s ease,
                transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1),
                padding 0.3s ease,
                margin 0.3s ease;

            /* Visual styling */
            outline: none;
            margin-top: 0;
            padding: 0 16px;
            border-radius: 8px;
            font-size: 0.93em;
            color: var(--text-secondary);
            line-height: 1.6;
            font-family: inherit;

            /* Subtle background */
            background: color-mix(in srgb, var(--bg-tertiary) 50%, transparent);
            border-left: 2px solid color-mix(in srgb, var(--primary-color) 40%, transparent);
        }

        /* Write mode: Always show explanation for editing */
        body.write-mode .nk-mcq-explanation {
            max-height: none;
            opacity: 1;
            transform: translateY(0);
            margin-top: 1rem;
            padding: 12px 16px;
        }

        /* Placeholder that disappears when typing */
        .nk-mcq-explanation:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            opacity: 0.5;
            font-style: italic;
        }

        /* Hide placeholder when focused */
        .nk-mcq-explanation:focus:empty::before {
            opacity: 0.3;
        }

        /* Read Mode - The Reveal State - Clean and simple */
        body.read-mode .nk-mcq-block[data-answered="true"] .nk-mcq-explanation,
        .focus-mode-overlay .nk-mcq-block[data-answered="true"] .nk-mcq-explanation {
            max-height: 600px;
            opacity: 1;
            transform: translateY(0);
            margin-top: 1rem;
            padding: 14px 16px;
            background: color-mix(in srgb, var(--bg-tertiary) 70%, transparent);
            border-left: 2px solid var(--primary-color);
        }

        body.read-mode .nk-mcq-block[data-answered="true"] .nk-mcq-explanation,
        .focus-mode-overlay .nk-mcq-block[data-answered="true"] .nk-mcq-explanation {
            position: relative;
        }

        /* Hide empty explanations even after answering */
        .nk-mcq-block[data-answered="true"] .nk-mcq-explanation:empty {
            display: none !important;
            max-height: 0 !important;
            margin: 0;
            padding: 0;
            border: none;
        }


        /* --- NEW: Text Tile (Feature #3 - "/textile" command) --- */
        .nk-text-tile {
            display: flex;
            /* Flex layout for proper height/width handling */
            align-items: center;
            gap: 0.5rem;
            vertical-align: middle;
            background-color: transparent;
            border: 2px solid;
            border-radius: 12px;
            padding: 0.65rem 1.25rem;
            /* Center the textile and give it breathing room */
            margin: 0.5rem auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08),
                0 2px 4px rgba(0, 0, 0, 0.04);
            position: relative;
            /* FIXED: Always take 95% of available width to prevent any scrollbars */
            width: 95%;
            max-width: 95% !important;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-break: break-word;
            overflow-wrap: break-word;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        /* Hover effect for premium feel */
        body.write-mode .nk-text-tile:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12),
                0 4px 8px rgba(0, 0, 0, 0.06);
        }

        .nk-text-tile-icon {
            font-size: 0.95em;
            opacity: 0.85;
        }

        /*  Textile Color Styles */
        .nk-text-tile.color-1 {
            background: var(--textile-bg-1);
            border: 2px solid var(--textile-border-1);
            color: var(--textile-text-1);
        }

        .nk-text-tile.color-2 {
            background: var(--textile-bg-2);
            border: 2px solid var(--textile-border-2);
            color: var(--textile-text-2);
        }

        .nk-text-tile.color-3 {
            background: var(--textile-bg-3);
            border: 2px solid var(--textile-border-3);
            color: var(--textile-text-3);
        }

        .nk-text-tile.color-4 {
            background: var(--textile-bg-4);
            border: 2px solid var(--textile-border-4);
            color: var(--textile-text-4);
        }

        .nk-text-tile.color-5 {
            background: var(--textile-bg-5);
            border: 2px solid var(--textile-border-5);
            color: var(--textile-text-5);
        }

        .nk-text-tile.color-6 {
            background: var(--textile-bg-6);
            border: 2px solid var(--textile-border-6);
            color: var(--textile-text-6);
        }

        .nk-text-tile.color-7 {
            background: var(--textile-bg-7);
            border: 2px solid var(--textile-border-7);
            color: var(--textile-text-7);
        }

        .nk-text-tile.color-8 {
            background: var(--textile-bg-8);
            border: 2px solid var(--textile-border-8);
            color: var(--textile-text-8);
        }

        .nk-text-tile.color-9 {
            background: var(--textile-bg-9);
            border: 2px solid var(--textile-border-9);
            color: var(--textile-text-9);
        }

        /* Ensure content inherits correct colors */
        .nk-text-tile.color-1 .nk-text-tile-content,
        .nk-text-tile.color-2 .nk-text-tile-content,
        .nk-text-tile.color-3 .nk-text-tile-content,
        .nk-text-tile.color-4 .nk-text-tile-content,
        .nk-text-tile.color-5 .nk-text-tile-content,
        .nk-text-tile.color-6 .nk-text-tile-content,
        .nk-text-tile.color-7 .nk-text-tile-content,
        .nk-text-tile.color-8 .nk-text-tile-content,
        .nk-text-tile.color-9 .nk-text-tile-content {
            color: inherit;
        }

        /* Default fallback style */
        .nk-text-tile.color-default {
            background-color: transparent;
            border: 2px solid var(--border-color);
            color: var(--text-primary);
        }

        /* Content styling - outline:none ensures no "box inside box" */
        .nk-text-tile-content {
            outline: none;
            font-family: var(--font-body);
            font-size: 1.05rem;
            font-weight: 500;
            line-height: 1.6;
            color: inherit;
            min-width: 40px;
            letter-spacing: 0.01em;
            width: 100%;
            white-space: pre-wrap;
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        .nk-text-tile-content:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            opacity: 0.6;
            font-style: italic;
            font-weight: 400;
            pointer-events: none;
        }

        /* Premium glossy overlay for all colors */
        .nk-text-tile.color-1::before,
        .nk-text-tile.color-2::before,
        .nk-text-tile.color-3::before,
        .nk-text-tile.color-4::before,
        .nk-text-tile.color-5::before,
        .nk-text-tile.color-6::before,
        .nk-text-tile.color-7::before,
        .nk-text-tile.color-8::before,
        .nk-text-tile.color-9::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 10px;
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.25) 0%,
                    rgba(255, 255, 255, 0.08) 50%,
                    rgba(0, 0, 0, 0.02) 100%);
            pointer-events: none;
            z-index: 0;
        }

        /* Adjusted glossy overlay for dark theme */
        [data-theme="dark"] .nk-text-tile.color-1::before,
        [data-theme="dark"] .nk-text-tile.color-2::before,
        [data-theme="dark"] .nk-text-tile.color-3::before,
        [data-theme="dark"] .nk-text-tile.color-4::before,
        [data-theme="dark"] .nk-text-tile.color-5::before,
        [data-theme="dark"] .nk-text-tile.color-6::before,
        [data-theme="dark"] .nk-text-tile.color-7::before,
        [data-theme="dark"] .nk-text-tile.color-8::before,
        [data-theme="dark"] .nk-text-tile.color-9::before {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.1) 0%,
                    rgba(255, 255, 255, 0.03) 50%,
                    rgba(0, 0, 0, 0.08) 100%);
        }

        /* Ensure content is above gradient */
        .nk-text-tile-content,
        .nk-text-tile-icon,
        .nk-text-tile-color-cycler {
            position: relative;
            z-index: 1;
        }

        .nk-text-tile-color-cycler {
            position: absolute;
            top: -12px;
            left: auto;
            right: 0;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border: 2px solid var(--border-color);
            border-radius: 50%;
            width: 28px;
            height: 28px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: scale(0.85);
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        body.write-mode .nk-text-tile:hover .nk-text-tile-color-cycler {
            opacity: 1;
            transform: scale(1);
        }

        body.write-mode .nk-text-tile-color-cycler:hover {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-color-hover) 100%);
            color: var(--text-on-primary);
            border-color: var(--primary-color);
            transform: scale(1.1) rotate(15deg);
        }

        /* NEW: Read Mode Fading for Memorization */
        body.read-mode .nk-text-tile {
            cursor: pointer;
        }

        body.read-mode .nk-text-tile.faded {
            border-style: dashed;
            box-shadow: none;
        }

        body.read-mode .nk-text-tile.faded .nk-text-tile-content {
            color: transparent;
            user-select: none;
        }

        /* --- NEW: Text Tile & Decktile System --- */
        /* Main .nk-text-tile styles defined above */


        .search-result-item .nk-text-tile {
            display: flex;
            width: 100%;
            max-width: 100%;
        }

        .search-result-item .nk-text-tile-content {
            font-size: inherit;
        }

        /* --- NEW: Decktile Container --- */
        .nk-textile-deck {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 1rem;
            border-radius: var(--border-radius-lg);
            border: 1px dashed var(--border-color);
            background-color: color-mix(in srgb, var(--border-color) 10%, transparent);
            margin: 1.5em 0;
            position: relative;
        }

        /* A Textile inside a deck loses its margin to fit neatly */
        .nk-textile-deck .nk-text-tile {
            margin: 0;
            flex-grow: 1;
            min-width: 150px;
            width: auto;
            max-width: 100%;
        }

        /* NEW: Stack layout for Decks */
        .nk-textile-deck.layout-stack {
            flex-direction: column;
            align-items: stretch;
        }

        .deck-add-tile-btn {
            display: none;
            align-items: center;
            justify-content: center;
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius-lg);
            min-height: 50px;
            color: var(--text-secondary);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-grow: 1;
            min-width: 150px;
        }

        /* Show Add button ONLY in write mode */
        body.write-mode .deck-add-tile-btn {
            display: flex;
        }

        .deck-add-tile-btn:hover {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            border-color: var(--primary-color);
        }

        .deck-layout-toggle {
            position: absolute;
            top: -12px;
            right: 8px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            color: var(--text-secondary);
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }

        /* Show layout toggle on hover in BOTH modes */
        .nk-textile-deck:hover .deck-layout-toggle {
            display: flex;
        }

        .deck-layout-toggle:hover {
            color: var(--primary-color);
            transform: scale(1.1);
        }

        /* --- FIX: Make standalone text tiles full-width --- */
        #article-content>.nk-text-tile {
            display: flex;
            width: 100%;
            max-width: 100%;
            margin-left: 0;
            margin-right: 5px;
        }

        #article-content>.nk-text-tile .nk-text-tile-content {
            white-space: normal;
        }

        /* --- NEW: Power Quote Gradient Text (Theme-Sensitive v2) --- */
        .power-quote-gradient {
            font-weight: 500;
            font-style: italic;
            background-size: 200% auto;
            color: #000;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: witty-text-glow 5s linear infinite;
            cursor: default;
        }

        [data-theme="light"] .power-quote-gradient {
            background-image: linear-gradient(90deg, #0d9488, #581c87, #0f766e);
        }

        [data-theme="dark"] .power-quote-gradient {
            background-image: linear-gradient(90deg, #E0B453, #34d399, #F7C96D);
        }

        [data-theme="sepia"] .power-quote-gradient {
            background-image: linear-gradient(90deg, #8c6d46, #4d7c0f, #73552a);
        }


        /* KASH Co-Pilot (AI Sidebar) */
        @keyframes copilot-glow {
            from {
                box-shadow: 0 0 8px -2px color-mix(in srgb, var(--primary-color) 40%, transparent);
                border-color: color-mix(in srgb, var(--primary-color) 70%, transparent);
            }

            to {
                box-shadow: 0 0 20px 4px color-mix(in srgb, var(--primary-color) 25%, transparent);
                border-color: var(--primary-color);
            }
        }

        @keyframes subtle-pan {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes copilot-slide-in {
            from {
                opacity: 0;
                transform: translateX(100%) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        @keyframes copilot-slide-up {
            from {
                opacity: 0;
                transform: translateY(100%) scale(0.98);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes message-appear {
            from {
                opacity: 0;
                transform: translateY(10px) scale(0.96);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes title-shimmer {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 0 0 0 color-mix(in srgb, var(--primary-color) 30%, transparent);
            }

            50% {
                box-shadow: 0 0 15px 3px color-mix(in srgb, var(--primary-color) 20%, transparent);
            }
        }

        #kash-copilot-toggle {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            z-index: 25005;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg,
                    rgba(var(--bg-secondary-rgb), 0.9),
                    rgba(var(--bg-primary-rgb), 0.7));
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1.5px solid color-mix(in srgb, var(--primary-color) 50%, var(--border-color));
            color: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            animation: copilot-glow 4s infinite alternate ease-in-out;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer;
        }

        #kash-copilot-toggle:hover {
            transform: scale(1.15) rotate(5deg);
            border-color: var(--primary-color);
            background: linear-gradient(135deg,
                    rgba(var(--bg-secondary-rgb), 1),
                    rgba(var(--bg-primary-rgb), 0.9));
            animation-play-state: paused;
            box-shadow: 0 8px 25px -5px color-mix(in srgb, var(--primary-color) 40%, transparent);
        }

        #kash-copilot-toggle:active {
            transform: scale(1.05);
        }

        #kash-copilot-toggle svg {
            width: 18px;
            height: 18px;
            transition: transform 0.3s ease;
        }

        #kash-copilot-toggle:hover svg {
            transform: rotate(-10deg);
        }

        #kash-copilot-sidebar {
            position: fixed;
            z-index: 25010;
            display: flex;
            flex-direction: column;
            border: 1px solid color-mix(in srgb, var(--primary-color) 20%, var(--border-color));
            box-shadow:
                0 25px 50px -12px rgba(0, 0, 0, 0.25),
                0 12px 24px -8px rgba(0, 0, 0, 0.15),
                0 0 0 1px color-mix(in srgb, var(--primary-color) 10%, transparent),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            opacity: 0;
            transform: translateX(100%);
            overflow: hidden;

            /* Enhanced Gradient Background with glassmorphism */
            background:
                radial-gradient(ellipse at top right, color-mix(in srgb, var(--primary-color) 15%, transparent), transparent 45%),
                radial-gradient(ellipse at bottom left, color-mix(in srgb, var(--cat-color-3-bg) 20%, transparent), transparent 55%),
                radial-gradient(ellipse at center, color-mix(in srgb, var(--cat-color-2-bg) 8%, transparent), transparent 70%),
                linear-gradient(180deg, rgba(var(--bg-primary-rgb), 0.95), rgba(var(--bg-secondary-rgb), 0.98));
            backdrop-filter: blur(20px) saturate(1.2);
            -webkit-backdrop-filter: blur(20px) saturate(1.2);
            background-size: 250% 250%;
            animation: subtle-pan 30s ease infinite;
        }

        #kash-copilot-sidebar.visible {
            opacity: 1;
            transform: translateX(0);
            animation: copilot-slide-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards, subtle-pan 30s ease infinite;
        }

        /* Desktop Styles */
        @media (min-width: 613px) {
            #kash-copilot-sidebar {
                top: 60px;
                right: 1rem;
                bottom: 1.5rem;
                width: clamp(380px, 35vw, 550px);
                min-width: 340px;
                max-width: 75vw;
                border-radius: 16px;
                transition: width 0.15s ease;
            }

            #kash-copilot-sidebar.visible {
                animation: copilot-slide-in 0.45s cubic-bezier(0.34, 1.56, 0.64, 1) forwards, subtle-pan 30s ease infinite;
            }
        }

        @media (max-width: 612px) {
            #kash-copilot-toggle {
                bottom: 1rem;
                right: 1rem;
            }

            #kash-copilot-sidebar {
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                height: 65vh;
                min-height: 280px;
                max-height: 85vh;
                border-radius: 20px 20px 0 0;
                transform: translateY(100%);
                transition: height 0.15s ease;
            }

            #kash-copilot-sidebar.visible {
                transform: translateY(0);
                animation: copilot-slide-up 0.45s cubic-bezier(0.34, 1.56, 0.64, 1) forwards, subtle-pan 30s ease infinite;
            }
        }

        /* Resize Handle */
        #copilot-resize-handle {
            position: absolute;
            background: transparent;
            z-index: 10;
            transition: background 0.2s ease, opacity 0.2s ease;
        }

        @media (min-width: 613px) {
            #copilot-resize-handle {
                left: 0;
                top: 0;
                bottom: 0;
                width: 6px;
                cursor: ew-resize;
            }

            #copilot-resize-handle::after {
                content: '';
                position: absolute;
                left: 2px;
                top: 50%;
                transform: translateY(-50%);
                width: 3px;
                height: 40px;
                background: var(--border-color);
                border-radius: 3px;
                opacity: 0;
                transition: opacity 0.2s ease, background 0.2s ease;
            }

            #copilot-resize-handle:hover::after,
            #copilot-resize-handle.resizing::after {
                opacity: 1;
                background: var(--primary-color);
            }
        }

        @media (max-width: 612px) {
            #copilot-resize-handle {
                left: 0;
                right: 0;
                top: 0;
                height: 12px;
                cursor: ns-resize;
            }

            #copilot-resize-handle::after {
                content: '';
                position: absolute;
                top: 6px;
                left: 50%;
                transform: translateX(-50%);
                width: 40px;
                height: 4px;
                background: var(--border-color);
                border-radius: 4px;
                opacity: 0.5;
                transition: opacity 0.2s ease, background 0.2s ease, width 0.2s ease;
            }

            #copilot-resize-handle:hover::after,
            #copilot-resize-handle.resizing::after {
                opacity: 1;
                background: var(--primary-color);
                width: 60px;
            }
        }

        /* Header - Premium Glassmorphic */
        #copilot-header {
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid color-mix(in srgb, var(--border-color) 60%, transparent);
            background: linear-gradient(180deg,
                    rgba(var(--bg-secondary-rgb), 0.7),
                    rgba(var(--bg-secondary-rgb), 0.4));
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            position: relative;
        }

        #copilot-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 5%;
            right: 5%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            opacity: 0.3;
        }

        #copilot-header .witty-gradient-text {
            font-weight: 600;
            font-size: 0.95rem;
            letter-spacing: 0.3px;
        }

        #copilot-header .btn-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #copilot-header .btn-icon:hover {
            transform: scale(1.1);
            color: var(--primary-color);
            background: color-mix(in srgb, var(--primary-color) 15%, transparent);
        }

        /* Conversation Area */
        #copilot-conversation-area {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            padding: 1.25rem;
            gap: 1rem;
            scroll-behavior: smooth;
        }

        /* Premium Scrollbar */
        #copilot-conversation-area::-webkit-scrollbar {
            width: 6px;
        }

        #copilot-conversation-area::-webkit-scrollbar-track {
            background: transparent;
        }

        #copilot-conversation-area::-webkit-scrollbar-thumb {
            background: color-mix(in srgb, var(--text-secondary) 30%, transparent);
            border-radius: 3px;
        }

        #copilot-conversation-area::-webkit-scrollbar-thumb:hover {
            background: color-mix(in srgb, var(--text-secondary) 50%, transparent);
        }

        /* Empty State */
        .copilot-empty-state {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            padding: 1.5rem;
            text-align: center;
            animation: message-appear 0.4s ease-out;
        }

        .copilot-centered-header {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .copilot-centered-header h2 {
            font-size: 1.6rem;
            margin: 0;
            font-weight: 700;
        }

        .copilot-centered-header p {
            color: var(--text-secondary);
            margin: 0.5rem 0 0 0;
            font-size: 0.95rem;
            max-width: 280px;
            line-height: 1.5;
        }

        /* Prompt Cards - Premium Glass */
        .copilot-prompt-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            width: 100%;
            max-width: 400px;
        }

        .copilot-prompt-card {
            background: linear-gradient(135deg,
                    rgba(var(--bg-secondary-rgb), 0.5),
                    rgba(var(--bg-primary-rgb), 0.3));
            border: 1px solid color-mix(in srgb, var(--border-color) 70%, transparent);
            border-radius: 12px;
            padding: 1rem 0.75rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.6rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-size: 0.8rem;
            font-weight: 500;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .copilot-prompt-card:hover {
            transform: translateY(-5px) scale(1.02);
            background: linear-gradient(135deg,
                    rgba(var(--bg-secondary-rgb), 0.8),
                    rgba(var(--bg-primary-rgb), 0.6));
            border-color: color-mix(in srgb, var(--primary-color) 60%, var(--border-color));
            box-shadow:
                0 12px 24px -8px color-mix(in srgb, var(--primary-color) 20%, transparent),
                0 0 0 1px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }

        .copilot-prompt-card:active {
            transform: translateY(-2px) scale(0.98);
        }

        .copilot-prompt-card i {
            font-size: 1.25rem;
            color: var(--primary-color);
            transition: transform 0.3s ease;
        }

        .copilot-prompt-card:hover i {
            transform: scale(1.15);
        }

        /* Messages */
        .copilot-message {
            display: flex;
            gap: 0.75rem;
            max-width: 100%;
            animation: message-appear 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .copilot-message.user {
            justify-content: flex-end;
        }

        .copilot-message-bubble {
            padding: 0.875rem 1.125rem;
            border-radius: 16px;
            line-height: 1.65;
            max-width: 88%;
            box-shadow:
                0 2px 8px -2px rgba(0, 0, 0, 0.1),
                0 4px 12px -4px rgba(0, 0, 0, 0.08);
            transition: all 0.2s ease;
        }

        .copilot-message.user .copilot-message-bubble {
            background: linear-gradient(135deg, var(--primary-color), color-mix(in srgb, var(--primary-color) 85%, #000));
            color: var(--text-on-primary);
            border-bottom-right-radius: 6px;
            box-shadow:
                0 4px 12px -2px color-mix(in srgb, var(--primary-color) 40%, transparent),
                0 2px 4px -1px rgba(0, 0, 0, 0.1);
        }

        .copilot-message.ai .copilot-message-bubble {
            background: linear-gradient(135deg,
                    rgba(var(--bg-primary-rgb), 0.95),
                    rgba(var(--bg-secondary-rgb), 0.9));
            border: 1px solid color-mix(in srgb, var(--border-color) 60%, transparent);
            border-bottom-left-radius: 6px;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .copilot-message.ai .copilot-message-bubble:hover {
            border-color: color-mix(in srgb, var(--primary-color) 30%, var(--border-color));
        }

        .copilot-message.ai .copilot-message-bubble[contenteditable="true"]:focus-within {
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 50%, transparent);
            border-color: var(--primary-color);
        }

        /* Thinking Bubble - Animated Dots */
        #thinking-bubble {
            animation: pulse-glow 1.5s infinite ease-in-out;
            display: flex;
            align-items: center;
            gap: 4px;
            min-height: 24px;
        }

        .thinking-dots {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
        }

        .thinking-dots span {
            width: 8px;
            height: 8px;
            background: linear-gradient(135deg, var(--primary-color), color-mix(in srgb, var(--primary-color) 70%, var(--text-secondary)));
            border-radius: 50%;
            animation: thinking-bounce 1.4s infinite ease-in-out both;
        }

        .thinking-dots span:nth-child(1) {
            animation-delay: -0.32s;
        }

        .thinking-dots span:nth-child(2) {
            animation-delay: -0.16s;
        }

        .thinking-dots span:nth-child(3) {
            animation-delay: 0s;
        }

        @keyframes thinking-bounce {

            0%,
            80%,
            100% {
                transform: scale(0.6);
                opacity: 0.5;
            }

            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Input Container - Premium Glass */
        #copilot-input-container {
            position: relative;
            flex-shrink: 0;
            padding: 0.875rem 1rem;
            border-top: 1px solid color-mix(in srgb, var(--border-color) 50%, transparent);
            display: flex;
            align-items: flex-end;
            gap: 0.625rem;
            background: linear-gradient(180deg,
                    rgba(var(--bg-tertiary-rgb), 0.6),
                    rgba(var(--bg-tertiary-rgb), 0.8));
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }

        #copilot-input {
            flex-grow: 1;
            resize: none;
            max-height: 150px;
            font-size: 0.95rem;
            line-height: 1.5;
            padding: 12px 16px;
            border: 1.5px solid color-mix(in srgb, var(--border-color) 80%, transparent);
            background: rgba(var(--bg-secondary-rgb), 0.7);
            color: var(--text-primary);
            border-radius: 12px;
            transition: all 0.25s ease;
        }

        #copilot-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        #copilot-input:hover {
            border-color: var(--border-color);
            background: rgba(var(--bg-secondary-rgb), 0.85);
        }

        #copilot-input:focus {
            outline: none;
            border-color: var(--primary-color);
            background: rgba(var(--bg-secondary-rgb), 0.95);
            box-shadow:
                0 0 0 3px color-mix(in srgb, var(--primary-color) 20%, transparent),
                0 4px 12px -4px color-mix(in srgb, var(--primary-color) 30%, transparent);
        }

        #copilot-send-btn {
            width: 42px;
            height: 42px;
            border-radius: 10px;
            transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #copilot-send-btn:hover {
            transform: scale(1.08);
            box-shadow: 0 4px 12px -2px color-mix(in srgb, var(--primary-color) 40%, transparent);
        }

        #copilot-send-btn:active {
            transform: scale(0.95);
        }

        #copilot-send-btn svg {
            transform: translate(0px, 1.5px);
            transition: transform 0.2s ease;
        }

        #copilot-send-btn:hover svg {
            transform: translate(2px, -0.5px);
        }

        /* Bubble Actions */
        .copilot-bubble-actions {
            display: none;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-top: 0.875rem;
            padding-top: 0.625rem;
            border-top: 1px solid color-mix(in srgb, var(--border-color) 40%, transparent);
        }

        .copilot-message.ai .copilot-message-bubble:hover .copilot-bubble-actions {
            display: flex;
            animation: message-appear 0.2s ease;
        }

        .copilot-bubble-actions .btn {
            font-size: 0.8rem;
            padding: 6px 12px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .copilot-bubble-actions .btn:hover {
            transform: translateY(-1px);
        }

        /* Command List */
        #copilot-command-list {
            border-radius: 12px;
            box-shadow: 0 8px 24px -6px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        #copilot-command-list button {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.85rem;
            padding: 10px 14px;
            transition: all 0.15s ease;
        }

        #copilot-command-list button:hover {
            background: color-mix(in srgb, var(--primary-color) 10%, var(--bg-secondary));
        }

        #copilot-command-list button.selected {
            background: linear-gradient(90deg, var(--primary-color), color-mix(in srgb, var(--primary-color) 85%, #000));
            color: var(--text-on-primary);
        }

        #copilot-command-list .command-icon {
            font-size: 1.1em;
            width: 24px;
            text-align: center;
        }




        /* === NEW: Aesthetic Welcome Screen (v2.101 FINAL) === */
        @keyframes warm-glow {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .welcome-hero .library-title {
            background: linear-gradient(90deg, #f43f5e, #fbbf24, #0d9488, #f43f5e);
            background-size: 250% 250%;
            animation: warm-glow 15s ease infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .welcome-container {
            max-width: 800px;
            margin: 8vh auto;
            animation: fadeIn 0.5s ease-out forwards;
        }

        .welcome-hero h1 {
            font-size: 3.5rem;
            margin-bottom: 0.5rem;
        }

        .welcome-hero p {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-top: 0;
            max-width: 550px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }

        .welcome-choices {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-top: 3rem;
        }

        @keyframes welcome-card-glow {
            from {
                box-shadow: 0 0 5px -5px color-mix(in srgb, var(--primary-color) 60%, transparent);
            }

            to {
                box-shadow: 0 0 15px 3px color-mix(in srgb, var(--primary-color) 20%, transparent);
            }
        }

        .welcome-card {
            background-color: var(--bg-secondary);
            padding: 1.5rem;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            text-align: left;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
            position: relative;
        }

        .welcome-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary-color);
            animation: welcome-card-glow 3s infinite alternate;
        }

        .welcome-card.recommended {
            border-width: 2px;
            border-color: var(--primary-color);
            box-shadow: 0 0 20px -5px color-mix(in srgb, var(--primary-color) 30%, transparent);
        }

        .welcome-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: var(--bg-tertiary);
        }

        .welcome-card.disabled:hover {
            transform: none;
            box-shadow: none;
            border-color: var(--border-color);
        }

        .welcome-card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .card-icon {
            width: 40px;
            height: 40px;
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-tertiary));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-color);
            flex-shrink: 0;
        }

        .card-title {
            font-size: 1.15rem;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .card-description {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin: 0;
        }

        .welcome-prompt-actions {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-top: 2rem;
        }

        .welcome-prompt-alternatives {
            display: flex;
            gap: 1rem;
            align-items: center;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .welcome-prompt-alternatives a {
            color: var(--text-secondary);
            text-decoration: underline;
            cursor: pointer;
        }

        .welcome-prompt-alternatives a:hover {
            color: var(--primary-color);
        }

        @media (max-width: 612px) {
            .welcome-choices {
                grid-template-columns: 1fr;
            }

            .welcome-hero h1 {
                font-size: 2.5rem;
            }
        }

        .welcome-container .library-title {
            font-size: 3.4rem;
            margin-bottom: 0.25rem;
        }

        #welcome-subtitle {
            font-size: 1.55rem;
            color: var(--text-secondary);
            height: 2em;
            font-family: cursive;

        }

        #welcome-subtitle .typewriter-cursor {
            animation: blink 0.7s infinite;
            color: var(--primary-color);
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        /* Fade-out animation */
        @keyframes fadeOutAndShrink {
            from {
                opacity: 1;
                transform: scale(1);
            }

            to {
                opacity: 0;
                transform: scale(0.95);
            }
        }

        .view.fading-out {
            animation: fadeOutAndShrink 0.5s ease-out forwards;
        }

        /* GLOBAL */
        /* Collapsible Headings System */
        :is(h1, h2, h3, h4, h5, h6).collapsible-heading {
            position: relative;
            cursor: pointer;
            user-select: none;
            padding-left: 1.1em;
        }

        /* The actual icon element */
        .collapsible-icon {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 0.7em;
            height: 0.7em;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            pointer-events: auto;
            z-index: 10;
        }

        /* Simple triangle using CSS - minimal and clear */
        .collapsible-icon::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 0.35em solid transparent;
            border-right: 0.35em solid transparent;
            border-top: 0.5em solid var(--text-primary);
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), border-color 0.15s;
            opacity: 0.65;
        }

        .collapsible-icon svg {
            display: none;
        }

        /* Hover effect - scale up and change color */
        :is(h1, h2, h3, h4, h5, h6).collapsible-heading:hover .collapsible-icon::before {
            opacity: 1;
            border-top-color: var(--primary-color);
            transform: scale(1.15);
        }

        /* Collapsed state - rotate icon to point right */
        :is(h1, h2, h3, h4, h5, h6).collapsible-heading[data-collapsed="true"] .collapsible-icon::before {
            transform: rotate(-90deg);
        }

        /* Collapsed state with hover - combine rotation and scale */
        :is(h1, h2, h3, h4, h5, h6).collapsible-heading[data-collapsed="true"]:hover .collapsible-icon::before {
            transform: rotate(-90deg) scale(1.15);
        }

        /* Make icon more visible in read mode */
        body.mode-read .collapsible-icon::before {
            opacity: 0.75;
            border-top-color: var(--text-primary);
        }

        /* The content elements that are hidden */
        .collapsible-hidden {
            display: none !important;
        }


        /* GLOBAL SEARCH MODULE */
        #global-search-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 15vh;
            backdrop-filter: blur(4px);
        }

        #global-search-overlay.hidden {
            display: none;
        }

        #global-search-modal {
            width: 100%;
            max-width: 750px;
            background-color: rgba(var(--bg-secondary-rgb), var(--ui-opacity));
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        #global-search-modal .search-input-wrapper {
            display: flex;
            align-items: flex-start;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
        }


        .search-input-wrapper svg {
            color: var(--text-secondary);
            margin-right: 12px;
            margin-top: 0.2em;
        }

        #global-search-input {
            width: 100%;
            font-size: 1.2em;
            border: none;
            outline: none;
            background: transparent;
            color: var(--text-primary);
            resize: none;
            overflow-y: hidden;
            line-height: 1.4;
            font-family: inherit;
        }

        #global-search-input.expanded {
            min-height: 90px;
            white-space: pre-wrap;
        }

        #global-search-results {
            max-height: 500px;
            overflow-y: auto;
        }

        #global-search-btn {
            background: transparent;
            border: none;
        }

        .search-result-item {
            display: flex;
            align-items: center;
            padding: 14px 18px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.2s ease;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background-color: var(--background-color-secondary);
        }

        .search-result-item.selected {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
        }

        .search-result-item.selected .result-text,
        .search-result-item.selected .result-category,
        .search-result-item.selected .result-icon {
            color: var(--text-on-primary);
        }

        /* --- Unified Image Snippet Styling --- */
        /* For Global Search Thumbnails */
        .search-result-image-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .search-result-image-wrapper img {
            width: 320px;
            height: 250px;
            object-fit: cover;
            border-radius: 6px;
            flex-shrink: 0;
        }

        .search-result-caption {
            font-size: 0.9em;
            font-style: italic;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .search-result-item.selected .search-result-caption {
            color: var(--text-on-primary);
        }

        /* For Category View (Read Mode Style) */
        .category-summary-card .snippet .image-container {
            max-width: 100%;
            display: inline-block;
            /* Prevents flex stretching issues */
        }

        .category-summary-card .snippet img {
            max-width: 100% !important;
            /* Force image to fit container */
            height: auto !important;
            /* Maintain aspect ratio */
        }

        .result-icon {
            margin-right: 16px;
            width: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result-icon svg {
            width: 20px;
            height: 20px;
            stroke-width: 2px;
            color: var(--text-secondary);
        }

        .result-content {
            display: flex;
            flex-direction: column;
        }

        .result-text {
            font-size: 1.05em;
            font-weight: 500;
            line-height: 1.3;
            color: var(--text-color);
        }

        .result-category {
            font-size: 0.75em;
            color: var(--text-color-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }

        /* Style for the "No results found" message */
        .no-results-item {
            padding: 20px;
            text-align: center;
            color: var(--text-color-secondary);
        }

        .search-footer {
            display: flex;
            justify-content: space-around;
            padding: 8px 16px;
            background-color: var(--background-color-secondary);
            font-size: 0.8em;
            color: var(--text-color-secondary);
        }

        #global-search-modal .result-icon .badge-icon svg {
            color: inherit;
        }

        /* --- Readability fix for 0% Opacity --- */
        :root.zero-opacity-active header .btn-icon,
        :root.zero-opacity-active .article-controls .btn-icon {
            color: #ffffff;
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.7));
        }

        :root.zero-opacity-active header .btn-icon:hover,
        :root.zero-opacity-active .article-controls .btn-icon:hover {
            background-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        /* MOBILE VIEW ADAPTATIONS (v2+) */

        body.mobile-view .card-header-info {
            justify-content: flex-start;
            gap: 4px;
        }

        body.mobile-view .article-container,
        body.mobile-view .category-view-container,
        body.mobile-view .tags-view-container,
        body.mobile-view .flashcard-grid,
        body.mobile-view .stats-dashboard-view {
            padding-left: 0.25rem;
            padding-right: 0.25rem;
        }

        body.mobile-view .modal-content {
            padding: 1.5rem 1rem;
        }

        body.mobile-view .category-filters .category-chip {
            padding: 6px 8px;
            font-size: 0.85rem;
        }

        /* --- REFINED MOBILE FLASHCARD FOOTER (OVERLAY STYLE) --- */
        body.mobile-view .flashcard-tile-footer {
            opacity: 1;
            transform: none;
            background: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            box-shadow: none;
            border: none;
            padding: 0;
            gap: 4px;
        }

        body.mobile-view .flashcard-tile-content {
            padding-bottom: 1px;
            -webkit-mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
            mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
        }

        body.mobile-view .flashcard-tile-footer .btn-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: rgba(var(--bg-secondary-rgb), 0.8);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
        }

        body.mobile-view .flashcard-tile-footer .btn-icon:hover {
            color: var(--text-secondary);
            transform: none;
            background-color: rgba(var(--bg-secondary-rgb), 0.8);
        }

        body.mobile-view {
            font-size: 15px;
            -webkit-tap-highlight-color: transparent;
        }

        body.mobile-view main .view.active,
        body.mobile-view .library-main,
        body.mobile-view .tags-view-container,
        body.mobile-view .stats-dashboard-view {
            padding: 0.75rem;
        }

        /* --- 2A. Global Layout & Header --- */
        body.mobile-view header {
            padding: 0 4px;
        }

        .mobile-header-more-btn {
            display: none;
            margin-top: 0;
        }

        body.mobile-view header .header-main-actions,
        body.mobile-view header .header-overflow-actions,
        body.mobile-view header .header-fixed-actions {
            gap: 3px;
        }

        /* Hide the overflow group by default in mobile view */
        body.mobile-view .header-overflow-actions {
            display: none;
        }

        /* Show the "More" button only on mobile */
        body.mobile-view .mobile-header-more-btn {
            display: flex;
        }

        /* When more is clicked, show the overflow buttons in a flex-column popup */
        body.mobile-view.mobile-header-expanded header {
            position: relative;
        }

        body.mobile-view.mobile-header-expanded .header-overflow-actions {
            display: flex;
            position: absolute;
            top: 100%;
            right: 5px;
            flex-direction: column;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            padding: 4px;
            z-index: 1001;
            animation: slideDown 0.2s ease-out;
            transform-origin: top right;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: scale(0.95) translateY(-10px);
            }

            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* FIX: Ensure split screen toolbar is well-positioned on mobile */
        body.mobile-view.split-iframe-mode .article-controls {
            max-width: 100% !important;
            bottom: 0 !important;
            border-radius: 0 !important;
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
        }

        /* --- 2B. Library View --- */
        body.mobile-view .article-grid {
            grid-template-columns: 1fr;
            gap: 12px;
        }

        body.mobile-view .library-title {
            font-size: 2.5rem;
        }

        body.mobile-view .search-and-filter-bar {
            display: flex;
            flex-direction: row;
            gap: 0.5rem;
            align-items: center;
        }

        body.mobile-view .category-chip {
            min-width: 55px;
            text-align: center;
            padding: 8px 10px;
        }

        body.mobile-view .search-and-filter-bar .search-bar-container {
            flex-grow: 1;
        }

        /* Make the sort button compact */
        body.mobile-view .search-and-filter-bar #sort-filter {
            flex-shrink: 0;
            padding: 8px 12px;
            font-size: 0.8rem;
        }

        body.mobile-view .category-filters {
            width: 100%;
            flex-wrap: wrap;
            justify-content: center;
            padding-bottom: 8px;
            gap: 3px;
        }

        body.mobile-view .category-filters::-webkit-scrollbar {
            height: 3px;
        }

        body.mobile-view .category-filters::-webkit-scrollbar-track {
            background: transparent;
        }

        body.mobile-view .category-filters .btn {
            flex-shrink: 0;
        }

        /* --- 2C. Article View & Controls --- */
        body.mobile-view.write-mode main {
            scroll-padding-bottom: 50vh;
        }

        body.mobile-view .article-container {
            padding: 1rem 1rem 20vh 1rem;
        }

        body.mobile-view #article-controls {
            padding: 4px;
            gap: 4px;
        }

        body.mobile-view .controls-wrapper {
            gap: 4px;
        }

        body.mobile-view .article-controls {
            max-width: 95vw;
            bottom: 1rem;
            padding: 4px;
        }

        /* NEW: This ensures the tutorial buttons are spaced evenly and look great */
        body.mobile-view .article-controls .controls-wrapper {
            width: 100%;
        }

        body.mobile-view .article-controls .btn-gradient-text {
            flex-grow: 1;
            padding: 12px 8px;
            font-size: 1rem;
        }

        /* Read Mode: Show only essential controls */
        body.mobile-view .read-mode-controls .control-divider,
        body.mobile-view .read-mode-controls [data-action="copyHighlights"],
        body.mobile-view .read-mode-controls [data-action="exportHtml"],
        body.split-iframe-mode .read-mode-controls .control-divider,
        body.split-iframe-mode .read-mode-controls [data-action="goToCategory"],
        body.split-iframe-mode .read-mode-controls [data-action="copyHighlights"],
        body.split-iframe-mode .read-mode-controls [data-action="exportHtml"] {
            display: none;
        }

        body.mobile-view .write-mode-controls .control-divider,
        body.mobile-view .write-mode-controls [data-action="format"],
        body.mobile-view .write-mode-controls #list-group,
        body.mobile-view .write-mode-controls #format-group,
        body.split-iframe-mode .write-mode-controls .control-divider,
        body.split-iframe-mode .write-mode-controls [data-action="format"],
        body.split-iframe-mode .write-mode-controls [data-action="manageTable"],
        body.split-iframe-mode .write-mode-controls #list-group,
        body.split-iframe-mode .write-mode-controls #format-group,
        body.split-iframe-mode .write-mode-controls [data-action="insertCheckbox"],
        body.split-iframe-mode .write-mode-controls [data-action="insertAccordion"] {
            display: none;
        }



        body.mobile-view #category-selector {
            max-width: 110px;
        }

        /* --- 2D. Flashcard Study View --- */
        body.mobile-view .study-view {
            padding: 0.5rem;
            padding-bottom: 150px;
        }

        body.mobile-view .study-card-content-box {
            font-size: var(--study-card-font-size, 1.5rem);
        }

        body.mobile-view .study-controls {
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }

        body.mobile-view .btn-study-rating {
            padding: 10px 16px;
            font-size: 0.9rem;
        }

        body.mobile-view .flashcard-view-header {
            justify-content: center;
        }

        /* --- 2E. Modals (Hub, Settings, etc.) --- */
        body.mobile-view .modal-backdrop {
            padding: 0;
            top: 48px;
            height: calc(100% - 48px);
        }

        body.mobile-view .modal-content:not(.productivity-modal) {
            width: 100%;
            max-width: 100%;
            height: 100%;
            max-height: 100vh;
            border-radius: 0;
            display: flex;
            flex-direction: column;
        }

        body.mobile-view .productivity-modal {
            width: 100%;
            max-width: 100%;
            height: 100%;
            max-height: 100%;
            border-radius: 0;
            box-shadow: none;
            border: none;
        }

        body.mobile-view .tag-modal-body,
        body.mobile-view .guide-content,
        body.mobile-view .shortcut-modal-content>div {
            max-height: calc(100vh - 150px);
        }

        /* --- 2F. General UI Tweaks --- */
        body.mobile-view .btn {
            padding: 8px 10px;
            white-space: nowrap;
        }

        body.mobile-view .btn-icon {
            width: 40px;
            height: 40px;
        }

        /* --- NEW: Command Palette Mobile Style --- */
        body.mobile-view #command-palette {
            width: 95vw;
            max-width: 400px;
        }

        body.mobile-view header,
        body.mobile-view #article-controls,
        body.mobile-view .modal-buttons,
        body.mobile-view .btn,
        body.mobile-view .category-chip {
            text-align: center;
            padding: 8px 12px;
        }

        body.mobile-view .btn,
        body.mobile-view .article-card,
        body.mobile-view .flashcard-tile,
        body.mobile-view .category-chip,
        body.mobile-view .tag-item {
            position: relative;
            overflow: hidden;
        }

        body.mobile-view *:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-color) 40%, transparent);
        }

        /* --- 2E-2. Map Views (Mind Map & Visual Map) --- */
        body.mobile-view #visual-map-view.active,
        body.mobile-view #mindmap-view.active {
            padding: 0.75rem;
            gap: 0.75rem;
        }

        body.mobile-view #visual-map-controls,
        body.mobile-view #mindmap-controls {
            gap: 6px;
            min-height: auto;
        }

        body.mobile-view #visual-map-container,
        body.mobile-view #mindmap-container {
            border-radius: var(--border-radius-lg);
        }

        body.mobile-view .control-group .search-input {
            width: 140px;
        }

        /* --- 2G. Zen Mode Mobile Responsiveness --- */

        body.mobile-view .zen-mode-overlay {
            padding: 1.5rem 1rem;
        }

        body.mobile-view .zen-timer {
            font-size: clamp(5.5rem, 22vw, 8rem);
        }

        body.mobile-view .zen-task-title {
            font-size: clamp(1.2rem, 5vw, 1.5rem);
            -webkit-line-clamp: 2;
        }

        body.mobile-view .zen-bottom-controls {
            bottom: 2.5rem;
            gap: 2rem;
        }

        body.mobile-view .zen-bottom-controls .btn-icon {
            transform: scale(1.2);
        }

        /* --- Audio Recording Indicator --- */
        @keyframes red-pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
            }
        }

        .write-mode-controls .btn-icon.is-recording {
            color: var(--danger-color);
            animation: red-pulse 2s infinite;
            border-radius: 50%;
        }

        html.mobile-view {
            scroll-behavior: smooth;
        }

        /* --- Ascension & License System (v2.0 REDESIGN) --- */
        #profile-hub {
            position: relative;
            display: flex;
            align-items: center;
            margin-right: 0;
            height: 100%;
        }

        #profile-badge {
            cursor: pointer;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        #profile-badge .badge-icon {
            width: 33px;
            height: 33px;
            transform: scale(0.95);
            box-shadow: none;
        }

        #profile-badge .badge-icon .inner-icon {
            width: 65%;
            height: 65%;
        }

        #profile-badge:hover {
            transform: scale(1.05);
            border-color: var(--primary-color);
            box-shadow: 0 0 10px rgba(var(--primary-color-rgb), 0.3);
        }

        /* Add a subtle shine to the badge */
        #profile-badge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0) 50%, rgba(255, 255, 255, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.3s ease-out;
            border-radius: inherit;
            pointer-events: none;
        }

        #profile-badge:hover::before {
            opacity: 1;
        }

        #profile-badge:hover {
            transform: scale(1.05);
            background-color: var(--bg-tertiary);
        }

        #profile-badge.active {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 10px rgba(var(--primary-color-rgb), 0.3);
        }

        /* Hide the welcome text */
        #profile-welcome {
            display: none;
        }

        /* NEW: Profile Notification Card - Polished & Clean */
        #profile-notification-card {
            position: absolute;
            top: calc(100% + 12px);
            left: -5px;
            width: 320px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 10px 30px -10px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.02);
            padding: 1.25rem;
            z-index: 1000;
            display: none;
            flex-direction: column;
            gap: 1rem;
            transform-origin: top left;
            animation: fadeInScale 0.2s ease-out forwards;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Pointer/Arrow */
        #profile-notification-card::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 24px;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid var(--border-color);
        }

        #profile-notification-card::after {
            content: '';
            position: absolute;
            top: -7px;
            left: 24px;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid var(--bg-primary);
        }

        .notification-header {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* Ensure Badge is perfectly circular and not stretched */
        .spark-particle {
            position: fixed;
            pointer-events: none;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            z-index: 999999;
            box-shadow: 0 0 4px currentColor;
        }

        #notification-badge-icon {
            flex-shrink: 0;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background-color: var(--bg-secondary);
            overflow: hidden;

            /* 3D Pop Effect & Draggability */
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s ease;
            cursor: grab;
            position: relative;
            z-index: 1001;
        }

        #notification-badge-icon:hover {
            transform: scale(1.15) translateZ(0);
            box-shadow:
                0 10px 20px -5px rgba(0, 0, 0, 0.2),
                inset 0 -5px 10px rgba(0, 0, 0, 0.1),
                inset 0 5px 10px rgba(255, 255, 255, 0.5);
            z-index: 1002;
        }

        #notification-badge-icon:active {
            cursor: grabbing;
            transform: scale(1.05);
        }

        /* Force image or svg inside to fit nicely */
        #notification-badge-icon svg,
        #notification-badge-icon img,
        #notification-badge-icon .badge-icon {
            width: 100% !important;
            height: 100% !important;
            object-fit: cover;
            pointer-events: none;
        }

        #notification-title {
            font-family: var(--article-font-family);
            font-weight: 700;
            font-size: 0.95rem;
            line-height: 1.25;
            color: var(--text-primary);
        }

        .notification-message {
            font-family: var(--article-font-family);
            font-style: italic;
            font-size: 1rem;
            line-height: 1.5;
            color: var(--text-secondary);
            background-color: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
            border-left: 3px solid var(--primary-color);
        }

        /* Hide the link section as requested */
        #notification-link {
            display: none !important;
        }




        /* NEW ELEGANT LOCKED STYLE */
        .premium-feature-locked {
            display: inline-block;
            opacity: 0.6;
            cursor: not-allowed !important;
            position: relative;
            overflow: hidden;
            border-radius: var(--border-radius);
        }

        /* --- DEFINITIVE REGRESSION FIX --- */
        .control-group.premium-feature-locked {
            display: flex;
            flex-direction: row;
        }

        .premium-feature-locked::before {
            content: '';
            position: absolute;
        }

        .premium-feature-locked::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: inherit;
            border: 1px dashed color-mix(in srgb, var(--primary-color) 60%, transparent);
            pointer-events: none;
        }

        .premium-feature-locked:hover::before {
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 8px color-mix(in srgb, var(--primary-color) 30%, transparent);
        }


        .license-header-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem 0 1.5rem;
            text-align: center;
        }

        .license-header-badge {
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 6px 16px;
            border-radius: 20px;
            color: var(--text-on-primary, #fff);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            margin-bottom: 0.75rem;
            font-size: 1.1em;
        }

        .license-header-info p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .license-status-display {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-top: 1.5rem;
            text-align: center;
        }

        .license-status-display p {
            margin-bottom: 0.5rem;
            font-size: 1.05rem;
            color: var(--text-primary);
        }

        .license-status-display p strong {
            color: var(--primary-color);
        }

        .license-form-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        @media (min-width: 600px) {
            .license-form-grid {
                grid-template-columns: 120px 1fr;
                align-items: center;
                gap: 1.25rem;
            }

            .license-form-grid label {
                text-align: right;
                padding-right: 1rem;
                color: var(--text-secondary);
                font-weight: 500;
            }
        }

        .license-form-grid textarea {
            resize: vertical;
            min-height: 70px;
        }

        .license-footer-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 1.5rem;
        }

        .modal-hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 1rem 0 2rem;
        }

        #new-article-btn.limit-reached {
            background-color: var(--bg-tertiary);
            cursor: pointer;
            animation: none;
        }

        #new-article-btn.limit-reached svg {
            color: var(--danger-color);
        }

        /* --- REDESIGNED ASCENSION MODAL --- */
        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: transparent;
            border: none;
            font-size: 1.5rem;
            line-height: 1;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.5rem;
            transition: transform 0.2s ease, color 0.2s ease;
        }

        .modal-close-btn:hover {
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .ascension-modal {
            max-width: 720px;
            width: 100%;
            text-align: center;
            border: 1px solid var(--border-color);
            background: linear-gradient(145deg, var(--bg-primary), var(--bg-secondary));
            max-height: 90vh;
            overflow-y: auto;
        }

        /* --- NEW: Ascension Modal Gradient Text (v2) --- */
        .witty-gradient-text {
            font-weight: 700;
            background-size: 200% auto;
            color: #000;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: witty-text-glow 6s linear infinite;
        }

        [data-theme="light"] .witty-gradient-text {
            background-image: linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488);
        }

        [data-theme="dark"] .witty-gradient-text {
            background-image: linear-gradient(90deg, #F7C96D, #34d399, #f06292, #F7C96D);
        }

        [data-theme="sepia"] .witty-gradient-text {
            background-image: linear-gradient(90deg, #8c6d46, #4d7c0f, #a16207, #8c6d46);
        }

        @keyframes witty-text-glow {
            to {
                background-position: -200% center;
            }
        }

        .ascension-badges-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1.25rem;
            margin: 2rem 0;
        }

        .ascension-badge {
            padding: 1.25rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
        }

        .ascension-badge:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: var(--primary-color);
            box-shadow: var(--shadow-lg);
        }

        .ascension-badge .badge-icon {
            font-size: 3rem;
            line-height: 1;
            margin-bottom: 0.75rem;
            display: block;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .ascension-badge .badge-name {
            font-weight: 600;
            font-size: 1rem;
            margin-top: 0.5rem;
            display: block;
            color: var(--text-primary);
        }

        .ascension-badge .badge-duration {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Special style for the best tier */
        .ascension-badge.tier-quantum {
            border-color: var(--primary-color);
            background: linear-gradient(to bottom right, var(--bg-secondary), var(--bg-tertiary));
            animation: quantum-glow 3s infinite alternate;
        }

        @keyframes quantum-glow {
            from {
                box-shadow: 0 0 5px color-mix(in srgb, var(--primary-color) 20%, transparent);
            }

            to {
                box-shadow: 0 0 20px 5px color-mix(in srgb, var(--primary-color) 40%, transparent);
            }
        }

        .ascension-badge.tier-quantum .badge-name {
            color: var(--primary-color);
        }

        .ascension-features {
            text-align: left;
            margin: 2rem auto;
            max-width: 450px;
            padding: 1.5rem;
            background-color: var(--bg-primary);
            border-radius: var(--border-radius);
        }

        .ascension-features h5 {
            margin-top: 0;
            margin-bottom: 1rem;
        }

        .ascension-features ul {
            list-style: none;
            padding: 0;
        }

        .ascension-features li {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .ascension-features svg {
            color: #2ecc71;
            flex-shrink: 0;
        }

        .ascension-footer {
            margin-top: 1.5rem;
            font-size: 0.9rem;
        }

        .ascension-footer a {
            color: var(--text-secondary);
            text-decoration: none;
            border-bottom: 1px dotted var(--text-secondary);
        }

        .ascension-footer a:hover {
            color: var(--text-primary);
            border-bottom-color: var(--text-primary);
        }

        /* NEW: Styled Maybe Later Button */
        .ascension-footer-button {
            background-color: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius-lg);
            font-weight: 500;
            transition: all 0.2s ease-in-out;
        }

        .ascension-footer-button:hover {
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-tertiary));
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .modal-content {
            max-height: 90vh;
            overflow-y: auto;
        }

        .ascension-features {
            text-align: left;
            margin: 2rem auto;
            max-width: 450px;
            padding: 1.5rem;
            background-color: var(--bg-tertiary);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
        }

        .ascension-features h5 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: var(--primary-color);
            font-size: 1.1em;
        }

        .ascension-features ul {
            list-style: none;
            padding: 0;
        }

        .ascension-features li {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
            font-size: 0.95rem;
        }

        .ascension-features svg {
            color: var(--success-color);
            flex-shrink: 0;
        }

        /* Use success color for checkmarks */
        #license-hub-container {
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 0;
            margin: 1rem 0;
        }

        .license-hub-grid {
            align-items: center;
        }

        #license-hub-status-badge {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* --- NEW: Polished Ascension Cards (v2) --- */
        .ascension-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1.5rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
        }

        .ascension-card:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: var(--primary-color);
            box-shadow: var(--shadow-lg);
        }

        .ascension-card-name {
            font-weight: 600;
            font-size: 1.05rem;
            color: var(--text-primary);
        }

        .ascension-card-duration {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .ascension-card.is-current-tier {
            cursor: default;
            background-color: var(--bg-secondary);
            border-style: dashed;
        }

        .ascension-card.is-current-tier:hover {
            transform: none;
            box-shadow: none;
            border-color: var(--border-color);
        }

        .ascension-card.is-current-tier::after {
            content: 'CURRENTLY';
            position: absolute;
            top: 16px;
            right: -35px;
            transform: rotate(45deg);
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            font-size: 0.55rem;
            font-weight: 700;
            padding: 5px 32px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* --- NEW: Ascension Grid Layout (v2) --- */
        .ascension-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1.25rem;
            margin: 2rem 0;
        }

        /* First 3 cards (Spark, Bronze, Silver) take 2 columns each, filling the first row */
        .ascension-grid .ascension-card:nth-child(-n+3) {
            grid-column: span 2;
        }

        /* Last 2 cards (Gold, Diamond) take 3 columns each, filling and centering on the second row */
        .ascension-grid .ascension-card:nth-child(n+4) {
            grid-column: span 3;
        }

        /* Media query for smaller screens to stack them nicely */
        @media (max-width: 680px) {
            .ascension-grid {
                grid-template-columns: 1fr;
            }

            .ascension-grid .ascension-card:nth-child(-n+3),
            .ascension-grid .ascension-card:nth-child(n+4) {
                grid-column: span 1;
            }
        }

        /* --- NEW: Refined Maybe Later Button (v2) --- */
        .ascension-footer-button.witty-gradient-text {
            border: 2px solid var(--border-color);
            padding: 0.75rem 1.5rem;
            font-size: 1.1rem;
            font-weight: bold;
            transition: border-color 0.3s ease;
        }

        .ascension-footer-button.witty-gradient-text:hover {
            border-color: var(--primary-color);
        }

        /* Center the button */
        .ascension-modal .modal-buttons {
            justify-content: center;
        }


        /* --- THE ASTRAL CORE: MASTERPIECE EDITION BADGES (v2.0) --- */
        .badge-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .badge-label {
            font-weight: 500;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .badge-icon {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            border-radius: 50%;
            overflow: hidden;
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .badge-icon:hover {
            transform: scale(1.1) translateY(-5px);
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.2), 0 8px 16px rgba(0, 0, 0, 0.4);
        }

        .badge-icon .inner-icon {
            width: 62%;
            height: 62%;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* FIX: Specific rule to correctly size the small profile badge icon */
        #profile-badge .badge-icon {
            width: 100%;
            height: 100%;
            box-shadow: none;
        }

        #profile-badge .inner-icon {
            width: 60%;
            height: 60%;
        }

        .badge-icon .inner-icon svg {
            width: 100%;
            height: 100%;
        }

        /* --- Badge Icon Fills (Definitive Cross-Browser Fix) --- */
        [data-theme="light"] .astral.spark .inner-icon svg {
            fill: #6c757d;
        }

        [data-theme="light"] .astral.bronze .inner-icon svg {
            fill: #fff3e0;
        }

        [data-theme="light"] .astral.silver .inner-icon svg {
            fill: #ffffff;
        }

        [data-theme="light"] .astral.gold .inner-icon svg {
            fill: #424242;
        }

        [data-theme="light"] .astral.diamond .inner-icon svg {
            fill: #ffffff;
        }

        [data-theme="dark"] .astral.spark .inner-icon svg {
            fill: #a0aec0;
        }

        [data-theme="dark"] .astral.bronze .inner-icon svg {
            fill: #d7ccc8;
        }

        [data-theme="dark"] .astral.silver .inner-icon svg {
            fill: #eceff1;
        }

        [data-theme="dark"] .astral.gold .inner-icon svg {
            fill: #fffde7;
        }

        [data-theme="dark"] .astral.diamond .inner-icon svg {
            fill: #fff;
        }

        [data-theme="sepia"] .astral.spark .inner-icon svg {
            fill: #7a6a57;
        }

        [data-theme="sepia"] .astral.bronze .inner-icon svg {
            fill: #f5f5f5;
        }

        [data-theme="sepia"] .astral.silver .inner-icon svg {
            fill: #f5f5f5;
        }

        [data-theme="sepia"] .astral.gold .inner-icon svg {
            fill: #fbf0d9;
        }

        [data-theme="sepia"] .astral.diamond .inner-icon svg {
            fill: #fbf0d9;
        }

        /* Badge Animations & Theme Backgrounds (No changes here) */
        @keyframes subtle-glow {

            0%,
            100% {
                box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.3), 0 0 10px 0px var(--glow-color);
            }

            50% {
                box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.3), 0 0 20px 5px var(--glow-color);
            }
        }

        @keyframes very-subtle-glow {

            0%,
            100% {
                box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.3), 0 0 5px 0px var(--glow-color);
            }

            50% {
                box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.3), 0 0 10px 2px var(--glow-color);
            }
        }

        @keyframes icon-pulse {

            0%,
            100% {
                transform: scale(0.90);
                filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.25)) brightness(1);
            }

            50% {
                transform: scale(1.15);
                filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.4)) brightness(1.25);
            }
        }

        @keyframes rotate-veryslow {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        @keyframes planetary-rotation {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        [data-theme="light"] .astral.spark {
            background: linear-gradient(145deg, #e9ecef, #dee2e6);
            color: #6c757d;
        }

        [data-theme="light"] .astral.bronze {
            background: linear-gradient(145deg, #d3a985, #b96f48);
            color: #fff3e0;
        }

        [data-theme="light"] .astral.silver {
            background: linear-gradient(145deg, #e0e0e0, #bdbdbd);
            color: #ffffff;
            --glow-color: rgba(33, 33, 33, 0.2);
            animation: very-subtle-glow 8s infinite ease-in-out;
        }

        [data-theme="light"] .astral.gold {
            background: linear-gradient(145deg, #fff176, #fbc02d);
            color: #424242;
            --glow-color: rgba(251, 192, 45, 0.3);
            animation: subtle-glow 7s infinite ease-in-out;
        }

        [data-theme="light"] .astral.diamond {
            background: linear-gradient(145deg, #81d4fa, #29b6f6);
            color: #ffffff;
            --glow-color: rgba(3, 155, 229, 0.5);
            animation: subtle-glow 6s infinite ease-in-out;
        }

        [data-theme="dark"] .astral.spark {
            background: radial-gradient(circle, #4a5568, #2d3748);
            color: #a0aec0;
        }

        [data-theme="dark"] .astral.bronze {
            background: radial-gradient(circle, #8d6e63, #4e342e);
            color: #d7ccc8;
        }

        [data-theme="dark"] .astral.silver {
            background: radial-gradient(circle, #78909c, #37474f);
            color: #eceff1;
            --glow-color: rgba(176, 190, 197, 0.3);
            animation: very-subtle-glow 8s infinite ease-in-out;
        }

        [data-theme="dark"] .astral.gold {
            background: radial-gradient(ellipse at center, #7f3d02, #ffb300, #f57f17);
            color: #fffde7;
            --glow-color: rgba(255, 236, 179, 0.35);
            animation: subtle-glow 7s infinite ease-in-out;
        }

        [data-theme="dark"] .astral.diamond {
            background: radial-gradient(ellipse at center, #01579b, #29b6f6, #000);
            color: #fff;
            --glow-color: rgba(128, 222, 234, 0.5);
            animation: subtle-glow 6s infinite ease-in-out;
        }

        [data-theme="sepia"] .astral.spark {
            background: radial-gradient(circle at 30% 30%, #fbf0d9, #e9dbbf);
            color: #7a6a57;
        }

        [data-theme="sepia"] .astral.bronze {
            background: radial-gradient(circle, #ab8669, #8c6d46);
            color: #f5f5f5;
        }

        [data-theme="sepia"] .astral.silver {
            background: radial-gradient(circle, #d2d0cb, #a8a399);
            color: #f5f5f5;
            --glow-color: rgba(215, 204, 182, 0.3);
            animation: very-subtle-glow 8s infinite ease-in-out;
        }

        [data-theme="sepia"] .astral.gold {
            background: radial-gradient(circle, #e6c589, #b08d4b);
            color: #fbf0d9;
            --glow-color: rgba(199, 159, 87, 0.4);
            animation: subtle-glow 7s infinite ease-in-out;
        }

        [data-theme="sepia"] .astral.diamond {
            background: radial-gradient(circle, #b8cdd9, #839aac);
            color: #fbf0d9;
            --glow-color: rgba(131, 154, 172, 0.4);
            animation: subtle-glow 6s infinite ease-in-out;
        }

        .astral.spark .inner-icon svg {
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
        }

        [data-theme="sepia"] .astral.spark .inner-icon svg {
            filter: drop-shadow(0 1px 2px rgba(91, 70, 54, 0.2));
        }

        .astral.bronze .orbiting-dots {
            animation: planetary-rotation 20s infinite linear;
            transform-origin: center;
        }

        .astral.silver .inner-icon {
            animation: rotate-veryslow 90s infinite linear;
        }

        .astral.silver .inner-icon svg {
            filter: drop-shadow(0 0 5px rgba(236, 239, 241, 0.5));
        }

        [data-theme="light"] .astral.silver .inner-icon svg {
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.7));
        }

        [data-theme="sepia"] .astral.silver .inner-icon svg {
            filter: drop-shadow(0 0 6px rgba(251, 240, 217, 0.6));
        }

        .astral.gold .inner-icon {
            animation: icon-pulse 18s infinite ease-in-out;
        }

        .astral.diamond .inner-icon {
            animation: icon-pulse 18s infinite ease-in-out -3.5s;
        }


        /* NEW: Premium Flashcard Upsell Tile (v2.0 REDESIGN) */
        .premium-upsell-tile {
            background: rgba(var(--bg-secondary-rgb), 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid color-mix(in srgb, var(--primary-color) 20%, transparent);
            border-left: 5px solid var(--primary-color) !important;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1.25rem;
            text-align: center;
            transition: all 0.2s ease-in-out;
            aspect-ratio: 1.7 / 1;
            min-height: 165px;
        }

        .premium-upsell-tile:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 0 20px 5px color-mix(in srgb, var(--primary-color) 20%, transparent);
            border-color: var(--primary-color);
        }

        .upsell-badge {
            align-self: center;
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            font-size: 0.8rem;
            font-weight: 600;
            padding: 4px 12px;
            border-radius: 16px;
        }

        .upsell-content h4 {
            margin: 1rem 0 0.5rem 0;
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        .upsell-content p {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin: 0;
        }

        .upsell-progress-bar {
            height: 6px;
            background-color: var(--border-color);
            border-radius: 3px;
            margin: 0.75rem auto 0;
            overflow: hidden;
            width: 90%;
        }

        .upsell-progress {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 3px;
        }

        .upsell-cta {
            font-weight: 600;
            color: var(--primary-color);
            margin-top: 1rem;
            font-size: 0.95rem;
        }

        /* NEW: Library Premium Upsell Card */
        .library-premium-card {
            grid-column: 1 / -1;
            border-color: var(--primary-color) !important;
            background: linear-gradient(135deg, color-mix(in srgb, var(--primary-color) 5%, var(--bg-secondary)), var(--bg-secondary));
            cursor: pointer;
            border-radius: var(--border-radius);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        /* FIX #4: Add a beautiful hover effect */
        .library-premium-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 20px 5px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }

        .premium-badge {
            background-color: var(--primary-color) !important;
            color: var(--text-on-primary) !important;
        }

        .premium-card-footer {
            flex-direction: column;
            align-items: stretch !important;
            gap: 0.75rem !important;
        }

        .premium-progress-bar {
            height: 6px;
            background-color: var(--border-color);
            border-radius: 3px;
            overflow: hidden;
            width: 100%;
        }

        .premium-progress {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 3px;
        }

        .premium-cta-text {
            font-weight: 600;
            color: var(--primary-color);
            text-align: right;
        }

        /* --- NEW: Audio Player Block --- */
        .nk-audio-player {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-left: 5px solid var(--primary-color);
            border-radius: var(--border-radius-lg);
            padding: 0.75rem 1rem;
            margin: 0.25em;
            box-shadow: var(--shadow-sm);
            user-select: none;
        }

        .audio-play-pause-btn {
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background-color: var(--primary-color);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .audio-play-pause-btn:hover {
            transform: scale(1.05);
            background-color: var(--primary-color-hover);
        }

        /* --- NEW: Refined Write Mode Toolbar (Modern Clean Design - Seamless) --- */
        .controls-wrapper.write-mode-controls {
            display: none;
            align-items: center;
            gap: 0.25rem;
            padding: 0 2px;
            margin-right: -0.25rem;
        }

        .read-mode .controls-wrapper.write-mode-controls {
            display: none !important;
        }

        .write-mode .controls-wrapper.write-mode-controls {
            display: flex;
        }

        /* Hide elements that shouldn't appear in Write Mode */
        .write-mode #unified-heart-btn,
        .write-mode [data-action="switchToWrite"] {
            display: none !important;
        }

        /* Surgical Button Styling for Write Toolbar */
        .write-mode-controls .btn-icon {
            color: var(--text-secondary);
            font-size: 1.15rem;
            opacity: 0.8;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            width: 36px;
            /* MATCH READ MODE: Larger influence zone */
            height: 36px;
            /* MATCH READ MODE */
            border-radius: 8px;
            /* Softer squares */
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .write-mode-controls .btn-icon:hover {
            opacity: 1;
            color: var(--primary-color);
            background-color: var(--bg-secondary);
            transform: translateY(-1px);
        }

        /* Masterpiece Save Button */
        .btn-icon.btn-save-circle {
            background-color: #8D6E63;
            color: white !important;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(141, 110, 99, 0.3);
            /* Softer, richer shadow */
            margin: 0 4px;
            /* Minimal margin */
            border: 2px solid white;
            position: relative;
            flex-shrink: 0;
        }

        .btn-icon.btn-save-circle:hover {
            background-color: #795548;
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(141, 110, 99, 0.4);
            border-color: #fff;
        }

        .btn-icon.btn-save-circle svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Play icon (triangle) */
        .audio-play-pause-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 55%;
            transform: translate(-50%, -50%);
            border-style: solid;
            border-width: 8px 0 8px 14px;
            border-color: transparent transparent transparent var(--text-on-primary);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        /* Pause icon (bars) */
        .audio-play-pause-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 43%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 16px;
            background-color: var(--text-on-primary);
            box-shadow: 6px 0 0 0 var(--text-on-primary);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .audio-play-pause-btn.playing::before {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.5);
        }

        .audio-play-pause-btn.playing::after {
            opacity: 1;
        }

        .audio-progress-bar-container {
            flex-grow: 1;
        }

        .audio-progress-bar {
            width: 100%;
            cursor: pointer;
        }

        .audio-time-display {
            font-family: var(--font-body);
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
            min-width: 85px;
            text-align: center;
        }

        .nk-audio-player audio {
            display: none;
        }

        /* Style for the recording indicator */
        .recording-visualizer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px;
            box-shadow: 0 6px 8px -1px rgba(141, 110, 99, 0.5);
        }

        /* Category Pill Select */
        .category-select-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        select.category-pill-select {
            appearance: none;
            -webkit-appearance: none;
            background-color: var(--bg-secondary);
            border: none;
            border-radius: 12px;
            padding: 0.3rem 1.8rem 0.3rem 0.7rem;
            /* Compact padding */
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
            cursor: pointer;
            outline: none;
            transition: background-color 0.2s;
            max-width: 140px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23666' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.6rem center;
        }

        select.category-pill-select:hover {
            background-color: var(--bg-hover);
        }

        /* Vertical Divider - REMOVED for consistency */
        .control-divider {
            display: none;
        }

        /* --- NEW: Reusable Gradient Text Style --- */
        .btn-gradient-text {
            background-size: 200% auto;
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            animation: witty-text-glow 8s linear infinite;
        }

        [data-theme="light"] .btn-gradient-text {
            background-image: linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488);
        }

        [data-theme="dark"] .btn-gradient-text {
            background-image: linear-gradient(90deg, #fde047, #6ee7b7, #f472b6, #fde047);
        }

        [data-theme="sepia"] .btn-gradient-text {
            background-image: linear-gradient(90deg, #b45309, #55a630, #92400e, #b45309);
        }


        /* --- REFINED: Transcribe Button Aesthetics --- */
        .nk-transcribe-container .btn.btn-secondary {
            font-weight: 600;
            /* Bolder for emphasis */
            border: 2.5px solid var(--primary-color);
            border-radius: 50% 20% / 10% 40%;
            padding: 0.6rem 1.2rem;
            background-color: var(--bg-tertiary);
            transition: all 0.2s ease-in-out;
        }

        .nk-transcribe-container .btn.btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow);
            border-color: var(--primary-color);
        }

        /* --- NEW: Toast Wave Animation --- */
        .toast-wave-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toast-wave-visualizer {
            display: flex;
            align-items: center;
            gap: 3px;
            height: 20px;
        }

        .toast-wave-visualizer .wave-bar {
            width: 4px;
            height: 100%;
            background-color: currentColor;
            border-radius: 2px;
            animation: toast-wave-dance 1.2s ease-in-out infinite;
        }

        .toast-wave-visualizer .wave-bar:nth-child(2) {
            animation-delay: -1.0s;
        }

        .toast-wave-visualizer .wave-bar:nth-child(3) {
            animation-delay: -0.8s;
        }

        .toast-wave-visualizer .wave-bar:nth-child(4) {
            animation-delay: -0.6s;
        }

        @keyframes toast-wave-dance {

            0%,
            100% {
                transform: scaleY(0.2);
            }

            50% {
                transform: scaleY(1.0);
            }
        }

        /* --- NEW: PDF Attachment & Viewer Styles --- */
        .pdf-attachment-pill {
            display: inline-flex;
            align-items: stretch;
            vertical-align: middle;
            position: relative;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            margin: 0.2em 0.25em;
            max-width: calc(100% - 0.5em);
            overflow: hidden;
            transition: all 0.2s ease-in-out;
            background-color: var(--bg-tertiary) !important;
            background-image: none !important;
        }

        .pdf-attachment-pill::before {
            content: 'PDF';
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 0.5px;
            background-color: var(--danger-color);
            color: var(--text-on-primary);
            border-right: 1px solid var(--border-color);
        }

        .pdf-attachment-name {
            display: block;
            padding: 6px 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            outline: none;
            min-width: 100px;
            font-family: inherit;
            font-weight: 600;
            background-image: none !important;
        }

        body.read-mode .pdf-attachment-pill {
            cursor: pointer;
        }

        body.read-mode .pdf-attachment-pill:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow);
            transform: translateY(-1px);
        }

        body.write-mode .pdf-attachment-name {
            cursor: text;
            transition: background-color 0.2s ease;
        }

        body.write-mode .pdf-attachment-pill:hover .pdf-attachment-name {
            background-color: color-mix(in srgb, var(--primary-color) 8%, var(--bg-tertiary));
        }

        body.write-mode .pdf-attachment-name:focus {
            background-color: var(--bg-secondary);
            box-shadow: inset 0 0 0 2px var(--primary-color);
            white-space: normal;
            overflow: visible;
        }

        /* --- PDF Viewer Styles (v2 Professional Redesign) --- */
        #pdf-viewer-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 25000;
            background-color: var(--bg-primary);
            display: none;
            flex-direction: column;
            animation: fadeIn 0.3s ease;
        }

        #pdf-viewer-container.visible {
            display: flex;
        }

        .pdf-viewer-header {
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background-color: rgba(var(--bg-secondary-rgb), 0.8);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 30;
        }

        .pdf-viewer-controls {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .pdf-viewer-title {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-primary);
            flex-grow: 1;
            flex-shrink: 1;
            min-width: 0;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0 1rem;
        }

        .pdf-page-indicator {
            font-variant-numeric: tabular-nums;
            font-weight: 500;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
        }

        #pdf-page-num {
            width: 45px;
            text-align: center;
            border: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            color: var(--text-primary);
            padding: 4px;
            margin: 0 6px;
            font-size: 0.9rem;
            font-family: var(--font-body);
        }

        #pdf-page-num:focus {
            outline: 2px solid var(--primary-color);
        }

        #pdf-page-num::-webkit-outer-spin-button,
        #pdf-page-num::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        #pdf-page-num[type=number] {
            -moz-appearance: textfield;
        }

        .pdf-viewer-main {
            flex-grow: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        #pdf-thumbnails-bar {
            width: 150px;
            background-color: var(--bg-tertiary);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 12px;
            display: none;
            flex-direction: column;
            gap: 2px;
            z-index: 20;
        }

        .pdf-thumbnail {
            cursor: pointer;
            border: 3px solid transparent;
            border-radius: var(--border-radius);
            padding: 3px;
            transition: all 0.2s ease;
            text-align: center;
        }

        .pdf-thumbnail canvas {
            width: 100%;
            height: auto;
            border-radius: 4px;
            box-shadow: var(--shadow-sm);
        }

        .pdf-thumbnail:hover {
            border-color: var(--primary-color-hover);
            background-color: var(--bg-secondary);
        }

        .pdf-thumbnail.active {
            border-color: var(--primary-color);
            background-color: var(--bg-secondary);
        }

        .pdf-thumbnail span {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-top: 4px;
            display: block;
        }

        .pdf-viewer-canvas-wrapper {
            flex-grow: 1;
            overflow: auto;
            display: grid;
            place-items: center;
            padding: 0.25rem;
            padding-top: 0px;
        }

        .pdf-viewer-main.thumbnails-active #pdf-thumbnails-bar {
            display: flex;
        }

        .pdf-viewer-main.thumbnails-active .pdf-viewer-canvas-wrapper {
            margin-left: 10px;
            transition: margin-left 0.3s ease-in-out;
        }

        /* --- THE CORE OF THE ALIGNMENT FIX --- */
        .pdf-page-container {
            position: relative;
            margin: 0 auto;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            line-height: 0;
        }

        #pdf-viewer-canvas {
            display: block;

        }

        #pdf-viewer-container.text-view-active #pdf-annotate-toggle,
        #pdf-viewer-container.text-view-active #pdf-annotation-toolbar {
            display: none !important;
        }

        /* --- DECOUPLED TEXT VIEW STYLES (v2) --- */
        #pdf-text-view-content {
            display: none;
            width: 100%;
            padding: 2rem 1rem;
            /* Restored correct padding */
            font-family: var(--article-font-family);
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        #pdf-text-view-content p {
            margin-block-start: 0;
            margin-block-end: 0.5em;
        }

        #pdf-text-view-content pre {
            font-family: inherit;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: inherit;
            text-align: left;
            margin: 0 auto;
            max-width: 80ch;
            line-height: 1.7;
        }

        /* --- END OF TEXT VIEW STYLES --- */

        #pdf-viewer-container .btn-icon.active {
            background-color: var(--bg-tertiary);
            color: var(--primary-color);
        }

        body.pdf-viewer-active>header {
            display: none;
        }

        .pdf-more-menu-container {
            position: relative;
            display: inline-block;
        }

        .pdf-more-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            z-index: 26000;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            padding: 4px;
            display: none;
            flex-direction: column;
            gap: 4px;
            width: 180px;
        }

        .pdf-more-menu.visible {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }

        .pdf-more-menu .btn {
            width: 100%;
            justify-content: flex-start;
        }

        /* --- VIEW TOGGLING LOGIC --- */
        #pdf-viewer-container.text-view-active .pdf-page-container {
            display: none;
        }

        #pdf-viewer-container.text-view-active #pdf-text-view-content {
            display: block;
        }

        /* --- NEW: Control Visibility Logic --- */
        .text-view-only-btn {
            display: none;
        }

        /* Show them only when text view is active */
        #pdf-viewer-container.text-view-active .text-view-only-btn {
            display: inline-flex;
        }

        /* Hide standard zoom controls when in text view */
        #pdf-viewer-container.text-view-active #pdf-zoom-out,
        #pdf-viewer-container.text-view-active #pdf-zoom-percent,
        #pdf-viewer-container.text-view-active #pdf-zoom-in {
            display: none;
        }

        #pdf-viewer-container.pdf-fullscreen-active .pdf-viewer-header {
            display: none;
        }

        /* --- NEW: PDF Annotation Styles --- */
        .pdf-page-container {
            position: relative;
        }

        #annotation-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        #pdf-viewer-container.annotation-active #annotation-layer {
            pointer-events: auto;
            cursor: crosshair;
        }

        #pdf-annotation-toolbar .btn-icon.active {
            background-color: var(--bg-tertiary);
            color: var(--primary-color);
        }

        /* PDF PAN MODE */
        #pdf-viewer-container.pan-active .pdf-viewer-canvas-wrapper,
        #pdf-viewer-container.grab-mode .pdf-viewer-canvas-wrapper {
            cursor: grab;
            user-select: none;
        }

        #pdf-viewer-container.pan-active.is-dragging .pdf-viewer-canvas-wrapper,
        #pdf-viewer-container.grab-mode.is-dragging .pdf-viewer-canvas-wrapper {
            cursor: grabbing;
        }

        .pdf-color-palette {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 4px;
        }

        .pdf-color-pick {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .pdf-color-pick:hover {
            transform: scale(1.15);
        }

        .pdf-color-pick.active {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 60%, transparent);
            transform: scale(1.1);
        }

        #pdf-thickness-cycler svg {
            transition: transform 0.2s ease-in-out;
        }

        /* This rule standardizes all icons in both toolbars for a consistent look */
        #annotation-toolbar .btn-icon svg,
        #pdf-annotation-toolbar .btn-icon svg {
            width: 20px;
            height: 20px;
        }

        /* NEW: A smaller inner circle for the color cycler button for visual balance */
        .color-cycler-inner {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        /* --- NEW: PDF Viewer Mobile Responsiveness --- */
        body.mobile-view #pdf-viewer-header {
            flex-wrap: wrap;
            padding: 0.4rem 0.25rem;
            gap: 0.25rem;
        }

        body.mobile-view .pdf-viewer-title {
            order: -1;
            width: 100%;
            text-align: center;
            padding-bottom: 0.5rem;
            font-size: 0.9rem;
            border-bottom: 1px solid var(--border-color);
            display: none;
        }

        body.mobile-view .pdf-viewer-main.thumbnails-active {
            flex-direction: column;
        }

        body.mobile-view #pdf-thumbnails-bar {
            width: 100%;
            height: 120px;
            flex-direction: row;
            overflow-x: auto;
            overflow-y: hidden;
            border-right: none;
            border-bottom: 1px solid var(--border-color);
        }

        body.mobile-view .pdf-thumbnail {
            min-width: 80px;
        }

        /* Hide less critical buttons on mobile main bar */
        body.mobile-view #pdf-thumbnails-toggle,
        body.mobile-view #pdf-fullscreen-toggle,
        body.mobile-view #pdf-viewer-header .control-divider {
            display: none;
        }

        .pdf-more-menu .mobile-only-btn {
            display: none;
        }

        body.mobile-view .pdf-more-menu .mobile-only-btn {
            display: flex;
        }

        .tutorial-btn {
            flex-shrink: 0;
            white-space: nowrap;
        }
    </style>

</head>

<body>

    <!-- SHELL-FIRST LOADER (CRITICAL PATH) -->
    <div id="nk-shell-loader"
        style="position:fixed;inset:0;background:radial-gradient(circle at center, #f4e9d8 0%, #e9dbbf 120%);color:#5b4636;z-index:9999999;display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:'Montserrat',sans-serif;transition:opacity 0.8s ease;will-change:opacity;">
        <style>
            /* --- 1. The Book Icon (Premium) --- */
            .nk-loader-book {
                width: 60px;
                height: 42px;
                position: relative;
                margin-bottom: 32px;
                perspective: 600px;
                transform-style: preserve-3d;
            }

            .nk-loader-book::before,
            .nk-loader-book::after {
                content: '';
                position: absolute;
                top: 0;
                width: 50%;
                height: 100%;
                background: #8c6d46;
                border-radius: 2px;
                box-shadow: inset 2px 0 0 rgba(255, 255, 255, 0.1), 0 8px 12px rgba(91, 70, 54, 0.15);
                transform-origin: center;
                transition: all 0.5s ease;
                border: 1px solid #705535;
                box-sizing: border-box;
            }

            /* Left Page */
            .nk-loader-book::before {
                left: 0;
                border-radius: 4px 0 0 4px;
                transform-origin: right;
                background: linear-gradient(90deg, #8c6d46 0%, #aa855a 100%);
                animation: nk-book-open-left 2s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
            }

            /* Right Page */
            .nk-loader-book::after {
                right: 0;
                border-radius: 0 4px 4px 0;
                transform-origin: left;
                background: linear-gradient(-90deg, #8c6d46 0%, #aa855a 100%);
                animation: nk-book-open-right 2s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
            }

            /* Pages Effect */
            .nk-loader-pages {
                position: absolute;
                top: 3px;
                bottom: 3px;
                left: 50%;
                transform: translateX(-50%);
                width: 94%;
                z-index: 2;
                perspective: 600px;
                display: flex;
                justify-content: center;
            }

            .nk-loader-pages::before,
            .nk-loader-pages::after {
                content: '';
                width: 48%;
                height: 100%;
                background: #fffcf5;
                border: 1px solid #dcd0b3;
                box-sizing: border-box;
            }

            .nk-loader-pages::before {
                border-radius: 2px 0 0 2px;
                transform-origin: right;
                animation: nk-pages-left 2s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
                box-shadow: inset -1px 0 2px rgba(0, 0, 0, 0.05);
            }

            .nk-loader-pages::after {
                border-radius: 0 2px 2px 0;
                transform-origin: left;
                animation: nk-pages-right 2s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
                box-shadow: inset 1px 0 2px rgba(0, 0, 0, 0.05);
            }

            @keyframes nk-book-open-left {
                0% {
                    transform: rotateY(0deg);
                }

                100% {
                    transform: rotateY(-25deg);
                }
            }

            @keyframes nk-book-open-right {
                0% {
                    transform: rotateY(0deg);
                }

                100% {
                    transform: rotateY(25deg);
                }
            }

            @keyframes nk-pages-left {
                0% {
                    transform: rotateY(0deg) scaleX(0.1);
                    opacity: 0;
                }

                100% {
                    transform: rotateY(-20deg) scaleX(1);
                    opacity: 1;
                }
            }

            @keyframes nk-pages-right {
                0% {
                    transform: rotateY(0deg) scaleX(0.1);
                    opacity: 0;
                }

                100% {
                    transform: rotateY(20deg) scaleX(1);
                    opacity: 1;
                }
            }

            /* --- 2. Typography --- */
            #nk-shell-loader h1 {
                font-size: 2.5rem;
                letter-spacing: 0.2em;
                margin: 0;
                font-weight: 700;
                text-transform: uppercase;
                color: #5b4636;
                opacity: 0;
                transform: translateY(10px);
                animation: nk-title-reveal 1.2s cubic-bezier(0.2, 0.8, 0.2, 1) forwards 0.3s;
                text-shadow: 0 2px 4px rgba(91, 70, 54, 0.05);
            }

            #nk-shell-loader p {
                font-family: 'Inter', sans-serif;
                font-style: italic;
                font-weight: 300;
                font-size: 1rem;
                margin-top: 16px;
                opacity: 0;
                filter: blur(4px);
                transform: scale(0.95);
                animation: nk-sub-reveal 1.5s ease forwards 1.0s;
                color: #8c6d46;
                letter-spacing: 0.02em;
            }

            @keyframes nk-title-reveal {
                to {
                    opacity: 1;
                    transform: translateY(0);
                    letter-spacing: 0.25em;
                }
            }

            @keyframes nk-sub-reveal {
                to {
                    opacity: 0.8;
                    filter: blur(0);
                    transform: scale(1);
                }
            }

            @media (max-width: 480px) {
                #nk-shell-loader h1 {
                    font-size: 1.8rem;
                    letter-spacing: 0.15em;
                }

                #nk-shell-loader p {
                    font-size: 0.9rem;
                }
            }
        </style>

        <div class="nk-loader-book">
            <div class="nk-loader-pages"></div>
        </div>
        <h1>NoteKash</h1>
        <p>Unlocking your Second Brain...</p>
    </div>
    <script>
        (function () {
            try {
                var k = 'notekash_initialized', o = document.getElementById('nk-shell-loader');
                // Check if returning user
                if (localStorage.getItem(k)) {
                    o.style.display = 'none'; o.remove();
                } else {
                    // New User: Show for 3 seconds then fade out
                    setTimeout(function () {
                        o.style.opacity = '0'; // Trigger CSS transition (0.8s)
                        setTimeout(function () {
                            if (o) o.remove();
                            try { localStorage.setItem(k, 'true'); } catch (e) { }
                        }, 800); // Wait for transition
                    }, 3000); // 3 seconds visible
                }
            } catch (e) {
                console.error('Loader error', e);
                var el = document.getElementById('nk-shell-loader');
                if (el) el.style.display = 'none';
            }
        })();
    </script>
    <!-- END SHELL-FIRST LOADER -->

    <div id="the-line-container">
        <div id="the-line"></div>
    </div>
    <div id="app-background"></div>
    <div id="text-measurer"
        style="position: absolute; left: -9999px; top: -9999px; visibility: hidden; pointer-events: none; padding: 10px 14px; font-family: var(--font-body); line-height: 1.5; word-wrap: break-word;">
    </div>

    <header>
        <div class="header-main-actions">
            <div id="profile-hub">
                <div id="profile-badge" title="Your Current Tier">
                </div>
                <div id="profile-notification-card">
                    <div class="notification-header">
                        <span id="notification-badge-icon"></span>
                        <span id="notification-title"></span>
                    </div>
                    <p id="notification-message" class="notification-message"></p>
                    <a id="notification-link" href="#"
                        onclick="event.preventDefault(); App.ui.closeProfileNotification(); App.ui.showLicenseModal();"
                        style="display: none; text-decoration: none; color: inherit;">
                        <p id="notification-link-message" class="notification-message"></p>
                    </a>
                </div>
            </div>
            <button class="btn-icon" aria-label="Go to Homepage" onclick="App.router.navigateTo('library')"
                title="Library">
                <svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 9v11a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9" />
                    <path d="M9 22V12h6v10" />
                    <path d="M2 10l10-7 10 7" />
                </svg>

            </button>
            <button class="btn-icon" id="todo-btn" onclick="App.hub.ui.showProductivityModal()"
                title="Tasks & Timer (Ctrl+K)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="12 2 2 7 12 12 22 7 12 2"></polygon>
                    <polyline points="2 17 12 22 22 17"></polyline>
                    <polyline points="2 12 12 17 22 12"></polyline>
                </svg>
                <span id="todo-badge" class="todo-badge" style="display: none;"></span>
            </button>
            <button class="btn-icon" id="flashcard-header-btn" onclick="App.router.navigateTo('flashcard')"
                title="Flashcards" aria-label="Go to flashcards">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect>
                    <path d="M17 2v4"></path>
                    <path d="M7 2v4"></path>
                    <path d="M2 11h20"></path>
                </svg>
            </button>
        </div>

        <div class="header-overflow-actions">
            <button class="btn-icon" id="stats-header-btn" onclick="App.router.navigateTo('stats-dashboard')"
                title="Statistics Dashboard" aria-label="Show statistics dashboard">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path>
                    <path d="M22 12A10 10 0 0 0 12 2v10z"></path>
                </svg>
            </button>
            <button class="btn-icon" id="visual-map-header-btn" onclick="App.router.navigateTo('visual-map')"
                title="Visual Map">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2a10 10 0 1 0 10 10" />
                    <path d="M12 18a6 6 0 1 0 0-12 6 6 0 0 0 0 12z" />
                    <path d="M12 12a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" />
                </svg>

            </button>
            <button class="btn-icon" id="mindmap-header-btn" onclick="App.router.navigateTo('mindmap')"
                title="Mind Map">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2.5"
                    stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="6" cy="12" r="3"></circle>
                    <circle cx="18" cy="7" r="2.5"></circle>
                    <circle cx="18" cy="17" r="2.5"></circle>
                    <path d="M9,12 C12,12 13,7 15.5,7"></path>
                    <path d="M9,12 C12,12 13,17 15.5,17"></path>
                </svg>
            </button>
            <button class="btn-icon" id="split-screen-btn" onclick="App.splitScreen.toggle()"
                title="Split Screen - View Two Panels Side by Side">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" />
                    <path d="M12 3v18" />
                </svg>
            </button>
            <button class="btn-icon" id="install-pwa-btn" title="Install App" aria-label="Install NoteKash App">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
            </button>
            <button class="btn-icon" id="folder-btn" onclick="App.events.triggerZipImport()"
                title="Import File (PDF, Note, or Backup)" aria-label="Import File">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                </svg>
            </button>
        </div>

        <div class="header-fixed-actions">
            <button class="btn-icon" id="settings-btn" onclick="App.ui.showSettingsModal()" title="Settings"
                aria-label="Open settings">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path
                        d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                    </path>
                </svg>
            </button>
            <button id="global-search-btn" class="btn-icon" title="Global Search (Ctrl+K)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
            </button>
            <button class="btn-icon" id="new-article-btn" onclick="App.events.createNewArticle()"
                title="New Article (Alt+Shift+N)" disabled
                style="width: 36px; height: 36px; background: linear-gradient(135deg, var(--primary-color), var(--primary-color-hover)); color: white; border-radius: 50%; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
            </button>
            <button class="btn-icon mobile-header-more-btn"
                onclick="document.body.classList.toggle('mobile-header-expanded')" title="More Tools"
                aria-label="More header actions">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"
                    stroke="none">
                    <rect x="3" y="3" width="7" height="7" rx="2" ry="2"></rect>
                    <rect x="14" y="3" width="7" height="7" rx="2" ry="2"></rect>
                    <rect x="14" y="14" width="7" height="7" rx="2" ry="2"></rect>
                    <rect x="3" y="14" width="7" height="7" rx="2" ry="2"></rect>
                </svg>
            </button>
        </div>
    </header>

    <main>
        <div id="welcome-view" class="view"></div>
        <div id="library-view" class="view"></div>
        <div id="article-view" class="view"></div>
        <div id="category-view" class="view"></div>
        <div id="tags-view" class="view"></div>
        <div id="flashcard-view" class="view"></div>
        <div id="stats-dashboard-view" class="view"></div>
        <div id="visual-map-view" class="view">
            <div id="visual-map-controls">
                <div class="control-group">
                    <input type="search" class="search-input" id="graph-search-input" placeholder="Search nodes... (S)">
                    <button class="control-btn" id="find-next-btn" title="Find Next Result (Enter)"><svg
                            xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            viewBox="0 0 16 16">
                            <path
                                d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0" />
                            <path
                                d="M6 8.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1-.5-.5m0-2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5" />
                        </svg></button>
                </div>
                <div class="control-group">
                    <button class="control-btn" id="filter-all-btn" title="Expand All Nodes"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M12 2L2 7l10 5 10-5-10-5z" />
                            <path d="M2 17l10 5 10-5" />
                            <path d="M2 12l10 5 10-5" />
                        </svg></button>
                    <button class="control-btn" id="filter-tags-btn" title="Collapse All to Tags"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path
                                d="M12.586 2.586a2 2 0 0 0-2.828 0L2.172 10.172a2 2 0 0 0 0 2.828l7.414 7.414a2 2 0 0 0 2.828 0l7.414-7.414a2 2 0 0 0 0-2.828L12.586 2.586z" />
                            <line x1="9" y1="9" x2="9.01" y2="9" />
                        </svg></button>
                    <button class="control-btn" id="filter-orphans-btn" title="Show Orphan Notes"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <circle cx="12" cy="12" r="10" />
                            <line x1="4.93" y1="4.93" x2="19.07" y2="19.07" />
                        </svg></button>
                    <button class="control-btn" id="cycle-category-btn" title="Toggle Categories (T)"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
                        </svg></button>
                </div>
                <div class="control-group premium-feature-locked">
                    <button class="control-btn" id="lasso-btn" title="Lasso Select Tool (L)"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path
                                d="M15.1 4.2c-1-1.5-2.8-2.2-4.6-1.9-2.8.5-4.8 2.8-5 5.6-.2 2.3 1.1 4.5 3.1 5.5 2.1 1 4.5.4 6-1.1l2.4 2.4c.4.4 1 .4 1.4 0l.6-.6c.4-.4.4-1 0-1.4l-2.4-2.4c1.5-1.5 2.1-4 .9-6.1z" />
                            <path
                                d="M10.8 7.3c-.4.4-.4 1 0 1.4l4.2 4.2c.4.4 1 .4 1.4 0l.8-.8c.4-.4.4-1 0-1.4l-4.2-4.2c-.4-.4-1-.4-1.4 0l-.8.8z" />
                        </svg></button>
                    <button class="control-btn" id="expand-selection-btn" title="Expand Selection"
                        style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path
                                d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
                        </svg></button>
                    <button class="control-btn" id="collapse-selection-btn" title="Collapse Selection"
                        style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path
                                d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" />
                        </svg></button>
                </div>
                <div class="control-group premium-feature-locked">
                    <button class="control-btn" id="random-color-btn" title="Cycle Colors (C)"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z" />
                        </svg></button>
                    <button class="control-btn" id="revert-color-btn" title="Revert to Default Colors"><svg
                            xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="m15 13-3-3-3 3" />
                            <path d="m12 10 3 3" />
                            <path d="M10.002 6.43A6.5 6.5 0 0 0 8.5 20a6.5 6.5 0 0 0 13 0c0-2.83-1.8-5.23-4.29-6.13" />
                            <path d="M4.24 10.32a6.5 6.5 0 0 0-1.74 6.18A6.5 6.5 0 0 0 8.5 20" />
                        </svg></button>
                    <button class="control-btn" id="visual-map-layout-toggle" title="Toggle Layout"></button>
                </div>
                <div class="control-group premium-feature-locked">
                    <button class="control-btn" id="gather-nodes-btn" title="Gather All Nodes"><svg
                            xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="4" y1="14" x2="10" y2="14"></line>
                            <line x1="4" y1="10" x2="10" y2="10"></line>
                            <line x1="14" y1="4" x2="14" y2="10"></line>
                            <line x1="10" y1="4" x2="10" y2="10"></line>
                            <line x1="20" y1="10" x2="14" y2="10"></line>
                            <line x1="20" y1="14" x2="14" y2="14"></line>
                            <line x1="10" y1="20" x2="10" y2="14"></line>
                            <line x1="14" y1="20" x2="14" y2="14"></line>
                        </svg></button>
                </div>
                <div class="control-group premium-feature-locked">
                    <button class="control-btn" id="visual-map-snapshot-btn" title="Take Snapshot (P)"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                            <circle cx="8.5" cy="8.5" r="1.5" />
                            <polyline points="21 15 16 10 5 21" />
                        </svg></button>
                    <button class="control-btn" id="toggle-snapshots-btn" title="View Snapshots"><svg
                            xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="1 4 1 10 7 10"></polyline>
                            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                        </svg></button>
                    <button class="control-btn" id="delete-snapshots-btn" title="Delete Oldest Snapshots"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2">
                            </path>
                            <line x1="10" y1="11" x2="10" y2="17"></line>
                            <line x1="14" y1="11" x2="14" y2="17"></line>
                        </svg></button>
                </div>
                <div class="control-group">
                    <button class="control-btn" id="zoom-in-btn" title="Zoom In (+, Spacebar)"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <circle cx="11" cy="11" r="8" />
                            <line x1="21" y1="21" x2="16.65" y2="16.65" />
                            <line x1="11" y1="8" x2="11" y2="14" />
                            <line x1="8" y1="11" x2="14" y2="11" />
                        </svg></button>
                    <button class="control-btn" id="zoom-out-btn" title="Zoom Out (-, Shift+Spacebar)"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <circle cx="11" cy="11" r="8" />
                            <line x1="21" y1="21" x2="16.65" y2="16.65" />
                            <line x1="8" y1="11" x2="14" y2="11" />
                        </svg></button>
                    <button class="control-btn" id="reset-view-btn" title="Reset View (R)"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M2.5 2v6h6M21.5 22v-6h-6" />
                            <path d="M22 11.5A10 10 0 0 0 3.2 7.2L2.5 8M2 12.5a10 10 0 0 0 18.8 4.2l.7-1.2" />
                        </svg></button>
                </div>
            </div>

            <div id="vm-focus-line" class="canvas-focus-line" title="Toggle Focus Mode (F)"></div>
            <div id="visual-map-container" tabindex="0"></div>
        </div>

        <div id="mindmap-view" class="view">
            <div id="mindmap-controls">
                <div class="control-group search-input-wrapper">
                    <input type="search" class="search-input" id="mindmap-search-input"
                        placeholder="Search MindMaps...(S)">
                    <button class="control-btn" id="mindmap-find-next-btn" title="Find Next Result (Enter)"><svg
                            xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            viewBox="0 0 16 16">
                            <path
                                d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0" />
                            <path
                                d="M6 8.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1-.5-.5m0-2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5" />
                        </svg></button>
                    <div class="search-results-list" id="mindmap-search-results" style="display: none;"></div>
                </div>
                <div class="control-group">
                    <button class="control-btn" id="mindmap-prev-btn" title="Previous Mind Map (J)"><svg
                            xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            viewBox="0 0 16 16">
                            <path fill-rule="evenodd"
                                d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z" />
                        </svg></button>
                    <button class="control-btn" id="mindmap-next-btn" title="Next Mind Map (K)"><svg
                            xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            viewBox="0 0 16 16">
                            <path fill-rule="evenodd"
                                d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z" />
                        </svg></button>
                </div>
                <div class="control-group premium-feature-locked">
                    <button id="mindmap-layout-toggle" class="control-btn" title="Toggle Layout"></button>
                    <button id="mindmap-expand-all" class="control-btn" title="Expand All"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path
                                d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
                        </svg></button>
                    <button id="mindmap-collapse-all" class="control-btn" title="Collapse All"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path
                                d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" />
                        </svg></button>
                </div>
                <div class="control-group premium-feature-locked">
                    <button class="control-btn" id="mindmap-rotate-colors" title="Rotate Colors (C)"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z" />
                        </svg></button>
                </div>
                <div class="control-group premium-feature-locked">
                    <button class="control-btn" id="mindmap-snapshot-btn" title="Take Snapshot (P)"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                            <circle cx="8.5" cy="8.5" r="1.5" />
                            <polyline points="21 15 16 10 5 21" />
                        </svg></button>
                    <button class="control-btn" id="mindmap-toggle-snapshots-btn" title="View Snapshots"><svg
                            xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="1 4 1 10 7 10"></polyline>
                            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                        </svg></button>
                    <button class="control-btn" id="mindmap-delete-snapshots-btn" title="Delete Oldest Snapshots"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2">
                            </path>
                            <line x1="10" y1="11" x2="10" y2="17"></line>
                            <line x1="14" y1="11" x2="14" y2="17"></line>
                        </svg></button>
                </div>
                <div class="control-group">
                    <button class="control-btn" id="mindmap-zoom-in-btn" title="Zoom In (Space)"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <circle cx="11" cy="11" r="8" />
                            <line x1="21" y1="21" x2="16.65" y2="16.65" />
                            <line x1="11" y1="8" x2="11" y2="14" />
                            <line x1="8" y1="11" x2="14" y2="11" />
                        </svg></button>
                    <button class="control-btn" id="mindmap-zoom-out-btn" title="Zoom Out (Shift+Space)"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <circle cx="11" cy="11" r="8" />
                            <line x1="21" y1="21" x2="16.65" y2="16.65" />
                            <line x1="8" y1="11" x2="14" y2="11" />
                        </svg></button>
                    <button class="control-btn" id="mindmap-reset-view-btn" title="Reset View"><svg
                            xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M2.5 2v6h6M21.5 22v-6h-6" />
                            <path d="M22 11.5A10 10 0 0 0 3.2 7.2L2.5 8M2 12.5a10 10 0 0 0 18.8 4.2l.7-1.2" />
                        </svg></button>
                </div>
                <div class="control-group">
                    <button class="control-btn" id="mindmap-gather-nodes-btn" title="Gather All Nodes"><svg
                            xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="4" y1="14" x2="10" y2="14"></line>
                            <line x1="4" y1="10" x2="10" y2="10"></line>
                            <line x1="14" y1="4" x2="14" y2="10"></line>
                            <line x1="10" y1="4" x2="10" y2="10"></line>
                            <line x1="20" y1="10" x2="14" y2="10"></line>
                            <line x1="20" y1="14" x2="14" y2="14"></line>
                            <line x1="10" y1="20" x2="10" y2="14"></line>
                            <line x1="14" y1="20" x2="14" y2="14"></line>
                        </svg></button>
                </div>
            </div>
            <div id="mm-focus-line" class="canvas-focus-line" title="Toggle Focus Mode (F)"></div>
            <div id="mindmap-container" tabindex="0"></div>
        </div>
        </div>
    </main>

    <div id="annotation-toolbar" style="display:none;">
        <button class="btn-icon" onclick="App.events.navigateStageSlide(-1)" title="Previous Slide ()">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"
                stroke-width="2.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
            </svg>
        </button>
        <button class="btn-icon" onclick="App.events.navigateStageSlide(1)" title="Next Slide ()">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"
                stroke-width="2.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
            </svg>
        </button>
        <div class="control-divider"></div>

        <button class="btn-icon tool-btn active" id="focus-tool-pen" onclick="App.annotationEngine.setTool('pen')"
            title="Pen Tool (P)"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"
                viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round"
                    d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" />
            </svg></button>
        <button class="btn-icon tool-btn" id="focus-tool-rect" onclick="App.annotationEngine.setTool('rect')"
            title="Rectangle Tool (R)"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"
                viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round"
                    d="M5.25 7.5A2.25 2.25 0 017.5 5.25h9a2.25 2.25 0 012.25 2.25v9a2.25 2.25 0 01-2.25 2.25h-9a2.25 2.25 0 01-2.25-2.25v-9z" />
            </svg></button>
        <button class="btn-icon tool-btn" id="focus-tool-eraser" onclick="App.annotationEngine.setTool('eraser')"
            title="Eraser Tool (E)"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"
                viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M11.25 4.5l7.5 7.5-7.5 7.5" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg></button>
        <div class="control-divider"></div>
        <button id="focus-color-cycler" class="btn-icon" style="border-radius: 50%;" title="Cycle Color (C)"
            onclick="App.annotationEngine.cycleColor()"></button>
        <button id="focus-thickness-cycler" class="btn-icon" title="Cycle Thickness (T)"
            onclick="App.annotationEngine.cycleThickness()">
            <svg width="24" height="24" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="3" fill="currentColor" />
            </svg>
        </button>
        <div class="control-divider"></div>
        <button class="btn-icon" onclick="App.annotationEngine.undo()" title="Undo Last Annotation (U)">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z" />
                <path
                    d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z" />
            </svg>
        </button>
        <button class="btn-icon" onclick="App.annotationEngine.clearCurrentPage()" title="Clear Annotations (X)">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
        </button>
        <button class="btn-icon" onclick="App.annotationEngine.toggle('focus')" title="Exit Annotation Mode (D or Esc)">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
    </div>


    <div id="study-view-container"></div>
    <div id="article-controls" class="article-controls"></div>
    <button id="focus-mode-toggle" class="btn-icon" onclick="App.events.toggleFocusMode()" title="Exit Focus Mode (Esc)"
        aria-label="Toggle focus mode"></button>
    <div id="selection-toolbar" style="display:none; position:absolute; z-index:1001;"></div>
    <div id="image-toolbar" style="display:none; position:absolute; z-index:1001;"></div>

    <!-- WHITEBOARD v3 - FULLSCREEN WITH BOTTOM TOOLBAR -->
    <div id="whiteboard-overlay" tabindex="-1">
        <div id="whiteboard-card">
            <!-- Canvas area FIRST (takes maximum space) -->
            <div id="whiteboard-canvas-container">
                <img id="whiteboard-bg-image"
                    style="position: absolute; display: none; pointer-events: none; z-index: 0; transform-origin: top left;" />
                <canvas id="whiteboard-canvas"></canvas>
                <svg id="whiteboard-connectors"></svg>
                <!-- Text boxes dynamically inserted here -->
            </div>

            <!-- Bottom toolbar with ALL controls -->
            <div id="whiteboard-toolbar">
                <!-- Cancel button () - left -->
                <button class="wb-action-cancel" id="whiteboard-cancel-btn" title="Close">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18" />
                        <line x1="6" y1="6" x2="18" y2="18" />
                    </svg>
                </button>

                <!-- Drawing Tools -->
                <div class="wb-tool-group">
                    <button class="wb-tool-btn active" data-tool="pen" title="Pen">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none" viewBox="0 0 24 24"
                            stroke-width="2" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" />
                        </svg>
                    </button>
                    <button class="wb-tool-btn" data-tool="line" title="Line">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2">
                            <line x1="5" y1="19" x2="19" y2="5" />
                        </svg>
                    </button>
                    <button class="wb-tool-btn" data-tool="rect" title="Rectangle">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none" viewBox="0 0 24 24"
                            stroke-width="2" stroke="currentColor">
                            <rect x="4" y="4" width="16" height="16" rx="2" />
                        </svg>
                    </button>
                    <button class="wb-tool-btn" data-tool="circle" title="Circle">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="9" />
                        </svg>
                    </button>

                    <button class="wb-tool-btn" data-tool="eraser" title="Eraser">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2">
                            <path
                                d="M20 20H7L3 16a1 1 0 010-1.41l9.586-9.586a2 2 0 012.828 0l4.172 4.172a2 2 0 010 2.828L12 19.586" />
                        </svg>
                    </button>

                    <button class="wb-tool-btn wb-image-only" data-tool="image" title="Move/Resize Image">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" />
                            <circle cx="8.5" cy="8.5" r="1.5" fill="currentColor" />
                            <path d="M21 15l-5-5L5 21" />
                        </svg>
                    </button>

                </div>

                <div class="wb-divider"></div>

                <div class="wb-divider"></div>

                <!-- Colors Group (kept visible) -->
                <div class="wb-color-group">
                    <div class="wb-color-swatch active" data-color="text-primary"
                        style="background: var(--text-primary);"></div>
                    <div class="wb-color-swatch" data-color="primary-color" style="background: var(--primary-color);">
                    </div>
                    <div class="wb-color-swatch" data-color="text-red" style="background: var(--text-red);"></div>
                    <div class="wb-color-swatch" data-color="text-green" style="background: var(--text-green);"></div>
                    <div class="wb-color-swatch" data-color="text-blue" style="background: var(--text-blue);"></div>
                    <div class="wb-color-swatch" data-color="text-orange" style="background: var(--text-orange);"></div>
                </div>

                <div class="wb-divider"></div>

                <div class="wb-tool-group">
                    <!-- Text Tool (Moved) -->
                    <button class="wb-tool-btn" data-tool="text" title="Text Box">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2">
                            <path d="M4 7V4h16v3M9 20h6M12 4v16" />
                        </svg>
                    </button>

                    <!-- Tape Tool (Moved) -->
                    <button class="wb-tool-btn" data-tool="tape" title="Occlusion Tape (Flashcard)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2">
                            <path d="M6 4h12l2 2v12l-2 2H6l-2-2V6l2-2z" fill="currentColor" fill-opacity="0.3" />
                            <path d="M6 4h12l2 2v12l-2 2H6l-2-2V6l2-2z" />
                            <line x1="8" y1="9" x2="16" y2="9" stroke-linecap="round" />
                            <line x1="8" y1="12" x2="16" y2="12" stroke-linecap="round" />
                            <line x1="8" y1="15" x2="12" y2="15" stroke-linecap="round" />
                        </svg>
                    </button>
                </div>

                <!-- MORE MENU CONTAINER -->
                <div class="wb-more-container" id="wb-more-container">
                    <button class="wb-tool-btn" id="whiteboard-more-btn" title="More Tools">
                        <!-- 2x2 Grid/Apps Icon -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="7" height="7" rx="1" />
                            <rect x="14" y="3" width="7" height="7" rx="1" />
                            <rect x="14" y="14" width="7" height="7" rx="1" />
                            <rect x="3" y="14" width="7" height="7" rx="1" />
                        </svg>
                    </button>

                    <!-- Popup Menu Items -->
                    <div class="wb-more-menu" id="wb-more-menu">
                        <!-- Thickness -->
                        <button class="wb-tool-btn" id="whiteboard-thickness-btn" title="Thickness">
                            <svg width="18" height="18" viewBox="0 0 24 24">
                                <circle cx="12" cy="12" r="4" fill="currentColor" />
                            </svg>
                        </button>
                        <!-- Undo -->
                        <button class="wb-tool-btn" id="whiteboard-undo-btn" title="Undo (Ctrl+Z)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M3 7v6h6"></path>
                                <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path>
                            </svg>
                        </button>
                        <!-- Paste -->
                        <button class="wb-tool-btn" id="whiteboard-paste-btn" title="Paste Image (Ctrl+V)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2">
                                </path>
                                <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                            </svg>
                        </button>
                        <!-- Clear Canvas -->
                        <button class="wb-tool-btn danger-hover" id="whiteboard-clear-btn" title="Clear Canvas">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6" />
                                <path
                                    d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
                            </svg>
                        </button>
                        <!-- Background Toggle -->
                        <button class="wb-tool-btn" id="whiteboard-bg-btn"
                            title="Background Color (Transparent/White/Dark/Grid)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"
                                fill="currentColor">
                                <path
                                    d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"
                                    opacity="0.3" />
                                <path d="M7 12h10M12 7v10" stroke="currentColor" stroke-width="2"
                                    stroke-linecap="round" />
                                <circle cx="8" cy="8" r="2.5" />
                                <circle cx="16" cy="16" r="2.5" />
                                <path d="M16 8l-8 8" stroke="currentColor" stroke-width="2" />
                            </svg>
                        </button>
                        <!-- Auto-Layout -->
                        <button class="wb-tool-btn" id="wb-auto-layout-btn"
                            title="Auto-Layout Magic Wand (Rearrange Nodes)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M15 4V2m0 2h-2m2 0h2M5 8l-2 2m2-2l2 2m-2-2l2-2m-2 2L3 6" />
                                <path d="M19 9l2 2m-2-2l-2 2m2-2l2-2m-2 2l-2-2" />
                                <line x1="15" y1="15" x2="21" y2="21"></line>
                                <line x1="4" y1="20" x2="10" y2="14"></line>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Add to Article button - direct action, no dropdown -->
                <button class="wb-action-add" id="whiteboard-add-btn" title="Add to Article as PNG">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <div id="context-menu-container"></div>

    <div id="toast-container"></div>
    <div id="modal-container"></div>
    <div id="zen-mode-container"></div>
    <input type="file" id="mobile-import-input" accept=".json" multiple style="display:none;">

    <div id="confetti-toast-container"></div>

    <script id="pomodoro-worker-script" type="text/js-worker">
        let timerId = null;
        let timeLeft = 0;

        self.onmessage = function(e) {
            const { command, newTimeLeft } = e.data;

            if (command === 'start') {
                if (timerId) clearInterval(timerId);
                timeLeft = newTimeLeft;
                timerId = setInterval(() => {
                    timeLeft--;
                    self.postMessage({ type: 'tick', timeLeft: timeLeft });
                    if (timeLeft <= 0) {
                        clearInterval(timerId);
                        timerId = null;
                    }
                }, 1000);
            } else if (command === 'pause') {
                if (timerId) {
                    clearInterval(timerId);
                    timerId = null;
                }
            } else if (command === 'stop') {
                if (timerId) {
                    clearInterval(timerId);
                    timerId = null;
                }
                timeLeft = 0;
            }
        };
    </script>
    <input type="file" id="background-image-input" accept="image/*" style="display: none;">
    <input type="file" id="import-files-input"
        accept=".zip,.notekash,.json,.pdf,application/pdf,application/json,application/zip,application/octet-stream,text/plain,*/*"
        multiple style="display:none">
    <input type="file" id="pdf-import-input" accept=".pdf,.txt,.doc,.docx" style="display: none;">
    <div id="pdf-viewer-container"></div>
    <script id="transcription-worker-script" type="text/js-worker">
        // **THE FIX**: This now uses the modern ES module import.
        // This is compatible with how the worker is created in runTranscription.
        // **OFFLINE FIX**
        let transcriber = null;
        let pipeline = null;

        self.addEventListener('message', async (event) => {
            const { audioData, modelName, playerId } = event.data;

            if (!pipeline) {
                try {
                    const module = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1');
                    pipeline = module.pipeline;
                } catch (e) {
                     self.postMessage({ status: 'error', data: 'Offline: AI disabled.', playerId: playerId });
                     return;
                }
            }

            if (!transcriber) {
                try {
                    transcriber = await pipeline('automatic-speech-recognition', modelName);
                } catch (e) {
                    console.error("Failed to load transcription pipeline in worker", e);
                    self.postMessage({ status: 'error', data: 'Failed to load AI model.', playerId: playerId });
                    return;
                }
            }

             try {
                // THE FIX: Adding a stride creates overlapping audio chunks, which is crucial 
                // for maintaining context and preventing repetition in longer audio files.
                const output = await transcriber(audioData, {
                    chunk_length_s: 30,
                    stride_length_s: 5
                });
                self.postMessage({ status: 'complete', text: output.text, playerId: playerId });
            } catch (e) {
                console.error("Transcription failed in worker", e);
                self.postMessage({ status: 'error', data: 'Transcription failed.', playerId: playerId });
            }
        });
    </script>

    <script>
        /* ==========================================================================
           3. APPLICATION LOGIC (JAVASCRIPT v2 SUPERTAGS UPDATE)
           ==========================================================================
         *
         * DEVELOPER MAP (REFINED v2.0):
         * --------------------------------------------------------------------------
         * App        - Main application namespace.
         * .pwa       - PWA Service Worker and install prompt logic.
         * .config    - Static configuration.
         * .state     - Dynamic application state.
         * .settings  - Handles loading/saving of persistent settings via settings.json.
         * .init()    - Entry point.
         * .indexedDB - Handles storing the directory handle.
         * .fs        - Centralized file system operations for all JSON files.
         * .storage   - Handles all article-specific FS ops, including tombstone logic.
         * .dropbox   - Full Dropbox sync engine.
         * .router    - Manages navigation between views.
         * .ui        - Renders and updates the DOM.
         * .events    - User-triggered event handlers and listeners.
         * .services  - Business logic (exports, image processing, backup).
         * .util      - General-purpose helper functions.
         * .hub       - Encapsulated logic for the Productivity Hub (Tasks & Pomodoro).
         * .quiz      - Logic for the Flashcard Quiz Mode.
         * .visualMap - NEW: D3 Force-Directed Graph logic.
         * .mindMap   - NEW: D3 Hierarchical Tree logic.
         * .contentTools- NEW: Logic for [[...]] and ==...== syntax, suggestions.
         * --------------------------------------------------------------------------
         */

        // --- ICONS & HELPERS (FROM PROTOTAGS) ---
        const ICON_FORCE = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 4h-2.5a3.5 3.5 0 0 0-3.5 3.5V11"/><path d="M6 11h2.5a3.5 3.5 0 0 1 3.5 3.5V18"/><circle cx="6" cy="4" r="2"/><circle cx="18" cy="18" r="2"/></svg>`;
        const ICON_RADIAL = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m4.93 19.07 1.41-1.41"/><path d="m17.66 6.34 1.41-1.41"/></svg>`;
        const ICON_MINDMAP_FORCE = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h3M18 12h3M12 3v3M12 18v3"/><circle cx="12" cy="12" r="7"/><path d="M8.5 8.5c.66-.66 1.54-1.2 2.5-1.42"/><path d="M15.5 15.5c-.66.66-1.54 1.2-2.5 1.42"/><path d="M15.5 8.5c-.66-.66-1.54-1.2-2.5-1.42"/><path d="M8.5 15.5c.66.66 1.54 1.2 2.5 1.42"/></svg>`;
        const ICON_MINDMAP_RADIAL = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="2"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m4.93 19.07 1.41-1.41"/><path d="m17.66 6.34 1.41-1.41"/></svg>`;

        // --- SHARED MODULE: Color Manager (FROM PROTOTAGS) ---
        const ColorManager = {
            palettes: ['c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'c10', 'c11', 'c12', 'c13', 'c14', 'c15'],
            assignment: new Map(),
            seed: 1,
            _pseudoRandom() { let x = Math.sin(this.seed++) * 10000; return x - Math.floor(x); },
            getSchemeFor(id, index) {
                if (!this.assignment.has(id)) this.assignment.set(id, this.palettes[index % this.palettes.length]);
                return this.assignment.get(id);
            },
            rotateSchemes() {
                const shuffledPalettes = [...this.palettes];
                for (let i = shuffledPalettes.length - 1; i > 0; i--) {
                    const j = Math.floor(this._pseudoRandom() * (i + 1));
                    [shuffledPalettes[i], shuffledPalettes[j]] = [shuffledPalettes[j], shuffledPalettes[i]];
                }
                const currentIds = Array.from(this.assignment.keys());
                this.assignment.clear();
                currentIds.forEach((id, index) => this.assignment.set(id, shuffledPalettes[index % shuffledPalettes.length]));
            },
            clear() { this.assignment.clear(); }
        };

        const DUMMY_TUTORIAL_ARTICLE = {
            title: "Welcome to Your Second Brain ",
            isDummy: true,
            get category() {
                const userCategories = App.settings.get('userCategories') || [];
                const defaultCategory = userCategories.find(c => c.isDefault);
                return defaultCategory ? defaultCategory.name : 'General'; // Fallback just in case.
            },
            get content() {
                const randomQuote = App.util.getRandomMessage(App.util.powerQuotes);
                const randomDevMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
                const styledDivider = `<hr style="border: none; border-top: 2px solid var(--border-color); opacity: 0.5; width: 60%; margin: 2em auto;">`;

                return `
                <!-- Introduction Section -->
                <div class="nk-text-tile color-3" style="margin-top: 1em; margin-bottom: 2em;">
                    <div class="nk-text-tile-content" style="text-align: center; padding: 1rem;">
                        <span class="power-quote-gradient" style="font-size: 1.4em; line-height: 1.4; display: block; margin-bottom: 0.5em;"><b><i>"${randomQuote}"</i></b></span>
                        <p style="margin: 0; font-size: 1.1em; opacity: 0.9;">Welcome to NoteKash! This isn't just a notepad; it's a powerful toolkit for thinking. This interactive note will show you what's possible. Let's begin.</p>
                    </div>
                </div>
                
                ${styledDivider}

                <!-- Section: Never Lose a Fleeting Thought -->
                <div style="margin-top: 3em; margin-bottom: 1.5em;">
                    <h2 style="font-family: var(--article-font-family); font-size: 1.8em; display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5em;">
                        <span style="background: var(--cat-color-2-bg); padding: 0.4rem; border-radius: 12px; display: flex; align-items: center; justify-content: center;"></span>
                        Never Lose a Fleeting Thought
                    </h2>
                    <p style="font-size: 1.1em; line-height: 1.8;">Your thoughts aren't flat, so your notes shouldn't be either. ::To Start new note click "+" Icon (top right)_r::. Now use simple shortcuts to bring them to life.</p>
                </div>

                <div class="nk-text-tile color-2" style="margin: 1.5em 0;">
                    <div class="nk-text-tile-content" style="padding: 0.5rem 1rem;">
                        <blockquote style="margin: 0; border-left: 4px solid var(--textile-border-2);">
                            You can type <kbd>&#61;&#61;double equals&#61;&#61;</kbd> for a <span class="highlight-1">quick highlight</span>, and <span class="text-blue"> even apply colored text</span> with <kbd>&#58;&#58;text color &#58;&#58;</kbd>. The most powerful feature? Weave a web of knowledge by creating a <span class="rendered-tag" data-tag="second-brain">[[SuperTag]]</span> when you type <kbd>&#91;&#91;double brackets&#93;&#93;</kbd>. <br/>
                            <i style="font-size: 0.95em; opacity: 0.8; display: block; margin-top: 0.5rem;">Use shortcuts to speed up your workflow e.g (Cmd+19) for highlight, find rest in K-Manual.</i>
                        </blockquote>
                    </div>
                </div>

                <ul style="list-style: none; padding-left: 1rem; border-left: 2px solid var(--border-color); margin: 1.5em 0;">
                    <li style="margin-bottom: 0.5em; display: flex; gap: 0.75rem;">
                        <span style="color: var(--primary-color);"></span>
                        <span>Start a line with <kbd>*</kbd> then <kbd>space</kbd> for bullet points. You can use '','','','','','','' as well.</span>
                    </li>
                </ul>

                <!-- Section: Build Lasting Knowledge -->
                <div style="margin-top: 4em; margin-bottom: 1.5em;">
                    <h2 style="font-family: var(--article-font-family); font-size: 1.8em; display: flex; align-items: center; gap: 0.75rem;">
                        <span style="background: var(--cat-color-3-bg); padding: 0.4rem; border-radius: 12px; display: flex; align-items: center; justify-content: center;"></span>
                        Build Lasting Knowledge
                    </h2>
                    <p style="font-size: 1.1em; line-height: 1.8;">Turn passive notes into an active learning system. Use our built-in tools to challenge your memory and solidify knowledge.</p>
                </div>

                <div class="nk-accordion" data-state="open">
                    <div class="nk-accordion-trigger">
                        <span class="nk-accordion-title"><b>How do I practice Active Recall? (Click me)</b></span>
                        <svg class="nk-accordion-chevron" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"></polyline></svg>
                    </div>
                    <div class="nk-accordion-content">
                        <p>Use these cards for Q&A (also creates front/back flashcard), or Just type <kbd>&#123;&#123;c1::cloze deletion&#125;&#125;</kbd> to instantly create a {{c1::Cloze Flashcard}} on key terms.</p>
                    </div>
                </div>

                <p style="margin-top: 1.5em;">You can also organize technical notes with clean code blocks.</p>
                <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: var(--border-radius-lg); border: 1px solid var(--border-color); margin: 1em 0;">
                    <pre style="margin: 0; background: transparent; border: none;"><code contenteditable="false" style="border-radius: var(--border-radius); font-family: 'Fira Code', monospace; font-size: 0.95em;">{\n  "idea": "Build a Second Brain",\n  "status": "in_progress",\n  "tags": ["productivity", "learning", "creativity"]\n}</code></pre>
                </div>

                <!-- Section: Create a Learning Engine -->
                <div style="margin-top: 4em; margin-bottom: 1.5em;">
                    <h2 style="font-family: var(--article-font-family); font-size: 1.8em; display: flex; align-items: center; gap: 0.75rem;">
                        <span style="background: var(--cat-color-1-bg); padding: 0.4rem; border-radius: 12px; display: flex; align-items: center; justify-content: center;"></span>
                        Create a Learning Engine
                    </h2>
                </div>

                <div class="nk-text-tile color-ghost-1" style="margin: 1.5em 0; border: 1px solid var(--primary-color); background: color-mix(in srgb, var(--primary-color) 5%, var(--bg-secondary));">
                    <div class="nk-text-tile-content" contenteditable="false" style="white-space: normal; padding: 1rem;">
                        <p style="margin: 0; line-height: 1.7;">Transform your notes into our powerful, <b>Automated Learning Engine (ALE)</b>. As you write, <i>instantly create flashcards from text using '<kbd>{{c1::cloze}}</kbd>' syntax, from Q&A accordions, or from full MCQ blocks</i>. Our <b> intelligent Spaced Repetition System (SRS) </b>then schedules the perfect time for you to review each card, ensuring you learn efficiently and remember what matterspermanently. <i>Stop just taking notes; start building lasting knowledge.</i></p>
                    </div>
                </div>

                <div class="nk-mcq-block" contenteditable="false">
                    <div class="nk-mcq-question" contenteditable="false">What's the best way to see all of NoteKash's features without leaving the keyboard?</div>
                    <div class="nk-mcq-options">
                        <div class="nk-mcq-option" data-is-correct="false"><div class="nk-mcq-option-text">Memorizing complex shortcuts</div></div>
                        <div class="nk-mcq-option" data-is-correct="true"><div class="nk-mcq-option-text">Pressing the '/' key for the Command Palette</div></div>
                        <div class="nk-mcq-option" data-is-correct="false"><div class="nk-mcq-option-text">Searching through the settings menu</div></div>
                    </div>
                    <div class="nk-mcq-explanation" contenteditable="false"><p><b>Correct!</b> The <b>Command Palette</b> is your superpower in writing. Pressing <b>'/'</b> gives you instant access to insert Tables, Charts, Timelines, Flashcards, MCQs, Lists, Code blocks, Pdfs, Audio, Decktiles and Other Cool Features. You can also Link content, Manage content and even define words on the fly.</p></div>
                </div>

                <!-- Section: See the Big Picture -->
                <div style="margin-top: 4em; margin-bottom: 1.5em;">
                    <h2 style="font-family: var(--article-font-family); font-size: 1.8em; display: flex; align-items: center; gap: 0.75rem;">
                        <span style="background: var(--cat-color-4-bg); padding: 0.4rem; border-radius: 12px; display: flex; align-items: center; justify-content: center;"></span>
                        See the Big Picture, Instantly
                    </h2>
                    <p style="font-size: 1.1em; line-height: 1.8;">As your Notes Grow, you need to see the Big Picture?. Our <b> Smart & Powerful, Automatic Learning Engine (ALE) </b> works in background to generate MindMaps and create VisualMaps from your Notes. Go to the <b>Visual Map</b> to see how your SuperTags connectyou can even add **Sticky Notes** to your canvas to capture new ideas. Or, view your highlighted snippets in the <b>Mind Map</b>.</p>
                </div>

                <div class="nk-timeline-block" contenteditable="false" style="margin: 2em 0;">
                    <div class="nk-timeline-entry"><div class="nk-timeline-content"><div class="nk-timeline-date">Phase 1</div><div class="nk-timeline-title">Capture Fleeting Ideas</div></div></div>
                    <div class="nk-timeline-entry"><div class="nk-timeline-content"><div class="nk-timeline-date">Phase 2</div><div class="nk-timeline-title">Form Connections & Insights</div></div></div>
                    <div class="nk-timeline-entry"><div class="nk-timeline-content"><div class="nk-timeline-date">Phase 3</div><div class="nk-timeline-title">Achieve Intuitive Clarity</div></div></div>
                </div>

                <div class="chart-container" contenteditable="false" style="background: var(--bg-secondary); padding: 1.5rem; border-radius: var(--border-radius-lg); border: 1px solid var(--border-color); box-shadow: var(--shadow-sm);">
                    <canvas data-chart-config='{"type":"bar","data":{"labels":["Clarity","Connections","Recall"],"datasets":[{"data":[20,55,85]}]},"options":{"indexAxis":"x"}}' width="600" height="300" style="max-width: 100%; height: auto;"></canvas>
                </div>

                <!-- Section: The Whiteboard -->
                <div style="margin-top: 4em; margin-bottom: 1.5em;">
                    <h2 style="font-family: var(--article-font-family); font-size: 1.8em; display: flex; align-items: center; gap: 0.75rem;">
                        <span style="background: var(--cat-color-6-bg); padding: 0.4rem; border-radius: 12px; display: flex; align-items: center; justify-content: center;"></span>
                        The Whiteboard
                    </h2>
                    <p style="font-size: 1.1em; line-height: 1.8;">Draw, sketch, annotate images, or create occlusion flashcards directly on a <b>freeform canvas</b>. Access it via the toolbar icon in Read Mode or type <kbd>/whiteboard</kbd> in the Command Palette. Perfect for visual learners and diagramming complex topics.</p>
                </div>

                <div class="nk-textile-deck" contenteditable="false" style="background: color-mix(in srgb, var(--primary-color) 3%, var(--bg-tertiary)); border: 2px dashed var(--primary-color); opacity: 0.9;">
                    <div class="deck-layout-toggle" title="Toggle Layout"><i class="fa-solid fa-table-cells"></i></div>
                    <div class="nk-text-tile color-2" data-color="2"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content">Freehand Drawing</div></div>
                    <div class="nk-text-tile color-5" data-color="5"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content">Annotate Images</div></div>
                    <div class="nk-text-tile color-8" data-color="8"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content">Flashcard Occlusion</div></div>
                    <div class="nk-text-tile color-3" data-color="3"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content">Mind-Mapping</div></div>
                </div>

                <!-- Section: Reclaim Your Focus & Time -->
                <div style="margin-top: 4em; margin-bottom: 1.5em;">
                    <h2 style="font-family: var(--article-font-family); font-size: 1.8em; display: flex; align-items: center; gap: 0.75rem;">
                        <span style="background: var(--cat-color-8-bg); padding: 0.4rem; border-radius: 12px; display: flex; align-items: center; justify-content: center;"></span>
                        Reclaim Your Focus & Time
                    </h2>
                    <p style="font-size: 1.1em; line-height: 1.8;">NoteKash is also your focus partner. Use the **Productivity Hub** (<kbd>Ctrl+;</kbd>) to manage tasks, start a Pomodoro timer, or enter the immersive, full-screen **Zen Mode** for ultimate deep focus.</p>
                </div>

                <div class="nk-textile-deck" contenteditable="false">
                    <div class="deck-layout-toggle" title="Toggle Layout"><i class="fa-solid fa-table-cells"></i></div>
                    <div class="nk-text-tile color-1" data-color="1"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content">Click to Hide</div></div>
                    <div class="nk-text-tile color-8" data-color="8"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content">Pomodoro Focus</div></div>
                    <div class="nk-text-tile color-6" data-color="6"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content">Zen Mode</div></div>
                    <div class="nk-text-tile color-4" data-color="4"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content">Task Manager</div></div>
                    <div class="nk-text-tile color-5" data-color="5"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content">Audio Notes</div></div>
                </div>

                <div class="nk-text-tile color-ghost-1" style="margin: 2em 0; display: flex; max-width: 100%; border: 1px solid var(--warning-color); background: color-mix(in srgb, var(--warning-color) 5%, var(--bg-secondary));">
                    <span class="nk-text-tile-icon" style="font-size: 1.5em; padding: 1rem;"></span>
                    <div class="nk-text-tile-content" contenteditable="false" style="white-space: normal; padding: 1rem 1rem 1rem 0;">
                        <b style="color: var(--primary-color);">Pro-Tip:</b> Super Search (<kbd>Ctrl+K</kbd>) is your command center. Use it to instantly <b>Create</b> notes on the fly using Syntax of <i>"note:[category]: Title >> Content"</i>, Create instant tasks using <i>"task:[category]: Task Name #priority" </i>, or Start pomodoro on Tasks or <b>Navigate</b> anywhere with commands like <i>%stats, %quiz, %new etc.</i> to track your learning streaks!
                    </div>
                </div>
                
                <p style="font-size: 1.1em; line-height: 1.8;">You can also Turn your notes into a captivating presentation == with <b>Stage Mode</b> ==g, reveal ideas one by one ==with <b>Cinematic Reveal</b>==c , or set the perfect mood from ==dozens of beautiful <b>Ambiance Themes</b>==. </p>
                <div class="nk-text-tile color-8" style="margin: 1.5em 0; width: fit-content; max-width: 100%;">
                    <div class="nk-text-tile-content" style="padding: 0.5rem 1rem; font-style: italic;">
                        This is just a single note. Imagine the power of these features working in concert across your entire library. Explore the full tutorial to discover even more powerful tools.
                    </div>
                </div>

                ${styledDivider}

                <!-- Section: Unlock Your AI Co-Pilot -->
                <div style="margin-top: 4em; margin-bottom: 1.5em;">
                    <h2 style="font-family: var(--article-font-family); font-size: 1.8em; display: flex; align-items: center; gap: 0.75rem;">
                        <span style="background: var(--cat-color-10-bg); padding: 0.4rem; border-radius: 12px; display: flex; align-items: center; justify-content: center;"></span>
                        Unlock Your AI Co-Pilot
                    </h2>
                    <p style="font-size: 1.1em; line-height: 1.8;">NoteKash AI isn't just a AI chatbot; with more than <b> 25+ AI Tools </b>, it's a <b> suite of powerful specialized tools </b> integrated directly into your workflow. Go beyond simple Q&A and let your AI co-pilot actively help you learn, create, think and beautify your notes. To call use "/kashcommands" to get job done faster.</p>
                </div>

                <div class="nk-textile-deck" contenteditable="false" style="border-style: solid; background: transparent;">
                    <div class="deck-layout-toggle" title="Toggle Layout"><i class="fa-solid fa-table-cells"></i></div>
                    <div class="nk-text-tile color-1"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content"><b>KashAsk</b></div></div>
                    <div class="nk-text-tile color-2"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content"><b>KashCurate</b></div></div>
                    <div class="nk-text-tile color-8"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content"><b>KashSummary</b></div></div>
                    <div class="nk-text-tile color-3"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content"><b>KashFlash</b></div></div>
                    <div class="nk-text-tile color-7"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content"><b>KashKeywords</b></div></div>
                    <div class="nk-text-tile color-6"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content"><b>KashExplain</b></div></div>
                    <div class="nk-text-tile color-4"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content"><b>KashMnemonic</b></div></div>
                    <div class="nk-text-tile color-5"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content"><b>KashScript</b></div></div>
                    <div class="nk-text-tile color-9"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content"><b>KashHighlight</b></div></div>
                    <div class="nk-text-tile color-3"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content"><b>KashTags</b></div></div>
                </div>

                <div class="nk-text-tile color-ghost-1" style="margin: 2em 0; display: flex; max-width: 100%; border: 1px dotted var(--primary-color);">
                    <span class="nk-text-tile-icon" style="font-size: 1.5em; padding: 1rem;"></span>
                    <div class="nk-text-tile-content" contenteditable="false" style="white-space: normal; padding: 1rem 1rem 1rem 0;">
                        <b>Pro-Tip:</b> Apart from using "/kashask" in in command palette of Write mode, You can also use "kashask:" command on Global search.
                    </div>
                </div>

                <p style="text-align: center; font-size: 1.3em; line-height: 1.5; margin: 2em 0;"><span class="power-quote-gradient"><b><i>Stop just writing notes. Start building knowledge with an AI partner that understands your learning.</i></b></span></p>
                
                ${styledDivider}

                <!-- Section: The NoteKash Difference -->
                <div style="margin-top: 4em; margin-bottom: 2em;">
                    <h2 style="font-family: var(--article-font-family); font-size: 1.8em; display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1em;">
                        <span style="background: var(--cat-color-0-bg); padding: 0.4rem; border-radius: 12px; display: flex; align-items: center; justify-content: center;"></span>
                        The NoteKash Difference
                    </h2>
                    <p style="font-size: 1.1em; line-height: 1.8;">Built for thinkers, learners, and creators who value speed, ownership, and a beautifully integrated workflow. This app is truely powerful that can replace your many apps for "Todo", "Pomodoro", "Mindmapping", "Flashcards", "Visualmapping" with power of Note Taking.</p>
                </div>

                <div id="article-content" style="margin: 2em 0; overflow-x: auto;">
                    <table style="width: 100%; border-collapse: separate; border-spacing: 0; border-radius: var(--border-radius-lg); overflow: hidden; border: 1px solid var(--border-color); box-shadow: var(--shadow-sm);">
                        <thead>
                            <tr style="background-color: var(--bg-tertiary);">
                                <th style="padding: 16px; text-align: left; font-size: 1.1em; border-bottom: 2px solid var(--border-color);">Feature</th>
                                <th style="padding: 16px; text-align: center; font-size: 1.1em; background-color: color-mix(in srgb, var(--danger-color) 8%, var(--bg-tertiary)); border-bottom: 2px solid var(--border-color);">Most Note Apps</th>
                                <th style="padding: 16px; text-align: center; font-size: 1.1em; background-color: color-mix(in srgb, var(--success-color) 8%, var(--bg-tertiary)); border-bottom: 2px solid var(--border-color); color: var(--primary-color);">NoteKash</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="border-top: 1px solid var(--border-color);">
                                <td style="padding: 14px 16px; font-weight: 500;">Data Ownership</td>
                                <td style="padding: 14px 16px; text-align: center; opacity: 0.8;"> Cloud-Only</td>
                                <td style="padding: 14px 16px; text-align: center; font-weight: 600; color: var(--primary-color);"> User Owned</td>
                            </tr>
                            <tr style="background-color: color-mix(in srgb, var(--border-color) 5%, transparent);">
                                <td style="padding: 14px 16px; font-weight: 500;">Pricing Model</td>
                                <td style="padding: 14px 16px; text-align: center;"><span class="nk-stat-badge" style="background: var(--bg-secondary); color: var(--text-secondary);"> Costly Monthly Subscriptions</span></td>
                                <td style="padding: 14px 16px; text-align: center;"><span class="nk-stat-badge" style="background: var(--bg-secondary); border-color: var(--primary-color); color: var(--primary-color); font-weight: 600;"> Lowest Price with One Time Cost</span></td>
                            </tr>
                            <tr>
                                <td style="padding: 14px 16px; font-weight: 500;">Offline Access</td>
                                <td style="padding: 14px 16px; text-align: center; color: var(--danger-color);"> Limited / None</td>
                                <td style="padding: 14px 16px; text-align: center; color: var(--success-color); font-weight: 600;"> Full Functionality</td>
                            </tr>
                            <tr style="background-color: color-mix(in srgb, var(--border-color) 5%, transparent);">
                                <td style="padding: 14px 16px; font-weight: 500;">Integrated Learning</td>
                                <td style="padding: 14px 16px; text-align: center; color: var(--danger-color);"> Separate Apps Needed</td>
                                <td style="padding: 14px 16px; text-align: center; color: var(--success-color); font-weight: 600;"> Built-in SRS Flashcards</td>
                            </tr>
                            <tr>
                                <td style="padding: 14px 16px; font-weight: 500;">Visual Thinking</td>
                                <td style="padding: 14px 16px; text-align: center; color: var(--danger-color);"> Basic Linking</td>
                                <td style="padding: 14px 16px; text-align: center; color: var(--success-color); font-weight: 600;"> Mind & Visual Maps</td>
                            </tr>
                            <tr style="background-color: color-mix(in srgb, var(--border-color) 5%, transparent);">
                                <td style="padding: 14px 16px; font-weight: 500;">Focus Tools</td>
                                <td style="padding: 14px 16px; text-align: center; color: var(--danger-color);"> Minimal</td>
                                <td style="padding: 14px 16px; text-align: center; color: var(--success-color); font-weight: 600;"> Pomodoro, Zen Mode, Todo</td>
                            </tr>
                            <tr>
                                <td style="padding: 14px 16px; font-weight: 500;">Note AI</td>
                                <td style="padding: 14px 16px; text-align: center; color: var(--danger-color);"> Limited & Costly</td>
                                <td style="padding: 14px 16px; text-align: center; color: var(--success-color); font-weight: 600;"> Unlimited & Powerful</td>
                            </tr>
                            <tr style="background-color: color-mix(in srgb, var(--border-color) 5%, transparent);">
                                <td style="padding: 14px 16px; font-weight: 500;">Speed & Performance</td>
                                <td style="padding: 14px 16px; text-align: center;"> Can be slow</td>
                                <td style="padding: 14px 16px; text-align: center; font-weight: 600; color: var(--primary-color);"> Blazing Fast</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p style="text-align: center; font-size: 1.3em; line-height: 1.5; margin-top: 3em; margin-bottom: 2em;"><span class="power-quote-gradient"><b><i>${randomDevMessage}</i></b></span></p>
                `;
            }
        };


        const App = {
            Updater: {
                async nukeCacheAndReload() {
                    const overlay = document.createElement('div');
                    overlay.style.position = 'fixed';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.width = '100vw';
                    overlay.style.height = '100vh';
                    overlay.style.background = 'rgba(0,0,0,0.85)';
                    overlay.style.zIndex = '9999';
                    overlay.style.display = 'flex';
                    overlay.style.flexDirection = 'column';
                    overlay.style.alignItems = 'center';
                    overlay.style.justifyContent = 'center';
                    overlay.style.color = 'white';
                    overlay.innerHTML = '<div style="font-size: 2rem; margin-bottom: 1rem;"></div><h2>Updating NoteKash...</h2><p>The app will reload in a moment.</p>';
                    document.body.appendChild(overlay);

                    // 1. Unregister Service Workers
                    if ('serviceWorker' in navigator) {
                        const registrations = await navigator.serviceWorker.getRegistrations();
                        for (const registration of registrations) {
                            await registration.unregister();
                        }
                    }

                    // 2. Clear File Caches (Crucial: This removes the old index.html)
                    if ('caches' in window) {
                        const keys = await caches.keys();
                        await Promise.all(keys.map(key => caches.delete(key)));
                    }

                    // 3. Force Reload from Server (ignoring cache)
                    setTimeout(() => {
                        window.location.reload(true);
                    }, 1000);
                }
            },



            // ==========================================================================
            // NEW: ASCENSION & LICENSE MODULE
            // ==========================================================================
            license: {
                state: {
                    tier: 'Spark', // Default free tier
                    userName: '',
                    isPremium: false,
                    expiry: null,
                    token: null
                },

                isPremium() {
                    // ADDED: Explicit check for the developer key for robustness.
                    if (this.state.token === 'testingnow') return true;

                    if (!this.state.isPremium || !this.state.expiry) return false;
                    // Check if the expiry date is in the future
                    return new Date(this.state.expiry) > new Date();
                },


                async activate() {
                    const nameInput = document.getElementById('license-name-input');
                    const statusInput = document.getElementById('license-status-input');
                    const keyInput = document.getElementById('license-key-input');
                    const name = nameInput.value.trim();
                    const status = statusInput.value.trim();
                    const key = keyInput.value.trim();

                    if (!name || !key) {
                        App.ui.showToast('Please enter both your name and license key.', 'warning');
                        return;
                    }

                    // Save status/bio locally regardless of activation success
                    await App.settings.set('userBio', status);

                    const validationUrl = '/.netlify/functions/validate';

                    try {
                        const response = await fetch(validationUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name, key })
                        });
                        const data = await response.json();
                        if (!response.ok) throw new Error(data.error || 'Activation failed.');

                        const token = data.token;
                        const payload = JSON.parse(atob(token.split('.')[1]));

                        this.state.token = token;
                        this.state.isPremium = payload.isPremium;
                        this.state.tier = payload.tier;
                        this.state.userName = payload.userName;
                        this.state.expiry = payload.expiry;

                        await App.settings.set('licenseToken', token);
                        App.ui.showToast(`Welcome, ${payload.tier} ${payload.userName}! Premium activated.`, 'success');
                        this.updateUIAfterStateChange();
                        App.ui.closeModal();

                    } catch (error) {
                        App.ui.showToast(`Activation Error: ${error.message}`, 'error');
                        console.error('Activation Error:', error);
                    }
                },

                revalidate() {
                    if (this.isPremium()) {
                        const expiryDate = new Date(this.state.expiry).toLocaleDateString();
                        App.ui.showToast(`License for ${this.state.userName} is valid until ${expiryDate}.`, 'success');
                    } else {
                        App.ui.showToast('No active license found to re-validate.', 'warning');
                    }
                },

                delete() {
                    App.ui.showConfirmationModal({
                        title: 'Delete License?',
                        message: 'Are you sure you want to delete your license and revert to the Spark (free) tier? All premium features will be locked.',
                        confirmText: 'Delete',
                        onConfirm: async () => {
                            await App.settings.set('licenseToken', null);
                            // Do NOT delete userBio, they might want to keep it.
                            this.state = { tier: 'Spark', userName: '', isPremium: false, expiry: null, token: null };
                            this.updateUIAfterStateChange();
                            App.ui.closeModal();
                            App.ui.showToast('License removed. You are now on the Spark tier.', 'info');
                        }
                    });
                },

                async loadState() {

                    const savedToken = App.settings.get('licenseToken');
                    // NEW: Intercept the developer key before validation
                    if (savedToken === 'testingnow') {
                        this.state.token = 'testingnow';
                        this.state.isPremium = true;
                        this.state.tier = 'Diamond';
                        this.state.userName = 'Developer';
                        // Set an expiry date far in the future for testing purposes
                        const futureDate = new Date();
                        futureDate.setFullYear(futureDate.getFullYear() + 10);
                        this.state.expiry = futureDate.toISOString();

                        // Bypass the rest of the validation logic
                        this.updateUIAfterStateChange();
                        return;
                    }

                    if (savedToken) {
                        try {
                            const payload = JSON.parse(atob(savedToken.split('.')[1]));
                            if (new Date(payload.expiry) > new Date()) {
                                this.state.token = savedToken;
                                this.state.isPremium = payload.isPremium;
                                this.state.tier = payload.tier;
                                this.state.userName = payload.userName;
                                this.state.expiry = payload.expiry;
                            } else {
                                App.ui.showToast('Your premium license has expired.', 'warning');
                                await App.settings.set('licenseToken', null);
                            }
                        } catch (e) {
                            console.error("Error parsing license token:", e);
                            await App.settings.set('licenseToken', null);
                        }
                    }
                    this.updateUIAfterStateChange();
                },

                updateUIAfterStateChange() {
                    const badgeInfo = { Spark: { icon: '', name: 'Spark', color: '#B0BEC5' }, Bronze: { icon: '', name: 'Bronze', color: '#CD7F32' }, Silver: { icon: '', name: 'Silver', color: '#C0C0C0' }, Gold: { icon: '', name: 'Gold', color: '#FFD700' }, Diamond: { icon: '', name: 'Diamond', color: '#B9F2FF' } };
                    const currentTier = badgeInfo[this.state.tier] || badgeInfo.Spark;
                    const isPremium = this.isPremium();

                    const profileBadge = document.getElementById('profile-badge');
                    if (profileBadge) {
                        // Replace the simple text content with our new rich HTML badge
                        profileBadge.innerHTML = App.util.getTierBadgeHTML(this.state.tier, 36);
                        profileBadge.title = `Your Current Tier: ${currentTier.name}`;
                    }

                    document.querySelectorAll('.premium-feature-locked').forEach(el => {
                        if (isPremium) {
                            el.classList.remove('premium-feature-locked');
                            if (el.dataset.originalTitle) {
                                el.title = el.dataset.originalTitle;
                            }
                        } else {
                            el.classList.add('premium-feature-locked');
                            if (!el.dataset.originalTitle) {
                                el.dataset.originalTitle = el.title;
                            }
                            el.title = 'This is a Premium feature. Upgrade to unlock.';
                        }
                    });
                    App.ui.updateHeaderState();
                    const activeViewId = App.router.getActiveView();
                    if (activeViewId === 'flashcard') App.ui.filterAndRenderFlashcards();
                    if (activeViewId === 'library') App.ui.filterAndRenderArticles();
                },
            },
            // ==========================================================================
            // 3.1. CONFIGURATION
            // ==========================================================================
            config: {
                categories: ["General", "Geography", "History", "Society", "Polity", "Security", "Science", "Ecology", "Economy", "Essay", "Ethics", "Opinion", "Misc"],
                highlightClasses: ['highlight-1', 'highlight-2', 'highlight-3', 'highlight-4', 'highlight-5', 'highlight-6', 'highlight-7'],
                textClasses: ['text-red', 'text-green', 'text-blue', 'text-magenta'],
                colorCycle: ['highlight-1', 'highlight-2', 'highlight-3', 'highlight-4', 'highlight-5', 'highlight-6', 'highlight-7', 'text-red', 'text-green', 'text-blue', 'text-magenta'],
                sparkTierLimit: 365,
                sm2: {
                    ratings: ['Again', 'Hard', 'Hold', 'Good', 'Easy'],
                    colors: { 'Again': 'red', 'Hard': 'orange', 'Hold': 'purple', 'Good': 'skyblue', 'Easy': 'green' },
                    leechThreshold: 5, // Mark a card as a leech after 5 lapses
                    baseIntervals: { 'Again': 600000, 'Hard': 3600000, 'Hold': 21600000, 'Good': 43200000, 'Easy': 172800000 },
                    maxReviewCount: 7
                },

                quiz: {
                    cardCount: 10,
                    scores: { 'Easy': 1.0, 'Good': 0.9, 'Hold': 0.7, 'Hard': 0.5, 'Again': 0.2 }
                },
                fonts: [
                    // 11 Offline System Fonts (Free)
                    { name: 'Arial', value: 'Arial, Helvetica, sans-serif' },
                    { name: 'Cambria', value: 'Cambria, Cochin, Georgia, Times, "Times New Roman", serif' },
                    { name: 'Courier New', value: "'Courier New', Courier, monospace" },
                    { name: 'Garamond', value: 'Garamond, serif' },
                    { name: 'Georgia', value: 'Georgia, serif' },
                    { name: 'Helvetica', value: 'Helvetica, Arial, sans-serif' },
                    { name: 'Monaco', value: 'Monaco, "Lucida Console", monospace' },
                    { name: 'Palatino', value: 'Palatino, "Palatino Linotype", serif' },
                    { name: 'Sans-Serif', value: 'sans-serif' },
                    { name: 'Times New Roman', value: "'Times New Roman', Times, serif" },
                    { name: 'Verdana', value: 'Verdana, Geneva, sans-serif' },
                    // 38 Google Web Fonts (Premium)
                    { name: 'Allura', value: 'Allura, cursive' },
                    { name: 'Arvo', value: 'Arvo, serif' },
                    { name: 'Bitter', value: 'Bitter, serif' },
                    { name: 'Cabin', value: 'Cabin, sans-serif' },
                    { name: 'Cabin Sketch', value: "'Cabin Sketch', cursive" },
                    { name: 'Changa One', value: "'Changa One', cursive" },
                    { name: 'Cinzel', value: 'Cinzel, serif' },
                    { name: 'Crimson Text', value: "'Crimson Text', serif'" },
                    { name: 'Dancing Script', value: "'Dancing Script', cursive" },
                    { name: 'Exo 2', value: "'Exo 2', sans-serif" },
                    { name: 'Fira Code', value: "'Fira Code', monospace" },
                    { name: 'Great Vibes', value: "'Great Vibes', cursive" },
                    { name: 'Inconsolata', value: 'Inconsolata, monospace' },
                    { name: 'Jersey 20', value: "'Jersey 20', sans-serif" },
                    { name: 'Josefin Sans', value: "'Josefin Sans', sans-serif" },
                    { name: 'Kaushan Script', value: "'Kaushan Script', cursive" },
                    { name: 'Lato', value: 'Lato, sans-serif' },
                    { name: 'Libre Baskerville', value: "'Libre Baskerville', serif" },
                    { name: 'Lobster', value: 'Lobster, cursive' },
                    { name: 'Merriweather', value: 'Merriweather, serif' },
                    { name: 'Metal Mania', value: "'Metal Mania', cursive" },
                    { name: 'Montserrat', value: 'Montserrat, sans-serif' },
                    { name: 'Pacifico', value: 'Pacifico, cursive' },
                    { name: 'Parisienne', value: 'Parisienne, cursive' },
                    { name: 'Patrick Hand', value: "'Patrick Hand', cursive" },
                    { name: 'Playfair Display', value: "'Playfair Display', serif" },
                    { name: 'Protest Revolution', value: "'Protest Revolution', sans-serif" },
                    { name: 'Righteous', value: 'Righteous, cursive' },
                    { name: 'Roboto', value: 'Roboto, sans-serif' },
                    { name: 'Rochester', value: 'Rochester, cursive' },
                    { name: 'Salsa', value: 'Salsa, cursive' },
                    { name: 'Satisfy', value: 'Satisfy, cursive' },
                    { name: 'Sofia', value: 'Sofia, cursive' },
                    { name: 'Source Code Pro', value: "'Source Code Pro', monospace" },
                    { name: 'Special Elite', value: "'Special Elite', cursive" },
                    { name: 'Syne Mono', value: "'Syne Mono', monospace" },
                    { name: 'Ubuntu', value: 'Ubuntu, sans-serif' },
                    { name: 'Vollkorn', value: 'Vollkorn, serif' },
                    { name: 'Zilla Slab', value: "'Zilla Slab', serif" },
                ],
                bulletCycle: ['default', 'bullet-square', 'bullet-triangle', 'bullet-empty-circle', 'bullet-hyphen'],
                themes: [{ id: 'light', name: 'Light' }, { id: 'dark', name: 'Dark' }, { id: 'sepia', name: 'Sepia' }, { id: 'custom', name: 'Create Theme' }],
                sanitizer: {
                    allowedTags: ['P', 'BR', 'B', 'I', 'U', 'STRONG', 'EM', 'SPAN', 'DIV', 'UL', 'OL', 'LI', 'A', 'BLOCKQUOTE', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HR', 'TABLE', 'THEAD', 'TBODY', 'TR', 'TH', 'TD', 'DEL', 'IMG', 'SUB', 'SUP', 'CODE', 'PRE', 'BUTTON', 'SVG', 'POLYLINE', 'MARK', 'CANVAS', 'AUDIO', 'INPUT', 'IFRAME'],
                    allowedAttributes: {
                        '*': ['class', 'id', 'title', 'style', 'data-wb-id', 'data-wb-state', 'data-wb-state-id', 'data-caption-theme', 'data-caption-align', 'data-original-width', 'data-original-height', 'data-collapsible-icon', 'data-collapsed'],
                        'a': ['href', 'target', 'data-link-type', 'data-link-id', 'data-article-id'],
                        'span': ['data-tag-text', 'contenteditable', 'data-placeholder', 'data-tag', 'data-pdf-id', 'data-original-name', 'data-wb-id'],
                        'mark': [],
                        'canvas': ['data-chart-config', 'width', 'height', 'style'],
                        'div': ['contenteditable', 'data-placeholder', 'data-state', 'data-checked', 'data-is-correct', 'data-answered', 'data-color', 'data-caption-theme', 'data-caption-align', 'data-wb-state', 'data-wb-id', 'data-wb-state-id', 'data-role', 'data-provider', 'data-embed-id', 'data-ratio', 'data-plyr-provider', 'data-plyr-embed-id'],
                        'img': ['src', 'alt', 'width', 'height', 'style', 'data-original-width', 'data-original-height', 'onerror'],
                        'td': ['colspan', 'rowspan'],
                        'th': ['colspan', 'rowspan'],
                        'button': ['aria-expanded', 'aria-controls', 'class', 'aria-label'],
                        'svg': ['viewBox', 'class', 'width', 'height', 'fill', 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'],
                        'polyline': ['points'],
                        'audio': ['src', 'controls', 'preload'],
                        'input': ['type', 'value', 'min', 'max', 'step', 'class', 'style', 'title'],
                        'iframe': ['src', 'width', 'height', 'frameborder', 'allow', 'allowfullscreen', 'referrerpolicy', 'scrolling', 'style', 'class']
                    }
                },
                image: {
                    maxWidth: 1024,
                    jpegQuality: 0.95,
                    maxUploadSize: 30 * 1024 * 1024 // 30MB
                },
                stickyNoteColors: [
                    'default', 'crimson', 'tangerine', 'sunflower', 'lime', 'forest', 'azure',
                    'indigo', 'amethyst', 'lavender', 'fuchsia', 'blush', 'terracotta',
                    'teal', 'slate', 'olive'
                ],

            },

            // ==========================================================================
            // 3.2. STATE
            // ==========================================================================
            state: {
                articles: [],
                isInitialLoadComplete: false,
                isDataFullyLoaded: false, // New flag for split mode readiness
                isHydrated: false,
                hydrationPromise: null,
                deletedRecords: [],
                activeArticleId: null,
                activeReaderTheme: 'default',
                currentMode: 'read',
                isFullscreen: false,
                directoryHandle: null,
                currentBulletIndex: 0,
                lastClickTime: 0,
                chartInstances: {},
                studySession: { isActive: false, isQuizMode: false, cards: [], currentIndex: 0, isRating: false },
                settings: {},
                libraryRender: {
                    isRendering: false,
                    currentIndex: 0,
                    filteredArticles: [],
                    searchTimeout: null,
                    lastSavedHash: '', // OPTIMIZATION: Track last saved hash to prevent redundant saves
                },
                flashcardRender: {
                    searchResults: [],
                    selectedIndex: -1
                },
                selectedImageContainer: null,
                savedRange: null,
                pwa: { installPromptEvent: null },
                dropboxToken: null,
                dropboxUser: null,
                isDropboxReady: false,
                isSyncing: false,
                isArticleDirty: false,
                isPristineNewArticle: false,
                lastHeartKeyPressTime: 0,
                focusSession: {
                    isActive: false,
                    articles: [],
                    currentIndex: 0,
                    isStageMode: false,
                    currentSlideIndex: 0,
                    scrollStops: [],
                    isCinematicActive: false,
                    teleprompterActive: false,
                    teleprompterSize: 30,
                    teleprompterFontSize: 1.1,
                },
                autosaveInterval: null,
                // New states from ProtoTags
                tags: {},
                visualMapState: { snapshots: [], stickyNotes: {} },
                mindMapState: { snapshots: [] },
                dataCache: { isBuilt: false, mindMapSnippets: {} },
                scrollToTagId: null,
                suggestionTimeout: null,
            },

            // ==========================================================================
            // 3.3. SETTINGS MANAGEMENT
            // ==========================================================================
            settings: {
                defaults: {
                    lastStorageMode: null,
                    hasSetViewPreference: false,
                    mobileViewEnabled: false,
                    userCategories: null,
                    categoryLayout: 'list',
                    categoryHighlightsVisible: true,
                    libraryTitle: 'My Library',
                    categoryNameStyle: 'full',
                    focusModeFontSize: '1.1rem',
                    theme: 'sepia',
                    readerTheme: 'default',
                    uiOpacity: 1.0,
                    fontFamily: 'Georgia, serif',
                    fontSize: '1.15rem',
                    lineHeight: '1.7',
                    backgroundImage: null,
                    customThemeBase: 'light',
                    flashcardSortBy: 'sm2',
                    tagSortBy: 'alpha',
                    colorCycleIndex: 0,
                    showTagsOnTiles: true,
                    categoryRenames: {},
                    enableDropboxSync: false,
                    dropboxToken: null,
                    dropboxClientId: null,
                    lastSyncTimestamp: null,
                    pomodoroWork: 25,
                    pomodoroBreak: 5,
                    studySessionSize: 25,
                    studyCardFontSize: '1.6rem',
                    jpegQuality: 0.9,
                    imageFormat: 'jpeg', // 'jpeg' for compression, 'png' for reliability
                    ocrThreshold: 128,
                    audioBitrate: 32000,
                    pdfTextViewFontSize: '1.1rem',
                    pdfTextViewTheme: 'default',
                    intervalModifier: 1.0,
                },
                async load() {
                    const savedSettings = await App.fs.read('settings.json');
                    App.state.settings = { ...this.defaults, ...savedSettings };

                    if (!App.state.settings.userCategories || (Array.isArray(App.state.settings.userCategories) && typeof App.state.settings.userCategories[0] === 'string')) {
                        console.log("Initializing or migrating category format to objects...");
                        const categoryNames = App.state.settings.userCategories || App.config.categories; // Use saved names or default
                        const migratedCategories = categoryNames.map((name, index) => ({
                            name: name,
                            colorIndex: index % App.util.getCategoryColorCount(),
                            isDefault: name === 'General' // <-- This is the surgical addition
                        }));

                        await this.set('userCategories', migratedCategories);
                    }
                    App.state.dropboxToken = App.state.settings.dropboxToken;
                },
                async save() {
                    await App.fs.write('settings.json', App.state.settings);
                },
                get(key) {
                    return App.state.settings[key];
                },
                async set(key, value) {
                    App.state.settings[key] = value;
                    await this.save();
                }
            },

            // ==========================================================================
            // 3.4. INITIALIZATION
            // ==========================================================================
            async _startFileSystemSession() {
                console.log("File system permission granted. Starting session...");

                const pendingRenamePlan = await App.fs.read('_category_rename_plan.json');
                if (pendingRenamePlan) {
                    App.ui.showToast('Resuming interrupted category rename...', { type: 'warning', duration: 0 });
                    await App.events.categories.executeRenamePlan(pendingRenamePlan);
                }

                const operationPlan = await App.fs.read('_category_operation_plan.json');
                if (operationPlan) {
                    if (operationPlan.status === 'cancelled') {
                        // If the operation was cancelled, clean up the plan file and do nothing.
                        console.log("Cleaning up a previously cancelled category operation.");
                        await App.fs.write('_category_operation_plan.json', null);
                    } else {
                        // If the plan is pending (or legacy without a status), execute it.
                        setTimeout(() => App.events.categories.executeOperationPlan(operationPlan), 500);
                    }
                }
                await App.settings.load(); // Load settings FIRST

                const userCategories = App.settings.get('userCategories');
                if (!userCategories || (Array.isArray(userCategories) && (userCategories.length === 0 || typeof userCategories[0] === 'string' || userCategories[0].displayName === undefined))) {
                    console.log("Performing one-time migration for user categories to add displayName...");

                    const categoryNames = Array.isArray(userCategories) && userCategories.length > 0 && typeof userCategories[0] === 'string'
                        ? userCategories
                        : (userCategories || App.config.categories).map(c => c.name || c);

                    const migratedCategories = categoryNames.map((name, index) => ({
                        name: name,
                        displayName: name,
                        colorIndex: userCategories?.find?.(c => c.name === name)?.colorIndex ?? index % App.util.getCategoryColorCount(),
                        isDefault: name === 'General'
                    }));

                    await App.settings.set('userCategories', migratedCategories); // <<< THE FIX IS HERE
                    console.log("Category migration complete.");
                }

                App.ui.applyTheme(App.settings.get('theme'), true); // Apply theme
                await App.loadInitialData(); // Load all other data
                // Skip default navigation if in split iframe mode - let handleSplitMode navigate instead
                if (!App.isSplitIframeMode) {
                    App.router.navigateTo('library');
                }
            },

            // --- OFFLINE HANDLING MODULE ---
            offline: {
                isOffline: false,
                init() {
                    // 1. Inject CSS for the offline indicator (Minimal fix)
                    const style = document.createElement('style');
                    style.textContent = `
                        #offline-indicator {
                            display: none; 
                            color: var(--danger-color, #ff6b6b);
                            margin-right: 4px; /* Adjust spacing to match other icons */
                        }
                        #offline-indicator.is-visible {
                            display: flex; /* btn-icon uses flex */
                            animation: none; /* No pulse */
                        }
                        #offline-indicator svg {
                            width: 20px;
                            height: 20px;
                        }
                    `;
                    document.head.appendChild(style);

                    // 2. Create the indicator element using standard button structure
                    this.el = document.createElement('button');
                    this.el.className = 'btn-icon';
                    this.el.id = 'offline-indicator';
                    this.el.setAttribute('aria-label', 'Offline Mode');
                    this.el.title = "Offline Mode - Cloud features paused";

                    // SVG Icon: Cloud Off (Feather Icons)
                    this.el.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path>
                            <line x1="1" y1="1" x2="23" y2="23"></line>
                        </svg>
                    `;

                    // 3. Inject into Header (before Settings button)
                    const tryInject = () => {
                        const headerActions = document.querySelector('.header-fixed-actions');
                        const settingsBtn = document.getElementById('settings-btn');
                        if (headerActions && settingsBtn) {
                            headerActions.insertBefore(this.el, settingsBtn);
                        } else {
                            if (document.readyState === 'loading') {
                                document.addEventListener('DOMContentLoaded', tryInject);
                            } else {
                                // Fallback
                                this.el.style.position = 'fixed';
                                this.el.style.bottom = '20px';
                                this.el.style.left = '20px';
                                this.el.style.zIndex = '1000';
                                document.body.appendChild(this.el);
                            }
                        }
                    };
                    tryInject();

                    // 4. Add click handler
                    this.el.addEventListener('click', () => {
                        App.ui.showToast('You are Offline. Cloud features are paused.', { type: 'warning', duration: 3000 });
                    });

                    // 5. Status Check Logic
                    const checkStatus = () => {
                        this.isOffline = !navigator.onLine;
                        document.body.classList.toggle('is-offline', this.isOffline);

                        if (this.isOffline) {
                            this.el.classList.add('is-visible');
                            console.log("App is OFFLINE. Disabling external libraries.");
                        } else {
                            this.el.classList.remove('is-visible');
                        }
                    };

                    window.addEventListener('online', () => {
                        checkStatus();
                        App.ui.showToast('You are back online!', { type: 'success' });
                    });
                    window.addEventListener('offline', () => {
                        checkStatus();
                        App.ui.showToast('You are offline. Cloud features disabled.', { type: 'warning' });
                    });

                    // Initial Check
                    checkStatus();
                },
                check(featureName = 'This feature') {
                    if (!navigator.onLine) {
                        App.ui.showToast(`${featureName} requires internet.`, { type: 'warning' });
                        return false;
                    }
                    return true;
                },
                safeChart(ctx, config) {
                    if (typeof Chart !== 'undefined') {
                        try {
                            return new Chart(ctx, config);
                        } catch (e) {
                            console.error("Chart init error:", e);
                            return null;
                        }
                    } else if (ctx) {
                        const c = ctx;
                        c.save();
                        c.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-tertiary') || '#f0f0f0';
                        c.fillRect(0, 0, c.canvas.width, c.canvas.height);
                        c.fillStyle = getComputedStyle(document.body).getPropertyValue('--text-secondary') || '#666';
                        c.font = '14px sans-serif';
                        c.textAlign = 'center';
                        c.textBaseline = 'middle';
                        c.fillText('Chart offline', c.canvas.width / 2, c.canvas.height / 2);
                        c.restore();
                    }
                    return null;
                },
                safeFuse(list, options) {
                    if (typeof Fuse !== 'undefined') {
                        return new window.Fuse(list, options);
                    }
                    return {
                        search: (query) => {
                            if (!query) return [];
                            const lowerQ = String(query).toLowerCase();
                            const keys = options.keys || [];
                            return list.map((item, index) => {
                                let match = false;
                                if (keys.length > 0) {
                                    match = keys.some(k => {
                                        const val = item[k];
                                        return val && String(val).toLowerCase().includes(lowerQ);
                                    });
                                } else {
                                    match = String(item).toLowerCase().includes(lowerQ);
                                }
                                if (match) return { item: item, refIndex: index, score: 0.1 };
                                return null;
                            }).filter(i => i !== null);
                        }
                    };
                }
            },

            async init() {
                this.offline.init();

                if ('launchQueue' in window && 'files' in LaunchParams.prototype) {
                    window.launchQueue.setConsumer(async (launchParams) => {
                        if (!launchParams.files || launchParams.files.length === 0) {
                            return;
                        }
                        const fileHandles = launchParams.files;
                        const files = await Promise.all(fileHandles.map(handle => handle.getFile()));
                        App.ui.showToast(`Importing ${files.length} shared note(s)...`, { type: 'info' });
                        App.services.backup.handleFileImport(files);
                    });
                }

                if (window.pdfjsLib) {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;
                }
                this.pwa.init();
                this.events.setupGlobalListeners();

                try {
                    await App.settings.load();
                } catch (e) {
                    console.error("Critical: Failed to load settings on initial boot.", e);
                    this.ui.applyTheme('light', true);
                }

                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('code')) {
                    await App.dropbox.handleRedirect(); // <-- This will now work
                }

                const mobileImportInput = document.getElementById('mobile-import-input');
                if (mobileImportInput) mobileImportInput.addEventListener('change', (e) => App.storage.handleMobileImport(e));

                try {
                    const savedHandle = await this.indexedDB.getHandle('directory');

                    if (savedHandle) {
                        App.state.directoryHandle = savedHandle;
                        App.state.storageMode = 'fileSystem';

                        const permissionStatus = await savedHandle.queryPermission({ mode: 'readwrite' });

                        if (permissionStatus === 'granted') {
                            const tempToken = App.state.dropboxToken; // <-- FIX: Capture token before FS load
                            await this._startFileSystemSession();
                            if (tempToken) {
                                App.state.dropboxToken = tempToken;
                                await App.settings.set('dropboxToken', tempToken); // <-- FIX: Persist token to FS
                            }
                        } else if (!App.isSplitIframeMode) {
                            this.ui.applyTheme(App.settings.get('theme') || 'sepia', true);
                            this.router.navigateTo('welcome', { permissionState: permissionStatus });
                        }
                    } else {
                        this.ui.applyTheme(App.settings.get('theme'), true);

                        if (App.settings.get('lastStorageMode') === 'browser') {
                            App.state.storageMode = 'browser';
                            await this.loadInitialData();
                            // Skip default navigation if in split iframe mode
                            if (!App.isSplitIframeMode) {
                                App.router.navigateTo('library');
                            }
                        } else if (!App.isSplitIframeMode) {
                            this.router.navigateTo('welcome', { permissionState: 'none' });
                        }
                    }
                } catch (error) {
                    console.error("Initialization error:", error);
                    this.ui.applyTheme(App.settings.get('theme') || 'sepia', true);
                    if (!App.isSplitIframeMode) {
                        this.router.navigateTo('welcome', { permissionState: 'none' });
                    }
                }
            },

            async loadInitialData() {

                console.log(`Loading data in '${App.state.storageMode}' mode.`);

                if (App.state.storageMode === 'fileSystem' && App.state.directoryHandle) {
                    const indexFile = await App.fs.read('_index.json');
                    if (indexFile && Array.isArray(indexFile)) {
                        App.state.articles = indexFile;
                    } else {
                        await this.storage.load();
                        await this.storage.generateIndexFromState();
                    }
                } else {
                    const articlesFromDB = await App.browserStore.getAllArticles();
                    App.state.articles = articlesFromDB;
                    App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                }

                App.state.activeReaderTheme = App.settings.get('readerTheme') || 'default';

                if (!this.settings.get('hasSetViewPreference')) {
                    if (window.innerWidth <= 768) await this.settings.set('mobileViewEnabled', true);
                    await this.settings.set('hasSetViewPreference', true);
                }


                this.ui.applyMobileView();
                this.ui.applyFontSettings();
                document.documentElement.style.setProperty('--ui-opacity', App.settings.get('uiOpacity'));
                const blurValue = parseFloat(App.settings.get('uiOpacity')) === 0 ? '0px' : '8px';
                document.documentElement.style.setProperty('--blur-intensity', blurValue);

                this.proactiveBackgroundLoader();
                App.state.isInitialLoadComplete = true;
            },

            async proactiveBackgroundLoader() {
                if (App.state.isHydrated) return;

                console.log("Starting proactive background load...");
                await App.license.loadState();
                let hydrationOccurred = false;

                if (App.state.directoryHandle && App.state.articles.length > 0 && App.state.articles[0].content === undefined) {
                    console.log("Hydrating articles with full content in the background...");
                    const { articles: fullArticles } = await this.storage.getAll();
                    App.state.articles = fullArticles;
                    App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                    hydrationOccurred = true; // Mark that a data update happened.
                    console.log("Article hydration complete.");
                }

                App.state.isHydrated = true;

                await this.hub.loadData();
                await this.quiz.loadStats();
                App.state.tags = await App.fs.read('tags.json') || {};
                App.state.visualMapState = await App.fs.read('visual-map-state.json') || { snapshots: [], stickyNotes: {} };
                App.state.mindMapState = await App.fs.read('mind-map-state.json') || { snapshots: [] };

                App.globalSearch.buildIndex();

                if (hydrationOccurred && App.router.getActiveView() === 'library') {
                    console.log("Hydration complete, re-rendering library view to ensure consistency.");
                    App.ui.filterAndRenderArticles();
                }

                App.ui.updateHeaderState();
                await this.dropbox.init();
                if (this.dropbox.isReady() && this.settings.get('enableDropboxSync')) {
                    this.dropbox.syncChanges(true);
                }

                await App.util.reconcileCategories();

                requestIdleCallback(() => App.contentTools.buildDataCache());

                // Signal that all data (articles, hub, stats) is ready for split mode
                App.state.isDataFullyLoaded = true;
                console.log("Proactive background load complete. Data fully loaded.");
            },

            // ==========================================================================
            // 3.5. DATABASE (INDEXEDDB for Handle Persistence)
            // ==========================================================================
            indexedDB: {
                db: null, dbName: 'NoteKashFSDatabase_v2', storeName: 'fileSystemHandles',
                async openDB() {
                    return new Promise((resolve, reject) => {
                        if (this.db) return resolve(this.db);
                        const request = indexedDB.open(this.dbName, 1);
                        request.onerror = () => reject("IndexedDB error: " + request.error);
                        request.onsuccess = (e) => { this.db = e.target.result; resolve(this.db); };
                        request.onupgradeneeded = (e) => e.target.result.createObjectStore(this.storeName);
                    });
                },
                async setHandle(key, value) {
                    const db = await this.openDB();
                    const tx = db.transaction(this.storeName, 'readwrite');
                    tx.objectStore(this.storeName).put(value, key);
                    return new Promise(resolve => tx.oncomplete = resolve);
                },
                async getHandle(key) {
                    const db = await this.openDB();
                    return new Promise((resolve, reject) => {
                        const req = db.transaction(this.storeName, 'readonly').objectStore(this.storeName).get(key);
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => reject(req.error);
                    });
                }
            },


            // ==========================================================================
            // 3.5. BROWSER STORAGE ABSTRACTION (NEW & ROBUST)
            // ==========================================================================
            browserStore: {
                _dbPromise: null,
                _dbName: 'NoteKash_BrowserStore_v1',
                _version: 1,

                _getDB() {
                    // This robust pattern ensures indexedDB.open is only called ONCE.
                    // All subsequent calls will await the same initial connection promise, preventing deadlocks.
                    if (!this._dbPromise) {
                        this._dbPromise = new Promise((resolve, reject) => {
                            const request = indexedDB.open(this._dbName, this._version);

                            request.onerror = (event) => {
                                console.error("IndexedDB connection error:", event.target.error);
                                reject("IndexedDB connection failed. Your browser might be in private mode or have storage disabled.");
                            };

                            request.onsuccess = (event) => {
                                resolve(event.target.result);
                            };

                            request.onupgradeneeded = (event) => {
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains('articles')) {
                                    db.createObjectStore('articles', { keyPath: 'id' });
                                }
                                if (!db.objectStoreNames.contains('files')) {
                                    db.createObjectStore('files', { keyPath: 'fileName' });
                                }
                            };
                        });
                    }
                    return this._dbPromise;
                },

                async _getStore(storeName, mode) {
                    const db = await this._getDB();
                    return db.transaction(storeName, mode).objectStore(storeName);
                },

                // --- Article-specific methods ---
                async getArticle(id) {
                    const store = await this._getStore('articles', 'readonly');
                    return new Promise((resolve) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => resolve(null);
                    });
                },

                async getAllArticles() {
                    const store = await this._getStore('articles', 'readonly');
                    return new Promise((resolve) => {
                        const request = store.getAll();
                        request.onsuccess = () => resolve(request.result || []);
                        request.onerror = () => resolve([]);
                    });
                },

                async setArticle(article) {
                    const store = await this._getStore('articles', 'readwrite');
                    return new Promise((resolve, reject) => {
                        const request = store.put(article);
                        request.onsuccess = resolve;
                        request.onerror = (event) => {
                            console.error("Error setting article in IndexedDB:", event.target.error);
                            reject(event.target.error);
                        };
                    });
                },

                async deleteArticle(articleId) {
                    const store = await this._getStore('articles', 'readwrite');
                    return new Promise((resolve) => {
                        store.delete(articleId).onsuccess = resolve;
                    });
                },
                async getFileMetadata(fileName) {
                    const store = await this._getStore('files', 'readonly');
                    return new Promise((resolve) => {
                        const request = store.get(fileName);
                        request.onsuccess = () => resolve(request.result ? { lastModified: request.result.lastModified } : null);
                        request.onerror = () => resolve(null);
                    });
                },
                // --- File-specific methods (for settings.json, etc.) ---
                async getFile(fileName) {
                    const store = await this._getStore('files', 'readonly');
                    return new Promise((resolve) => {
                        const request = store.get(fileName);
                        request.onsuccess = () => resolve(request.result ? request.result.data : null);
                        request.onerror = () => resolve(null);
                    });
                },

                async setFile(fileName, data) {
                    const store = await this._getStore('files', 'readwrite');
                    const wrapper = {
                        fileName: fileName,
                        data: data,
                        lastModified: new Date().toISOString()
                    };
                    return new Promise((resolve, reject) => {
                        const request = store.put(wrapper);
                        request.onsuccess = resolve;
                        request.onerror = (event) => {
                            console.error("Error setting file in IndexedDB:", event.target.error);
                            reject(event.target.error);
                        };
                    });
                },
            },

            // ==========================================================================
            // 3.6. FILE SYSTEM (FS) MODULE
            // ==========================================================================

            fs: {
                async read(fileName) {
                    if (App.state.directoryHandle) {
                        try {
                            const fileHandle = await App.state.directoryHandle.getFileHandle(fileName);
                            const file = await fileHandle.getFile();
                            const text = await file.text();
                            if (!text) return null;
                            return JSON.parse(text);
                        } catch (err) {
                            if (err.name === 'NotFoundError') return null;
                            console.error(`Error reading or parsing ${fileName}:`, err);
                            App.ui.showToast(`Could not load ${fileName}. It may be corrupted.`, 'error');
                            return null;
                        }
                    } else {
                        return App.browserStore.getFile(fileName);
                    }
                },
                async write(fileName, data) {
                    if (App.state.directoryHandle) {
                        try {
                            const fileHandle = await App.state.directoryHandle.getFileHandle(fileName, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(JSON.stringify(data, null, 2));
                            await writable.close();
                        } catch (err) {
                            console.error(`Error writing to ${fileName}:`, err);
                            App.ui.showToast(`Error saving data to ${fileName}.`, 'error');
                        }
                    } else {
                        await App.browserStore.setFile(fileName, data);
                    }
                },
                async getFileMetadata(fileName) {
                    if (App.state.storageMode === 'fileSystem' && App.state.directoryHandle) {
                        try {
                            const fileHandle = await App.state.directoryHandle.getFileHandle(fileName);
                            const file = await fileHandle.getFile();
                            return { lastModified: new Date(file.lastModified).toISOString() };
                        } catch (err) {
                            if (err.name === 'NotFoundError') return null; // File doesn't exist
                            console.error(`Error getting metadata for ${fileName}:`, err);
                            return null;
                        }
                    } else if (App.state.storageMode === 'browser') {
                        return await App.browserStore.getFileMetadata(fileName);
                    }
                    return null;
                },
            },


            // ==========================================================================
            // 3.7. STORAGE ENGINE (File System + Tombstones)
            // ==========================================================================
            storage: {
                DELETED_RECORDS_FILENAME: '_deleted.json',

                async load() {
                    // This function is now ONLY for File System mode. Browser mode is handled in loadInitialData.
                    if (!App.state.directoryHandle) return;

                    const { articles, failedCount, total } = await this.getAll();
                    App.state.articles = articles;
                    App.state.deletedRecords = await this.getDeletedRecords();
                    App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));

                    if (failedCount > 0) App.ui.showToast(`${failedCount} corrupt file(s) skipped.`, { type: 'warning' });
                    if (total > 0) App.ui.showToast(`${articles.length} articles loaded.`, { type: 'success' });
                },

                async createArticle(data) {
                    // Refined for Sync: Respect existing ID and metadata if provided (e.g. from Dropbox)
                    const newArticle = {
                        id: data.id || ('art_' + crypto.randomUUID()),
                        title: data.title || 'Untitled Article',
                        content: data.content || '<p><br></p>',
                        category: data.category || 'General',
                        readCount: (typeof data.readCount === 'number') ? data.readCount : 0,
                        readHistory: Array.isArray(data.readHistory) ? data.readHistory : [],
                        tags: Array.isArray(data.tags) ? data.tags : [],
                        flashcards: (typeof data.flashcards === 'object') ? data.flashcards : {},
                        createdAt: data.createdAt || new Date().toISOString(),
                        updatedAt: data.updatedAt || new Date().toISOString()
                    };

                    try {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = newArticle.content;
                        newArticle.wordCount = (tempDiv.textContent || "").trim().split(/\s+/).filter(Boolean).length;

                        if (App.state.directoryHandle) {
                            await App.fs.write(`${newArticle.id}.json`, newArticle); // Directly use App.fs
                            await this.generateIndexFromState();
                        } else {
                            await App.browserStore.setArticle(newArticle); // Use new browser store
                        }

                        App.state.articles.unshift(newArticle);
                        App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                        return newArticle;
                    } catch (err) { console.error("Failed to create article:", err); App.ui.showToast("Error saving new article.", { type: 'error' }); return null; }
                },

                async updateArticle(id, updates) {
                    const articleIndex = App.state.articles.findIndex(a => a.id === id);
                    if (articleIndex === -1) return { success: false, error: 'Article not found in state.' };

                    // Refined for Sync: Use provided updatedAt if available, otherwise generate new one.
                    const updatedArticle = {
                        ...App.state.articles[articleIndex],
                        ...updates,
                        updatedAt: updates.updatedAt || new Date().toISOString()
                    };

                    try {
                        if (updatedArticle.content) {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = updatedArticle.content;
                            updatedArticle.wordCount = (tempDiv.textContent || "").trim().split(/\s+/).filter(Boolean).length;
                        }

                        if (App.state.directoryHandle) {
                            await App.fs.write(`${updatedArticle.id}.json`, updatedArticle); // Directly use App.fs
                            await this.generateIndexFromState();
                        } else {
                            await App.browserStore.setArticle(updatedArticle); // Use new browser store
                        }

                        App.state.articles[articleIndex] = updatedArticle;
                        App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                        return { success: true, article: updatedArticle };
                    } catch (err) {
                        console.error("Failed to update article:", err);
                        App.ui.showToast(`Save failed. Could not update the article.`, { type: 'error' });
                        return { success: false, error: err.message };
                    }
                },

                async deleteArticle(id) {
                    const articleInState = this.getArticle(id);
                    if (!articleInState) return;
                    App.state.articles = App.state.articles.filter(a => a.id !== id);
                    try {
                        if (App.state.directoryHandle) {
                            await this.recordDeletion(id);
                            await App.state.directoryHandle.removeEntry(`${id}.json`).catch(e => { if (e.name !== 'NotFoundError') throw e; });
                            await this.generateIndexFromState();
                        } else {
                            await App.browserStore.deleteArticle(id); // Use new browser store
                        }
                    } catch (err) { console.error("Failed to delete article:", err); App.ui.showToast("Error: Could not delete the article.", { type: 'error' }); }
                },

                async handleMobileImport(event) {
                    const files = event.target.files;
                    if (!files.length) return;
                    const toast = App.ui.showToast(`Importing 0 / ${files.length} notes...`, { duration: 0 });
                    let importedCount = 0;
                    for (const file of files) {
                        if (file.name.endsWith('.json')) {
                            try {
                                const article = JSON.parse(await file.text());
                                if (article.id && article.title) {
                                    await App.browserStore.setArticle(article);
                                    importedCount++;
                                    App.ui.updateToast(toast, `Importing ${importedCount} / ${files.length} notes...`);
                                }
                            } catch (e) { console.warn(`Skipping invalid file: ${file.name}`); }
                        }
                    }
                    App.ui.hideToast(toast);
                    App.ui.showToast(`${importedCount} notes imported!`, 'success');

                    // Set the correct state and trigger the main loading sequence for consistency.
                    App.state.isInitialLoadComplete = false;
                    App.state.isHydrated = false; // <-- THE FIX: Reset the hydration flag
                    App.state.storageMode = 'browser';
                    App.state.directoryHandle = null;

                    await App.loadInitialData();
                    App.router.navigateTo('library');
                },

                // --- The functions below are now ONLY used for File System mode ---
                async verifyPermission(handle) {
                    if (await handle.queryPermission({ mode: 'readwrite' }) === 'granted') return true;
                    if (await handle.requestPermission({ mode: 'readwrite' }) === 'granted') return true;
                    return false;
                },
                async getAll() {
                    if (!App.state.directoryHandle) return { articles: [], failedCount: 0, total: 0 };
                    const entries = [];
                    const dataFiles = ['settings.json', 'todos.json', 'pomodoro.json', 'quiz_stats.json', 'tags.json', 'visual-map-state.json', 'mind-map-state.json'];
                    for await (const entry of App.state.directoryHandle.values()) {
                        if (entry.kind === 'file' && entry.name.endsWith('.json') && !entry.name.startsWith('_') && !dataFiles.includes(entry.name)) {
                            entries.push(entry);
                        }
                    }
                    const total = entries.length;
                    if (total === 0) return { articles: [], failedCount: 0, total: 0 };
                    const toastId = App.ui.showToast(`Loading 0 / ${total} articles...`, { type: 'info', duration: 120000 });
                    const articles = []; let failedCount = 0; let count = 0;
                    for (const entry of entries) {
                        try {
                            const file = await entry.getFile(); const content = await file.text(); const article = JSON.parse(content);
                            if (typeof article.id === 'string' && typeof article.title === 'string' && typeof article.content === 'string' && typeof article.category === 'string' && !isNaN(new Date(article.updatedAt))) {
                                articles.push(article);
                            } else { throw new Error('Invalid NoteKash article structure'); }
                        } catch (err) { console.error(`Skipping invalid or corrupt file ${entry.name}:`, err.message); App.ui.showToast(`Skipped corrupt file: ${entry.name}`, { type: 'warning' }); failedCount++; }
                        count++; App.ui.updateToast(toastId, `Loading ${count} / ${total} articles...`);
                    }
                    App.ui.hideToast(toastId); return { articles, failedCount, total };
                },
                async generateIndexFromState() {
                    if (!App.state.directoryHandle) return;
                    const tempDiv = document.createElement('div');
                    const indexData = App.state.articles.map(article => {
                        let wordCount = article.wordCount;
                        if (typeof article.content === 'string') {
                            tempDiv.innerHTML = article.content;
                            wordCount = (tempDiv.textContent || "").trim().split(/\s+/).filter(Boolean).length;
                        }
                        return { id: article.id, title: article.title, category: article.category, tags: article.tags || [], readCount: article.readCount || 0, createdAt: article.createdAt, updatedAt: article.updatedAt, wordCount: wordCount || 0 };
                    });
                    await App.fs.write('_index.json', indexData);
                    console.log(`Regenerated _index.json from state with ${indexData.length} articles.`);
                },
                async getDeletedRecords() { return await App.fs.read(this.DELETED_RECORDS_FILENAME) || []; },
                async saveDeletedRecords(records) { await App.fs.write(this.DELETED_RECORDS_FILENAME, records); },
                async recordDeletion(id) {
                    const now = new Date().toISOString(); const records = await this.getDeletedRecords();
                    if (!records.some(r => r.id === id)) { records.push({ id, deletedAt: now }); }
                    await this.saveDeletedRecords(records); App.state.deletedRecords = records;
                },
                async _getAllArticlesFromCurrentStore() {
                    if (App.state.storageMode === 'fileSystem' && App.state.directoryHandle) {
                        const { articles } = await this.getAll();
                        return articles;
                    } else if (App.state.storageMode === 'browser') {
                        return await App.browserStore.getAllArticles();
                    }
                    return [];
                },
                getArticle(id) { return App.state.articles.find(a => a.id === id); },
            },

            // ==========================================================================
            // 3.8. DROPBOX SYNC ENGINE
            // ==========================================================================
            dropbox: {
                SINGLETON_DATA_FILES: ['settings.json', 'todos.json', 'pomodoro.json', 'quiz_stats.json', 'tags.json', 'visual-map-state.json', 'mind-map-state.json'],
                async init() {
                    if (App.state.dropboxToken) {
                        await this.validateToken();
                    }
                },

                async connect() {
                    const clientId = App.settings.get('dropboxClientId');
                    if (!clientId) { App.ui.showToast("Please set your Dropbox Client ID first.", { type: 'error' }); return; }
                    const codeVerifier = this.generateCodeVerifier();
                    localStorage.setItem('dropbox-code-verifier', codeVerifier); // <-- FIX #2
                    localStorage.setItem('dropbox-client-id', clientId); // <-- FIX #4: Backup Client ID
                    const codeChallenge = await this.generateCodeChallenge(codeVerifier);
                    const authUrl = new URL('https://www.dropbox.com/oauth2/authorize');

                    const dynamicRedirectUri = window.location.origin + window.location.pathname;

                    authUrl.searchParams.set('client_id', clientId);
                    authUrl.searchParams.set('response_type', 'code');
                    authUrl.searchParams.set('redirect_uri', dynamicRedirectUri);
                    authUrl.searchParams.set('code_challenge_method', 'S256');
                    authUrl.searchParams.set('code_challenge', codeChallenge);
                    window.location.href = authUrl.toString();
                },

                async handleRedirect() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const authCode = urlParams.get('code');
                    const codeVerifier = localStorage.getItem('dropbox-code-verifier'); // <-- FIX #3a

                    //Retrieve Client ID from settings OR LocalStorage backup
                    let clientId = App.settings.get('dropboxClientId');
                    if (!clientId) {
                        clientId = localStorage.getItem('dropbox-client-id');
                        console.log("Retrieved Dropbox Client ID from LocalStorage backup.");
                    }

                    if (!authCode || !codeVerifier || !clientId) {
                        App.ui.showToast("Dropbox connection failed: Missing auth data.", { type: 'error' });
                        console.error('Auth Data Missing:', {
                            hasCode: !!authCode,
                            hasVerifier: !!codeVerifier,
                            hasClientId: !!clientId
                        });
                        return;
                    }
                    try {
                        const dynamicRedirectUri = window.location.origin + window.location.pathname;

                        const response = await fetch('https://api.dropboxapi.com/oauth2/token', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                            body: new URLSearchParams({
                                code: authCode,
                                grant_type: 'authorization_code',
                                redirect_uri: dynamicRedirectUri,
                                code_verifier: codeVerifier,
                                client_id: clientId,
                            })
                        });
                        if (!response.ok) throw new Error('Failed to get token');
                        const data = await response.json();

                        // Ensure we update settings (and memory) with the new token
                        await App.settings.set('dropboxToken', data.access_token);
                        App.state.dropboxToken = data.access_token;

                        await this.validateToken();
                    } catch (error) {
                        console.error("Dropbox Auth Error:", error);
                        App.ui.showToast("Dropbox connection failed.", { type: 'error' });
                    } finally {
                        window.history.replaceState({}, document.title, window.location.pathname);
                        localStorage.removeItem('dropbox-code-verifier'); // <-- FIX #3b
                        localStorage.removeItem('dropbox-client-id'); // <-- FIX #4: Cleanup

                        App.ui.applyTheme(App.settings.get('theme'), true);
                        App.ui.showStorageModal();
                    }
                },

                async validateToken() {
                    try {
                        const user = await this.apiCall('users/get_current_account', null, { silent: true });
                        App.state.dropboxUser = user;
                        App.state.isDropboxReady = true;
                        if (App.state.dropboxToken) App.ui.showToast(`Connected as ${user.name.display_name}.`, { type: 'success' });
                    } catch (error) {
                        console.error("Token validation failed:", error);
                        // Already disconnected by apiCall if 401, but just in case
                        if (App.state.dropboxToken) this.disconnect(true);
                    }
                },
                async disconnect(silent = false) {
                    await App.settings.set('dropboxToken', null);
                    App.state.dropboxToken = null;
                    App.state.dropboxUser = null;
                    App.state.isDropboxReady = false;
                    if (!silent) App.ui.showToast("Disconnected from Dropbox.");
                    if (document.getElementById('settings-modal-content')) App.ui.showSettingsModal(); // <-- FIX: Immediate UI Refresh
                },

                async apiCall(endpoint, body, options = {}) {
                    if (!App.state.dropboxToken) {
                        return Promise.reject(new Error("Not connected to Dropbox."));
                    }

                    const isUpload = endpoint.includes('files/upload');
                    const isDownload = endpoint.includes('files/download');

                    const apiUrl = (isUpload || isDownload)
                        ? `https://content.dropboxapi.com/2/${endpoint}`
                        : `https://api.dropboxapi.com/2/${endpoint}`;

                    const headers = { 'Authorization': `Bearer ${App.state.dropboxToken}`, ...options.headers };
                    const fetchOptions = { method: 'POST', headers };

                    if (isUpload) {
                        // Uploads (like articles) send data in the body
                        headers['Content-Type'] = 'application/octet-stream';
                        fetchOptions.body = body;
                    } else if (isDownload) {

                    } else if (body) {
                        // Standard API calls (like list_folder) send JSON
                        headers['Content-Type'] = 'application/json';
                        fetchOptions.body = JSON.stringify(body);
                    }


                    try {
                        const response = await fetch(apiUrl, fetchOptions);

                        if (!response.ok) {
                            if (response.status === 401) {
                                this.disconnect(options.silent);
                                if (!options.silent) App.ui.showToast("Dropbox connection expired. Please reconnect.", { type: 'error' });
                            }

                            if (response.status === 429) {
                                const retryAfter = response.headers.get('Retry-After') || 60;
                                console.warn(`Dropbox rate limit hit. Retry after ${retryAfter}s.`);
                                throw new Error(`Rate limit hit. Pausing sync for ${retryAfter}s.`);
                            }

                            let errorMessage = `API Error: ${response.status} ${response.statusText}`;
                            try {
                                const errorJson = await response.json();
                                if (errorJson.error_summary) {
                                    errorMessage = errorJson.error_summary; // e.g., "path/not_found/..."
                                } else if (errorJson.error && errorJson.error.reason) {
                                    errorMessage = JSON.stringify(errorJson.error.reason); // Deeper error object
                                } else if (errorJson.error) {
                                    errorMessage = errorJson.error;
                                }
                            } catch (e) {
                            }

                            if (errorMessage.includes('insufficient_space')) {
                                App.ui.showToast("Your Dropbox is full. Sync failed.", { type: 'error' });
                            }

                            throw new Error(errorMessage);
                        }

                        if (options.isDownload) {
                            const content = await response.text();
                            return { content };
                        }
                        if (response.headers.get('content-length') === '0' || response.status === 204) {
                            return null;
                        }

                        return response.json();

                    } catch (e) {
                        if (e instanceof TypeError) {
                            console.warn("Network error during Dropbox API call:", e);
                        }
                        throw e;
                    }
                },

                async syncChanges(isSilent = false) {
                    if (App.state.isSyncing) {
                        if (!isSilent) App.ui.showToast("Sync already in progress.", { type: 'warning' });
                        return;
                    }
                    if (!this.isReady()) {
                        console.warn("Dropbox sync called but not ready. Aborting.");
                        return;
                    }

                    App.state.isSyncing = true;
                    if (document.getElementById('settings-modal-content')) App.ui.showSettingsModal();

                    let syncToastId = null;
                    if (!isSilent) {
                        syncToastId = App.ui.showToast("Syncing...", { duration: 0, type: 'info' });
                    }

                    // Stats for Summary Toast
                    const stats = { uploaded: 0, downloaded: 0, deleted: 0, errors: 0 };

                    // Throttling Helper (Simple concurrency limiter)
                    const processInBatches = async (items, batchSize, taskFn) => {
                        const results = [];
                        for (let i = 0; i < items.length; i += batchSize) {
                            const batch = items.slice(i, i + batchSize);
                            const batchResults = await Promise.allSettled(batch.map(item => taskFn(item)));
                            results.push(...batchResults);
                        }
                        return results;
                    };

                    try {
                        // STEP 1: GET LOCAL DATA (Unchanged for Articles)
                        const localArticles = await App.storage._getAllArticlesFromCurrentStore();
                        const localDeletedRecords = await App.storage.getDeletedRecords();

                        const localArticlesMap = new Map(localArticles.map(a => [a.id, a]));
                        const localDeletedMap = new Map(localDeletedRecords.map(r => [r.id, r]));

                        // STEP 2: GET REMOTE DATA & SEGREGATE
                        const remoteFiles = await this.listAllFiles();
                        let remoteDeletedRecords = [];
                        const remoteArticlesMap = new Map();
                        const remoteSingletonsMap = new Map();

                        for (const file of remoteFiles) {
                            const name = file.name;
                            if (name === App.storage.DELETED_RECORDS_FILENAME) {
                                const { content } = await this.apiCall('files/download', null, { headers: { 'Dropbox-API-Arg': JSON.stringify({ path: file.path_lower }) }, isDownload: true });
                                remoteDeletedRecords = content ? JSON.parse(content) : [];
                            }
                            else if (this.SINGLETON_DATA_FILES.includes(name)) {
                                remoteSingletonsMap.set(name, file);
                            }
                            else if (name.endsWith('.json') && !name.startsWith('_') && name.startsWith('art_')) {
                                remoteArticlesMap.set(name.replace('.json', ''), file);
                            }
                        }

                        const remoteDeletedMap = new Map(remoteDeletedRecords.map(r => [r.id, r]));

                        // STEP 3: MERGE DELETION RECORDS 
                        const masterDeletedMap = new Map(localDeletedMap);
                        remoteDeletedMap.forEach((remoteRecord, id) => {
                            const localRecord = masterDeletedMap.get(id);
                            if (!localRecord || new Date(remoteRecord.deletedAt) > new Date(localRecord.deletedAt)) {
                                masterDeletedMap.set(id, remoteRecord);
                            }
                        });

                        // STEP 4: COMPARE & BUILD SYNC LISTS
                        const toUploadArticles = [], toDownloadArticles = [], toDeleteLocal = [], toDeleteRemotePaths = [];
                        const toUploadSingletons = [], toDownloadSingletons = [];
                        const TOLERANCE_MS = 2000; // Dropbox timestamp tolerance

                        // 4a. Compare Articles
                        const allArticleIds = new Set([...localArticlesMap.keys(), ...remoteArticlesMap.keys()]);
                        for (const id of allArticleIds) {
                            if (masterDeletedMap.has(id)) continue;
                            const local = localArticlesMap.get(id);
                            const remote = remoteArticlesMap.get(id);

                            if (local && !remote) { toUploadArticles.push(local); }
                            else if (!local && remote) { toDownloadArticles.push(remote); }
                            else if (local && remote) {
                                const localDate = new Date(local.updatedAt);
                                const remoteDate = new Date(remote.server_modified);
                                if (Math.abs(localDate.getTime() - remoteDate.getTime()) > TOLERANCE_MS) {
                                    if (localDate > remoteDate) { toUploadArticles.push(local); }
                                    else { toDownloadArticles.push(remote); }
                                }
                            }
                        }

                        // 4b. Compare Deletion Lists 
                        masterDeletedMap.forEach(record => {
                            if (localArticlesMap.has(record.id)) toDeleteLocal.push(record.id);
                            if (remoteArticlesMap.has(record.id)) toDeleteRemotePaths.push({ path: `/${record.id}.json` });
                        });

                        // 4c. Compare Singleton Data Files
                        for (const fileName of this.SINGLETON_DATA_FILES) {
                            const localMeta = await App.fs.getFileMetadata(fileName);
                            const remoteMeta = remoteSingletonsMap.get(fileName);

                            if (localMeta && !remoteMeta) {
                                const localData = await App.fs.read(fileName);
                                if (localData) toUploadSingletons.push({ name: fileName, data: localData });
                            }
                            else if (!localMeta && remoteMeta) {
                                toDownloadSingletons.push(remoteMeta);
                            }
                            else if (localMeta && remoteMeta) {
                                const localDate = new Date(localMeta.lastModified);
                                const remoteDate = new Date(remoteMeta.server_modified);

                                if (Math.abs(localDate.getTime() - remoteDate.getTime()) > TOLERANCE_MS) {
                                    if (localDate > remoteDate) {
                                        const localData = await App.fs.read(fileName);
                                        if (localData) toUploadSingletons.push({ name: fileName, data: localData });
                                    } else {
                                        toDownloadSingletons.push(remoteMeta);
                                    }
                                }
                            }
                        }

                        // STEP 5: EXECUTE SYNC OPERATIONS (THROTTLED)
                        const BATCH_SIZE = 3; // Max parallel requests

                        // 5a. Uploads (Articles + Singletons)
                        const allUploads = [...toUploadArticles.map(a => ({ type: 'article', data: a })), ...toUploadSingletons.map(s => ({ type: 'singleton', ...s }))];
                        await processInBatches(allUploads, BATCH_SIZE, async (item) => {
                            try {
                                const path = item.type === 'article' ? `/${item.data.id}.json` : `/${item.name}`;
                                const body = item.type === 'article' ? JSON.stringify(item.data) : JSON.stringify(item.data);
                                await this.apiCall('files/upload', body, { headers: { 'Dropbox-API-Arg': JSON.stringify({ path, mode: 'overwrite' }) } });
                                stats.uploaded++;
                            } catch (e) {
                                console.error(`Failed upload: ${item.name || item.data.id}`, e);
                                stats.errors++;
                            }
                        });


                        // 5b. Downloads (Articles + Singletons)
                        const allDownloads = [...toDownloadArticles.map(m => ({ type: 'article', meta: m })), ...toDownloadSingletons.map(m => ({ type: 'singleton', meta: m }))];
                        await processInBatches(allDownloads, BATCH_SIZE, async (item) => {
                            try {
                                const { content } = await this.downloadFile(item.meta);
                                if (content) {
                                    const data = JSON.parse(content);
                                    if (item.type === 'article') {
                                        if (localArticlesMap.has(data.id)) await App.storage.updateArticle(data.id, data);
                                        else await App.storage.createArticle(data);
                                    } else {
                                        await App.fs.write(item.meta.name, data);
                                    }
                                    stats.downloaded++;
                                }
                            } catch (e) {
                                console.error(`Failed download: ${item.meta.name}`, e);
                                stats.errors++;
                            }
                        });


                        // 5e. Remote Deletions 
                        if (toDeleteRemotePaths.length > 0) {
                            await this.apiCall('files/delete_batch', { entries: toDeleteRemotePaths });
                            stats.deleted += toDeleteRemotePaths.length;
                        }

                        // 5f. Local Deletions 
                        for (const id of toDeleteLocal) {
                            await App.storage.deleteArticle(id);
                            stats.deleted++;
                        }

                        // 5g. Sync Deleted Records 
                        const finalDeletedRecords = Array.from(masterDeletedMap.values());
                        if (localDeletedMap.size !== finalDeletedRecords.length || remoteDeletedMap.size !== finalDeletedRecords.length) {
                            await App.storage.saveDeletedRecords(finalDeletedRecords);
                            await this.apiCall('files/upload', JSON.stringify(finalDeletedRecords), { headers: { 'Dropbox-API-Arg': JSON.stringify({ path: `/${App.storage.DELETED_RECORDS_FILENAME}`, mode: 'overwrite' }) } });
                        }

                        // STEP 6: FINALIZE & RELOAD UI
                        const hasChanges = stats.uploaded + stats.downloaded + stats.deleted > 0;

                        if (hasChanges) {
                            // Re-sort and Refresh
                            if (toUploadArticles.length + toDownloadArticles.length > 0) {
                                App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                                await App.util.reconcileCategories();
                                const activeView = App.router.getActiveView();
                                if (['library', 'flashcard', 'stats-dashboard', 'visual-map', 'mindmap', 'category'].includes(activeView)) {
                                    App.router.navigateTo(activeView, App.router.getActiveViewData(), true); // Fix #1 used here
                                }
                            }
                        }

                        // CONSOLIDATED FEEDBACK
                        if (!isSilent) {
                            if (stats.errors > 0) {
                                App.ui.showToast(`Sync Complete: ${stats.uploaded} ${stats.downloaded}. ${stats.errors} failed.`, { type: 'warning', duration: 5000 });
                            } else if (hasChanges) {
                                App.ui.showToast(`Sync Complete: ${stats.uploaded} ${stats.downloaded}.`, { type: 'success' });
                            } else {
                                App.ui.showToast("Everthing is up to date.", { type: 'success' });
                            }
                        }

                        await App.settings.set('lastSyncTimestamp', new Date().toISOString());

                    } catch (error) {
                        console.error("Sync Error:", error);
                        if (!isSilent) App.ui.showToast(`Sync failed: ${error.message}`, { type: 'error' });
                    } finally {
                        if (syncToastId) App.ui.hideToast(syncToastId);
                        App.state.isSyncing = false;
                        if (document.getElementById('settings-modal-content')) App.ui.showSettingsModal();
                    }
                },

                async downloadFile(remoteMeta) {
                    return await this.apiCall('files/download', null, { headers: { 'Dropbox-API-Arg': JSON.stringify({ path: remoteMeta.path_lower }) }, isDownload: true });
                },
                async listAllFiles() {
                    if (!this.isReady()) return [];
                    try {
                        let result = await this.apiCall('files/list_folder', { path: '' });
                        const allFiles = [...result.entries];
                        while (result.has_more) {
                            result = await this.apiCall('files/list_folder/continue', { cursor: result.cursor });
                            allFiles.push(...result.entries);
                        }
                        return allFiles.filter(f => f['.tag'] === 'file');
                    } catch (err) {
                        if (err.message && err.message.includes("path/not_found")) return [];
                        else throw err;
                    }
                },
                generateCodeVerifier() { const c = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01236789-._~'; let r = ''; const v = new Uint8Array(128); crypto.getRandomValues(v); for (let i = 0; i < v.length; i++)r += c[v[i] % c.length]; return r; },
                async generateCodeChallenge(v) { const d = new TextEncoder().encode(v); const h = await crypto.subtle.digest('SHA-256', d); return btoa(String.fromCharCode.apply(null, new Uint8Array(h))).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, ''); },
                isReady: () => App.state.isDropboxReady,
            },

            // ==========================================================================
            // 3.9. ROUTER
            // ==========================================================================
            router: {
                navigateTo(viewId, data = null, isPopState = false) {

                    // Check if we're running inside an iframe in split mode - skip split screen deactivation
                    const isInSplitIframe = document.body.classList.contains('split-iframe-mode');

                    // Deactivate split screen overlay when navigating normally (but NOT if we're inside an iframe)
                    if (!isInSplitIframe && App.splitScreen && App.splitScreen.state.isActive) {
                        App.splitScreen.deactivate();
                    }

                    document.getElementById('welcome-view')?.classList.remove('fading-out');
                    document.body.classList.remove('canvas-focus-mode', 'mobile-header-expanded');

                    // Manage browser history for a functional back button.
                    // Skip history changes when in split iframe mode to prevent affecting parent window
                    if (!isPopState && !isInSplitIframe) {
                        const currentState = history.state || {};
                        // Prevent pushing the same page onto the history stack twice.
                        if (currentState.viewId !== viewId || JSON.stringify(currentState.data) !== JSON.stringify(data)) {
                            const url = `#${viewId}`;
                            history.pushState({ viewId, data }, '', url);
                        }
                    }

                    App.state.libraryRender.isRendering = false;
                    clearTimeout(App.state.libraryRender.searchTimeout);
                    App.events.unmountViewListeners();

                    // --- NEW CO-PILOT LOGIC ---
                    const coPilotViews = ['category', 'visual-map', 'mindmap'];
                    const coPilotToggle = document.getElementById('kash-copilot-toggle');
                    if (coPilotToggle) {
                        coPilotToggle.style.display = coPilotViews.includes(viewId) ? 'flex' : 'none';
                    }
                    if (App.coPilot.state.isOpen) {
                        App.coPilot.toggle(); // Automatically close the sidebar when navigating away
                    }

                    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                    const view = document.getElementById(`${viewId}-view`);

                    const mainEl = document.querySelector('main');
                    const root = document.documentElement;
                    const body = document.body;

                    const isMap = viewId === 'visual-map' || viewId === 'mindmap';
                    if (isMap) {
                        if (typeof d3 === 'undefined') {
                            App.ui.showToast('Visual Maps are not available offline.', { type: 'warning' });
                            return;
                        }
                        mainEl.style.height = '100vh';
                        mainEl.style.overflow = 'hidden';
                        root.style.overflow = 'hidden';
                        body.style.overflow = 'hidden';
                    } else {
                        mainEl.style.height = '';
                        mainEl.style.overflow = '';
                        root.style.overflow = '';
                        body.style.overflow = '';
                    }

                    if (view) {
                        App.ui.renderView(viewId, data, view);
                        view.classList.add('active');
                    }

                    const articleControls = document.getElementById('article-controls');
                    if (articleControls) {
                        articleControls.style.display = viewId === 'article' ? 'flex' : 'none';
                    }

                    if (viewId !== 'article') {
                        App.ui.updateTheLine(1);
                    }

                    App.ui.updateHeaderState();
                    App.events.mountViewListeners(viewId);
                },
                getActiveView: () => document.querySelector('.view.active')?.id.replace('-view', ''),
                getActiveViewData: () => history.state?.data || null, // <-- FIX #1: Added missing function
            },

            // ==========================================================================
            // 3.9.1. SPLIT SCREEN (Iframe-Based)
            // ==========================================================================
            splitScreen: {
                state: {
                    isActive: false,
                    leftView: null,
                    rightView: null,
                    splitRatio: 50
                },

                supportedViews: ['library', 'flashcard', 'tags', 'stats-dashboard'],

                viewIcons: {
                    library: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 9v11a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9"/><path d="M9 22V12h6v10"/><path d="M2 10l10-7 10 7"/></svg>',
                    flashcard: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="15" rx="2"/><path d="M17 2v4"/><path d="M7 2v4"/><path d="M2 11h20"/></svg>',
                    tags: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>',
                    'stats-dashboard': '<svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/><path d="M12 3 v9 h9"/></svg>'
                },

                viewNames: {
                    library: 'Library',
                    flashcard: 'Flashcards',
                    tags: 'Tags',
                    'stats-dashboard': 'Statistics'
                },

                getOverlay() {
                    let overlay = document.getElementById('split-screen-overlay');
                    if (!overlay) {
                        overlay = document.createElement('div');
                        overlay.id = 'split-screen-overlay';
                        document.body.appendChild(overlay);
                    }
                    return overlay;
                },

                toggle() {
                    if (this.state.isActive) {
                        this.deactivate();
                    } else {
                        this.activate();
                    }
                },

                activate() {
                    const currentView = App.router.getActiveView();

                    if (!this.supportedViews.includes(currentView)) {
                        App.ui.showToast('Split screen works best from home', 'info');
                    }

                    this.state.isActive = true;
                    this.state.leftView = this.supportedViews.includes(currentView) ? currentView : 'library';
                    this.state.rightView = null;

                    this.updateHeaderState();
                    this.render();
                },

                deactivate() {
                    this.state.isActive = false;
                    const overlay = this.getOverlay();
                    overlay.classList.remove('active');
                    overlay.innerHTML = '';
                    this.updateHeaderState();
                },

                ensureStructure() {
                    const overlay = this.getOverlay();
                    if (!overlay.querySelector('.split-panel')) {
                        overlay.innerHTML = '';
                        overlay.classList.add('active');

                        // Create left panel wrapper
                        const leftPanel = document.createElement('div');
                        leftPanel.className = 'split-panel';
                        leftPanel.id = 'split-panel-left';
                        leftPanel.style.flex = `0 0 ${this.state.splitRatio}%`;
                        leftPanel.innerHTML = `
                            <div class="split-panel-header">
                                <select onchange="App.splitScreen.changeLeftView(this.value)"></select>
                            </div>
                            <div class="split-panel-content">
                                <iframe title="Left Panel"></iframe>
                            </div>
                        `;

                        // Create resize handle
                        const resizeHandle = document.createElement('div');
                        resizeHandle.className = 'split-resize-handle';
                        resizeHandle.addEventListener('mousedown', (e) => this.startResize(e));
                        resizeHandle.addEventListener('touchstart', (e) => this.startResize(e), { passive: false });

                        // Create right panel wrapper
                        const rightPanel = document.createElement('div');
                        rightPanel.className = 'split-panel';
                        rightPanel.id = 'split-panel-right';
                        rightPanel.style.flex = `0 0 ${100 - this.state.splitRatio - 1}%`;
                        rightPanel.innerHTML = `
                            <div class="split-panel-header"></div>
                            <div class="split-panel-content"></div>
                        `;

                        overlay.appendChild(leftPanel);
                        overlay.appendChild(resizeHandle);
                        overlay.appendChild(rightPanel);
                    }
                },

                render() {
                    this.ensureStructure();
                    const overlay = this.getOverlay();
                    if (!overlay.classList.contains('active')) overlay.classList.add('active');

                    // Update Left Panel
                    const leftSelect = overlay.querySelector('#split-panel-left select');
                    if (leftSelect) {
                        if (leftSelect.options.length !== this.supportedViews.length) {
                            leftSelect.innerHTML = this.supportedViews.map(v => `<option value="${v}">${this.viewNames[v]}</option>`).join('');
                        }
                        leftSelect.value = this.state.leftView;
                    }

                    const leftIframe = overlay.querySelector('#split-panel-left iframe');
                    if (leftIframe) {
                        const targetSrc = this.getIframeSrc(this.state.leftView);
                        if (leftIframe.getAttribute('src') !== targetSrc) {
                            leftIframe.src = targetSrc;
                        }
                    }


                    // Update Right Panel
                    const rightPanel = overlay.querySelector('#split-panel-right');
                    const rightHeader = rightPanel.querySelector('.split-panel-header');
                    const rightContent = rightPanel.querySelector('.split-panel-content');

                    if (this.state.rightView) {
                        rightHeader.innerHTML = `
                             <select onchange="App.splitScreen.changeRightView(this.value)">
                                ${this.supportedViews.map(v => `<option value="${v}" ${v === this.state.rightView ? 'selected' : ''}>${this.viewNames[v]}</option>`).join('')}
                            </select>
                            <button class="split-close-btn" onclick="App.splitScreen.deactivate()" title="Exit Split Screen">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                            </button>
                        `;

                        let iframe = rightContent.querySelector('iframe');
                        if (!iframe) {
                            rightContent.innerHTML = `<iframe title="Split Panel"></iframe>`;
                            iframe = rightContent.querySelector('iframe');
                        } else {
                            if (rightContent.querySelector('.split-view-selector')) {
                                rightContent.innerHTML = `<iframe title="Split Panel"></iframe>`;
                                iframe = rightContent.querySelector('iframe');
                            }
                        }

                        const targetSrc = this.getIframeSrc(this.state.rightView);
                        if (iframe.getAttribute('src') !== targetSrc) {
                            iframe.src = targetSrc;
                        }

                    } else {
                        if (!rightContent.querySelector('.split-view-selector')) {
                            rightHeader.innerHTML = `
                                <span class="split-panel-label">Split Panel</span>
                                <button class="split-close-btn" onclick="App.splitScreen.deactivate()" title="Exit Split Screen">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                </button>
                             `;

                            rightContent.innerHTML = `
                                <div class="split-view-selector">
                                    <h2>Split Panel</h2>
                                    <p>Search articles or select a view</p>
                                    <div class="split-search-container">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
                                        <input type="text" class="split-search-input" id="split-search-input" placeholder="Search articles..." oninput="App.splitScreen.handleSearch(this.value)">
                                        <div class="split-search-results" id="split-search-results"></div>
                                    </div>
                                    <div class="split-view-grid">
                                        ${this.supportedViews.map(v => `
                                            <div class="split-view-option" onclick="App.splitScreen.setRightView('${v}')">
                                                ${this.viewIcons[v]}
                                                <span>${this.viewNames[v]}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }
                    }
                },

                getIframeSrc(viewId) {
                    const currentUrl = new URL(window.location.href);
                    currentUrl.searchParams.set('splitView', viewId);
                    currentUrl.searchParams.set('splitMode', 'iframe');
                    return currentUrl.toString();
                },

                changeLeftView(viewId) {
                    this.state.leftView = viewId;
                    const leftIframe = document.querySelector('#split-panel-left iframe');
                    if (leftIframe) {
                        leftIframe.src = this.getIframeSrc(viewId);
                    } else {
                        // Fallback in case structure is missing
                        this.render();
                    }
                },

                changeRightView(viewId) {
                    this.state.rightView = viewId;
                    const rightIframe = document.querySelector('#split-panel-right iframe');
                    if (rightIframe) {
                        rightIframe.src = this.getIframeSrc(viewId);
                    } else {
                        // Fallback/Force render if we were in selector mode
                        this.render();
                    }
                },

                setRightView(viewId) {
                    this.state.rightView = viewId;
                    this.render();
                },

                startResize(e) {
                    e.preventDefault();
                    const handle = e.target.closest('.split-resize-handle');
                    if (!handle) return;
                    handle.classList.add('dragging');

                    const isMobile = window.innerWidth <= 768;
                    const overlay = this.getOverlay();
                    const startPos = isMobile ? (e.touches?.[0]?.clientY || e.clientY) : (e.touches?.[0]?.clientX || e.clientX);
                    const overlayRect = overlay.getBoundingClientRect();
                    const totalSize = isMobile ? overlayRect.height : overlayRect.width;
                    const startRatio = this.state.splitRatio;

                    // Disable iframe pointer events during resize
                    document.querySelectorAll('#split-screen-overlay iframe').forEach(f => f.style.pointerEvents = 'none');

                    const onMove = (moveEvent) => {
                        const currentPos = isMobile
                            ? (moveEvent.touches?.[0]?.clientY || moveEvent.clientY)
                            : (moveEvent.touches?.[0]?.clientX || moveEvent.clientX);
                        const delta = currentPos - startPos;
                        const deltaPercent = (delta / totalSize) * 100;
                        this.state.splitRatio = Math.max(25, Math.min(75, startRatio + deltaPercent));
                        this.applySplitRatio();
                    };

                    const onEnd = () => {
                        handle.classList.remove('dragging');
                        document.querySelectorAll('#split-screen-overlay iframe').forEach(f => f.style.pointerEvents = '');
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onEnd);
                        document.removeEventListener('touchmove', onMove);
                        document.removeEventListener('touchend', onEnd);
                    };

                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                },

                applySplitRatio() {
                    const leftPanel = document.getElementById('split-panel-left');
                    const rightPanel = document.getElementById('split-panel-right');
                    if (leftPanel && rightPanel) {
                        leftPanel.style.flex = `0 0 ${this.state.splitRatio}%`;
                        rightPanel.style.flex = `0 0 ${100 - this.state.splitRatio - 1}%`;
                    }
                },

                updateHeaderState() {
                    const btn = document.getElementById('split-screen-btn');
                    if (btn) {
                        btn.classList.toggle('split-active', this.state.isActive);
                    }
                },

                // Called on iframe load to handle split mode - returns true if in split mode
                handleSplitMode() {
                    const params = new URLSearchParams(window.location.search);
                    if (params.get('splitMode') === 'iframe') {
                        // Set flag IMMEDIATELY (sync) so App.init() can check it
                        App.isSplitIframeMode = true;
                        document.body.classList.add('split-iframe-mode');
                        const viewId = params.get('splitView');
                        const articleId = params.get('id');

                        // Wait for app to be fully ready (including settings, hub, quiz AND verified data load)
                        const checkReady = setInterval(() => {
                            // Check for all components needed by different views
                            const isReady = App.state &&
                                App.state.isDataFullyLoaded && // Wait for our new flag
                                App.state.articles &&
                                App.state.settings &&
                                App.router &&
                                App.hub && App.hub.util &&  // For stats-dashboard
                                App.quiz;                   // For stats-dashboard

                            if (isReady) {
                                clearInterval(checkReady);

                                // For flashcard view, ensure category is set to 'All' so all cards display
                                if (viewId === 'flashcard') {
                                    if (!App.state.settings.flashcardCategory) {
                                        App.state.settings.flashcardCategory = 'All';
                                    }
                                }

                                if (viewId === 'article' && articleId) {
                                    App.router.navigateTo('article', { id: articleId });
                                } else if (viewId && this.supportedViews.includes(viewId)) {
                                    App.router.navigateTo(viewId);
                                } else {
                                    App.router.navigateTo('library');
                                }
                            }
                        }, 50);
                        return true;
                    }
                    return false;
                },

                // Simple, reliable Library search - just search notes by title and content
                handleSearch(query) {
                    const resultsContainer = document.getElementById('split-search-results');
                    if (!resultsContainer) return;

                    // Clear if query too short
                    if (!query || query.length < 2) {
                        resultsContainer.innerHTML = '';
                        return;
                    }

                    // Get articles from state
                    const articles = App.state?.articles || App.state?.savedArticles || [];
                    if (!articles.length) {
                        resultsContainer.innerHTML = `<div class="split-search-empty">No articles found</div>`;
                        return;
                    }

                    // Create simple Fuse.js instance for article search
                    const fuse = App.offline.safeFuse(articles, {
                        keys: ['title', 'plainText', 'content'],
                        threshold: 0.4,
                        includeScore: true
                    });

                    const results = fuse.search(query).slice(0, 8);

                    if (results.length === 0) {
                        resultsContainer.innerHTML = `<div class="split-search-empty">No matching articles</div>`;
                        return;
                    }

                    // Render clean, simple results
                    resultsContainer.innerHTML = results.map(r => {
                        const article = r.item;
                        const title = (article.title || 'Untitled').substring(0, 50);
                        const preview = (article.plainText || article.content || '').replace(/<[^>]*>/g, '').substring(0, 60);

                        return `
                            <div class="split-search-item" onclick="App.splitScreen.openArticleInSplit('${article.id}')">
                                <div class="split-search-text">
                                    <strong>${title}</strong>
                                    <small>${preview}...</small>
                                </div>
                            </div>
                        `;
                    }).join('');
                },

                // Open an article in the right split panel
                openArticleInSplit(articleId) {
                    const rightPanel = document.getElementById('split-panel-right');
                    if (!rightPanel) return;

                    const currentUrl = new URL(window.location.href);
                    currentUrl.searchParams.set('splitView', 'article');
                    currentUrl.searchParams.set('splitMode', 'iframe');
                    currentUrl.searchParams.set('id', articleId);

                    this.state.rightView = 'article';

                    const rightHeader = rightPanel.querySelector('.split-panel-header');
                    const rightContent = rightPanel.querySelector('.split-panel-content');

                    // Update header to show 'Article' option
                    rightHeader.innerHTML = `
                         <select onchange="App.splitScreen.changeRightView(this.value)">
                            ${this.supportedViews.map(v => `<option value="${v}">${this.viewNames[v]}</option>`).join('')}
                            <option value="article" selected>Article</option>
                        </select>
                        <button class="split-close-btn" onclick="App.splitScreen.deactivate()" title="Exit Split Screen">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                        </button>
                    `;

                    // Update iframe safely
                    let iframe = rightContent.querySelector('iframe');
                    if (!iframe) {
                        // If we were in selector mode, clean up and create iframe
                        rightContent.innerHTML = `<iframe title="Split Panel"></iframe>`;
                        iframe = rightContent.querySelector('iframe');
                    }

                    iframe.src = currentUrl.toString();
                }
            },


            // ==========================================================================
            // 3.10. UI RENDERING
            // ==========================================================================
            ui: {



                async renderView(viewId, data, view) {
                    // First, handle special cases like maps that have a unique setup.
                    if (viewId === 'visual-map' || viewId === 'mindmap') {
                        if (!view.hasChildNodes()) {
                            const mapType = viewId.split('-')[0];
                            const controlsId = `${mapType}-map-controls`;
                            const containerId = `${mapType}-map-container`;
                            const focusLineId = `${mapType === 'visual' ? 'vm' : 'mm'}-focus-line`;
                            const controlsPlaceholder = document.createElement('div');
                            controlsPlaceholder.id = controlsId;
                            const focusLinePlaceholder = document.createElement('div');
                            focusLinePlaceholder.id = focusLineId;
                            focusLinePlaceholder.className = 'canvas-focus-line';
                            focusLinePlaceholder.title = 'Toggle Focus Mode (Esc)';
                            const containerPlaceholder = document.createElement('div');
                            containerPlaceholder.id = containerId;
                            containerPlaceholder.tabIndex = 0;
                            view.appendChild(controlsPlaceholder);
                            view.appendChild(focusLinePlaceholder);
                            view.appendChild(containerPlaceholder);
                        }

                        if (viewId === 'visual-map') setTimeout(() => App.visualMap.init(), 50);
                        if (viewId === 'mindmap') setTimeout(() => App.mindMap.init(), 50);
                        return;
                    }

                    // MEMORY OP: Clear previous view's heavy data before rendering new one
                    App.util.freeMemory();

                    view.innerHTML = ''; // Clear the view first

                    switch (viewId) {
                        case 'welcome': this.renderWelcomeView(view, data); break;
                        case 'library': this.renderLibraryView(view); break;
                        case 'article': await this.renderArticleView(view, data); break;
                        case 'category': this.renderCategoryView(view, data); break;
                        case 'tags': this.renderTagsView(view); break;
                        case 'flashcard': this.renderFlashcardView(view, data); break;
                        case 'stats-dashboard': this.renderStatsDashboardView(view, data); break;
                    }
                },

                renderWelcomeView(container, data) {
                    const { permissionState } = data || {};

                    // RATIONALE: All icon definitions are moved here for consistency and easy access.
                    const folderIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"></path></svg>`;
                    const browserIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>`;
                    const resumeIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"/><path d="m19 9-5 5-4-4-3 3"/></svg>`;

                    const headerHTML = `
                    <div class="welcome-hero">
                        <h1 class="library-title">NoteKash</h1>
                        <p id="welcome-subtitle"></p>
                    </div>`;

                    let choicesHTML = '';

                    if (permissionState === 'prompt') {
                        // RATIONALE: Replaced the 2-column grid with a single-column flex container. This ensures the single "Resume" card is always perfectly centered on the screen, fixing the alignment issue.
                        choicesHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 1.5rem; margin-top: 3rem;">
                            <div class="welcome-card recommended" onclick="App.events.requestStoredPermission()" style="width: 100%; max-width: 420px;">
                                <div class="welcome-card-header">
                                    <div class="card-icon">${resumeIcon}</div>
                                    <h3 class="card-title">Resume Session</h3>
                                </div>
                                <p class="card-description">Grant access to your previously selected folder to continue where you left off.</p>
                            </div>
                            <div class="welcome-prompt-alternatives">
                                <a href="#" onclick="event.preventDefault(); App.events.selectDirectory(true)">Choose a New Folder</a>
                                <span>&bull;</span>
                                <a href="#" onclick="event.preventDefault(); App.events.useBrowserStorage()">Use Browser Instead</a>
                            </div>
                        </div>`;
                    } else {
                        const isFPIsupported = 'showDirectoryPicker' in window;
                        const folderCardClass = isFPIsupported ? 'recommended' : 'disabled';
                        const folderCardTitle = isFPIsupported ? 'Best for privacy & data ownership.' : 'Your browser does not support this feature.';
                        const folderCardOnClick = isFPIsupported ? `App.events.selectDirectory()` : '';

                        choicesHTML = `
                        <div class="welcome-choices">
                            <div class="welcome-card ${folderCardClass}" onclick="${folderCardOnClick}" title="${folderCardTitle}">
                                <div class="welcome-card-header">
                                    <div class="card-icon">${folderIcon}</div>
                                    <h3 class="card-title">On My Device</h3>
                                </div>
                                <p class="card-description">Store notes privately on your device. Ideal for privacy, reliability & ownership.</p>
                            </div>
                            <div class="welcome-card" onclick="App.events.useBrowserStorage()" title="Easiest setup, works on all browsers.">
                                <div class="welcome-card-header">
                                    <div class="card-icon">${browserIcon}</div>
                                    <h3 class="card-title">In the Browser</h3>
                                </div>
                                <p class="card-description">Store notes inside your browser's database. No folder setup required.</p>
                            </div>
                        </div>`;
                    }
                    container.innerHTML = `<div class="welcome-container">${headerHTML}${choicesHTML}</div>`;

                    const subtitleEl = document.getElementById('welcome-subtitle');
                    if (subtitleEl) {
                        App.util.typewriter(subtitleEl, "Unleash the Power of Your Second Brain...", 65); // Speed up from 45ms to 40ms

                    }

                    if (permissionState === 'denied') {
                        container.querySelector('.welcome-hero p').insertAdjacentHTML('afterend',
                            `<p style="color:var(--danger-color); font-weight: 500; margin-top: -0.5rem; margin-bottom: 1.5rem;">Access was denied. Please select a folder again or use the alternatives below.</p>`
                        );
                    }
                },

                renderLibraryView(container) {
                    const mainCategories = [
                        { name: 'Tags', action: 'tags', data: '' },
                        { name: 'Flashcards', action: 'flashcard', data: '' }
                    ];

                    const userCategoryObjects = App.settings.get('userCategories');
                    const otherCategories = userCategoryObjects.map(catObj => ({
                        name: catObj.name,
                        colorIndex: catObj.colorIndex,
                        action: 'category',
                        data: `'${catObj.name}'`
                    }));

                    const nameStyle = App.settings.get('categoryNameStyle') || 'full';

                    // --- NEW: Theme-aware icon selection logic ---
                    const currentTheme = App.settings.get('theme') || 'sepia';
                    const customBase = App.settings.get('customThemeBase');
                    let toggleIcon;

                    switch (currentTheme) {
                        case 'sepia':
                            toggleIcon = '';
                            break;
                        case 'dark':
                            toggleIcon = '';
                            break;
                        case 'custom':
                            // Use specific icons based on the custom theme's base
                            toggleIcon = (customBase === 'dark') ? '' : '';
                            break;
                        case 'light':
                        default:
                            toggleIcon = '';
                            break;
                    }

                    const toggleButtonHTML = `
                    <button class="category-chip category-action-btn" id="category-name-toggle" title="Toggle Category Name Length" onclick="App.events.toggleCategoryNameStyle()">
                        ${toggleIcon}
                    </button>
                `;

                    const allCategoryButtons = [...mainCategories, ...otherCategories];
                    const libraryTitle = App.util.escapeHtml(App.settings.get('libraryTitle') || 'My Library');

                    container.innerHTML = `
                    <div class="library-main">
                        <div class="library-header">
                            <a href="https://studyrecapped.com/general/the-official-notekash-guide-art-of-building-a-second-brain/" target="_blank" rel="noopener noreferrer"><h1 class="library-title">${libraryTitle}</h1></a>
                        </div>
                        <div class="search-and-filter-bar">
                            <div class="search-bar-container">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>
                                <input type="text" id="search-input" placeholder="Search by titles, snippets, '*category', read count e.g *law, 0 (unread)" aria-label="Search articles">
                            </div>
                            <select id="sort-filter" class="btn btn-secondary" aria-label="Sort articles by">
                                <option value="updatedAt">Sort by Newest</option>
                                <option value="createdAt">Sort by Oldest</option>
                                <option value="title">Sort by Title</option>
                                <option value="unread">Sort by Unread</option>
                                <option value="read">Sort by Read</option>
                                <option value="random">Sort by Random</option>
                            </select>
                        </div>
                        <div class="category-filters">
                            ${toggleButtonHTML}
                            ${allCategoryButtons.map(cat => {

                        let className, style = '', buttonText, titleText;
                        titleText = (cat.name === 'Tags' || cat.name === 'Flashcards') ? cat.name : App.util.getCategoryDisplayName(cat.name);

                        if (cat.name === 'Tags') {
                            className = 'category-chip category-action-btn action-secondary';
                            buttonText = 'Tags';
                        } else if (cat.name === 'Flashcards') {
                            className = 'category-chip category-action-btn action-primary';
                            buttonText = 'Flash';
                        } else {
                            className = 'category-chip';
                            const backgroundColor = `var(--cat-color-${cat.colorIndex}-bg)`;
                            const textColor = `var(--category-pill-text)`;
                            style = `style="background-color: ${backgroundColor}; color: ${textColor};"`;
                            buttonText = (nameStyle === 'full') ? titleText : titleText.substring(0, 4);
                        }

                        return `<button class="${className}" ${style} onclick="App.router.navigateTo('${cat.action}', ${cat.data})" title="${titleText}">${buttonText}</button>`;
                    }).join('')}

                            <button class="category-chip category-action-btn action-primary" onclick="App.router.navigateTo('category', 'All')">All</button>
                            
                        </div>
                        <hr style="width:100%; border-color: var(--border-color); margin: 0;">
                        <div id="article-grid-container">
                            <div class="article-grid" id="article-grid">
                                <div class="empty-state" style="grid-column: 1 / -1;"><div class="spin">${App.util.icons.cycle}</div><h3>Loading Library...</h3></div>
                            </div>
                            <div id="library-sentinel" style="height: 20px; width: 100%; margin-top: 20px;"></div>
                        </div>
                    </div>`;

                    setTimeout(() => App.ui.filterAndRenderArticles(), 50);
                },

                filterAndRenderArticles() {
                    const grid = document.getElementById('article-grid');
                    if (!grid) return;

                    const searchTerm = document.getElementById('search-input')?.value || '';
                    let articlesToDisplay = [...App.state.articles];
                    let currentSearchTerm = searchTerm.trim();

                    const sortBy = App.settings.get('librarySortBy') || 'updatedAt';
                    switch (sortBy) {
                        case 'createdAt':
                            articlesToDisplay.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
                            break;
                        case 'title':
                            articlesToDisplay.sort((a, b) => a.title.localeCompare(b.title));
                            break;
                        case 'unread':
                            articlesToDisplay.sort((a, b) => (a.readCount || 0) - (b.readCount || 0));
                            break;
                        case 'read':
                            articlesToDisplay.sort((a, b) => (b.readCount || 0) - (a.readCount || 0));
                            break;
                        case 'random':
                            articlesToDisplay.sort(() => Math.random() - 0.5);
                            break;
                        case 'updatedAt':
                        default:
                            articlesToDisplay.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                            break;
                    }

                    const readCountMatch = currentSearchTerm.match(/^(\d+)\s*(.*)/);
                    let readCountFilter = null;
                    if (readCountMatch) {
                        readCountFilter = parseInt(readCountMatch[1], 10);
                        currentSearchTerm = readCountMatch[2].trim();
                        if (readCountFilter === 0) {
                            articlesToDisplay = articlesToDisplay.filter(a => !a.readCount || a.readCount === 0);
                        } else {
                            articlesToDisplay = articlesToDisplay.filter(a => a.readCount === readCountFilter);
                        }
                    }

                    const categoryMatch = currentSearchTerm.match(/^\*(\w*)\s*/);
                    if (categoryMatch) {
                        const prefix = categoryMatch[1].toLowerCase();
                        const userCategories = App.settings.get('userCategories'); // Get the category objects

                        if (prefix && userCategories) { // Add a check for userCategories
                            const matchingCategoryNames = userCategories
                                .filter(catObj => // Filter the objects directly
                                    catObj.name.toLowerCase().startsWith(prefix) ||
                                    (App.util.getCategoryDisplayName(catObj.name) || '').toLowerCase().startsWith(prefix)
                                )
                                .map(catObj => catObj.name); // Then get the names

                            const matchingCategorySet = new Set(matchingCategoryNames);
                            if (matchingCategorySet.size > 0) {
                                articlesToDisplay = articlesToDisplay.filter(a => matchingCategorySet.has(a.category));
                            }
                        }
                        currentSearchTerm = currentSearchTerm.replace(/^\*(\w*)\s*/, '').trim();
                    }

                    if (currentSearchTerm) {
                        const searchableData = articlesToDisplay.map(article => ({
                            id: article.id,
                            title: article.title,
                            tags: (article.tags || []).join(' '),
                            snippets: App.util.extractSnippets(article, 'highlight').map(s => s.text)
                        }));

                        const fuse = App.offline.safeFuse(searchableData, {
                            keys: [{ name: 'title', weight: 0.6 }, { name: 'tags', weight: 0.3 }, { name: 'snippets', weight: 0.1 }],
                            includeScore: true, threshold: 0.4
                        });
                        const results = fuse.search(currentSearchTerm);
                        const filteredIds = new Set(results.map(r => r.item.id));
                        articlesToDisplay = articlesToDisplay.filter(a => filteredIds.has(a.id));
                    }

                    let finalHTML = '';

                    if (!App.license.isPremium()) {
                        const articlesUsed = App.state.articles.length;
                        const articleLimit = App.config.sparkTierLimit;
                        const percentageUsed = Math.min(100, Math.round((articlesUsed / articleLimit) * 100));

                        finalHTML += `
                        <div class="article-card library-premium-card" title="A message from the developer...">
                            <div class="card-category-badge premium-badge"> Spark Tier</div>
                            <h3 class="card-title">You've used ${percentageUsed}% Quota (${articlesUsed} of ${articleLimit} notes)</h3>
                            <div class="card-footer premium-card-footer">
                                <div class="premium-progress-bar">
                                    <div class="premium-progress" style="width: ${percentageUsed}%;"></div>
                                </div>
                                <span class="premium-cta-text">Click to see what's possible </span>
                            </div>
                        </div>`;
                    }

                    if (articlesToDisplay.length > 0) {
                        finalHTML += articlesToDisplay.map(article => this.getArticleCardHTML(article)).join('');
                    }
                    else {
                        if (App.state.articles.length === 0) {
                            finalHTML += `<div class="empty-state" style="grid-column: 1 / -1;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><path d="M12 2a10 10 0 1 0 10 10"/><path d="M12 18a6 6 0 1 0 0-12 6 6 0 0 0 0 12z"/><path d="M12 12a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></svg>
                            <h3>Your Second Brain Awaits!</h3>
                            <p>Click the <strong>+</strong> button in the top right to create your first note.</p>
                        </div>`;
                        } else {
                            finalHTML += `<div class="empty-state" style="grid-column: 1 / -1;"><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg><h3>Ouch, No Results Found</h3><p>Try a different title, tag, or filter combination.</p></div>`;
                        }
                    }
                    grid.innerHTML = finalHTML;

                    const visibleCards = Array.from(grid.querySelectorAll('.article-card:not(.library-premium-card)'));
                    const shouldHighlight = !!currentSearchTerm || readCountFilter !== null || !!categoryMatch;
                    visibleCards.forEach(card => card.classList.toggle('search-highlight-card', shouldHighlight));
                    document.querySelectorAll('.search-selected-card').forEach(c => c.classList.remove('search-selected-card'));
                    App.state.libraryRender.searchResults = visibleCards;
                    App.state.libraryRender.selectedIndex = -1;
                    if (shouldHighlight && visibleCards.length > 0) {
                        App.state.libraryRender.selectedIndex = 0;
                        visibleCards[0].classList.add('search-selected-card');
                        if (document.activeElement.id === 'sort-filter') {
                            visibleCards[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                },

                async startLibraryRender() {
                    const grid = document.getElementById('article-grid');
                    if (!grid) return;

                    App.state.libraryRender.isRendering = true;
                    // Reset index
                    App.state.libraryRender.currentIndex = 0;
                    grid.innerHTML = '';
                    window.scrollTo(0, 0);

                    // Check for empty state *before* rendering batches
                    if (App.state.libraryRender.filteredArticles.length === 0) {
                        let emptyMessage = `<div class="empty-state" style="grid-column: 1 / -1;"><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg><h3>No Articles Found</h3><p>Try adjusting your search or create a new article.</p></div>`;
                        if (!App.state.directoryHandle) {
                            emptyMessage = `<div class="empty-state" style="grid-column:1/-1; text-align:center; padding: 4rem 1rem;"><p>Please select a folder to begin.</p></div>`
                        }
                        grid.innerHTML = emptyMessage;
                        App.state.libraryRender.isRendering = false;
                        return;
                    }

                    // 1. Render Initial Batch
                    this.renderArticleBatch(20);

                    // 2. Setup Infinite Scroll (Virtualization Lite)
                    const sentinel = document.getElementById('library-sentinel');
                    if (sentinel) {
                        if (App.state.libraryObserver) App.state.libraryObserver.disconnect();

                        App.state.libraryObserver = new IntersectionObserver((entries) => {
                            if (entries[0].isIntersecting) {
                                // Load next chunk
                                if (App.state.libraryRender.currentIndex < App.state.libraryRender.filteredArticles.length) {
                                    this.renderArticleBatch(20);
                                }
                            }
                        }, { rootMargin: '400px' }); // Pre-load well before reaching bottom

                        App.state.libraryObserver.observe(sentinel);
                    }
                },


                renderArticleBatch(count) {
                    const grid = document.getElementById('article-grid');
                    if (!grid) return;

                    const { filteredArticles, currentIndex } = App.state.libraryRender;
                    const endIndex = Math.min(currentIndex + count, filteredArticles.length);

                    let articlesHTML = '';
                    for (let i = currentIndex; i < endIndex; i++) {
                        articlesHTML += this.getArticleCardHTML(filteredArticles[i]);
                    }

                    grid.insertAdjacentHTML('beforeend', articlesHTML);
                    App.state.libraryRender.currentIndex = endIndex;
                },

                getArticleCardHTML(article) {
                    // Find the category object to get its colorIndex
                    const categoryObj = App.settings.get('userCategories').find(c => c.name === article.category) || { name: article.category, colorIndex: 0 };
                    const backgroundColor = App.util.getCategoryColor(categoryObj.colorIndex);

                    const readCount = article.readCount || 0;
                    const progressColorVar = `var(${App.util.getReadProgressColorVar(readCount)})`;
                    const borderStyle = `border-left-color: ${progressColorVar};`;

                    const heartTitle = `Read ${readCount} time(s)`;
                    let heartSVG;
                    if (readCount === 0) {
                        heartSVG = `<svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z" fill="${progressColorVar}"/></svg>`;
                    } else {
                        const masteryGlow = readCount >= 10 ? `filter: drop-shadow(0 0 5px ${progressColorVar});` : '';
                        heartSVG = `<svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20" style="${masteryGlow}"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" fill="${progressColorVar}"/></svg>`;
                    }

                    const readCountBadgeHTML = `<div title="${heartTitle}" style="display: flex; align-items: center; justify-content: center; height: 24px; width: 24px;">${heartSVG}</div>`;
                    const wordCountHTML = `<span class="card-word-count">${article.wordCount || 0} words</span>`;
                    const date = new Date(article.updatedAt);
                    const dateHTML = `<span class="card-date">${date.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' })}</span>`;

                    // UPDATED: Note the inline style for background-color and removal of data-category
                    return `<div class="article-card ui-card" tabindex="0" data-id="${article.id}" style="${borderStyle}">
                    <div class="card-header-info">
                        <div class="card-category-badge category-pill" style="background-color: ${backgroundColor};">${App.util.getCategoryDisplayName(categoryObj.name)}</div>
                        ${readCountBadgeHTML}
                    </div>
                    <h3 class="card-title">${article.title}</h3>
                    <div class="card-footer">${wordCountHTML}${dateHTML}</div>
                </div>`;
                },

                // New Helper for Native-like Inputs
                showInputModal(title, placeholder, defaultValue, onConfirm) {
                    this.closeModal(); // Ensure no stacking

                    const modalId = `input-modal-${Date.now()}`;
                    const modalHTML = `
                    <div id="${modalId}" class="modal-backdrop" style="animation: fadeIn 0.2s ease-out; z-index: 20000; background-color: rgba(0,0,0,0.6);">
                        <div class="modal-content ui-card" style="max-width: 400px; transform-origin: center center; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);">
                            <h3 style="margin-top:0;">${title}</h3>
                            <input type="text" id="${modalId}-input" class="text-input" placeholder="${placeholder}" value="${defaultValue || ''}" style="width: 100%; margin-top: 10px; margin-bottom: 20px;">
                            <div class="modal-buttons" style="margin-top: 0; justify-content: flex-end; gap: 10px;">
                                <button class="btn btn-secondary" id="${modalId}-cancel">Cancel</button>
                                <button class="btn btn-primary" id="${modalId}-confirm">Confirm</button>
                            </div>
                        </div>
                    </div>`;

                    document.body.insertAdjacentHTML('beforeend', modalHTML);
                    const modalEl = document.getElementById(modalId);
                    const inputEl = document.getElementById(`${modalId}-input`);
                    const cancelBtn = document.getElementById(`${modalId}-cancel`);
                    const confirmBtn = document.getElementById(`${modalId}-confirm`);

                    inputEl.focus();
                    if (defaultValue) inputEl.select();

                    const cleanup = () => modalEl.remove();

                    // Actions
                    const handleConfirm = () => {
                        const val = inputEl.value.trim();
                        if (val) onConfirm(val);
                        cleanup();
                    };

                    confirmBtn.onclick = handleConfirm;
                    cancelBtn.onclick = cleanup;

                    // Allow Enter to confirm, Esc to cancel
                    inputEl.onkeydown = (e) => {
                        if (e.key === 'Enter') handleConfirm();
                        if (e.key === 'Escape') cleanup();
                    };

                    // Close on backdrop click
                    modalEl.onclick = (e) => {
                        if (e.target === modalEl) cleanup();
                    };
                },

                showAscensionModal() {
                    const wittyMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
                    const maybeLaterText = App.util.getRandomMessage(App.util.maybeLaterMessages);

                    // --- FIX: "isCurrent" is now determined dynamically by checking the user's license state ---
                    const badgeTiers = [
                        { name: 'Spark', duration: 'Free Tier', isCurrent: App.license.state.tier === 'Spark' },
                        { name: 'Bronze', duration: '3 Months', isCurrent: App.license.state.tier === 'Bronze' },
                        { name: 'Silver', duration: '6 Months', isCurrent: App.license.state.tier === 'Silver' },
                        { name: 'Gold', duration: '1 Year', isCurrent: App.license.state.tier === 'Gold' },
                        { name: 'Diamond', duration: 'Lifetime', isCurrent: App.license.state.tier === 'Diamond' }
                    ];

                    const badgesHTML = badgeTiers.map(tier => `
                <div class="ascension-card ${tier.isCurrent ? 'is-current-tier' : ''}" 
                    style="border-radius: 24px; min-width: 160px;"
                    onclick="${tier.isCurrent ? '' : `App.ui.closeModal(); App.ui.showLicenseModal();`}">

                    ${App.util.getTierBadgeHTML(tier.name)}
                    <span class="ascension-card-name">${tier.name}</span>
                    <span class="ascension-card-duration">${tier.duration}</span>
                </div>
            `).join('');

                    const mailtoLink = 'mailto:learningmarvel@gmail.com';

                    const modalHTML = `
                <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                    <div class="modal-content ui-card ascension-modal" onclick="event.stopPropagation()">
                        <div id="ascension-witty-message" class="witty-gradient-text" style="font-size: 1.8rem; margin-bottom: 1rem;">${wittyMessage}</div>
                        <h4 class="witty-gradient-text" style="font-size: 1.2rem;">Choose Your Ascension</h4>
                        <div class="ascension-grid">${badgesHTML}</div>
                        <div class="ascension-features">
                            <h5>Unlock Your Full Potential:</h5>
                            <ul>
                                <li>${App.util.icons.saveAndRead} Unlimited Notes & Flashcards & Quiz</li>
                                <li>${App.util.icons.saveAndRead} Unlock all Advanced Pro Commands</li>
                                <li>${App.util.icons.saveAndRead} Unlimited Search Results & Power Search</li>
                                <li>${App.util.icons.saveAndRead} Unlimited MindMaps & VisualMaps </li>
                                <li>${App.util.icons.saveAndRead} Unlimited access to NoteKash AI</li>
                                <li>${App.util.icons.saveAndRead} Unlimited AI Audio Transcription </li>
                                <li>${App.util.icons.saveAndRead} Unlock Automatic Cloud Sync</li>
                                <li>${App.util.icons.saveAndRead} Unlock All Export Options (PDF,TSV ...)</li>
                                <li>${App.util.icons.saveAndRead} Customize your Fonts & Themes</li>
                                <li>${App.util.icons.saveAndRead} Remove Adverts & Join our Elite Group </li>
                                <li>${App.util.icons.saveAndRead} Get cool Premium Badge & Templates</li>
                                <li>${App.util.icons.saveAndRead} Get promised access to All Future Features...</li>
                            </ul>
                        </div>
                        <div class="ascension-footer">
                            <a href="${mailtoLink}">Prefer to Donate or Get a Discount? Contact me directly.</a>
                        </div>
                        <div class="modal-buttons" style="margin-top: 1.5rem;">
                            <button class="ascension-footer-button witty-gradient-text" onclick="App.ui.closeModal()">${maybeLaterText}</button>
                        </div>
                    </div>
                </div>`;
                    document.getElementById('modal-container').innerHTML = modalHTML;
                    const savedKey = App.settings.get('openRouterKey');
                    const savedModel = App.settings.get('openRouterModel');
                    if (savedKey) document.getElementById('openrouter-key-input').value = savedKey;
                    if (savedModel) document.getElementById('openrouter-model-select').value = savedModel;
                },

                closeAscensionModal() {
                    const modal = document.getElementById('ascension-modal-backdrop');
                    if (modal) modal.style.display = 'none';
                },

                async renderArticleView(container, data) {
                    const { id, mode, articleObject, scrollToSnippetId, overrideContent, restoredScrollTop, isPreviewing } = data; // Added isPreviewing
                    let article = articleObject ? articleObject : App.storage.getArticle(id);

                    if (!article) { App.router.navigateTo('library'); return; }

                    // ... (keep the existing content loading logic here) ...
                    if (article.content === undefined && !articleObject && !overrideContent) {
                        const fullArticleData = await App.fs.read(`${article.id}.json`);
                        if (fullArticleData) {
                            Object.assign(article, fullArticleData);
                        } else {
                            App.ui.showToast(`Error: Could not load article content for ${article.title}.`, 'error');
                            App.router.navigateTo('library');
                            return;
                        }
                    }

                    App.state.activeArticleId = article.id;
                    App.state.currentMode = mode;
                    document.body.classList.remove('read-mode', 'write-mode');
                    document.body.classList.add(`${mode}-mode`);
                    if (App.settings.get('theme') === 'custom') { document.body.classList.add('image-theme-active'); }
                    App.ui.applyFontSettings();

                    const finalContent = overrideContent ?? article.content;

                    container.innerHTML = `<div class="article-view-wrapper">
                <div class="article-container ui-card">
                    <div class="article-tags-display"></div>
                    <input type="text" class="article-title-input" value="${App.util.escapeHtml(article.title)}" id="article-title" readonly>
                    <div class="article-metadata-bar">
                        <span id="word-count-display"></span>
                        <span id="creation-date-display"></span>
                    </div>
                    <hr class="title-divider">
                    <div id="article-content" spellcheck="false" data-placeholder="Start writing here..."></div>
                </div>
            </div>`;

                    // --- FIX: Apply the preview class if we are in a preview state ---
                    if (isPreviewing) {
                        const articleContainer = container.querySelector('.article-container');
                        if (articleContainer) {
                            articleContainer.classList.add('is-in-preview-mode');
                        }
                    }

                    // ... (The rest of the function remains identical) ...
                    this.updateArticleMetadata(finalContent, article.createdAt);
                    this.renderArticleControls(article);
                    this.updateArticleViewForMode({ ...article, content: finalContent });

                    if (typeof restoredScrollTop === 'number') {
                        setTimeout(() => {
                            const mainEl = document.querySelector('main');
                            if (mainEl) mainEl.scrollTop = restoredScrollTop;
                        }, 50);
                    }

                    if (scrollToSnippetId) {
                        setTimeout(() => {
                            let targetElement = document.getElementById(scrollToSnippetId);
                            // NEW: Check if it's a PDF pill
                            if (!targetElement && scrollToSnippetId.startsWith('pdf_')) {
                                targetElement = document.querySelector(`.pdf-attachment-pill[data-pdf-id="${scrollToSnippetId}"]`);
                            }
                            if (targetElement) {
                                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                targetElement.style.transition = 'background-color 0.5s, box-shadow 0.5s, border-color 0.5s';
                                targetElement.style.boxShadow = `0 0 15px 5px var(--hl-1-border)`;
                                targetElement.style.borderColor = 'var(--hl-1-border)'; // For PDF pills
                                setTimeout(() => { targetElement.style.boxShadow = ''; targetElement.style.borderColor = ''; }, 2500);
                            }
                        }, 100);
                    }

                    setTimeout(() => App.events.updateReadingProgress(), 100);
                    const contentDiv = document.getElementById('article-content');
                    if (contentDiv) {
                        contentDiv.querySelectorAll('canvas[data-chart-config]').forEach(canvas => {
                            App.ui.renderChartOnCanvas(canvas);
                        });
                    }

                    const wrapper = container.querySelector('.article-view-wrapper');
                    const controls = document.getElementById('article-controls');
                    if (wrapper && controls) {
                        wrapper.appendChild(controls);
                    }
                    this.applyReaderTheme();

                },


                updateArticleMetadata(content = '', createdAt = '') {
                    const wordCountEl = document.getElementById('word-count-display');
                    const dateEl = document.getElementById('creation-date-display');

                    if (wordCountEl) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = content;
                        const text = tempDiv.textContent || tempDiv.innerText || "";
                        const words = text.trim().split(/\s+/).filter(Boolean).length;
                        wordCountEl.textContent = `${words} words`;
                    }

                    if (dateEl && createdAt) {
                        const date = new Date(createdAt);
                        const options = { year: 'numeric', month: 'long', day: 'numeric' };
                        dateEl.textContent = `Created on ${date.toLocaleDateString(undefined, options)}`;
                    }
                },

                updateArticleViewForMode(article) {
                    const titleInput = document.getElementById('article-title');
                    const contentDiv = document.getElementById('article-content');
                    const tagsContainer = document.querySelector('.article-tags-display');
                    const isWriteMode = App.state.currentMode === 'write';


                    titleInput.readOnly = !isWriteMode;
                    contentDiv.contentEditable = isWriteMode;

                    // --- OPTIMIZATION: Skip unnecessary re-renders in Read Mode ---
                    const currentMode = isWriteMode ? 'write' : 'read';

                    const contentHash = App.util.hashString(article.content + article.title + (article.attachments ? JSON.stringify(article.attachments) : ''));

                    if (!isWriteMode &&
                        contentDiv.dataset.renderMode === 'read' &&
                        contentDiv.dataset.renderHash === contentHash &&
                        contentDiv.innerHTML.trim() !== '') {
                        return;
                    }

                    // Update render state tracking
                    contentDiv.dataset.renderMode = currentMode;
                    contentDiv.dataset.renderHash = contentHash;
                    // -------------------------------------------------------------

                    if (isWriteMode) {
                        contentDiv.innerHTML = article.content;
                        const isEffectivelyEmpty = article.content.trim() === '' || article.content.trim() === '<p><br></p>';
                        contentDiv.classList.toggle('is-empty', isEffectivelyEmpty);
                        contentDiv.setAttribute('data-placeholder', "Start writing... Use [[tags]] for Visual Map, ==highlights== for Mind Map, or {{c1::cloze}} for flashcards.");

                        // Migration: Add resize handles to existing visual flashcards and image containers
                        setTimeout(() => {
                            contentDiv.querySelectorAll('.nk-visual-flashcard, .image-container').forEach(container => {
                                if (!container.querySelector('.resize-handle')) {
                                    const handle = document.createElement('div');
                                    handle.className = 'resize-handle resize-handle-se';
                                    container.appendChild(handle);
                                    console.log('Added resize handle to image container');
                                }
                            });
                        }, 10);

                        // RATIONALE (WRITE MODE): A short timeout is necessary here. The browser needs a moment
                        setTimeout(() => {
                            App.audio.initializePlayersIn(contentDiv);
                            App.util.initPlyr(contentDiv);
                        }, 50);

                    } else {
                        let parsedContent = App.util.parseShortcuts(article.content);
                        let finalContent = App.util.renderClozeForDisplay(parsedContent);
                        finalContent = finalContent.replaceAll(' contenteditable="true"', '');
                        finalContent = finalContent.replaceAll(" contenteditable='true'", '');
                        // If the article has attachments, verify and render them
                        if (article.attachments) {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = finalContent;
                            tempDiv.querySelectorAll('.pdf-attachment-pill[data-pdf-id]').forEach(pill => {
                                const attachment = article.attachments.find(a => a.id === pill.dataset.pdfId);
                                if (!attachment) {
                                    pill.outerHTML = '[Invalid PDF Attachment]';
                                }
                            });
                            finalContent = tempDiv.innerHTML;
                        }

                        contentDiv.innerHTML = App.util.sanitizeHTML(finalContent);

                        contentDiv.querySelectorAll('.nk-text-tile').forEach(tile => {
                            if (tile.textContent.trim() === '') {
                                App.util.unwrapNode(tile);
                            }
                        });

                        contentDiv.querySelectorAll('.nk-accordion').forEach(accordion => {
                            const hintEditor = accordion.querySelector('.nk-accordion-hint-editor');
                            if (hintEditor && (hintEditor.textContent.trim() || hintEditor.querySelector('.nk-accordion-hint-content')?.innerHTML.trim())) {
                                const hintBtn = accordion.querySelector('.nk-accordion-hint-btn');
                                if (hintBtn) hintBtn.style.display = 'flex';
                                hintEditor.style.display = 'none';
                            }
                        });

                        App.contentTools.autoSuggestTags(contentDiv);

                        App.audio.initializePlayersIn(contentDiv);
                        App.util.initPlyr(contentDiv);
                    }

                    const categoryObj = App.settings.get('userCategories').find(c => c.name === article.category) || { name: article.category, colorIndex: 0 };
                    const categoryPillHTML = `<span class="category-pill" style="background-color: ${App.util.getCategoryColor(categoryObj.colorIndex)}; cursor: pointer;" onclick="App.router.navigateTo('category', '${article.category}')">${App.util.getCategoryDisplayName(categoryObj.name)}</span>`;

                    const tagsHTML = (article.tags || []).map(tag => `<span class="tag-item" onclick="App.events.showTagModal('${tag}')">${App.state.tags[tag]?.displayName || tag}</span>`).join('');

                    tagsContainer.innerHTML = isWriteMode ? tagsHTML : categoryPillHTML + tagsHTML;
                },


                renderArticleControls(article) {
                    const controlsContainer = document.getElementById('article-controls');
                    if (!controlsContainer) return;

                    if (article.isDummy) {
                        controlsContainer.innerHTML = `
                    <div class="controls-wrapper" style="display: flex; justify-content: center; gap: 1rem;">
                        <button class="btn btn-primary btn-gradient-text tutorial-btn" style="font-weight: 700; border: 2px solid transparent; border-radius: var(--border-radius-lg); background-image: linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488), linear-gradient(var(--bg-secondary), var(--bg-secondary)), linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488); background-origin: border-box; background-clip: text, padding-box, border-box;" onclick="window.open('https://studyrecapped.com/general/the-official-notekash-guide-art-of-building-a-second-brain/', '_blank')">
                             Tutorial
                        </button>
                        <button class="btn btn-primary btn-gradient-text tutorial-btn" style="font-weight: 700; border: 2px solid transparent; border-radius: var(--border-radius-lg); background-image: linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488), linear-gradient(var(--bg-secondary), var(--bg-secondary)), linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488); background-origin: border-box; background-clip: text, padding-box, border-box;" onclick="App.ui.showAscensionModal()">
                             Unlock Pro
                        </button>
                    </div>
                `;
                        return;
                    }

                    const readCount = article.readCount || 0;
                    const progressColorVar = `var(${App.util.getReadProgressColorVar(readCount)})`;

                    const newHeartButtonHTML = `
                <button class="btn-icon"
                        id="unified-heart-btn" 
                        title="Click to advance read count (S).. Double-click to reset (SS)." 
                        aria-label="Mark as finished or reset count">
                    <svg width="28" height="28" viewBox="0 0 24 24" style="transform: scale(1.35);">
                        <defs>
                            <filter id="heart-shadow" x="-50%" y="-50%" width="200%" height="200%">
                                <feDropShadow dx="0" dy="1" stdDeviation="1" flood-color="#000000" flood-opacity="0.2"/>
                            </filter>
                            <filter id="badge-shadow" x="-50%" y="-50%" width="200%" height="200%">
                                <feDropShadow dx="0.5" dy="1" stdDeviation="1.5" flood-color="#000000" flood-opacity="0.35"/>
                            </filter>
                        </defs>
                        <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" fill="${progressColorVar}" style="pointer-events: none;" filter="url(#heart-shadow)"></path>
                        ${readCount > 0 ? `
                        <g transform="translate(18, 6.5)" style="pointer-events: none;" filter="url(#badge-shadow)">
                            <circle r="5.5" fill="#f8f9fa" stroke="${progressColorVar}" stroke-width="1"></circle>
                            <text x="0" y="0.5" text-anchor="middle" dominant-baseline="central" fill="${progressColorVar}" font-size="8px" font-weight="bold" font-family="var(--font-body)">
                                ${readCount}
                            </text>
                        </g>
                        ` : ''}
                    </svg>
                </button>
            `;

                    const categoryOptions = App.settings.get('userCategories').map(cat =>
                        `<option value="${cat.name}" ${article.category === cat.name ? 'selected' : ''}>${App.util.getCategoryDisplayName(cat.name)}</option>`
                    ).join('');

                    // --- NEW DYNAMIC BUTTON LOGIC (Enhanced Picker) ---
                    const textColors = ['text-red', 'text-green', 'text-blue', 'text-magenta', 'text-orange', 'text-teal', 'text-slate'];
                    const currentTextColorIndex = App.settings.get('textColorCycleIndex') || 0;
                    const colorToShowCssVar = `var(--${textColors[currentTextColorIndex]})`;

                    const colorOptionsHTML = textColors.map((color, index) => `
                        <div class="color-circle-btn ${index === currentTextColorIndex ? 'active' : ''}"
                             style="background-color: var(--${color})"
                             onmousedown="event.preventDefault()"
                             onclick="App.events.selectTextColor('${color}')"
                             title="${color.replace('text-', '')}">
                        </div>
                    `).join('');

                    const textColorButtonHTML = `
                <div class="color-picker-group" id="text-color-picker-group">
                    <button class="btn-icon" onmousedown="event.preventDefault()" onclick="App.events.toggleTextColorPopover(event)" title="Text Color Picker (Hover/Click)" aria-label="Text Color Picker">
                        <svg width="24" height="24" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="10" fill="${colorToShowCssVar}" stroke="var(--border-color)" stroke-width="1.5"></circle>
                        </svg>
                    </button>
                    <div class="color-picker-popover" id="text-color-popover" onmousedown="event.preventDefault()" onclick="event.stopPropagation()">
                        ${colorOptionsHTML}
                    </div>
                </div>
            `;

                    const shareButtonHTML = navigator.share ? `
                <button class="btn-icon" data-action="shareArticle" title="Share Article">
                   <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>
                </button>
            ` : '';

                    controlsContainer.innerHTML = `
                <div class="controls-wrapper read-mode-controls" style="gap:6px; padding: 0 8px;">
                    <!-- 1. Category (Left) -->
                    <button class="btn-icon" data-action="goToCategory" title="Go to Category View" aria-label="Go to category view">${App.util.icons.category}</button>
                    
                    <!-- 2. Cycle (Ambiance) - Left of Whiteboard -->
                    <button class="btn-icon" onclick="App.events.cycleReaderTheme()" oncontextmenu="event.preventDefault(); App.events.cycleReaderTheme(true)" ondblclick="event.preventDefault(); App.events.resetReaderTheme()" title="Cycle Ambiance (C, Right-click back, Double-click reset)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg>
                    </button>

                    <!-- 3. Whiteboard (Left of Heart) -->
                     <button class="btn-icon" onclick="App.whiteboard.open('end')" title="Quick Sketch / Whiteboard" aria-label="Open whiteboard annotation">
                        <i class="fa-solid fa-pen-nib"></i>
                    </button>

                    <!-- 4. Heart (Center) -->
                    ${newHeartButtonHTML}

                    <!-- 5. Edit (Right of Heart) -->
                    <button class="btn-icon" data-action="switchToWrite" title="Edit Article (E)" aria-label="Edit article">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                    </button>

                    <!-- 6. Export Popover -->
                    <div class="control-group-popover">
                        <button class="btn-icon" id="export-popover-btn" title="Export Options" aria-label="Export options">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/></svg>
                        </button>
                        <div class="popover-menu">
                            <button class="btn-icon" data-action="copyHighlights" title="Copy Title &amp; Highlights">${App.util.icons.copy}</button>
                            <button class="btn-icon" data-action="exportHtml" title="Export as HTML File">${App.util.icons.html}</button>
                            ${shareButtonHTML}
                            <button class="btn-icon" data-action="exportNoteKash" title="Export as .notekash File">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z"/>
                                </svg>
                            </button>
                            <button class="btn-icon" data-action="exportPdf" title="Export as PDF Document">${App.util.icons.pdfExport}</button>
                        </div>
                    </div>

                    <!-- 7. Immersive (Rightmost & Polished) -->
                    <button class="btn-icon" data-action="toggleFocusMode" title="Fullscreen Read Mode (F)" aria-label="Toggle fullscreen read mode">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.8">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M4 8V6a2 2 0 012-2h2M4 16v2a2 2 0 002 2h2M16 4h2a2 2 0 012 2v2M16 20h2a2 2 0 002-2v-2M12 9a3 3 0 100 6 3 3 0 000-6z" />
                        </svg>
                    </button>
                </div>
                <div class="controls-wrapper write-mode-controls">
                    <!-- 1. Microphone -->
                    <button class="btn-icon" id="record-audio-btn" onclick="App.audio.toggleRecording()" title="Start/Stop Recording" aria-label="Start or stop audio recording">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
                    </button>

                    <!-- 2. AI Flash -->
                    <button class="btn-icon" onclick="App.events.openCommandPaletteFromButton()" title="Open Command Palette (/)" aria-label="Open command palette">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M5.52.359A.5.5 0 0 1 6 0h4a.5.5 0 0 1 .474.658L8.694 6H12.5a.5.5 0 0 1 .395.807l-7 9a.5.5 0 0 1-.873-.454L6.823 9.5H3.5a.5.5 0 0 1-.48-.641l2.5-8.5z"/></svg>
                    </button>

                    <!-- 3. Color Circle -->
                    ${textColorButtonHTML}

                    <!-- 4. Insert Group (Table, Accordion, Gallery) -->
                    <div class="insert-toolbar-group" id="insert-group">
                        <button class="btn-icon" title="Insert Items" aria-label="Insert items">
                            <i class="fa-solid fa-layer-group" style="font-size: 18px;"></i>
                        </button>
                        <div class="insert-popover">
                            <button class="btn-icon" title="Manage Table" data-action="manageTable" onmousedown="event.preventDefault()" aria-label="Insert or modify table">${App.util.icons.table}</button>
                            <button class="btn-icon" title="Insert Accordion Card" data-action="insertAccordion" onmousedown="event.preventDefault()" aria-label="Insert accordion card">
                                ${App.util.icons.accordion}
                            </button>
                            <button class="btn-icon" title="Insert Image from Gallery" onmousedown="event.preventDefault()" onclick="document.getElementById('write-mode-image-input').click()" aria-label="Insert image from gallery">
                                ${App.util.icons.image}
                            </button>
                            <button class="btn-icon" title="Import PDF" onmousedown="event.preventDefault()" onclick="App.pdf.triggerImport()" aria-label="Import PDF">
                                ${App.util.icons.pdf}
                            </button>
                            <button class="btn-icon" title="Insert Checkbox" data-action="insertCheckbox" onmousedown="event.preventDefault()" aria-label="Insert checkbox">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path><polyline points="9 11 12 14 22 4"></polyline></svg>
                            </button>
                            <!-- Moved Pen (Focus Mode) to Insert Menu for Mobile Optimization -->
                            <button class="btn-icon" data-action="toggleFocusMode" title="Focus Mode" onmousedown="event.preventDefault()" aria-label="Toggle focus mode">${App.util.icons.pen}</button>
                        </div>
                    </div>
                    <input type="file" id="write-mode-image-input" accept="image/*" style="display:none" onchange="App.events.handleWriteModeImageUpload(event)">

                    <!-- Divider -->
                    <div class="control-divider"></div>

                    <!-- 6. Save/Read (Brown Bookmark Circle - Masterpiece) -->
                    <button class="btn-icon btn-save-circle" data-action="saveAndRead" title="Done Editing (Finish & Read)" aria-label="Save and switch to read mode">
                         <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"> <path d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"/> </svg>
                         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="position:absolute;">
                            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
                        </svg>
                    </button>
                    
                    <!-- 7. Category Selector -->
                    <div class="category-select-wrapper">
                        <select id="category-selector" class="category-pill-select" aria-label="Select article category">${categoryOptions}</select>
                    </div>

                    <!-- 8. Trash -->
                    <button class="btn-icon" data-action="deleteArticle" title="Delete Article" aria-label="Delete article"><i class="fa-solid fa-trash-can" style="font-size: 17px;"></i></button>

                    <!-- Divider -->
                    <div class="control-divider"></div>

                    <!-- 9. List Group -->
                    <div class="list-toolbar-group" id="list-group">
                        <button class="btn-icon" title="List Styles" aria-label="List formatting options"><i class="fa-solid fa-list-check" style="font-size: 17px;"></i></button>
                        <div class="list-popover">
                            <button class="btn-icon" title="Bulleted List" data-action="execCommand" data-value="insertUnorderedList" onmousedown="event.preventDefault()"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm-3 1a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/></svg></button>
                            <button class="btn-icon" title="Numbered List (1,2,3)" data-action="execCommand" data-value="insertOrderedList" onmousedown="event.preventDefault()"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 1.222V2.5h1V.5H.5v.722zM1.354 4.08V3.34h-.843v.74h.843zM1.354 5.21V4.47h-.843v.74h.843zm.353 1.63h-.843V6.1h.843v.74zm-.002 1.144h-.843v.74h.843v-.74zM1.354 9.17V8.43h-.843v.74h.843zm.353 1.63h-.843v-.74h.843v.74zm0 1.144h-.843v.74h.843v-.74z"/><path d="M5.5 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM5.5 7.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0 4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5z"/></svg></button>
                            <button class="btn-icon" title="Lettered List (a,b,c)" data-action="applyListStyle" data-value="ordered-alpha" onmousedown="event.preventDefault()"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M5.286 14H3.945L1.81 7.643h1.39l1.412 4.158h.053l1.412-4.158h1.39L5.286 14zM13.385 7.643h-1.39L10.58 4h1.42l1.385 3.643zM11.95 5.07c.053.15.1.32.14.51h.053c.04-.19.087-.36.14-.51L12.89 3.5h-1.8L11.95 5.07zM12 14a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5zm0-1a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z"/></svg></button>
                            <button class="btn-icon" title="Triangle Bullet" data-action="applyListStyle" data-value="bullet-triangle" onmousedown="event.preventDefault()"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="m13.142 8.285-9.428 5.443a.5.5 0 0 1-.715-.434V2.706a.5.5 0 0 1 .715-.434l9.428 5.443a.5.5 0 0 1 0 .868z"/></svg></button>
                            <button class="btn-icon" title="Circle Bullet" data-action="applyListStyle" data-value="bullet-empty-circle" onmousedown="event.preventDefault()"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/></svg></button>
                            <button class="btn-icon" title="Square Bullet" data-action="applyListStyle" data-value="bullet-square" onmousedown="event.preventDefault()">
                            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2z"/></svg></button>
                        </div>
                    </div>

                    <!-- 10. Format Group (Restored Paragraph Icon) -->
                    <div class="format-toolbar-group" id="format-group">
                        <button class="btn-icon" title="Text Formatting" aria-label="Text formatting options">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M13 4v16"></path><path d="M17 4v16"></path><path d="M19 4H9.5a4.5 4.5 0 0 0 0 9H13"></path></svg>
                        </button>
                        <div class="format-popover" id="format-popover">
                                <button class="btn-icon" title="Bold (Cmd/Ctrl+B)" data-action="execCommand" data-value="bold" onmousedown="event.preventDefault()" aria-label="Bold text"><b>B</b></button>
                                <button class="btn-icon" title="Italic (Cmd/Ctrl+I)" data-action="execCommand" data-value="italic" onmousedown="event.preventDefault()" aria-label="Italicize text"><i>I</i></button>
                                <button class="btn-icon" title="Underline (Cmd/Ctrl+U)" data-action="execCommand" data-value="underline" onmousedown="event.preventDefault()" aria-label="Underline text"><u>U</u></button>
                        </div>
                    </div>

                    </div>
                </div>
            `;
                    if (App.audio.isRecording) {
                        const recordBtn = controlsContainer.querySelector('#record-audio-btn');
                        if (recordBtn) recordBtn.classList.add('is-recording');
                    }
                    const heartButton = controlsContainer.querySelector('#unified-heart-btn');
                    if (heartButton) {
                        let clickTimer = null;

                        heartButton.addEventListener('click', () => {
                            clearTimeout(clickTimer);
                            clickTimer = setTimeout(() => {
                                App.events.finishArticle();
                            }, 450);
                        });

                        heartButton.addEventListener('dblclick', () => {
                            clearTimeout(clickTimer);
                            App.events.resetReadCount();
                        });
                        heartButton.addEventListener('contextmenu', (event) => {
                            event.preventDefault();
                        });
                    }
                },

                renderCategoryView(container, data) {
                    const category = typeof data === 'string' ? data : data.category;
                    const articleIdToFocus = typeof data === 'object' ? data.articleId : null;
                    const isAllCategory = category === 'All';
                    const layoutMode = App.settings.get('categoryLayout') || 'list';
                    const highlightsVisible = App.settings.get('categoryHighlightsVisible') !== false;
                    const sortBy = App.settings.get('categorySortBy') || 'updatedAt';

                    const sortedArticles = App.services.export.getSortedArticlesForCategory(category);

                    if (layoutMode === 'timeline') {
                        if (sortBy === 'updatedAt') {
                            sortedArticles.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                        } else {
                            sortedArticles.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
                        }
                    }

                    // OPTIMIZATION: Fast Filter using String Search instead of full DOM parsing
                    const articlesToRender = sortedArticles.filter(article => {
                        const c = article.content || '';
                        return c.includes('highlight-') || c.includes('==') || c.includes('nk-mcq') || c.includes('nk-timeline');
                    });

                    // Store rendering state for Virtualization
                    App.state.categoryRender = {
                        articles: articlesToRender, // Raw articles, snippets extract JIT
                        currentIndex: 0,
                        layoutMode,
                        isRendering: true
                    };

                    container.innerHTML = `
            <div class="category-view-container ${!highlightsVisible ? 'hide-snippet-colors' : ''} ${layoutMode === 'grid' ? 'grid-mode-active' : ''}" data-category="${category}">
                <div class="category-controls-hub">
                    <h2 style="margin:0;">${isAllCategory ? 'All Snippets' : `Category: ${App.util.getCategoryDisplayName(category)}`}</h2>
                    <div class="category-controls-group">
                        <button class="btn-icon" title="Present Category" onclick="App.events.enterFocusModeForCategory('${category}')">
                            ${App.util.icons.present}
                        </button>
                        <div class="layout-toggle-btn">
                            <button class="btn-icon ${layoutMode === 'list' ? 'active' : ''}" id="layout-btn-list" title="List View"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" /></svg></button>
                            <button class="btn-icon ${layoutMode === 'grid' ? 'active' : ''}" id="layout-btn-grid" title="Grid View"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6A2.25 2.25 0 016 3.75h2.25A2.25 2.25 0 0110.5 6v2.25a2.25 2.25 0 01-2.25 2.25H6A2.25 2.25 0 013.75 8.25V6zM3.75 15.75A2.25 2.25 0 016 13.5h2.25a2.25 2.25 0 012.25 2.25V18a2.25 2.25 0 01-2.25 2.25H6A2.25 2.25 0 013.75 18v-2.25zM13.5 6A2.25 2.25 0 0115.75 3.75h2.25A2.25 2.25 0 0120.25 6v2.25a2.25 2.25 0 01-2.25 2.25H15.75A2.25 2.25 0 0113.5 8.25V6zM13.5 15.75A2.25 2.25 0 0115.75 13.5h2.25a2.25 2.25 0 012.25 2.25V18a2.25 2.25 0 01-2.25 2.25H15.75A2.25 2.25 0 0113.5 18v-2.25z" /></svg></button>
                            <button class="btn-icon ${layoutMode === 'timeline' ? 'active' : ''}" id="layout-btn-timeline" title="Timeline View"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25H12" /></svg></button>
                        </div>
                        <select id="category-sort-filter" class="btn btn-secondary" aria-label="Sort snippets by">
                            <option value="updatedAt">Last Created</option>
                            <option value="createdAt">First Created</option>
                            <option value="read">Read</option>
                            <option value="unread">Unread</option>
                            <option value="random">Random</option>
                        </select>
                        <div class="toggle-switch" id="highlight-toggle" title="Toggle Highlight Colors"></div>
                        <div class="export-dropdown-container">
                            <button class="btn btn-primary" onclick="this.nextElementSibling.classList.toggle('show'); event.stopPropagation();">Export</button>
                            <div class="export-dropdown-menu">
                                <button class="btn btn-secondary" onclick="App.services.export.copyCategoryContent('${category}')">Copy Text</button>
                                <button class="btn btn-secondary" onclick="App.services.export.copyCategoryContentAsMarkdown('${category}')">Copy MD</button>
                                <button class="btn btn-secondary ${!App.license.isPremium() ? 'premium-feature-locked' : ''}" onclick="if(App.license.isPremium()) App.services.export.categoryAsText('${category}'); else App.ui.showAscensionModal();">.TXT</button>
                                <button class="btn btn-secondary ${!App.license.isPremium() ? 'premium-feature-locked' : ''}" onclick="if(App.license.isPremium()) App.services.export.exportCategoryAsHtml('${category}'); else App.ui.showAscensionModal();">.HTML</button>
                                <button class="btn btn-secondary" onclick="App.services.export.categoryAsPdf('${category}')">PDF Output</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="sectional-card-container ${layoutMode === 'timeline' ? 'is-timeline' : ''}" id="category-card-container">
                    ${articlesToRender.length === 0 ? `<div class="empty-state" style="grid-column: 1 / -1;"><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg><h3>No Highlights in this Category</h3><p>Use ==highlights== in your notes to see them here.</p></div>` : ''}
                </div>
                <!-- Sentinel for Infinite Scroll -->
                <div id="category-sentinel" style="height: 20px; width: 100%; margin-top: 20px;"></div>
            </div>`;

                    if (articlesToRender.length > 0) {
                        let initialBatchCount = 10;
                        if (articleIdToFocus) {
                            const targetIndex = articlesToRender.findIndex(a => a.id === articleIdToFocus);
                            if (targetIndex >= 0) {
                                initialBatchCount = targetIndex + 5;
                            }
                        }

                        this.renderCategoryBatch(initialBatchCount);

                        const sentinel = document.getElementById('category-sentinel');
                        if (sentinel) {
                            if (App.state.categoryObserver) App.state.categoryObserver.disconnect();
                            App.state.categoryObserver = new IntersectionObserver((entries) => {
                                if (entries[0].isIntersecting) {
                                    this.renderCategoryBatch(10); // Render next 10
                                }
                            }, { rootMargin: '400px' });
                            App.state.categoryObserver.observe(sentinel);
                        }
                    }

                    document.getElementById('category-sort-filter').value = sortBy;
                    document.getElementById('category-sort-filter').addEventListener('change', (e) => App.events.changeCategorySort(e, category));

                    const highlightToggle = document.getElementById('highlight-toggle');
                    highlightToggle.addEventListener('click', App.events.toggleCategoryHighlights);
                    const isHiding = container.classList.contains('hide-snippet-colors');
                    highlightToggle.classList.toggle('active', !isHiding);

                    document.getElementById('layout-btn-list').addEventListener('click', () => App.events.setCategoryLayout('list'));
                    document.getElementById('layout-btn-grid').addEventListener('click', () => App.events.setCategoryLayout('grid'));
                    document.getElementById('layout-btn-timeline').addEventListener('click', () => App.events.setCategoryLayout('timeline'));

                    document.addEventListener('click', (e) => {
                        const dropdown = document.querySelector('.export-dropdown-menu');
                        if (dropdown && dropdown.classList.contains('show') && !e.target.closest('.export-dropdown-container')) {
                            dropdown.classList.remove('show');
                        }
                    }, { once: true });

                    if (articleIdToFocus) {
                        setTimeout(() => {
                            const targetCard = document.getElementById(`summary-${articleIdToFocus}`);
                            if (targetCard) {
                                targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                targetCard.style.transition = 'box-shadow 0.5s ease-in-out';
                                targetCard.style.boxShadow = `0 0 20px 5px var(--primary-color)`;
                                setTimeout(() => { targetCard.style.boxShadow = ''; }, 2500);
                            }
                        }, 100);
                    }
                },

                renderCategoryBatch(count) {
                    const container = document.getElementById('category-card-container');
                    if (!container) return;

                    const state = App.state.categoryRender;
                    const endIndex = Math.min(state.currentIndex + count, state.articles.length);

                    let html = '';
                    const buildSectionalCardHTML = (article) => {
                        // JIT Snippet Extraction
                        if (!article.snippets) {
                            // FIXED: Extract ALL snippet types to ensure MCQs and Charts are present for both Category View and future Focus Mode sessions
                            let snippets = App.util.extractSnippets(article, ['highlight', 'mcq', 'blocks', 'cloze'], true);
                            snippets = snippets.filter(s => !s.html.includes('class="rendered-tag"'));
                            article.snippets = snippets;
                        }

                        if (article.snippets.length === 0) return ''; // Skip if no snippets found after parsing

                        // FIXED: Filter for DISPLAY only. We have everything in cache for Focus Mode, 
                        const displaySnippets = article.snippets.filter(s => s.type === 'snippet');

                        if (displaySnippets.length === 0) return '';

                        const snippetHTML = displaySnippets.map(s => `<div class="snippet" style="cursor: pointer;" onclick="App.router.navigateTo('article', {id: '${s.articleId}', mode: 'read', scrollToSnippetId: '${s.id}'})">${s.html}</div>`).join('');

                        return `<div class="sectional-card-header">
                                <h3 class="sectional-card-title" onclick="App.router.navigateTo('article', {id: '${article.id}', mode: 'read'})">${article.title}</h3>
                                <div class="category-controls-group">
                                    <button class="btn-icon" title="Present Article" onclick="App.events.enterFocusMode('${article.id}')">
                                        ${App.util.icons.present}
                                    </button>
                                </div>
                            </div>
                            <div class="sectional-card-body">${snippetHTML}</div>`;
                    };

                    for (let i = state.currentIndex; i < endIndex; i++) {
                        const article = state.articles[i];
                        const cardContent = buildSectionalCardHTML(article);

                        if (cardContent) { // Only append if content exists
                            if (state.layoutMode === 'timeline') {
                                const formattedDate = new Date(article.createdAt).toLocaleDateString(undefined, { day: 'numeric', month: 'short' });
                                html += `<div class="timeline-entry" style="animation-delay: ${(i - state.currentIndex) * 50}ms;">
                                    <div class="timeline-marker">
                                        <div class="timeline-date">${formattedDate}</div>
                                    </div>
                                    <div class="sectional-card" id="summary-${article.id}">
                                        ${cardContent}
                                    </div>
                                </div>`;
                            } else {
                                html += `<div class="sectional-card" id="summary-${article.id}">${cardContent}</div>`;
                            }
                        }
                    }

                    container.insertAdjacentHTML('beforeend', html);
                    state.currentIndex = endIndex;
                },

                renderTagsView(container) {
                    const sortBy = App.settings.get('tagSortBy');

                    container.innerHTML = `
                <div class="tags-view-container ui-card">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 24px; flex-wrap: wrap; gap: 1rem;">
                        <div class="search-bar-container" style="flex-basis: 300px; flex-grow: 1;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>
                            <input type="text" id="tag-search-input" placeholder="Search tags..." aria-label="Search tags">
                        </div>
                        <select id="tag-sort-filter" class="btn btn-secondary" aria-label="Sort tags by">
                            <option value="alpha" ${sortBy === 'alpha' ? 'selected' : ''}>Alphabetical</option>
                            <option value="date-new" ${sortBy === 'date-new' ? 'selected' : ''}>Newest</option>
                            <option value="date-old" ${sortBy === 'date-old' ? 'selected' : ''}>Oldest</option>
                            <option value="random" ${sortBy === 'random' ? 'selected' : ''}>Random</option>
                        </select>
                    </div>
                    <div id="tag-cloud-container"></div>
                </div>`;
                    App.events.filterAndRenderTags();
                },

                renderFlashcardView(container) {
                    const category = App.settings.get('flashcardCategory') || 'All';
                    const sortBy = App.settings.get('flashcardSortBy');

                    const nameStyle = App.settings.get('categoryNameStyle') || 'full';

                    const userCategories = App.settings.get('userCategories');
                    const allCategoryNames = ['All', ...userCategories.map(c => c.name)];

                    const categoryChips = allCategoryNames.map(catName => {
                        const isActive = category === catName;
                        let buttonText;
                        const fullDisplayName = App.util.getCategoryDisplayName(catName);
                        if (catName === 'All') {
                            buttonText = 'All';
                        } else {
                            buttonText = (nameStyle === 'full') ? fullDisplayName : fullDisplayName.substring(0, 4);
                        }

                        const titleText = (catName === 'All') ? 'All' : fullDisplayName;
                        const categoryObj = userCategories.find(c => c.name === catName);
                        const colorIndex = categoryObj ? categoryObj.colorIndex : 0;

                        const style = catName === 'All'
                            ? ''
                            : `style="background-color: var(--cat-color-${colorIndex}-bg); color: var(--category-pill-text);"`;

                        return `<button class="btn category-chip ${isActive ? 'active' : ''}" ${style} onclick="App.events.changeFlashcardCategory('${catName}')" title="${titleText}">${buttonText}</button>`;
                    }).join('');

                    container.innerHTML = `
                <div class="flashcard-view-header">
                    <div style="display: flex; align-items: stretch; gap: 0.75rem; flex-wrap: wrap; width: 100%;">
                        <div style="display: flex; align-items: stretch; ">
                            <button class="btn btn-primary" onclick="App.events.study.start()">Study Session</button>
                        </div>
                        <button class="btn btn-secondary" onclick="App.events.study.start({ mode: 'allDue' })" title="Study ALL due cards without a limit">S-Due Cards</button>
                        <button class="btn btn-secondary" onclick="App.events.study.start({ mode: 'mcqOnly' })" title="Study only Multiple-Choice Questions from this deck">S-MCQ</button>
                        <button class="btn btn-primary btn-quiz" onclick="App.quiz.start()">Recall Quiz</button>
                        <button class="btn btn-primary btn-quiz" onclick="App.quiz.start({ mode: 'mcq' })">MCQ Quiz</button>
                        <button class="btn btn-danger" onclick="App.events.resetFilteredFlashcardsConfirmation()" title="Reset progress for all cards in the current filter">Reset</button>
                        <button class="btn-icon" onclick="App.ui.showFlashcardSettingsModal()" title="Flashcard Settings">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311a1.464 1.464 0 0 1 0 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105 0l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.31-.17a1.464 1.464 0 0 1 2.105-.872l-.1-.34c.413-1.4 2.397-1.4 2.81 0l.1.34a1.464 1.464 0 0 1 2.105.872l.31.17c1.283.698-2.686-.705-1.987-1.987l-.169-.311a1.464 1.464 0 0 1 0-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105 0l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.31.17a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/></svg>
                        </button>
                    </div>
                    <div class="category-filters" style="width: 100%;">${categoryChips}</div>
                </div>
                <div style="display:flex; gap: 1rem; align-items:center; margin-bottom: 1.5rem;">
                    <div class="search-bar-container">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>
                        <input type="text" id="flashcard-search-input" placeholder="Search flashcards (Press 'S' to focus)..." aria-label="Search flashcards">
                    </div>
                    <select id="flashcard-sort" class="btn btn-secondary" aria-label="Sort flashcards by">
                        <option value="sm2" ${sortBy === 'sm2' ? 'selected' : ''}>Sort by SRS</option>
                        <option value="mcq" ${sortBy === 'mcq' ? 'selected' : ''}>Sort by MCQ</option>
                        <option value="random" ${sortBy === 'random' ? 'selected' : ''}>Sort by Random</option>
                        <option value="createdAt-desc" ${sortBy === 'createdAt-desc' ? 'selected' : ''}>Sort by Newest</option>
                        <option value="createdAt-asc" ${sortBy === 'createdAt-asc' ? 'selected' : ''}>Sort by Oldest</option>
                        <option value="read" ${sortBy === 'read' ? 'selected' : ''}>Sort by Read</option>
                        <option value="unread" ${sortBy === 'unread' ? 'selected' : ''}>Sort by Unread</option>
                        <option value="leeches" ${sortBy === 'leeches' ? 'selected' : ''}>Sort by Leeches</option>
                    </select>
                    <div class="export-dropdown-container">
                        <button class="btn btn-primary" onclick="this.nextElementSibling.classList.toggle('show'); event.stopPropagation();">Export</button>
                        <div class="export-dropdown-menu">
                            <div class="${!App.license.isPremium() ? 'premium-feature-locked' : ''}" style="width:100%;">
                                <button class="btn btn-secondary" style="width:100%;" onclick="if(App.license.isPremium()) App.services.export.exportFlashcardsAsTxt(); else { App.ui.showAscensionModal(); this.parentElement.parentElement.classList.remove('show'); }">.TXT</button>
                            </div>
                            <div class="${!App.license.isPremium() ? 'premium-feature-locked' : ''}" style="width:100%;">
                                <button class="btn btn-secondary" style="width:100%;" onclick="if(App.license.isPremium()) App.services.export.exportFlashcardsAsTsv(); else { App.ui.showAscensionModal(); this.parentElement.parentElement.classList.remove('show'); }">.TSV (Anki)</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flashcard-grid" id="flashcard-grid"></div>
            `;
                    this.filterAndRenderFlashcards();
                },


                filterAndRenderFlashcards() {
                    const grid = document.getElementById('flashcard-grid');
                    if (!grid) return;

                    const searchTerm = document.getElementById('flashcard-search-input')?.value || '';
                    let filteredFlashcards = App.util.getSortedFlashcardsForDisplay(searchTerm);

                    const isPremium = App.license.isPremium();
                    const flashcardLimit = App.config.sparkTierLimit;
                    const totalFlashcards = App.util.getAllFlashcards().length;

                    if (!isPremium) {
                        // If the user is not premium, ALWAYS add the upsell tile first.
                        filteredFlashcards.unshift({
                            type: 'premium-upsell-tile',
                            used: totalFlashcards,
                            limit: flashcardLimit
                        });

                        // Then, slice the array of actual flashcards to enforce the limit.
                        filteredFlashcards = filteredFlashcards.slice(0, flashcardLimit + 1); // +1 to keep the upsell tile
                    }

                    if (filteredFlashcards.length === 0) {
                        grid.innerHTML = `<div class="empty-state" style="grid-column: 1 / -1;"><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1"><path stroke-linecap="round" stroke-linejoin="round" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z" /></svg><h3>No Flashcards Found</h3><p>Create flashcards using {{c1::your text}} or accordions in an article.</p></div>`;
                    } else {
                        grid.innerHTML = filteredFlashcards.map(this.getFlashcardTileHTML).join('');
                    }

                    const visibleCards = Array.from(grid.querySelectorAll('.flashcard-tile'));
                    const isSearching = searchTerm.trim() !== '';

                    visibleCards.forEach(card => card.classList.toggle('search-highlight-card', isSearching));
                    document.querySelectorAll('.flashcard-tile.search-selected-card').forEach(c => c.classList.remove('search-selected-card'));

                    App.state.flashcardRender.searchResults = isSearching ? visibleCards : [];
                    App.state.flashcardRender.selectedIndex = -1;

                    if (isSearching && visibleCards.length > 0) {
                        App.state.flashcardRender.selectedIndex = 0;
                        visibleCards[0].classList.add('search-selected-card');
                    }
                },


                getFlashcardTileHTML(flashcard) {
                    if (flashcard.type === 'premium-upsell-tile') {
                        const actualUsed = flashcard.used;
                        const limit = flashcard.limit;
                        const displayUsed = Math.min(actualUsed, limit);
                        const percentageUsed = Math.min(100, Math.round((actualUsed / limit) * 100));

                        return `
                    <div class="flashcard-tile premium-upsell-tile" onclick="App.ui.showAscensionModal()">
                        <div class="upsell-badge"> Spark Tier</div>
                        <div class="upsell-content">
                            <h4>Unlock Unlimited Cards</h4>
                            <p>Quota used: <strong>${percentageUsed}%</strong> <i> (${displayUsed} of ${limit} flashcards) </i>. Go Premium to Go Unlimited!</p>
                            <div class="upsell-progress-bar">
                                <div class="upsell-progress" style="width: ${percentageUsed}%;"></div>
                            </div>
                        </div>
                        <div class="upsell-cta">Go Premium</div>
                    </div>`;
                    }

                    const color = App.util.sm2.getRatingColor(flashcard.rating);
                    let cardFront, cardBack;

                    //  NEW: Leech indicator logic.
                    const leechIndicator = (flashcard.lapses || 0) >= App.config.sm2.leechThreshold
                        ? '<span title="Leech Card: This card is difficult for you. Consider rephrasing it." style="cursor: help;"></span> '
                        : '';

                    if (flashcard.type === 'collapsible') {
                        const reversibleIndicator = flashcard.isReversed ? `<span class="reversible-indicator" title="Reversible Card (Answer Side)">${App.util.icons.reversible}</span>` : '';
                        cardFront = leechIndicator + flashcard.frontText + reversibleIndicator;
                        cardBack = flashcard.backText;
                    } else if (flashcard.type === 'mcq') {
                        cardFront = leechIndicator + flashcard.question;
                        const correctOption = flashcard.options.find(opt => opt.isCorrect);
                        const answerText = correctOption ? correctOption.text : 'N/A';
                        let explanationHTML = '';
                        if (flashcard.explanation) {
                            explanationHTML = `<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color); font-size: 0.85em; color: var(--text-secondary);">${flashcard.explanation}</div>`;
                        }
                        cardBack = `<p><b>Correct:</b> ${answerText}</p>${explanationHTML}`;
                    } else if (flashcard.type === 'image-occlusion') {
                        // Image Occlusion: show front (with tape) and back (revealed)
                        const occlusionIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><rect x="7" y="7" width="4" height="4" rx="1" fill="currentColor"/><rect x="13" y="13" width="4" height="4" rx="1" fill="currentColor"/></svg>`;
                        cardFront = `${leechIndicator}<div class="vfc-tile-image"><img src="${flashcard.frontImage}" alt="Question" style="max-width:100%; max-height:200px; border-radius:8px; object-fit:contain;"></div><span class="vfc-badge" title="Image Occlusion Card">${occlusionIcon}</span>`;
                        cardBack = `<div class="vfc-tile-image"><img src="${flashcard.backImage}" alt="Answer" style="max-width:100%; max-height:200px; border-radius:8px; object-fit:contain;"></div>`;
                    } else { // Default to legacy cloze
                        const parsedFullText = App.util.parseShortcuts(flashcard.fullText);
                        // FIX: Updated regex to [\s\S]*?
                        // FIX: Safe Regex with Negative Lookahead to prevent runaway matching
                        cardFront = leechIndicator + parsedFullText.replace(/{{c\d+::((?:(?!{{c\d+::)[\s\S])*?)}}/g, '<strong class="cloze-hidden">[?]</strong>');
                        cardBack = parsedFullText.replace(/{{c\d+::((?:(?!{{c\d+::)[\s\S])*?)}}/g, '<span class="cloze-revealed-wrapper"><strong class="cloze-revealed">$1</strong></span>');
                    }

                    let reviewInfo = 'New Card';
                    if (flashcard.nextReviewDue) {
                        const nextDate = new Date(flashcard.nextReviewDue);
                        const now = new Date();
                        const options = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
                        if (nextDate > now) {
                            reviewInfo = `Next: ${nextDate.toLocaleString('en-GB', options)}`;
                        } else {
                            reviewInfo = 'Review Due!';
                        }
                    }

                    return `
                <div class="flashcard-tile" style="border-left-color: ${color};" 
                    onclick="this.classList.toggle('is-flipped')" 
                    oncontextmenu="App.events.flashcardContextMenu(event, '${flashcard.id}')"
                    title="Click to flip, right-click for options">
                    <div class="flashcard-tile-flipper">
                        <div class="flashcard-tile-face flashcard-tile-front">
                            <div class="flashcard-tile-content">${cardFront}</div>
                            <div class="flashcard-tile-footer">
                                <button class="btn-icon" title="Go to Source Article" onclick="event.stopPropagation(); App.router.navigateTo('article', {id: '${flashcard.articleId}', mode: 'read'})">${App.util.icons.article}</button>
                                <button class="btn-icon" title="Delete Card" onclick="event.stopPropagation(); App.events.deleteFlashcardConfirmation('${flashcard.id}')">${App.util.icons.trash}</button>
                                <button class="btn-icon" title="Reset Card Progress" onclick="event.stopPropagation(); App.events.resetFlashcard('${flashcard.id}')">${App.util.icons.reset}</button>
                                <button class="btn-icon" title="Review 1 Day Earlier" onclick="event.stopPropagation(); App.events.nudgeReviewDate('${flashcard.id}', -1)">${App.util.icons.minus}</button>
                                <button class="btn-icon" title="Review 1 Day Later" onclick="event.stopPropagation(); App.events.nudgeReviewDate('${flashcard.id}', 1)">${App.util.icons.plus}</button>
                            </div>
                        </div>
                        <div class="flashcard-tile-face flashcard-tile-back">
                            <div class="flashcard-tile-content">${cardBack}</div>
                            <div class="flashcard-tile-footer" style="justify-content:flex-end;">
                                <small>${reviewInfo}</small>
                            </div>
                        </div>
                    </div>
                </div>`;
                },

                renderStudyView(session) {
                    const container = document.getElementById('study-view-container');
                    document.documentElement.style.setProperty('--study-card-font-size', App.settings.get('studyCardFontSize') || '1.6rem');
                    if (!session.isActive || session.cards.length === 0) {
                        container.innerHTML = '';
                        document.body.classList.remove('study-mode-active', 'read-mode');
                        return;
                    }
                    document.body.classList.add('study-mode-active', 'read-mode');

                    const card = session.cards[session.currentIndex];
                    const borderColor = App.util.sm2.getRatingColor(card.rating);
                    let cardFront, cardBack, contentBoxClass = '';

                    let controlsHTML = '';
                    const isFirstCard = session.currentIndex === 0;
                    const isLastCard = session.currentIndex === session.cards.length - 1;

                    const prevButtonIcon = `<button class="btn-icon-nav" onclick="App.events.study.prev()" ${isFirstCard ? 'disabled' : ''} title="Previous Card ()">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg>
            </button>`;
                    const nextButtonIcon = `<button class="btn-icon-nav" onclick="App.events.study.next()" ${isLastCard ? 'disabled' : ''} title="Next Card ()">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" /></svg>
            </button>`;
                    const exitButtonIcon = `<button class="btn-icon-nav btn-exit-study" onclick="App.events.study.exit()" title="Exit Session (Esc)">${App.util.icons.close}</button>`;
                    const currentFontSize = App.settings.get('studyCardFontSize') || '1.6rem';
                    const fontSizeButton = `<button class="btn-icon-nav" onclick="App.events.study.toggleFontSize(this)" title="Cycle Font Size">
                <span style="font-weight: 700; font-size: 1rem;">${currentFontSize.replace('rem', '')}</span>
            </button>`;
                    const themeButtonIcon = `<button class="btn-icon-nav" title="Cycle Ambiance (C, Right-click to go back)" oncontextmenu="event.preventDefault(); App.events.study.cycleStudyTheme(true);" onclick="App.events.study.cycleStudyTheme()">${App.util.icons.theme}</button>`;

                    if (session.quizType === 'mcq') {
                        controlsHTML = `
                    <div class="study-nav-and-ratings">
                        ${prevButtonIcon}
                        ${themeButtonIcon}
                        ${nextButtonIcon}
                    </div>
                    <div class="mcq-controls-right-group">
                        ${fontSizeButton}
                        ${exitButtonIcon}
                    </div>
                `;
                    } else {
                        // New layout for SRS with corrected grouping
                        controlsHTML = `
                    <div class="study-nav-and-ratings">
                        ${prevButtonIcon}
                        ${themeButtonIcon}
                        ${nextButtonIcon}
                    </div>
                    <div class="srs-rating-group">
                        <button class="btn btn-study-rating btn-again" onclick="App.events.study.rate('Again')">Again</button>
                        <button class="btn btn-study-rating btn-hard" onclick="App.events.study.rate('Hard')">Hard</button>
                        <button class="btn btn-study-rating btn-hold" onclick="App.events.study.rate('Hold')" title="Snooze this card until tomorrow">Bury</button>
                        <button class="btn btn-study-rating btn-good" onclick="App.events.study.rate('Good')">Good</button>
                        <button class="btn btn-study-rating btn-easy" onclick="App.events.study.rate('Easy')">Easy</button>
                    </div>
                    <div class="mcq-controls-right-group">
                        ${fontSizeButton}
                        ${exitButtonIcon}
                    </div>
                `;
                    }

                    if (card.type === 'collapsible') {
                        const reversibleIndicator = card.isReversed ? `<span class="reversible-indicator" title="Reversible Card (Answer Side)">${App.util.icons.reversible}</span>` : '';
                        const hintArea = card.hint ? `<div class="study-hint-container"><button class="btn btn-secondary study-hint-btn">Show Hint</button><div class="study-hint-content" style="display: none;">${card.hint}</div></div>` : '';
                        cardFront = card.frontText + reversibleIndicator + hintArea;
                        cardBack = card.backText;
                    } else if (card.type === 'mcq') {
                        contentBoxClass = 'mcq-type';
                        const optionsHtml = card.options.map(opt => `<div class="nk-mcq-option" data-is-correct="${opt.isCorrect}">${opt.text}</div>`).join('');
                        cardFront = `<div class="nk-mcq-block" data-quiz-mode="${session.quizType}"><div class="nk-mcq-question">${card.question}</div><div class="nk-mcq-options">${optionsHtml}</div></div>`;
                        const correctOption = card.options.find(opt => opt.isCorrect);
                        let answerHTML = `<strong>Answer:</strong> <span style="color: var(--success-color);">${correctOption ? correctOption.text : 'N/A'}</span>`;
                        if (card.explanation) {
                            answerHTML += `<hr style="margin: 1rem 0;"><div style="font-size: 0.8em; color: var(--text-secondary);">${card.explanation}</div>`;
                        }
                        cardBack = `<div><div><strong>Question:</strong> ${card.question}</div><hr style="margin: 1.5rem 0;"><div>${answerHTML}</div></div>`;
                    } else if (card.type === 'image-occlusion') {
                        // Image Occlusion: show front (with tape) and back (revealed) images
                        contentBoxClass = 'image-occlusion-type';
                        cardFront = `<div class="study-vfc-image"><img src="${card.frontImage}" alt="Question - Click to reveal"></div>`;
                        cardBack = `<div class="study-vfc-image"><img src="${card.backImage}" alt="Answer"></div>`;
                    } else {
                        const parsedFullText = App.util.parseShortcuts(card.fullText);
                        // FIX: Updated regex to [\s\S]*?
                        // FIX: Safe Regex with Negative Lookahead to prevent runaway matching
                        cardFront = parsedFullText.replace(/{{c\d+::((?:(?!{{c\d+::)[\s\S])*?)}}/g, '<strong class="cloze-hidden">[?]</strong>');
                        cardBack = parsedFullText.replace(/{{c\d+::((?:(?!{{c\d+::)[\s\S])*?)}}/g, '<span class="cloze-revealed-wrapper"><strong class="cloze-revealed">$1</strong></span>');
                    }

                    const activeTheme = session.activeTheme || 'default';
                    const activeThemeClass = activeTheme !== 'default' ? `ambiance-${activeTheme}` : '';
                    const globalTheme = App.settings.get('theme');
                    let backgroundStyle = (activeTheme === 'default' && globalTheme === 'custom' && App.settings.get('backgroundImage'))
                        ? `background-image: url(${App.settings.get('backgroundImage')});`
                        : '';

                    container.innerHTML = `<div class="study-view ${activeThemeClass}" role="dialog" aria-modal="true" aria-label="Study Session">
                <div class="study-background" style="${backgroundStyle}"></div>
                <div class="study-content-container">
                    <div class="study-card" onclick="if (this.querySelector('.nk-mcq-block') && !this.querySelector('.nk-mcq-block[data-answered=true]')) return; this.classList.toggle('is-flipped')" tabindex="0" aria-label="Flashcard, press Space to flip">
                        <div class="study-card-face study-card-front"><div class="study-card-content-box ${contentBoxClass}" style="border-color: ${borderColor};">${cardFront}</div></div>
                        <div class="study-card-face study-card-back"><div class="study-card-content-box" style="border-color: ${borderColor};">${cardBack}</div></div>
                    </div>
                </div>
                <div class="study-controls-container">
                    <div class="study-progress-wrapper">
                        <progress id="study-progress-bar" class="study-progress-bar" value="${session.currentIndex + 1}" max="${session.cards.length}"></progress>
                        <div class="study-progress-counter">${session.currentIndex + 1} / ${session.cards.length}</div>
                    </div>
                    <div class="study-controls">${controlsHTML}</div>
                </div>
            </div>`;

                    // FIX #1: Add manual wheel event listener to enable scrolling on long flashcards.
                    const studyViewOverlay = container.querySelector('.study-view');
                    if (studyViewOverlay) {
                        studyViewOverlay.addEventListener('wheel', (e) => {
                            const studyCard = studyViewOverlay.querySelector('.study-card');
                            if (!studyCard) return;

                            const isFlipped = studyCard.classList.contains('is-flipped');
                            const activeFaceSelector = isFlipped ? '.study-card-back' : '.study-card-front';
                            const contentBox = studyViewOverlay.querySelector(`${activeFaceSelector} .study-card-content-box`);

                            if (contentBox && contentBox.scrollHeight > contentBox.clientHeight) {
                                e.preventDefault();
                                contentBox.scrollTop += e.deltaY;
                            }
                        }, { passive: false });
                    }

                    if (card.type === 'mcq') { container.querySelector('.study-card-front .study-card-content-box')?.addEventListener('click', (e) => App.events.handleMcqAnswer(e, true)); }
                    if (card.type === 'collapsible' && card.hint) { const hintBtn = container.querySelector('.study-hint-btn'); if (hintBtn) { hintBtn.addEventListener('click', (e) => { e.stopPropagation(); const hintContent = hintBtn.nextElementSibling; const isHidden = hintContent.style.display === 'none'; hintContent.style.display = isHidden ? 'block' : 'none'; hintBtn.textContent = isHidden ? 'Hide Hint' : 'Show Hint'; }); } }

                    const studyCardEl = container.querySelector('.study-card');
                    if (studyCardEl && card.type !== 'mcq') {
                        App.events.study.setupCardGestures(studyCardEl);
                    }

                    const keyboardHandler = session.quizType === 'mcq' ? App.quiz.handleKeyboard : App.events.study.handleKeyboard;
                    document.addEventListener('keydown', keyboardHandler.bind(App.quiz), { once: true });
                    App.util.trapFocus(container.querySelector('.study-view'));
                },

                renderStatsDashboardView(container, data) {
                    const today = new Date();
                    const selectedMonth = data?.month !== undefined ? data.month : today.getMonth();
                    const selectedYear = data?.year !== undefined ? data.year : today.getFullYear();

                    container.innerHTML = `
                <div class="stats-dashboard-view">
                    <div class="stats-header">
                        <h1 class="library-title">Stats Dashboard</h1>
                    </div>
                    <div id="stats-content-area"></div>
                </div>
            `;
                    this.renderStatsContent(document.getElementById('stats-content-area'), selectedMonth, selectedYear);

                    const readingData = App.util.getReadingChartData(selectedMonth, selectedYear);
                    const flashcardData = App.util.getFlashcardChartData(selectedMonth, selectedYear);

                    const baseColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
                    const baseColorRgb = App.util.colorToRgb(baseColor);
                    const chartFillColor = baseColorRgb ? `rgba(${baseColorRgb.join(',')}, 0.2)` : '#cccccc';

                    const readCtx = document.getElementById('readingActivityChart')?.getContext('2d');
                    if (readCtx) {
                        if (App.state.chartInstances.reading) App.state.chartInstances.reading.destroy();
                        App.state.chartInstances.reading = App.offline.safeChart(readCtx, {
                            type: 'line', data: { labels: readingData.labels, datasets: [{ label: `Articles Completed`, data: readingData.data, borderColor: baseColor, borderWidth: 2, tension: 0.4, fill: true, backgroundColor: chartFillColor }] },
                            options: { scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } } }
                        });
                    }

                    const flashCtx = document.getElementById('flashcardActivityChart')?.getContext('2d');
                    if (flashCtx) {
                        if (App.state.chartInstances.flashcard) App.state.chartInstances.flashcard.destroy();
                        App.state.chartInstances.flashcard = App.offline.safeChart(flashCtx, {
                            type: 'bar', data: { labels: flashcardData.labels, datasets: [{ label: `Flashcards Reviewed`, data: flashcardData.data, backgroundColor: baseColor }] },
                            options: { scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } } }
                        });
                    }
                    //  NEW & CORRECTED: Render Flashcard Forecast Chart
                    const forecastCtx = document.getElementById('flashcardForecastChart')?.getContext('2d');
                    if (forecastCtx) {
                        if (App.state.chartInstances.forecast) App.state.chartInstances.forecast.destroy();
                        const forecastData = App.util.getFlashcardForecastData();
                        App.state.chartInstances.forecast = App.offline.safeChart(forecastCtx, {
                            type: 'bar',
                            data: {
                                labels: Array.from({ length: 30 }, (_, i) => `+${i}d`),
                                datasets: [{
                                    label: 'Cards Due',
                                    data: forecastData,
                                    backgroundColor: chartFillColor, // Uses the correctly defined color from the parent function
                                    borderColor: baseColor,        // Uses the correctly defined color from the parent function
                                    borderWidth: 1
                                }]
                            },
                            options: {
                                scales: { y: { beginAtZero: true, ticks: { stepSize: 5 } } },
                                plugins: { legend: { display: false } }
                            }
                        });
                    }

                    //  NEW & CORRECTED: Render Card Ease Distribution Chart
                    const easeCtx = document.getElementById('cardEaseDistributionChart')?.getContext('2d');
                    if (easeCtx) {
                        if (App.state.chartInstances.ease) App.state.chartInstances.ease.destroy();
                        const easeData = App.util.getCardEaseDistributionData();
                        App.state.chartInstances.ease = App.offline.safeChart(easeCtx, {
                            type: 'doughnut',
                            data: {
                                labels: ['Leech', 'Hard', 'Normal', 'Easy', 'New'],
                                datasets: [{
                                    label: 'Card Distribution',
                                    data: [easeData.Leech, easeData.Hard, easeData.Normal, easeData.Easy, easeData.New],
                                    //  FIX: Get the computed color values directly to fix the display bug
                                    backgroundColor: [
                                        getComputedStyle(document.documentElement).getPropertyValue('--danger-color').trim(),      // Leech
                                        getComputedStyle(document.documentElement).getPropertyValue('--warning-color').trim(),     // Hard
                                        getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(),     // Normal
                                        getComputedStyle(document.documentElement).getPropertyValue('--success-color').trim(),     // Easy
                                        getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim()   // New
                                    ],
                                    borderColor: getComputedStyle(document.documentElement).getPropertyValue('--bg-primary').trim(),
                                    borderWidth: 2
                                }]
                            },
                            options: {
                                responsive: true,
                                plugins: {
                                    legend: {
                                        position: 'top',
                                    }
                                }
                            }
                        });
                    }
                    const monthSelect = document.getElementById('stats-month-select');
                    const yearSelect = document.getElementById('stats-year-select');

                    const updateView = () => {
                        const newMonth = parseInt(monthSelect.value);
                        const newYear = parseInt(yearSelect.value);
                        App.router.navigateTo('stats-dashboard', { month: newMonth, year: newYear });
                    };

                    monthSelect?.addEventListener('change', updateView);
                    yearSelect?.addEventListener('change', updateView);
                },



                renderStatsContent(container, currentMonth, currentYear) {
                    const readingStats = App.util.getReadingStats();
                    const hubStats = App.hub.util.getDashboardStats();
                    const flashcardStats = App.util.getFlashcardStats();
                    const quizStats = App.quiz.getStats();
                    const dailyStreak = App.util.calculateQuizStreak();
                    const weekCompletionData = App.util.getWeekCompletionData();
                    const todayFlashcards = App.util.getFlashcardStatsForPeriod('today').reviewed;
                    const yesterdayFlashcards = App.util.getFlashcardStatsForPeriod('yesterday').reviewed;
                    const todayArticles = App.util.getReadingStatsForPeriod('today').read;
                    const yesterdayArticles = App.util.getReadingStatsForPeriod('yesterday').read;
                    const today = new Date();
                    const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
                    const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();

                    let heatmapHtml = '';
                    for (let day = 1; day <= daysInMonth; day++) {
                        const date = new Date(Date.UTC(currentYear, currentMonth, day));
                        const dateStr = date.toISOString().slice(0, 10);
                        const seconds = hubStats.pomodoro.dailyTotals[dateStr] || 0;
                        const formattedDate = date.toLocaleDateString(undefined, { day: 'numeric', month: 'short', timeZone: 'UTC' });
                        const formattedTime = App.hub.util.formatSecondsToDecimalHours(seconds);
                        let level = 0; const hours = seconds / 3600;
                        if (hours >= 8) level = 6; else if (hours >= 6) level = 5; else if (hours >= 4.5) level = 4;
                        else if (hours >= 3) level = 3; else if (hours >= 1.5) level = 2; else if (hours >= 0.25) level = 1;
                        heatmapHtml += `<div class="heatmap-day level-${level}" title="${formattedDate}\n${formattedTime} focused"></div>`;
                    }
                    const dayOfWeek = new Date(currentYear, currentMonth, 1).getDay();
                    const startOffset = (dayOfWeek === 0 ? 6 : dayOfWeek - 1);
                    heatmapHtml = Array(startOffset).fill('<div class="heatmap-day empty"></div>').join('') + heatmapHtml;
                    const totalCells = startOffset + daysInMonth;
                    const remainingCells = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
                    heatmapHtml += Array(remainingCells).fill('<div class="heatmap-day empty"></div>').join('');

                    const categoryTimeMap = new Map(hubStats.pomodoro.categories);
                    const categoryTilesHTML = App.settings.get('userCategories').map(cat => {
                        const seconds = categoryTimeMap.get(cat.name) || 0;
                        // NEW: Apply dynamic background color
                        const backgroundColor = App.util.getCategoryColor(cat.colorIndex);
                        return `<div class="category-card"><div class="category-card-info"><div class="category-pill" style="background-color: ${backgroundColor};">${App.util.getCategoryDisplayName(cat.name)}</div></div><div class="category-card-value">${App.hub.util.formatSecondsToDecimalHours(seconds)}</div></div>`
                    }).join('');

                    const { firstYear, firstMonth } = App.util.getAppStartDate();
                    const yearOptions = [];
                    for (let y = today.getFullYear(); y >= firstYear; y--) {
                        yearOptions.push(`<option value="${y}" ${y === currentYear ? 'selected' : ''}>${y}</option>`);
                    }
                    const monthOptions = Array.from({ length: 12 }, (_, i) => {
                        const date = new Date(currentYear, i);
                        const isDisabled = currentYear === firstYear && i < firstMonth;
                        return `<option value="${i}" ${i === currentMonth ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}>${date.toLocaleString('default', { month: 'long' })}</option>`;
                    }).join('');

                    const weeklyCalendarHTML = weekCompletionData.map(day => `
                <div class="week-day ${day.isCompleted ? 'completed' : ''} ${day.isToday ? 'today' : ''}">
                    <span class="day-letter">${day.dayLetter}</span>
                    <span class="date-number">${day.dateNumber}</span>
                </div>
            `).join('');

                    container.innerHTML = `
                <div class="stats-section-title">Cards Quiz Stats</div>
                <div class="quiz-stats-container">
                    <div class="streak-container">
                        <div class="streak-display daily" title="${dailyStreak > 0 ? `You're on a ${dailyStreak}-day streak!` : 'Complete a quiz today to start a streak!'}">
                            <div class="streak-value">${dailyStreak}</div>
                            <div class="streak-label">Day Streak </div>
                        </div>
                        <div class="weekly-streak-calendar" title="Your quiz activity for the current week.">
                            ${weeklyCalendarHTML}
                        </div>
                    </div>
                    <div class="sub-stats-grid">
                        <div class="stat-card"><div class="stat-card-value">${quizStats.lastScore.toFixed(1)}</div><div class="stat-card-label">Last Score</div></div>
                        <div class="stat-card"><div class="stat-card-value">${quizStats.bestScore.toFixed(1)}</div><div class="stat-card-label">Best Score</div></div>
                        <div class="stat-card"><div class="stat-card-value">${quizStats.avgScore.toFixed(2)}</div><div class="stat-card-label">Avg. Score</div></div>
                        <div class="stat-card"><div class="stat-card-value">${quizStats.totalScore.toFixed(1)}/${quizStats.totalQuizzes * 10}</div><div class="stat-card-label">Total Score</div></div>
                    </div>
                </div>
                <div class="stats-section-title">Focus Calendar</div>
                <div class="heatmap-container"><div class="heatmap-header"><b>${monthNames[currentMonth]} ${currentYear}</b></div><div class="heatmap-grid">${heatmapHtml}</div></div>
                <div class="stats-section-title">Pomodoro Focus Stats</div>
                <div class="stats-grid">
                    <div class="stat-card"><div class="stat-card-value">${App.hub.util.formatSecondsToDecimalHours(hubStats.pomodoro.today)}</div><div class="stat-card-label">Today</div></div>
                    <div class="stat-card"><div class="stat-card-value">${App.hub.util.formatSecondsToDecimalHours(hubStats.pomodoro.yesterday)}</div><div class="stat-card-label">Yesterday</div></div>
                    <div class="stat-card"><div class="stat-card-value">${App.hub.util.formatSecondsToDecimalHours(hubStats.pomodoro.average)}</div><div class="stat-card-label">Daily Average</div></div>
                    <div class="stat-card"><div class="stat-card-value">${App.hub.util.formatSecondsToDecimalHours(hubStats.pomodoro.best)}</div><div class="stat-card-label">Best Day</div></div>
                </div>
                <div class="stats-section-title">Time by Note Category</div>
                <div class="category-grid">${categoryTilesHTML.length > 0 ? categoryTilesHTML : `<p style="text-align:center; color: var(--text-secondary);">No focused time recorded yet.</p>`}</div>
                <div class="stats-section-title">Task Stats</div>
                <div class="stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));">
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.total}</div><div class="stat-card-label">Total Tasks</div></div>
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.completed}</div><div class="stat-card-label">Completed</div></div>
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.completedToday}</div><div class="stat-card-label">Done Today</div></div>
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.completedYesterday}</div><div class="stat-card-label">Done Yesterday</div></div>
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.backlog}</div><div class="stat-card-label">Backlog</div></div>
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.upcoming}</div><div class="stat-card-label">Upcoming</div></div>
                </div>
                <div class="stats-section-title">Flashcard Spaced Repetition</div>
                <div class="stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));">
                    <div class="stat-card"><div class="stat-card-value">${flashcardStats.total}</div><div class="stat-card-label">Total Cards</div></div>
                    <div class="stat-card"><div class="stat-card-value">${flashcardStats.due}</div><div class="stat-card-label">To Study</div></div>
                    ${App.config.sm2.ratings.map(r => `<div class="stat-card"><div class="stat-card-value">${flashcardStats.ratings[r] || 0}</div><div class="stat-card-label">${r}</div></div>`).join('')}
                    <div class="stat-card"><div class="stat-card-value">${flashcardStats.ratings['New'] || 0}</div><div class="stat-card-label">New Cards</div></div>
                    <div class="stat-card"><div class="stat-card-value">${yesterdayFlashcards}</div><div class="stat-card-label">Yesterday</div></div>
                    <div class="stat-card"><div class="stat-card-value" style="color:var(--success-color);">${todayFlashcards}</div><div class="stat-card-label">Today</div></div>
                </div>
                <div style="margin-top: 2rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
                    <div><canvas id="flashcardActivityChart" style="margin-top: 1rem;"></canvas></div>
                </div>
                <div style="margin-top: 2rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
                    <div>
                        <h4 style="text-align: center;">Upcoming Reviews (Next 30 Days)</h4>
                        <canvas id="flashcardForecastChart"></canvas>
                    </div>
                </div>
                <div style="margin-top: 2rem;">
                    <h4 style="text-align: center;">Card Difficulty Distribution</h4>
                    <div style="max-width: 400px; margin: 0 auto;">
                        <canvas id="cardEaseDistributionChart"></canvas>
                    </div>
                </div>
                <div class="stats-section-title">Reading Stats</div>
                <div class="stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));">
                    <div class="stat-card"><div class="stat-card-value">${readingStats.total}</div><div class="stat-card-label">Total Articles</div></div>
                    <div class="stat-card"><div class="stat-card-value">${readingStats.completed}</div><div class="stat-card-label">Completed</div></div>
                    <div class="stat-card"><div class="stat-card-value">${readingStats.unread}</div><div class="stat-card-label">Unread</div></div>
                    ${Object.entries(readingStats.stages).map(([stage, count]) => `<div class="stat-card"><div class="stat-card-value">${count}</div><div class="stat-card-label">Read ${stage}${stage === '5' ? '+' : ''}x</div></div>`).join('')}
                    <div class="stat-card"><div class="stat-card-value">${yesterdayArticles}</div><div class="stat-card-label">Yesterday</div></div>
                    <div class="stat-card"><div class="stat-card-value" style="color:var(--success-color);">${todayArticles}</div><div class="stat-card-label">Today</div></div>
                </div>
                <div style="margin-top: 2rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
                    <div><canvas id="readingActivityChart" style="margin-top: 1rem;"></canvas></div>
                </div>
                <div class="stats-section-title" style="margin-top: 3rem; text-align:center; border:none;">View Historical Data</div>
                <div style="display:flex; justify-content:center; gap: 1rem; margin-top: -0.5rem;">
                    <select id="stats-month-select" class="btn btn-secondary">${monthOptions}</select>
                    <select id="stats-year-select" class="btn btn-secondary">${yearOptions.join('')}</select>
                </div>
            `;
                },

                renderFocusMode() {
                    const session = App.state.focusSession;
                    if (!session.isActive) {
                        const coPilotToggle = document.getElementById('kash-copilot-toggle');
                        if (coPilotToggle) coPilotToggle.style.display = 'none';
                        return;
                    }

                    // JIT: Ensure snippets are ready for the current article
                    if (!session.articles[session.currentIndex].snippets) {
                        if (App.events.prepareFocusArticle) {
                            App.events.prepareFocusArticle(session.currentIndex);
                        }
                    }

                    // PRE-FETCH: Lazy load the next article's snippets in the background
                    setTimeout(() => {
                        if (session.isActive && App.events.prepareFocusArticle && session.currentIndex + 1 < session.articles.length) {
                            App.events.prepareFocusArticle(session.currentIndex + 1);
                        }
                    }, 500);

                    const coPilotToggle = document.getElementById('kash-copilot-toggle');
                    if (coPilotToggle) coPilotToggle.style.display = 'flex';

                    let overlay = document.getElementById('focus-mode-overlay');
                    if (!overlay) {
                        overlay = document.createElement('div');
                        overlay.id = 'focus-mode-overlay';
                        document.body.appendChild(overlay);
                    }

                    overlay.className = `focus-mode-overlay ${session.isStageMode ? 'stage-mode-active' : ''} ${session.activeTheme && session.activeTheme !== 'default' ? 'ambiance-' + session.activeTheme : ''}`;
                    if (session.isCinematicActive) {
                        overlay.classList.add('cinematic-active');
                    }

                    const highlightsVisible = App.settings.get('categoryHighlightsVisible') !== false;
                    const currentArticle = session.articles[session.currentIndex];
                    const fontSize = App.settings.get('focusModeFontSize') || '1.1rem';

                    const sigmaMode = session.sigmaMode || 'presentation';
                    overlay.classList.toggle('sigma-mode-article', sigmaMode === 'article');

                    // REVERT: NON-PERSISTENT STRUCTURE (Simpler, Robust)
                    let contentHTML = '';

                    if (sigmaMode === 'article') {
                        // SIGMA MODE: FULL ARTICLE - Remove restrictive inline styles to allow CSS to control width
                        contentHTML = `<div class="article-content-wrapper">${currentArticle.content}</div>`;
                    } else {
                        // SIGMA MODE: PRESENTATION (Snippets)
                        contentHTML = currentArticle.snippets.map(item => {
                            if (item.type === 'mcq' || item.type === 'timeline' || item.type === 'chart' || item.type === 'accordion' || item.type === 'video') {
                                let finalHtml = item.html.replace(/contenteditable="true"/g, 'contenteditable="false"');

                                if (item.type === 'mcq') finalHtml = finalHtml.replace('class="nk-mcq-block"', 'class="nk-mcq-block" tabindex="0"');
                                if (item.type === 'timeline') finalHtml = finalHtml.replace('class="nk-timeline-block"', 'class="nk-timeline-block" tabindex="0"');
                                if (item.type === 'chart') finalHtml = finalHtml.replace('class="chart-container"', 'class="chart-container" tabindex="0"');
                                if (item.type === 'accordion') {
                                    const accordionWithTabindex = finalHtml.replace('class="nk-accordion"', 'class="nk-accordion" tabindex="0"');
                                    finalHtml = `<div>${accordionWithTabindex}</div>`;
                                }
                                if (item.type === 'video') {
                                    // Ensure video is not contenteditable and has focusability
                                    finalHtml = finalHtml.replace('class="nk-video-embed"', 'class="nk-video-embed" tabindex="0"');
                                    // Wrapper for layout preservation
                                    return `<div class="snippet video-snippet-wrapper" style="width: 100%; display: flex; justify-content: center; background: transparent; padding: 0;">${finalHtml}</div>`;
                                }
                                return finalHtml;
                            } else {
                                let snippetHtml = item.html;
                                if (snippetHtml && snippetHtml.includes('cloze-flashcard')) {
                                    snippetHtml = snippetHtml.replace(/<span class="cloze-flashcard">(.*?)<\/span>/g,
                                        (match, content) => {
                                            return `<span class="focus-cloze" 
                                                    onclick="event.stopPropagation(); this.classList.toggle('revealed')" 
                                                    title="Click to reveal cloze">
                                                <span class="focus-cloze-hidden">[...]</span>
                                                <span class="focus-cloze-revealed">${content}</span>
                                            </span>`;
                                        }
                                    );
                                }

                                return `<div class="snippet" tabindex="0" onclick="App.events.toggleSnippetVisibility(event)">${snippetHtml}</div>`;
                            }
                        }).join('');
                    }

                    // Toggle Overlay Classes
                    if (overlay) {
                        overlay.classList.toggle('articulator-active', sigmaMode === 'article');
                        overlay.classList.remove('sigma-web'); // Ensure web class is gone
                    }

                    overlay.innerHTML = `
                <div id="blackout-screen"></div> <div id="whiteboard-screen"></div> 
                <div class="laser-pointer" id="laser-pointer" style="display: none;"></div>
                <div class="focus-mode-content" tabindex="-1">
                    <h1 class="focus-mode-title" onclick="App.events.exitFocusMode(); App.router.navigateTo('article', {id: '${currentArticle.id}', mode: 'read'})">${currentArticle.title}</h1>
                    <div class="focus-mode-body ${!highlightsVisible ? 'hide-snippet-colors' : ''}" style="--focus-mode-font-size: ${fontSize};">
                        <canvas id="annotation-canvas"></canvas> 
                        ${contentHTML}
                    </div>
                </div>
                <div class="focus-mode-controls" id="focus-controls-container"></div>`;

                    overlay.querySelectorAll('canvas[data-chart-config]').forEach(canvas => {
                        App.ui.renderChartOnCanvas(canvas);
                    });

                    if (session.isStageMode) {
                        setTimeout(() => {
                            const bodyEl = overlay.querySelector('.focus-mode-body');
                            if (bodyEl) {
                                const sigmaMode = session.sigmaMode || 'presentation';

                                // STAGE MODE INNOVATIONS (only for Sigma Presentation mode)
                                if (sigmaMode === 'presentation') {
                                    // Innovation 1: Prepare Bento layouts
                                    this._prepareStageModeBentoLayouts(bodyEl);

                                    // Innovation 2: Prepare list build animations
                                    this._prepareListBuildAnimations(bodyEl);

                                    // Innovation 3: 2D Camera viewport (optional feature flag)
                                    // Enable by setting session.use2DCamera = true before entering Stage Mode
                                    if (session.use2DCamera) {
                                        this._prepare2DCameraViewport(bodyEl);
                                    }
                                }

                                // Use camera map if available, otherwise use scroll stops
                                if (session.cameraMap && session.cameraMap.positions.length > 0) {
                                    session.scrollStops = session.cameraMap.positions.map((_, i) => i);
                                    this._navigate2DCamera(bodyEl, 0, 0);
                                } else {
                                    session.scrollStops = this._calculateScrollStops(bodyEl);
                                    bodyEl.scrollTo({ top: session.scrollStops[session.currentSlideIndex], behavior: 'auto' });
                                }

                                // Get all observable elements for smart blur logic
                                const allElements = bodyEl.querySelectorAll('.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-accordion, .nk-text-tile, .stage-bento-split, .stage-bento-split-alt, .stage-hero-image');
                                const totalItems = allElements.length;

                                // Smart blur: If very few items or only one slide, disable blur
                                if (totalItems <= 3 || session.scrollStops.length <= 1) {
                                    bodyEl.classList.add('smart-blur-disabled');
                                }

                                const observer = new IntersectionObserver((entries) => {
                                    let visibleCount = 0;
                                    entries.forEach(entry => {
                                        const isVisible = entry.isIntersecting;
                                        entry.target.classList.toggle('is-visible', isVisible);
                                        if (isVisible) visibleCount++;
                                        if (isVisible && session.isCinematicActive && !entry.target.querySelector('img')) {
                                            App.events.typewriter.setup(entry.target);
                                        } else if (!isVisible && entry.target === App.events.typewriter.currentSnippet) {
                                            App.events.typewriter.reset();
                                        }
                                    });

                                    // Smart blur: Check if all or most items are visible
                                    const allVisibleItems = bodyEl.querySelectorAll('.is-visible').length;
                                    if (allVisibleItems >= totalItems || totalItems <= 3) {
                                        bodyEl.classList.add('smart-blur-disabled');
                                    } else {
                                        bodyEl.classList.remove('smart-blur-disabled');
                                    }
                                }, { root: bodyEl, threshold: 0.8 });

                                allElements.forEach(el => observer.observe(el));
                            }
                            this.renderFocusModeControls();
                            // Fix: Initialize video players in Stage Mode
                            App.util.initPlyr(bodyEl);
                        }, 100);
                    } else {
                        this.renderFocusModeControls();
                    }

                    overlay.addEventListener('click', App.events.handleContentClick);
                    const bodyEl = overlay.querySelector('.focus-mode-body');
                    if (bodyEl) {
                        const canvas = overlay.querySelector('#annotation-canvas');
                        canvas.width = bodyEl.offsetWidth;
                        canvas.height = bodyEl.scrollHeight;
                        bodyEl.addEventListener('scroll', () => { if (App.annotationEngine.state.isActive && App.annotationEngine.state.context === 'focus') App.annotationEngine.redrawPageAnnotations(); });
                        bodyEl.addEventListener('mouseover', App.events.handleSpotlight);
                        bodyEl.addEventListener('mouseout', App.events.handleSpotlight);
                    }
                    overlay.querySelector('.focus-mode-content').focus();
                },

                renderFocusModeControls() {
                    const session = App.state.focusSession;
                    const container = document.getElementById('focus-controls-container');
                    if (!container) return;

                    const isPremium = App.license.isPremium();
                    const premiumLockClass = App.license.isPremium() ? '' : 'premium-feature-locked';

                    let controlsHTML = '';
                    const isStageMode = session.isStageMode;
                    const highlightsVisible = App.settings.get('categoryHighlightsVisible') !== false;
                    const themeIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg>`;
                    const stageModeToggleIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM8 17H6v-2h2v2zm4 0h-2v-2h2v2zm4 0h-2v-2h2v2z"/></svg>`;
                    const highlighterIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="1.8" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 012.829-5.185l7.423-2.119a2.25 2.25 0 001.624-1.624l2.119-7.423a4.5 4.5 0 015.185-2.829l2.846.813L15.904 9.813a2.25 2.25 0 00-1.624 1.624l-2.119 7.423z" /><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 16.5h2.25a2.25 2.25 0 002.25-2.25V6.75" /></svg>`;

                    if (isStageMode) {
                        const slideCount = session.scrollStops ? session.scrollStops.length : 0;
                        let progressDots = '';

                        if (slideCount <= 4) {
                            progressDots = Array.from({ length: slideCount }, (_, i) =>
                                `<div class="progress-dot ${i === session.currentSlideIndex ? 'active' : ''}" onclick="App.state.focusSession.currentSlideIndex=${i}; App.events.navigateStageSlide(0);"></div>`
                            ).join('');
                        } else {
                            const isFirst = session.currentSlideIndex === 0;
                            const isLast = session.currentSlideIndex === slideCount - 1;
                            const isMiddle = !isFirst && !isLast;

                            progressDots += `<div class="progress-dot ${isFirst ? 'active' : ''}" onclick="App.state.focusSession.currentSlideIndex=0; App.events.navigateStageSlide(0);"></div>`;
                            progressDots += `<div class="progress-dot ${isMiddle ? 'active' : ''}" onclick="App.state.focusSession.currentSlideIndex=${Math.floor((slideCount - 1) / 2)}; App.events.navigateStageSlide(0);"></div>`;
                            progressDots += `<div class="progress-dot ${isLast ? 'active' : ''}" onclick="App.state.focusSession.currentSlideIndex=${slideCount - 1}; App.events.navigateStageSlide(0);"></div>`;
                        }

                        container.className = 'stage-mode-controls';

                        // --- NEW: Icons for Stage Mode More Menu ---
                        const sigmaMode = session.sigmaMode || 'presentation';
                        const sigmaIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" class="sigma-icon" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 4h14v2H7.66l6.63 6-6.63 6H19v2H5v-2l7-7-7-7V4z"/></svg>`;
                        const isActive = sigmaMode !== 'presentation';
                        const moreIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"/></svg>`;
                        const cinematicIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m2 6 3 3 3-3 3 3 3-3 3 3 3-3"/><path d="M2 12l3 3 3-3 3 3 3-3 3 3 3-3"/><path d="M2 18l3 3 3-3 3 3 3-3 3 3 3-3"/></svg>`;

                        const cinematicActive = session.isCinematicActive;
                        const cinematicOnClick = isPremium ? "App.events.presentation.toggleCinematicMotion(this)" : "App.ui.showToast('Cinematic Reveal is a Premium feature.', 'info')";
                        const annotationOnClick = isPremium ? "App.annotationEngine.toggle('focus')" : "App.ui.showToast('Live Annotation is a Premium feature.', 'info')";
                        const exportOnClick = isPremium ? "App.events.exportCurrentSlide()" : "App.ui.showToast('Copying slides is a Premium feature.', 'info')";


                        controlsHTML = `
                    <button class="btn-icon" onclick="App.events.navigateStageSlide(-1)" title="Previous Slide ()"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg></button>
                    <div class="stage-progress-indicator" title="Jump to slide">${progressDots}</div>
                    <button class="btn-icon" onclick="App.events.navigateStageSlide(1)" title="Next Slide ()"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" /></svg></button>
                    <div class="control-divider"></div>
                    
                    <button class="btn-icon" id="teleprompter-toggle-btn" onclick="App.events.presentation.toggleTeleprompter()" title="Toggle Teleprompter (i)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M6 3h8a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zM4 2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h1v-1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h1V2H4z"/><path d="M7 5.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/></svg>
                    </button>
                    <button class="btn-icon ${highlightsVisible ? 'active' : ''}" onclick="App.events.toggleStageModeHighlights(this)" title="Toggle Highlight Colors (H)">${highlighterIcon}</button>

                    <div class="${premiumLockClass}">
                        <button class="btn-icon ${cinematicActive ? 'active' : ''}" onclick="${cinematicOnClick}" title="Toggle Cinematic Reveal">${cinematicIcon}</button>
                    </div>
                <div class="${premiumLockClass}">
                        <button class="btn-icon annotation-btn" onclick="${annotationOnClick}" title="Toggle Annotation (D)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" /></svg>
                        </button>
                    </div>
                    
                    
                    <div class="stage-more-menu-container">
                        <button class="btn-icon" title="More Options" onclick="this.closest('.stage-more-menu-container').classList.toggle('active')">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="3" y="3" width="7" height="7" rx="2" />
                                <rect x="14" y="3" width="7" height="7" rx="2" />
                                <rect x="14" y="14" width="7" height="7" rx="2" />
                                <rect x="3" y="14" width="7" height="7" rx="2" />
                            </svg>
                        </button>
                        <div class="stage-more-popup">
                             <!-- Mobile-only duplicates of hidden toolbar buttons -->
                             <button class="btn-icon mobile-only-option" onclick="App.events.presentation.toggleTeleprompter()" title="Toggle Teleprompter (i)">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M6 3h8a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zM4 2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h1v-1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h1V2H4z"/><path d="M7 5.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/></svg>
                             </button>
                             <button class="btn-icon mobile-only-option ${highlightsVisible ? 'active' : ''}" onclick="App.events.toggleStageModeHighlights(this)" title="Toggle Highlight Colors (H)">${highlighterIcon}</button>
                             <div class="mobile-only-option ${premiumLockClass}">
                                 <button class="btn-icon ${cinematicActive ? 'active' : ''}" onclick="${cinematicOnClick}" title="Toggle Cinematic Reveal">${cinematicIcon}</button>
                             </div>
                             <div class="mobile-only-option ${premiumLockClass}">
                                 <button class="btn-icon annotation-btn" onclick="${annotationOnClick}" title="Toggle Annotation (D)">
                                     <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" /></svg>
                                 </button>
                             </div>
                             <!-- Regular More Options items -->
                             <button id="focus-mode-immersive-toggle" class="btn-icon" onclick="App.events.toggleFocusModeControls()" title="Toggle Immersive Mode (F)">${App.util.icons.expand}</button>
                             <div class="${premiumLockClass}">
                                <button class="btn-icon" onclick="${exportOnClick}" title="Screenshot (P)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.774 48.774 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" /><path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z" /></svg>
                                </button>
                             </div>
                             <button class="btn-icon" id="laser-pointer-toggle" title="Toggle Laser Pointer (L)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.042 21.672L13.684 16.6m0 0l-2.51 2.225.569-9.47 5.227 7.917-3.286-.672zM12 2.25a8.25 8.25 0 00-8.25 8.25c0 1.721.576 3.322 1.568 4.675A8.25 8.25 0 0012 21.75a8.25 8.25 0 008.25-8.25c0-4.556-3.694-8.25-8.25-8.25z" /></svg></button>
                             <button class="btn-icon" onclick="App.events.annotation.toggleWhiteboard()" title="Whiteboard (W)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line></svg></button>
                             <button class="btn-icon ${isActive ? 'active' : ''}" onclick="App.events.toggleSigmaMode(this)" title="Sigma Mode: Pres -> Article -> Web">${sigmaIcon}</button>
                             <button class="btn-icon" onclick="App.events.stageTimer.toggle()" title="Stage Timer (T)" style="animation: fadeIn 0.3s ease 0.1s both;"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg></button>
                        </div>
                    </div>

                    <button class="btn-icon" onclick="App.events.toggleStageMode()" title="Exit Stage Mode (Esc)">${stageModeToggleIcon}</button>
                    <!-- Top Right Exit Immersive Button -->
                    <button id="immersive-exit-btn" onclick="App.events.toggleFocusModeControls()" title="Exit Immersive Mode (F)">
                        ${App.util.icons.compress}
                    </button>
                `;
                    } else { // Standard Focus Mode
                        const fontSize = App.settings.get('focusModeFontSize') || '1.1rem';
                        const isControlsHidden = document.querySelector('.focus-mode-overlay')?.classList.contains('controls-hidden');
                        const stageModeToggleIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 17.25v1.007a3 3 0 01-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0115 18.257V17.25m6-12V15a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 15V5.25A2.25 2.25 0 015.25 3h13.5A2.25 2.25 0 0121 5.25z" /></svg>`;
                        container.className = 'focus-mode-controls';
                        controlsHTML = `
                    <button id="focus-mode-immersive-toggle" class="btn-icon immersive-toggle-btn" onclick="App.events.toggleFocusModeControls()" title="${isControlsHidden ? 'Show Controls' : 'Hide Controls'}">${isControlsHidden ? App.util.icons.compress : App.util.icons.expand}</button>    
                    <button class="btn-icon" onclick="App.events.toggleStageMode()" title="Enter Stage Mode">${stageModeToggleIcon}</button>
                    <button class="btn-icon" onclick="App.events.presentation.cycleAmbiance()" oncontextmenu="event.preventDefault(); App.events.presentation.cycleAmbiance(true);" title="Cycle Ambiance (C, Right-click to go back)">${themeIcon}</button>

                    <button id="focus-font-size-btn" class="btn-icon" onclick="App.events.toggleFocusModeFontSize(this)" title="Cycle Font Size (F)"><span style="font-weight: 700; font-size: 1rem;">${fontSize.replace('rem', '')}</span></button>
                    <button class="btn-icon ${highlightsVisible ? 'active' : ''}" onclick="App.events.toggleFocusModeHighlights(this)" title="Toggle Highlight Colors (s)">${highlighterIcon}</button>
                    <button class="btn-icon" onclick="App.events.navigateFocusMode(-1)" title="Previous Article ()"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg></button>
                    <button class="btn-icon" onclick="App.events.navigateFocusMode(1)" title="Next Article ()"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" /></svg></button>
                    <button class="btn-icon btn-danger" onclick="App.events.exitFocusMode()" title="Exit Focus Mode (Esc)">${App.util.icons.close}</button>
                    
                `;
                    }
                    container.innerHTML = controlsHTML;
                    const laserToggle = document.getElementById('laser-pointer-toggle');
                    if (laserToggle) {
                        laserToggle.onclick = () => App.events.toggleSharedLaser('stage');
                        laserToggle.classList.toggle('active', document.querySelector('.focus-mode-overlay.laser-active') !== null);
                    }
                },

                _calculateScrollStops(bodyEl) {

                    const elements = Array.from(bodyEl.querySelectorAll('.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-accordion'));

                    if (elements.length === 0) return [0];

                    const containerHeight = bodyEl.clientHeight;
                    const scrollStops = [];
                    let currentPageElements = [];
                    let currentPageHeight = 0;
                    const verticalMargin = 16;

                    elements.forEach((el) => {
                        const elHeight = el.offsetHeight;
                        if (elHeight > containerHeight) {
                            if (currentPageElements.length > 0) { scrollStops.push(currentPageElements[0].offsetTop); }
                            scrollStops.push(el.offsetTop);
                            currentPageElements = []; currentPageHeight = 0; return;
                        }
                        if (currentPageHeight + elHeight + (currentPageElements.length > 0 ? verticalMargin : 0) > containerHeight) {
                            scrollStops.push(currentPageElements[0].offsetTop);
                            currentPageElements = [el]; currentPageHeight = elHeight;
                        } else {
                            currentPageElements.push(el);
                            currentPageHeight += elHeight + (currentPageElements.length > 1 ? verticalMargin : 0);
                        }
                    });

                    if (currentPageElements.length > 0) { scrollStops.push(currentPageElements[0].offsetTop); }
                    if (scrollStops.length > 0) { scrollStops[0] = 0; }

                    return scrollStops.length > 0 ? scrollStops : [0];
                },

                // --- STAGE MODE INNOVATIONS ---

                /**
                 * Innovation 1: Intelligent "Bento" Slide Layouts
                 * Scans DOM for patterns and wraps them in CSS Grid containers
                 */
                _prepareStageModeBentoLayouts(bodyEl) {
                    if (!bodyEl) return;

                    // Optimization: Use a single pass and minimal DOM manipulation
                    const snippets = Array.from(bodyEl.querySelectorAll('.snippet'));
                    let alternateLayout = false;

                    for (let i = 0; i < snippets.length - 2; i++) {
                        const snippet = snippets[i];

                        // Skip if already processed
                        if (snippet.closest('.stage-bento-split, .stage-bento-split-alt, .stage-hero-image')) continue;

                        const nextSnippet = snippets[i + 1];
                        const nextNextSnippet = snippets[i + 2];

                        // Safety: Don't mess with videos in the Bento grouping logic if they are sensitive
                        if (snippet.querySelector('.nk-video-embed') ||
                            nextSnippet.querySelector('.nk-video-embed') ||
                            nextNextSnippet.querySelector('.nk-video-embed')) {
                            continue;
                        }

                        // Pattern 1: "Split Slide" - Header + Image + Text
                        const headerMatch = snippet.querySelector('h1, h2, h3');
                        const hasImage = nextSnippet.querySelector('.image-container, img');
                        const hasText = nextNextSnippet.querySelector('p, ul, ol');

                        if (headerMatch && hasImage && hasText) {
                            // Valid Pattern Found
                            const wrapper = document.createElement('div');
                            // Use text direction class for alternate layout
                            wrapper.className = alternateLayout ? 'stage-bento-split-alt' : 'stage-bento-split';
                            wrapper.dataset.bentoWrapper = 'true';

                            // Insert wrapper at the position of the first element
                            snippet.parentNode.insertBefore(wrapper, snippet);

                            // Construction:
                            // 1. Header (snippet) always goes first/top-left
                            wrapper.appendChild(snippet);

                            // 2. Arrange Image and Text based on layout
                            if (alternateLayout) {
                                // For alt layout, we wrap text to target it specifically with CSS order
                                const textWrapper = document.createElement('div');
                                textWrapper.className = 'bento-text-content';
                                textWrapper.appendChild(nextNextSnippet);
                                wrapper.appendChild(nextSnippet); // Image
                                wrapper.appendChild(textWrapper); // Text
                            } else {
                                wrapper.appendChild(nextSnippet); // Image
                                wrapper.appendChild(nextNextSnippet); // Text
                            }

                            alternateLayout = !alternateLayout;
                            i += 2; // Advanced index
                        }
                    }

                    // Separate pass for Hero Images to avoid complex nested loops
                    const remainingSnippets = bodyEl.querySelectorAll('.snippet > .image-container');
                    remainingSnippets.forEach(imgContainer => {
                        const snippet = imgContainer.closest('.snippet');
                        if (!snippet || snippet.closest('[data-bento-wrapper="true"]')) return;

                        // Check if it's "standalone" (mostly image)
                        const textContent = snippet.textContent.trim();
                        // Loose check: clearly less than 100 chars of text, mostly just the image
                        if (textContent.length < 100) {
                            const wrapper = document.createElement('div');
                            wrapper.className = 'stage-hero-image';
                            wrapper.dataset.bentoWrapper = 'true';
                            snippet.parentNode.insertBefore(wrapper, snippet);
                            wrapper.appendChild(snippet);
                        }
                    });
                },


                _cleanupStageModeBentoLayouts(bodyEl) {
                    if (!bodyEl) return;

                    // Find all bento wrappers and unwrap them
                    const wrappers = bodyEl.querySelectorAll('[data-bento-wrapper="true"]');
                    wrappers.forEach(wrapper => {
                        // Unwrap text wrappers first
                        const textWrappers = wrapper.querySelectorAll('.bento-text-content');
                        textWrappers.forEach(tw => {
                            while (tw.firstChild) {
                                tw.parentNode.insertBefore(tw.firstChild, tw);
                            }
                            tw.remove();
                        });

                        // Move children out of wrapper
                        while (wrapper.firstChild) {
                            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                        }
                        wrapper.remove();
                    });
                },

                /**
                 * Innovation 2: List Build Animations
                 * Sets up list items for progressive reveal
                 */
                _prepareListBuildAnimations(bodyEl) {
                    if (!bodyEl) return;

                    const lists = bodyEl.querySelectorAll('ul, ol');
                    lists.forEach(list => {
                        const items = list.querySelectorAll('li');
                        items.forEach((item, index) => {
                            if (index === 0) {
                                // First item is visible
                                item.classList.add('stage-build-visible');
                                item.classList.remove('stage-build-hidden');
                            } else {
                                // Other items start hidden
                                item.classList.add('stage-build-hidden');
                                item.classList.remove('stage-build-visible');
                            }
                        });
                    });
                },

                /**
                 * Reveals the next hidden list item in the current visible snippet
                 * Returns true if an item was revealed, false if all items are visible
                 */
                _revealNextListItem(bodyEl) {
                    if (!bodyEl) return false;

                    // Find the currently visible snippet
                    const visibleSnippet = bodyEl.querySelector('.snippet.is-visible, .stage-bento-split.is-visible, .stage-hero-image.is-visible');
                    if (!visibleSnippet) return false;

                    // Find the first hidden list item
                    const hiddenItem = visibleSnippet.querySelector('li.stage-build-hidden');
                    if (!hiddenItem) return false;

                    // Reveal it
                    hiddenItem.classList.remove('stage-build-hidden');
                    hiddenItem.classList.add('stage-build-visible');

                    return true;
                },

                /**
                 * Checks if there are still hidden list items in the current visible snippet
                 */
                _hasHiddenListItems(bodyEl) {
                    if (!bodyEl) return false;
                    const visibleSnippet = bodyEl.querySelector('.snippet.is-visible, .stage-bento-split.is-visible, .stage-hero-image.is-visible');
                    if (!visibleSnippet) return false;
                    return visibleSnippet.querySelector('li.stage-build-hidden') !== null;
                },

                /**
                 * Innovation 3: 2D "Camera" Transitions
                 * Calculates a 2D grid map for slides using a snaking pattern
                 * Returns: { positions: [{x, y, width, height}], gridWidth, gridHeight }
                 */
                _calculate2DScrollMap(bodyEl) {
                    if (!bodyEl) return { positions: [], gridWidth: 0, gridHeight: 0 };

                    const elements = Array.from(bodyEl.querySelectorAll('.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-accordion, .stage-bento-split, .stage-bento-split-alt, .stage-hero-image'));
                    if (elements.length === 0) return { positions: [], gridWidth: 0, gridHeight: 0 };

                    const viewportWidth = bodyEl.clientWidth;
                    const viewportHeight = bodyEl.clientHeight;

                    // Calculate how many slides fit per row (2-3 based on content density)
                    const slidesPerRow = Math.min(3, Math.max(2, Math.ceil(Math.sqrt(elements.length))));

                    const positions = [];
                    let currentRow = 0;
                    let currentCol = 0;
                    let goingRight = true;

                    elements.forEach((el, index) => {
                        // Snaking pattern: row 0 goes right, row 1 goes left, etc.
                        if (goingRight) {
                            positions.push({
                                x: currentCol * viewportWidth,
                                y: currentRow * viewportHeight,
                                width: viewportWidth,
                                height: viewportHeight,
                                element: el
                            });
                            currentCol++;
                            if (currentCol >= slidesPerRow) {
                                currentRow++;
                                currentCol = slidesPerRow - 1;
                                goingRight = false;
                            }
                        } else {
                            positions.push({
                                x: currentCol * viewportWidth,
                                y: currentRow * viewportHeight,
                                width: viewportWidth,
                                height: viewportHeight,
                                element: el
                            });
                            currentCol--;
                            if (currentCol < 0) {
                                currentRow++;
                                currentCol = 0;
                                goingRight = true;
                            }
                        }
                    });

                    const gridWidth = slidesPerRow * viewportWidth;
                    const gridHeight = (currentRow + 1) * viewportHeight;

                    return { positions, gridWidth, gridHeight };
                },

                /**
                 * Navigates the 2D camera to a specific position
                 * Uses CSS transform for smooth GPU-accelerated animation
                 */
                _navigate2DCamera(bodyEl, targetX, targetY) {
                    if (!bodyEl) return;

                    const canvas = bodyEl.querySelector('.stage-camera-canvas');
                    if (!canvas) return;

                    // Use negative values to translate canvas in opposite direction
                    canvas.style.transform = `translate3d(${-targetX}px, ${-targetY}px, 0)`;
                },

                /**
                 * Prepares the 2D camera viewport structure
                 * Wraps content in a transformable canvas
                 */
                _prepare2DCameraViewport(bodyEl) {
                    if (!bodyEl) return;

                    // Check if already prepared
                    if (bodyEl.querySelector('.stage-camera-canvas')) return;

                    const map = this._calculate2DScrollMap(bodyEl);
                    if (map.positions.length === 0) return;

                    // Create the camera canvas
                    const canvas = document.createElement('div');
                    canvas.className = 'stage-camera-canvas';
                    canvas.style.width = `${map.gridWidth}px`;
                    canvas.style.height = `${map.gridHeight}px`;

                    // Move all elements into the canvas and position them absolutely
                    map.positions.forEach((pos, index) => {
                        const el = pos.element;
                        if (el && el.parentNode === bodyEl) {
                            // Wrap element in a positioned container
                            const slideContainer = document.createElement('div');
                            slideContainer.className = 'stage-camera-slide';
                            slideContainer.style.cssText = `
                                position: absolute;
                                left: ${pos.x}px;
                                top: ${pos.y}px;
                                width: ${pos.width}px;
                                height: ${pos.height}px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                box-sizing: border-box;
                                padding: 2rem;
                            `;

                            // Move element into slide container
                            bodyEl.removeChild(el);
                            slideContainer.appendChild(el);
                            canvas.appendChild(slideContainer);
                        }
                    });

                    // Add canvas to body
                    bodyEl.appendChild(canvas);
                    bodyEl.classList.add('stage-camera-active');

                    // Store map in session for navigation
                    App.state.focusSession.cameraMap = map;

                    // Navigate to first slide
                    this._navigate2DCamera(bodyEl, 0, 0);
                },

                /**
                 * Cleans up the 2D camera viewport
                 */
                _cleanup2DCameraViewport(bodyEl) {
                    if (!bodyEl) return;

                    const canvas = bodyEl.querySelector('.stage-camera-canvas');
                    if (!canvas) return;

                    // Move all elements back to body
                    const slides = canvas.querySelectorAll('.stage-camera-slide');
                    slides.forEach(slide => {
                        while (slide.firstChild) {
                            bodyEl.insertBefore(slide.firstChild, canvas);
                        }
                    });

                    canvas.remove();
                    bodyEl.classList.remove('stage-camera-active');
                    delete App.state.focusSession.cameraMap;
                },

                migrationScreen: {
                    state: { isCancelled: false },

                    show(title = "Migrating Data") {
                        this.state.isCancelled = false; // Reset cancellation state on every new operation
                        const overlay = document.createElement('div');
                        overlay.id = 'migration-overlay';
                        overlay.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(var(--bg-primary-rgb), 0.8); backdrop-filter: blur(4px);
                    z-index: 100000; display: flex; align-items: center; justify-content: center;
                    animation: fadeIn 0.3s;
                `;

                        const dynamicStyles = `
                    <style>
                        @keyframes migration-card-glow {
                            from { box-shadow: 0 0 8px -4px var(--primary-color); border-color: var(--primary-color); }
                            to { box-shadow: 0 0 20px 2px color-mix(in srgb, var(--primary-color) 40%, transparent); border-color: color-mix(in srgb, var(--primary-color) 70%, transparent); }
                        }
                        @keyframes gradient-pan {
                            0% { background-position: 0% 50%; }
                            50% { background-position: 100% 50%; }
                            100% { background-position: 0% 50%; }
                        }
                        .migration-card-glowing {
                            border: 1.5px solid var(--primary-color);
                            animation: migration-card-glow 2.5s infinite alternate ease-in-out;
                        }
                        .migration-title-gradient {
                            background: linear-gradient(45deg, #FF8C42, #FFD05A, #00A896, #A2E869, #05A387);
                            background-size: 250% 250%;
                            -webkit-background-clip: text;
                            background-clip: text;
                            -webkit-text-fill-color: transparent;
                            animation: gradient-pan 10s ease infinite;
                        }
                        .migration-cancel-btn-styled {
                            background-color: transparent;
                            border: 1px solid var(--border-color);
                            color: var(--text-secondary);
                            transition: all 0.2s ease-in-out;
                        }
                        .migration-cancel-btn-styled:hover {
                            background-color: color-mix(in srgb, var(--danger-color) 10%, transparent);
                            border-color: var(--danger-color);
                            color: var(--danger-color);
                            transform: translateY(-1px);
                        }
                        .migration-progress-gradient {
                            background: linear-gradient(90deg, var(--pomo-color-1), var(--pomo-color-3), var(--pomo-color-5), var(--pomo-color-7), var(--pomo-color-9));
                        }
                    </style>
                `;

                        overlay.innerHTML = `
                    ${dynamicStyles}
                    <div class="ui-card migration-card-glowing" style="width: 90%; max-width: 450px; padding: 2rem; text-align: center; display: flex; flex-direction: column; gap: 1rem;">
                        <div id="migration-spinner" class="spin" style="font-size: 2rem; color: var(--primary-color); margin: 0 auto;">
                            ${App.util.icons.cycle}
                        </div>
                        
                        <h2 id="migration-title" class="migration-title-gradient" style="font-family: var(--font-display); font-size: 1.75rem; margin: -0.5rem 0 0 0;">${title}</h2>
                        
                        <p id="migration-status" style="color: var(--text-secondary); min-height: 1.5em;"></p>
                        
                        <div style="width: 100%; background: var(--bg-tertiary); border-radius: 8px; overflow: hidden; margin-top: 0.5rem;">
                            <div id="migration-progress-bar" class="migration-progress-gradient" style="width: 0%; height: 8px; transition: width 0.3s ease;"></div>
                        </div>

                        <button id="migration-cancel-btn" class="btn migration-cancel-btn-styled" style="margin-top: 1.5rem; width: 50%; align-self: center;">Cancel</button>
                    </div>
                `;
                        document.body.appendChild(overlay);

                        document.getElementById('migration-cancel-btn').onclick = async () => {
                            this.state.isCancelled = true;
                            App.ui.showToast('Operation cancelled by user.', 'warning');

                            // Update the plan file to reflect the cancellation
                            try {
                                const plan = await App.fs.read('_category_operation_plan.json');
                                if (plan) {
                                    plan.status = 'cancelled';
                                    await App.fs.write('_category_operation_plan.json', plan);
                                }
                            } catch (e) {
                                console.error("Could not update operation plan to 'cancelled':", e);
                            }

                            this.hide();
                        };
                    },

                    update(progress, statusText) {
                        const bar = document.getElementById('migration-progress-bar');
                        const status = document.getElementById('migration-status');
                        if (bar) bar.style.width = `${progress}%`;
                        if (status) status.textContent = statusText;
                    },

                    hide() {
                        const overlay = document.getElementById('migration-overlay');
                        if (overlay) overlay.remove();
                    }
                },


                applyTheme(theme, isInitialLoad = false) {
                    const isCustom = theme === 'custom';
                    const baseTheme = App.settings.get('customThemeBase');
                    document.documentElement.setAttribute('data-theme', isCustom ? baseTheme : theme);

                    const bgImage = App.settings.get('backgroundImage');
                    const hasBgImage = isCustom && !!bgImage;
                    document.body.classList.toggle('image-theme-active', hasBgImage);
                    document.getElementById('app-background').style.backgroundImage = hasBgImage ? `url(${bgImage})` : 'none';

                    const opacity = App.settings.get('uiOpacity');
                    document.documentElement.style.setProperty('--ui-opacity', opacity);
                    const blurIntensity = parseFloat(opacity) === 0 ? '0px' : '8px';
                    document.documentElement.style.setProperty('--blur-intensity', blurIntensity);
                    document.documentElement.classList.toggle('zero-opacity-active', parseFloat(opacity) === 0);

                    if (!isInitialLoad) {
                        App.settings.set('theme', theme);
                    }

                    setTimeout(() => {
                        const primaryBg = getComputedStyle(document.documentElement).getPropertyValue('--bg-primary').trim();
                        const secondaryBg = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary').trim();
                        const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
                        const primaryRgb = App.util.colorToRgb(primaryBg);
                        const secondaryRgb = App.util.colorToRgb(secondaryBg);
                        const primaryColorRgb = App.util.colorToRgb(primaryColor);
                        if (primaryRgb) document.documentElement.style.setProperty('--bg-primary-rgb', primaryRgb.join(','));
                        if (secondaryRgb) document.documentElement.style.setProperty('--bg-secondary-rgb', secondaryRgb.join(','));
                        if (primaryColorRgb) document.documentElement.style.setProperty('--primary-color-rgb', primaryColorRgb.join(','));

                        const activeView = App.router.getActiveView();
                        if (activeView === 'library') {
                            const toggleButton = document.getElementById('category-name-toggle');
                            if (toggleButton) {
                                let newIcon;
                                switch (theme) {
                                    case 'sepia': newIcon = ''; break;
                                    case 'dark': newIcon = ''; break;
                                    case 'custom':
                                        const customBase = App.settings.get('customThemeBase');
                                        newIcon = (customBase === 'dark') ? '' : '';
                                        break;
                                    case 'light': default: newIcon = ''; break;
                                }
                                toggleButton.innerHTML = newIcon;
                            }
                        }

                        // --- FIX: Typo corrected below (currentAactiveView -> currentActiveView) ---
                        const currentActiveView = App.router.getActiveView();

                        if (currentActiveView === 'article') {
                            const contentDiv = document.getElementById('article-content');
                            if (contentDiv) {
                                contentDiv.querySelectorAll('canvas[data-chart-config]').forEach(canvas => App.ui.renderChartOnCanvas(canvas));
                            }
                        } else if (currentActiveView === 'stats-dashboard') {
                            const viewContainer = document.getElementById('stats-dashboard-view');
                            const monthSelect = document.getElementById('stats-month-select');
                            const yearSelect = document.getElementById('stats-year-select');
                            if (viewContainer && monthSelect && yearSelect) {
                                const currentMonth = parseInt(monthSelect.value);
                                const currentYear = parseInt(yearSelect.value);
                                App.ui.renderStatsDashboardView(viewContainer, { month: currentMonth, year: currentYear });
                            }
                        }
                    }, 50);
                },

                applyMobileView() {
                    const enabled = App.settings.get('mobileViewEnabled');
                    document.body.classList.toggle('mobile-view', enabled);

                    const toggleSwitch = document.getElementById('mobile-view-toggle');
                    const labelContainer = document.getElementById('mobile-view-label-container');

                    if (toggleSwitch) {
                        toggleSwitch.classList.toggle('active', enabled);
                    }
                    if (labelContainer) {
                        // NEW: More intuitive labels
                        const label = enabled ? 'Switch to Desktop View' : 'Switch to Mobile View';
                        const description = enabled ? 'For utilizing full power of App' : 'Optimized for small screens & touch.';
                        labelContainer.innerHTML = `<b>${label}</b><small>${description}</small>`;
                    }
                },

                applyFontSettings() {
                    const family = App.settings.get('fontFamily');
                    const size = App.settings.get('fontSize');
                    const lineHeight = App.settings.get('lineHeight');
                    document.documentElement.style.setProperty('--article-font-family', family);
                    document.documentElement.style.setProperty('--article-font-size', size);
                    document.documentElement.style.setProperty('--article-line-height', lineHeight);
                },

                updateHeaderState() {
                    const newArticleBtn = document.getElementById('new-article-btn');
                    if (!newArticleBtn) return;

                    if (App.state.storageMode === 'fileSystem' && !App.state.directoryHandle) {
                        newArticleBtn.disabled = true;
                        newArticleBtn.classList.remove('limit-reached');
                        newArticleBtn.title = 'Select a folder to begin';
                        return;
                    }

                    newArticleBtn.disabled = false;
                    const isPremium = App.license.isPremium();
                    const articleLimit = App.config.sparkTierLimit;
                    const articlesUsed = App.state.articles.length;
                    const canCreateArticle = isPremium || articlesUsed < articleLimit;

                    newArticleBtn.classList.toggle('limit-reached', !canCreateArticle);

                    if (!canCreateArticle) {
                        newArticleBtn.title = `Spark plan limit of ${articleLimit} notes reached. Go Premium for unlimited notes.`;
                        newArticleBtn.onclick = () => App.ui.showAscensionModal();
                    } else {
                        newArticleBtn.title = 'New Article (Alt+Shift+N)';
                        newArticleBtn.onclick = () => App.events.createNewArticle();
                    }
                },

                applyReaderTheme() {
                    const wrapper = document.querySelector('.article-view-wrapper');
                    if (!wrapper) return;
                    const theme = App.state.activeReaderTheme;
                    wrapper.className = wrapper.className.replace(/\bambiance-\S+/g, '').trim();

                    if (theme !== 'default') {
                        wrapper.classList.add(`ambiance-${theme}`);
                    }
                },
                applyStudyTheme() {
                    const studyView = document.querySelector('.study-view');
                    if (!studyView) return;
                    const theme = App.state.studySession.activeTheme;

                    studyView.className = studyView.className.replace(/\bambiance-\S+/g, '').trim();

                    if (theme !== 'default') {
                        studyView.classList.add(`ambiance-${theme}`);
                    }
                },

                showSelectionToolbar(range) {
                    const toolbar = document.getElementById('selection-toolbar');

                    const icons = {
                        format: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M13 4v16"></path><path d="M17 4v16"></path><path d="M19 4H9.5a4.5 4.5 0 0 0 0 9H13"></path></svg>`,
                        drag: `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="5" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="12" cy="19" r="1"/></svg>`,
                        palette: `<svg viewBox="0 0 24 24" width="23" height="23" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg>`,
                        tag: `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="9" x2="20" y2="9"/><line x1="4" y1="15" x2="20" y2="15"/><line x1="10" y1="3" x2="8" y2="21"/><line x1="16" y1="3" x2="14" y2="21"/></svg>`,
                        cloze: `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"/><path d="M2 12h20"/><path d="M17 2v5"/><path d="M7 2v5"/></svg>`,
                        aiMagic: `<svg viewBox="0 0 24 24" width="20" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v2.35M10.15 6.344l-1.493-1.493M6.344 10.15l-2.187-2.187M3 12h2.35M6.344 13.85l-2.187 2.187M10.15 17.656l-1.493 1.493M12 21v-2.35M13.85 17.656l1.493 1.493M17.656 13.85l2.187 2.187M21 12h-2.35M17.656 10.15l2.187-2.187M13.85 6.344l1.493-1.493"/><circle cx="12" cy="12" r="2.35"/></svg>`,
                        clear: `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 12.5h10.5M11 12.5a5 5 0 0 1-5-5V4.5"/><path d="M4 4.5h10.5"/><path d="M4 19.5h10.5"/><path d="m18 10-2-2 2-2"/><path d="m21 17-2-2 2-2"/></svg>`,
                        orientation: `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M4 6h16M4 12h16M4 18h16"/></svg>`
                    };

                    const highlightButtons = App.config.highlightClasses.slice(0, 6).map((cls, i) =>
                        `<button class="btn-icon highlight-btn" 
                    style="background-color:var(--${cls.replace('highlight-', 'hl-')}-bg); border:1px solid var(--${cls.replace('highlight-', 'hl-')}-border);" 
                    title="Highlight (Cmd+Shift+${i + 2})" onmousedown="event.preventDefault(); App.events.applyFormatting('class', '${cls}')"></button>`
                    ).join('');


                    toolbar.innerHTML = `
                        <div class="toolbar-wrapper">
                            <div class="toolbar-drag-handle" title="Drag Toolbar or Double click to Lock">${icons.drag}</div>
                            <button id="ai-magic-btn" class="btn-icon" title="AI Magic  (Ctrl+J)">${icons.aiMagic}</button>
                            <div class="control-divider"></div>
                            
                            <div class="format-toolbar-group" style="position: relative;">
                                <button class="btn-icon" title="Text Formatting" onmousedown="event.preventDefault()">${icons.format}</button>
                                <div class="format-popover" style="bottom: 110%;">
                                    <button class="btn-icon" title="Bold (Cmd/Ctrl+B)" onmousedown="event.preventDefault(); document.execCommand('bold', false, null);" aria-label="Bold text"><b>B</b></button>
                                    <button class="btn-icon" title="Italic (Cmd/Ctrl+I)" onmousedown="event.preventDefault(); document.execCommand('italic', false, null);" aria-label="Italicize text"><i>I</i></button>
                                    <button class="btn-icon" title="Underline (Cmd/Ctrl+U)" onmousedown="event.preventDefault(); document.execCommand('underline', false, null);" aria-label="Underline text"><u>U</u></button>
                                </div>
                            </div>
                            ${highlightButtons}
                            <div class="control-divider"></div>
                            <button class="btn-icon" title="Create Tag [[...]]" onmousedown="event.preventDefault(); App.contentTools.tagSelection()">${icons.tag}</button>
                            <button class="btn-icon" title="Create Cloze Flashcard" onmousedown="event.preventDefault(); App.events.applyFormatting('cloze')">${icons.cloze}</button>  
                            <button class="btn-icon" title="Remove Formatting" onmousedown="event.preventDefault(); App.events.removeFormatting()">${icons.clear}</button>
                            <button class="btn-icon" id="toolbar-orientation-toggle" title="Toggle Layout">${icons.orientation}</button>
                        </div>
                    `;

                    const rect = range.getBoundingClientRect();
                    toolbar.style.display = 'block';
                    const isMobileView = document.body.classList.contains('mobile-view');
                    const toolbarHeight = toolbar.offsetHeight || 50;
                    const toolbarWidth = toolbar.offsetWidth || 300;
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    const MARGIN = 10;
                    const GAP = 10;

                    const wrapper = toolbar.querySelector('.toolbar-wrapper');
                    const dragHandle = toolbar.querySelector('.toolbar-drag-handle');
                    const toggleBtn = document.getElementById('toolbar-orientation-toggle');

                    // Load State
                    let savedOrientation = 'horizontal';
                    let savedX = null, savedY = null;
                    try {
                        const savedState = JSON.parse(localStorage.getItem('noteKashToolbarState'));
                        if (savedState) {
                            savedOrientation = savedState.orientation ?? 'horizontal';
                            savedX = savedState.x;
                            savedY = savedState.y;
                        }
                    } catch (e) { }

                    // Check for Locked State
                    let isLocked = false;
                    let lockedX = null, lockedY = null;
                    try {
                        const lockState = JSON.parse(localStorage.getItem('noteKashToolbarLock'));
                        if (lockState && lockState.isLocked) {
                            isLocked = true;
                            lockedX = lockState.x;
                            lockedY = lockState.y;
                        }
                    } catch (e) { }

                    const isVertical = savedOrientation === 'vertical';

                    // --- POSITIONING LOGIC ---
                    if (isLocked && lockedX !== null && lockedY !== null) {
                        // === LOCKED MODE: Always Fixed Position ===
                        toolbar.style.position = 'fixed';
                        // Maintain current orientation style, but force fixed pos
                        if (isVertical) {
                            wrapper.classList.add('vertical');
                            toggleBtn.querySelector('svg').style.transform = 'rotate(90deg)';
                        } else {
                            wrapper.classList.remove('vertical');
                            toggleBtn.querySelector('svg').style.transform = 'rotate(0deg)';
                        }

                        toolbar.style.left = `${lockedX}px`;
                        toolbar.style.top = `${lockedY}px`;
                        dragHandle.classList.add('locked');

                    } else if (isVertical) {
                        // VERTICAL MODE: FIXED POSITION (Screen Relative)
                        toolbar.style.position = 'fixed';
                        wrapper.classList.add('vertical');
                        toggleBtn.querySelector('svg').style.transform = 'rotate(90deg)';
                        dragHandle.classList.remove('locked');

                        let topPos, leftPos;

                        // Check if saved position is valid (within current viewport)
                        // Note: We're interpreting savedX/Y as viewport coords for vertical mode
                        const isValid = savedX !== null && savedY !== null &&
                            savedX >= MARGIN && savedX + toolbarWidth <= viewportWidth - MARGIN &&
                            savedY >= MARGIN && savedY + toolbarHeight <= viewportHeight - MARGIN;

                        if (isValid) {
                            leftPos = savedX;
                            topPos = savedY;
                        } else {
                            // Default to unobtrusive position near selection if possible
                            leftPos = rect.right + GAP;
                            topPos = rect.top;

                            // Adjust if off screen
                            if (leftPos + toolbarWidth > viewportWidth - MARGIN) {
                                leftPos = rect.left - toolbarWidth - GAP; // Try left
                            }
                            if (leftPos < MARGIN) {
                                leftPos = viewportWidth - toolbarWidth - MARGIN; // right dock
                            }
                            if (topPos + toolbarHeight > viewportHeight - MARGIN) {
                                topPos = viewportHeight - toolbarHeight - MARGIN;
                            }
                            if (topPos < MARGIN) topPos = MARGIN;
                        }

                        toolbar.style.left = `${leftPos}px`;
                        toolbar.style.top = `${topPos}px`;

                    } else {
                        // HORIZONTAL MODE: ABSOLUTE POSITION (Document Relative)
                        toolbar.style.position = 'absolute';
                        wrapper.classList.remove('vertical');
                        toggleBtn.querySelector('svg').style.transform = 'rotate(0deg)';
                        dragHandle.classList.remove('locked');

                        let topPos = rect.bottom + window.scrollY + GAP;
                        let leftPos = rect.left + window.scrollX + (rect.width / 2) - (toolbarWidth / 2);

                        // Clamp Horizontal
                        if (leftPos < window.scrollX + MARGIN) leftPos = window.scrollX + MARGIN;
                        if (leftPos + toolbarWidth > window.scrollX + viewportWidth - MARGIN) {
                            leftPos = window.scrollX + viewportWidth - toolbarWidth - MARGIN;
                        }

                        // Flip if bottom overflow
                        if (rect.bottom + GAP + toolbarHeight > viewportHeight) {
                            const topSpace = rect.top - MARGIN;
                            if (topSpace > toolbarHeight) {
                                topPos = rect.top + window.scrollY - toolbarHeight - GAP;
                            }
                        }

                        toolbar.style.left = `${leftPos}px`;
                        toolbar.style.top = `${topPos}px`;
                    }

                    // --- HELPERS ---
                    const saveState = () => {
                        // Only save routine state if NOT locked. 
                        // If locked, we don't want to overwrite the 'normal' preferred position with the locked one necessarily, but user might expect it.
                        // Actually, let's keep them separate.
                        const style = window.getComputedStyle(toolbar);
                        const isVert = wrapper.classList.contains('vertical');
                        const x = parseFloat(style.left);
                        const y = parseFloat(style.top);

                        localStorage.setItem('noteKashToolbarState', JSON.stringify({
                            x: x, y: y,
                            orientation: isVert ? 'vertical' : 'horizontal'
                        }));

                        // If locked, update lock coordinates too so dragging works while locked
                        if (dragHandle.classList.contains('locked')) {
                            // For locked, we need Viewport coordinates.
                            // If position is fixed, x/y are already viewport.
                            // If position is absolute, we must subtract scroll.
                            let vx = x, vy = y;
                            if (toolbar.style.position === 'absolute') {
                                vx -= window.scrollX;
                                vy -= window.scrollY;
                            }
                            localStorage.setItem('noteKashToolbarLock', JSON.stringify({ isLocked: true, x: vx, y: vy }));
                        }
                    };

                    document.getElementById('ai-magic-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        App.ui.hideSelectionToolbar();
                        App.ui.aiMagicModal.open();
                    });

                    // TOGGLE ORIENTATION
                    toggleBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        const isVertNow = wrapper.classList.toggle('vertical');
                        toggleBtn.querySelector('svg').style.transform = isVertNow ? 'rotate(90deg)' : 'rotate(0deg)';

                        const rectBefore = toolbar.getBoundingClientRect();

                        // If locked, we just stay fixed but rotate.
                        // If unlocked, we switch positioning modes.
                        if (!dragHandle.classList.contains('locked')) {
                            if (isVertNow) {
                                // Switch to Fixed (Viewport)
                                toolbar.style.position = 'fixed';
                                toolbar.style.left = rectBefore.left + 'px';
                                toolbar.style.top = rectBefore.top + 'px';
                            } else {
                                // Switch to Absolute (Document)
                                toolbar.style.position = 'absolute';
                                toolbar.style.left = (rectBefore.left + window.scrollX) + 'px';
                                toolbar.style.top = (rectBefore.top + window.scrollY) + 'px';
                            }
                        }
                        saveState();
                    });

                    // LOCK TOGGLE
                    dragHandle.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        const isLockedNow = dragHandle.classList.toggle('locked');
                        if (isLockedNow) {
                            const r = toolbar.getBoundingClientRect();
                            // Lock to current viewport coordinates
                            toolbar.style.position = 'fixed';
                            toolbar.style.left = r.left + 'px';
                            toolbar.style.top = r.top + 'px';

                            localStorage.setItem('noteKashToolbarLock', JSON.stringify({ isLocked: true, x: r.left, y: r.top }));
                            App.ui.showToast("Toolbar Position Locked ", { type: 'success' });
                        } else {
                            localStorage.removeItem('noteKashToolbarLock');
                            App.ui.showToast("Toolbar Position Unlocked ", { type: 'info' });
                            // We don't immediately jump; next selection will reset, or user can drag/toggle.
                            // But let's revert to 'smart' behavior if we are horizontal?
                            // Actually, let's just leave it where it is until next selection or interaction.
                        }
                    });

                    // DRAG LOGIC
                    let offsetX, offsetY;
                    const move = (e) => {
                        const cx = e.touches ? e.touches[0].clientX : e.clientX;
                        const cy = e.touches ? e.touches[0].clientY : e.clientY;

                        let newX = cx - offsetX;
                        let newY = cy - offsetY;

                        if (toolbar.style.position === 'absolute') {
                            newX += window.scrollX;
                            newY += window.scrollY;
                        }

                        toolbar.style.left = `${newX}px`;
                        toolbar.style.top = `${newY}px`;
                    };

                    const up = () => {
                        document.removeEventListener('mousemove', move);
                        document.removeEventListener('mouseup', up);
                        document.removeEventListener('touchmove', move);
                        document.removeEventListener('touchend', up);
                        saveState();
                    };

                    const down = (e) => {
                        e.preventDefault();
                        const r = toolbar.getBoundingClientRect();
                        const cx = e.touches ? e.touches[0].clientX : e.clientX;
                        const cy = e.touches ? e.touches[0].clientY : e.clientY;

                        offsetX = cx - r.left;
                        offsetY = cy - r.top;

                        document.addEventListener('mousemove', move);
                        document.addEventListener('mouseup', up);
                        document.addEventListener('touchmove', move);
                        document.addEventListener('touchend', up);
                    };

                    dragHandle.addEventListener('mousedown', down);
                    dragHandle.addEventListener('touchstart', down, { passive: false });
                },


                hideSelectionToolbar() { document.getElementById('selection-toolbar').style.display = 'none'; },


                showImageToolbar(imageContainer) {
                    const toolbar = document.getElementById('image-toolbar');
                    const isHighlighted = imageContainer.classList.contains('highlighted-image');
                    const isWriteMode = App.state.currentMode === 'write';
                    const isWhiteboardEmbed = imageContainer.classList.contains('wb-embed');

                    // Whiteboard buttons (moved to popover)
                    const editWhiteboardBtn = isWhiteboardEmbed ? `
                        <button class="btn-icon" title="Edit Whiteboard" onmousedown="event.preventDefault(); App.whiteboard.reopenFromEmbed(App.state.selectedImageContainer);" style="color: var(--primary-color); font-weight: 600;">
                            <i class="fa-solid fa-pencil"></i>
                        </button>
                    ` : '';

                    const annotateBtn = `
                        <button class="btn-icon" title="Annotate / Whiteboard" onmousedown="event.preventDefault(); App.whiteboard.initImageAnnotation(App.state.selectedImageContainer);">
                            <i class="fa-solid fa-pen-nib"></i>
                        </button>
                    `;

                    const toolsPopover = `
                <div class="list-toolbar-group" id="image-tools-group">
                    <button class="btn-icon" title="More Image Tools" aria-label="More image tools">
                        <i class="fa-solid fa-ellipsis-vertical"></i>
                    </button>
                    <div class="list-popover">
                        ${editWhiteboardBtn}
                        ${annotateBtn}
                        <button class="btn-icon ${!App.license.isPremium() ? 'premium-feature-locked' : ''}" title="Extract Text from Image (OCR)" onmousedown="event.preventDefault(); if (App.license.isPremium()) App.services.image.runOCR(); else App.ui.showAscensionModal();">
                            <i class="fa-solid fa-file-pen"></i>
                        </button>
                        <button class="btn-icon" title="Copy Image" onmousedown="event.preventDefault(); App.services.image.copy(App.state.selectedImageContainer);">${App.util.icons.copy}</button>
                        <button class="btn-icon" title="Reset Size" onmousedown="event.preventDefault(); App.events.handleImageAlignment('reset-size');">${App.util.icons.reset}</button>
                        ${isWriteMode ? `<button class="btn-icon" title="Delete Image" onmousedown="event.preventDefault(); App.services.image.delete(App.state.selectedImageContainer);">${App.util.icons.trash}</button>` : ''}
                    </div>
                </div>
            `;

                    const toolbarButtons = `
                <button class="btn-icon" title="Align Left" onmousedown="event.preventDefault(); App.events.handleImageAlignment('align-left');">${App.util.icons.alignLeft}</button>
                <button class="btn-icon" title="Align Center" onmousedown="event.preventDefault(); App.events.handleImageAlignment('align-center');">${App.util.icons.alignCenter}</button>
                <button class="btn-icon" title="Align Right" onmousedown="event.preventDefault(); App.events.handleImageAlignment('align-right');">${App.util.icons.alignRight}</button>
                <div class="control-divider"></div>
                <button class="btn-icon" title="Highlight Image" onmousedown="event.preventDefault(); App.events.highlightImage();" style="color: ${isHighlighted ? 'var(--primary-color)' : 'inherit'}">${isHighlighted ? App.util.icons.star : App.util.icons.starOutline}</button>
                <button class="btn-icon" title="View Fullscreen" onmousedown="event.preventDefault(); App.ui.imageLightbox.open(App.state.selectedImageContainer);">${App.util.icons.expand}</button>
                ${isWriteMode ? `<button class="btn-icon" title="Add/Edit Caption" onmousedown="event.preventDefault(); App.events.addImageCaption();">${App.util.icons.caption}</button>` : ''}
                <div class="control-divider"></div>
                ${toolsPopover}
            `;

                    toolbar.innerHTML = `<div class="toolbar-wrapper">${toolbarButtons}</div>`;
                    const rect = imageContainer.getBoundingClientRect();
                    toolbar.style.display = 'block';
                    toolbar.style.left = `${rect.left + window.scrollX + rect.width / 2 - toolbar.offsetWidth / 2}px`;
                    toolbar.style.top = `${rect.top + window.scrollY - toolbar.offsetHeight - 8}px`;
                },



                hideImageToolbar() { document.getElementById('image-toolbar').style.display = 'none'; },

                aiMagicModal: {
                    state: {
                        isOpen: false,
                        savedRange: null,
                        commands: [],
                        filteredCommands: [],
                        selectedIndex: 0,
                        fuse: null,
                    },

                    init() {
                        this._handleKeyDown = this._handleKeyDown.bind(this);
                    },

                    open() {
                        if (this.state.isOpen) return;

                        const selection = window.getSelection();
                        this.state.savedRange = (selection && !selection.isCollapsed && selection.rangeCount > 0)
                            ? selection.getRangeAt(0).cloneRange()
                            : null;

                        this.state.isOpen = true;
                        this.state.commands = this._getCommands();
                        this.state.fuse = App.offline.safeFuse(this.state.commands.filter(c => c.type !== 'separator'), { keys: ['title', 'desc', 'id'], threshold: 0.4 });
                        this.state.filteredCommands = this.state.commands;
                        this.state.selectedIndex = -1;

                        const modalHTML = `
                    <div class="ai-magic-backdrop">
                        <div class="ai-magic-modal">
                            <div class="ai-magic-header">
                                <h3 class="ai-magic-title witty-gradient-text">NoteKash AI Co-Pilot</h3>
                                <div class="ai-magic-prompt-container">
                                    <input type="text" id="ai-magic-prompt-input" placeholder="Search or Ask AI anything ..." autocomplete="off">
                                    <button id="ai-magic-prompt-send" class="btn-icon btn-primary" title="Ask AI">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
                                            <path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div id="ai-magic-command-list"></div>
                        </div>
                    </div>`;

                        document.getElementById('modal-container').innerHTML = modalHTML;

                        // THE FIX: Add the event listener ONLY when the modal opens.
                        document.addEventListener('keydown', this._handleKeyDown, true);

                        this._renderCommands();
                        this._addListeners();
                        document.getElementById('ai-magic-prompt-input').focus();
                    },

                    close() {
                        if (!this.state.isOpen) return;
                        this.state.isOpen = false;
                        this.state.savedRange = null;
                        document.getElementById('modal-container').innerHTML = '';

                        document.removeEventListener('keydown', this._handleKeyDown, true);
                    },

                    _showUpsellCard() {
                        const commandListEl = document.getElementById('ai-magic-command-list');
                        if (!commandListEl) return;
                        const promptContainer = document.querySelector('.ai-magic-prompt-container');
                        if (promptContainer) promptContainer.style.display = 'none';

                        const wittyMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
                        const diamondBadgeHTML = App.util.getTierBadgeHTML('Diamond');

                        const upsellHTML = `
                    <div class="ai-upsell-card">
                        ${diamondBadgeHTML}
                        <h4>Unlock Your Thinking Partner</h4>
                        <p>Go Premium to use all 25+ specialized AI tools. Turn raw notes into structured knowledge, get instant insights, and write faster than ever before.</p>
                        <button class="btn btn-primary" onclick="App.ui.showAscensionModal(); App.ui.aiMagicModal.close();">Unlock Full AI Power</button>
                        <p class="witty-gradient-text"><em>"${wittyMessage}"</em></p>
                    </div>
                `;

                        commandListEl.innerHTML = upsellHTML;
                    },

                    _getCommands() {
                        const hasSelection = !!this.state.savedRange;
                        const allCommands = [
                            // Selection Commands
                            { id: 'kashwriting', title: 'Improve Writing', desc: 'Refine the selected text', icon: 'fa-solid fa-wand-sparkles', action: () => App.events.ai.executeImproveWriting(), selection: true },
                            { id: 'kashgrammar', title: 'Fix Grammar', desc: 'Correct spelling and Grammar ', icon: 'fa-solid fa-pen-nib', action: () => App.events.ai.executeFixGrammar(), selection: true },
                            { id: 'kashexplain', title: 'Explain This', desc: 'Explain the selected concept', icon: 'fa-solid fa-lightbulb', action: () => App.events.ai.executeKashExplain(), selection: true },
                            { id: 'kashflash', title: 'Generate Flashcard', desc: 'Create a cloze from selection', icon: 'fa-solid fa-clone', action: () => App.events.ai.executeKashFlash(), selection: true },
                            { id: 'kashmnemonic', title: 'Create Mnemonic', desc: 'Generate a memory aid', icon: 'fa-solid fa-brain', action: () => App.events.ai.executeKashMnemonic(), selection: true },
                            { id: 'convertMcq', title: 'Convert to MCQ', desc: 'Turn selection into an MCQ block', icon: 'fa-solid fa-list-check', action: () => App.commandPalette.convertSelectionToMcq(), selection: true },
                            { id: 'kashtranslate', title: 'Translate...', desc: 'Translate selection to another language', icon: 'fa-solid fa-earth-americas', action: () => { const lang = prompt('Translate to language:'); if (lang) App.events.ai.executeKashTranslate(lang); }, selection: true },
                            { id: 'kashlist', title: 'Convert to List', desc: 'Restructure selection as a list', icon: 'fa-solid fa-list-ul', action: () => App.events.ai.executeKashListify(), selection: true },
                            { id: 'kashtable', title: 'Convert to Table', desc: 'Restructure selection into a table', icon: 'fa-solid fa-table-cells', action: () => App.events.ai.executeKashTable(), selection: true },

                            // Article-wide Commands
                            { id: 'kashexpand', title: 'Continue Writing', desc: 'Let AI continue from your cursor', icon: 'fa-solid fa-pen-fancy', action: () => App.events.ai.executeKashExpand() },
                            { id: 'kashsummary', title: 'Summarize Article', desc: 'Generate a summary of the entire note', icon: 'fa-solid fa-file-lines', action: () => App.events.ai.executeKashSummary() },
                            { id: 'kashcurate', title: 'Curate & Beautify', desc: 'Let AI structure and format the note', icon: 'fa-solid fa-wand-magic-sparkles', action: () => App.events.ai.executeKashCurate() },
                            { id: 'kashaccordion', title: 'Generate Q&A', desc: 'Create Q&A accordions from the note', icon: 'fa-solid fa-clipboard-question', action: () => App.events.ai.executeKashAccordion() },
                            { id: 'kashmcq', title: 'Generate MCQs', desc: 'Create multiple-choice questions', icon: 'fa-solid fa-list-check', action: () => App.events.ai.executeKashMcqGenerator() },
                            { id: 'kashhighlight', title: 'Auto-Highlight', desc: 'Highlight key parts of the note', icon: 'fa-solid fa-highlighter', action: () => App.events.ai.executeKashHighlight() },
                            { id: 'kashtags', title: 'Auto-Tag', desc: 'Automatically generate and apply tags', icon: 'fa-solid fa-tags', action: () => App.events.ai.executeKashTags() },
                            { id: 'kashkeywords', title: 'Extract Key Concepts', desc: 'Pull out main ideas into a Deck', icon: 'fa-solid fa-key', action: () => App.events.ai.executeKashKeywords() },
                            { id: 'kashtimeline', title: 'Create Timeline', desc: 'Generate a timeline from the note', icon: 'fa-solid fa-timeline', action: () => App.events.ai.executeKashTimeline() },

                            // --- NEWLY ADDED COMMANDS ---
                            { id: 'kashcraft', title: 'KashCraft Analysis', desc: 'Transform note into a structured analysis', icon: 'fa-solid fa-graduation-cap', action: () => App.events.ai.executeKashCraft() },
                            { id: 'kashextract', title: 'Extract Topic...', desc: 'Extract a specific topic from the note', icon: 'fa-solid fa-magnifying-glass-chart', action: () => { const topic = prompt('What topic do you want to extract? (e.g., key arguments, dates)'); if (topic) App.events.ai.executeKashExtract(topic); } },
                            { id: 'kashlink', title: 'Create & Link Note...', desc: 'Generate a new note on a topic and link it', icon: 'fa-solid fa-link', action: () => { const topic = prompt('What topic for the new note?'); if (topic) App.events.ai.executeKashLink(topic); } },
                            { id: 'kashlong', title: 'Detailed Summary', desc: 'Generate a long, detailed summary of the note', icon: 'fa-solid fa-file-export', action: () => App.events.ai.executeKashLong() },
                            { id: 'kashoutline', title: 'Generate Outline...', desc: 'Create an outline for a new topic', icon: 'fa-solid fa-list-ol', action: () => { const topic = prompt('What topic do you want an outline for?'); if (topic) App.events.ai.executeKashOutline(topic); } },
                            // --- END OF NEW COMMANDS ---

                            { id: 'kashsplit', title: 'Split Note', desc: 'Intelligently split this note into two', icon: 'fa-solid fa-scissors', action: () => App.events.ai.executeKashSplit() },
                            { id: 'kashquote', title: 'Find a Quote', desc: 'Add a relevant quote to your note', icon: 'fa-solid fa-quote-left', action: () => App.events.ai.executeKashQuote() },
                            { id: 'kashstory', title: 'Write a Story', desc: 'Turn the note into a memorable story', icon: 'fa-solid fa-book-open', action: () => App.events.ai.executeKashStory() },
                            { id: 'kashscript', title: 'Write a Script', desc: 'Generate a short video script', icon: 'fa-solid fa-clapperboard', action: () => App.events.ai.executeKashScript() },
                            { id: 'kashcomedy', title: 'Make it Funny', desc: 'Turn the note into a comedy routine', icon: 'fa-solid fa-masks-theater', action: () => App.events.ai.executeKashComedy() },
                            { id: 'kashquestion', title: 'Generate Questions', desc: 'Create study questions from the note', icon: 'fa-solid fa-circle-question', action: () => App.events.ai.executeKashQuestion() },
                            { id: 'kashdebate', title: 'Create a Debate', desc: 'Generate a pros and cons table', icon: 'fa-solid fa-scale-balanced', action: () => App.events.ai.executeKashDebate() },
                        ];

                        const selectionCommands = allCommands.filter(cmd => cmd.selection);
                        const articleCommands = allCommands.filter(cmd => !cmd.selection);

                        if (hasSelection) {
                            return [...selectionCommands, { type: 'separator' }, ...articleCommands];
                        }
                        return articleCommands;
                    },

                    _renderCommands() {
                        const listEl = document.getElementById('ai-magic-command-list');
                        if (!listEl) return;


                        const numColumns = Math.floor(listEl.offsetWidth / 195); // Approx width of a tile + gap
                        const isCompact = this.state.filteredCommands.length < numColumns && this.state.filteredCommands.length > 0;
                        listEl.classList.toggle('compact-grid', isCompact);

                        const html = this.state.filteredCommands.map((cmd, index) => {
                            if (cmd.type === 'separator') {
                                return '<div class="ai-magic-separator"></div>';
                            }
                            const isSelected = this.state.selectedIndex === index; // Check against visual index

                            const itemHTML = `
                        <div class="ai-magic-command-item ${isSelected ? 'selected' : ''}" data-visual-index="${index}" title="${cmd.desc}">
                            <i class="command-icon ${cmd.icon}"></i>
                            <div class="command-text">
                                <div class="command-title">${cmd.title}</div>
                            </div>
                        </div>
                    `;
                            return itemHTML;
                        }).join('');

                        listEl.innerHTML = html;
                    },

                    _addListeners() {
                        const backdrop = document.querySelector('.ai-magic-backdrop');
                        const searchInput = document.getElementById('ai-magic-prompt-input');
                        const sendBtn = document.getElementById('ai-magic-prompt-send');
                        const commandList = document.getElementById('ai-magic-command-list');

                        backdrop.addEventListener('click', (e) => { if (e.target === backdrop) this.close(); });

                        const handlePrompt = async () => {
                            if (!App.license.isPremium()) {
                                this._showUpsellCard();
                                return;
                            }
                            const query = searchInput.value.trim();
                            if (query) {
                                // --- SURGICAL FIX #2 STARTS HERE ---
                                const commandListEl = document.getElementById('ai-magic-command-list');
                                if (commandListEl) {
                                    commandListEl.innerHTML = `
                            <div class="copilot-empty-state" style="justify-content: center; text-align: center; padding: 2rem;">
                                <div class="spin" style="font-size: 2.5rem; color: var(--primary-color);">${App.util.icons.cycle}</div>
                                <h4 class="witty-gradient-text" style="margin-top: 1rem;">Your Second Brain is thinking...</h4>
                            </div>`;
                                }
                                // --- SURGICAL FIX #2 ENDS HERE ---

                                if (this.state.savedRange) {
                                    const selection = window.getSelection();
                                    selection.removeAllRanges();
                                    selection.addRange(this.state.savedRange);
                                }
                                const selection = window.getSelection();
                                const context = (selection && !selection.isCollapsed) ? selection.toString() : document.getElementById('article-content').innerText;
                                const fullPrompt = `Based on the following context:\n\n---\n${context}\n---\n\nAnswer this question: ${query}`;

                                await App.events.ai.executeKashAsk(fullPrompt);
                                this.close();
                            }
                        };

                        sendBtn.addEventListener('click', handlePrompt);
                        searchInput.addEventListener('input', () => {
                            const query = searchInput.value;
                            if (query) {
                                this.state.filteredCommands = this.state.fuse.search(query).map(r => r.item);
                            } else {
                                this.state.filteredCommands = this._getCommands();
                            }
                            this.state.selectedIndex = -1;
                            this._renderCommands();
                        });

                        commandList.addEventListener('click', (e) => {
                            const itemEl = e.target.closest('.ai-magic-command-item');
                            if (itemEl) {
                                if (!App.license.isPremium()) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    this._showUpsellCard();
                                    return;
                                }
                                this.state.selectedIndex = parseInt(itemEl.dataset.visualIndex, 10);
                                this._executeSelected();
                            }
                        });
                    },

                    _handleKeyDown(e) {
                        // CORRECTED: The internal reference must also use the correct name.
                        if (!App.ui.aiMagicModal.state.isOpen) return;
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            e.stopPropagation();
                            this.close();
                            return;
                        }
                        const items = Array.from(document.querySelectorAll('.ai-magic-command-item'));
                        if (items.length === 0 && e.key !== 'Enter') return;
                        const isInputFocused = document.activeElement.id === 'ai-magic-prompt-input';
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            if (isInputFocused) {
                                document.getElementById('ai-magic-prompt-send').click();
                            } else {
                                this._executeSelected();
                            }
                            return;
                        }
                        // Arrow key navigation logic remains the same.
                        if (e.key === 'ArrowUp' && this.state.selectedIndex !== -1) {
                            e.preventDefault();
                            const numColumns = getComputedStyle(document.getElementById('ai-magic-command-list')).gridTemplateColumns.split(' ').length;
                            const newIndex = this.state.selectedIndex - numColumns;
                            if (newIndex < 0) {
                                this.state.selectedIndex = -1;
                                document.getElementById('ai-magic-prompt-input').focus();
                                this._updateSelection();
                            } else {
                                this.state.selectedIndex = newIndex;
                                this._updateSelection();
                            }
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            const numColumns = getComputedStyle(document.getElementById('ai-magic-command-list')).gridTemplateColumns.split(' ').length;
                            if (isInputFocused) {
                                this.state.selectedIndex = 0;
                            } else {
                                this.state.selectedIndex = Math.min(this.state.selectedIndex + numColumns, items.length - 1);
                            }
                            this._updateSelection();
                        } else if (e.key === 'ArrowLeft' && !isInputFocused) {
                            e.preventDefault();
                            this.state.selectedIndex = Math.max(0, this.state.selectedIndex - 1);
                            this._updateSelection();
                        } else if (e.key === 'ArrowRight' && !isInputFocused) {
                            e.preventDefault();
                            this.state.selectedIndex = Math.min(this.state.selectedIndex + 1, items.length - 1);
                            this._updateSelection();
                        }
                    },

                    _updateSelection() {
                        const items = document.querySelectorAll('.ai-magic-command-item');
                        items.forEach((item) => {
                            const visualIndex = parseInt(item.dataset.visualIndex, 10);
                            const isSelected = visualIndex === this.state.selectedIndex;
                            item.classList.toggle('selected', isSelected);
                            if (isSelected) {
                                item.scrollIntoView({ block: 'nearest' });
                            }
                        });
                    },

                    _executeSelected() {
                        const command = this.state.filteredCommands[this.state.selectedIndex];
                        if (command && command.action) {
                            if (this.state.savedRange) {
                                const selection = window.getSelection();
                                selection.removeAllRanges();
                                selection.addRange(this.state.savedRange);
                            }
                            command.action();
                            this.close();
                        }
                    }
                },


                imageLightbox: {
                    state: {
                        scale: 1,
                        isDragging: false,
                        startPos: { x: 0, y: 0 },
                        translatePos: { x: 0, y: 0 }
                    },

                    open(imageContainer) {
                        if (!imageContainer) return;
                        const img = imageContainer.querySelector('img');
                        if (!img) return;

                        this.state = { scale: 1, isDragging: false, startPos: { x: 0, y: 0 }, translatePos: { x: 0, y: 0 } };

                        const lightboxHTML = `
                    <div id="image-lightbox-overlay" class="modal-backdrop" style="z-index: 25000; background-color: rgba(0,0,0,0.8);">
                        <div class="lightbox-image-wrapper">
                            <img src="${img.src}" class="lightbox-image" alt="Lightbox image">
                        </div>
                        <div class="lightbox-controls">
                            <button class="btn-icon" id="lightbox-zoom-in" title="Zoom In (+)">${App.util.icons.zoomIn}</button>
                            <button class="btn-icon" id="lightbox-zoom-out" title="Zoom Out (-)">${App.util.icons.zoomOut}</button>
                            <button class="btn-icon" id="lightbox-reset" title="Reset View (R)">${App.util.icons.reset}</button>
                            <button class="btn-icon" id="lightbox-close" title="Close (Esc)">${App.util.icons.close}</button>
                        </div>
                    </div>
                `;
                        document.body.insertAdjacentHTML('beforeend', lightboxHTML);
                        this.addListeners();
                    },
                    showAiContextMenu(range) {
                        this.hideContextMenu(); // Ensure no other context menus are open
                        const rect = range.getBoundingClientRect();
                        const x = rect.left + window.scrollX;
                        const y = rect.top + window.scrollY - 38; // Position it just above the selection

                        const menuHtml = `
                    <button onclick="App.events.ai.executeImproveWriting()">Improve Writing</button>
                    <button onclick="App.events.ai.executeFixGrammar()">Fix Grammar & Spelling</button>
                `;

                        this.showContextMenu(x, y, menuHtml);
                    },
                    close() {
                        const overlay = document.getElementById('image-lightbox-overlay');
                        if (overlay) overlay.remove();
                        document.removeEventListener('keydown', this.handleKeyDown);
                    },

                    addListeners() {
                        const overlay = document.getElementById('image-lightbox-overlay');
                        const imageWrapper = overlay.querySelector('.lightbox-image-wrapper');

                        document.getElementById('lightbox-zoom-in').addEventListener('click', () => this.zoom(1));
                        document.getElementById('lightbox-zoom-out').addEventListener('click', () => this.zoom(-1));
                        document.getElementById('lightbox-reset').addEventListener('click', () => this.reset());
                        document.getElementById('lightbox-close').addEventListener('click', () => this.close());

                        overlay.addEventListener('click', (e) => { if (e.target === overlay) this.close(); });

                        imageWrapper.addEventListener('mousedown', (e) => this.startPan(e));
                        imageWrapper.addEventListener('mousemove', (e) => this.pan(e));
                        imageWrapper.addEventListener('mouseup', () => this.endPan());
                        imageWrapper.addEventListener('mouseleave', () => this.endPan());
                        imageWrapper.addEventListener('wheel', (e) => {
                            e.preventDefault();
                            this.zoom(e.deltaY > 0 ? -1 : 1);
                        }, { passive: false });

                        document.addEventListener('keydown', this.handleKeyDown.bind(this));
                    },

                    updateTransform() {
                        const wrapper = document.querySelector('.lightbox-image-wrapper');
                        if (wrapper) {
                            wrapper.style.transform = `translate(${this.state.translatePos.x}px, ${this.state.translatePos.y}px) scale(${this.state.scale})`;
                        }
                    },

                    zoom(direction) {
                        const zoomFactor = 1.2;
                        this.state.scale *= (direction > 0) ? zoomFactor : (1 / zoomFactor);
                        this.state.scale = Math.max(0.5, Math.min(this.state.scale, 8)); // Clamp zoom level

                        if (this.state.scale <= 1) this.reset();
                        else this.updateTransform();
                    },

                    reset() {
                        this.state.scale = 1;
                        this.state.translatePos = { x: 0, y: 0 };
                        this.updateTransform();
                    },

                    startPan(e) {
                        if (this.state.scale <= 1) return;
                        e.preventDefault();
                        this.state.isDragging = true;
                        this.state.startPos = { x: e.clientX - this.state.translatePos.x, y: e.clientY - this.state.translatePos.y };
                        const wrapper = document.querySelector('.lightbox-image-wrapper');
                        if (wrapper) wrapper.style.cursor = 'grabbing';
                    },

                    pan(e) {
                        if (!this.state.isDragging) return;
                        this.state.translatePos.x = e.clientX - this.state.startPos.x;
                        this.state.translatePos.y = e.clientY - this.state.startPos.y;
                        this.updateTransform();
                    },

                    endPan() {
                        this.state.isDragging = false;
                        const wrapper = document.querySelector('.lightbox-image-wrapper');
                        if (wrapper) wrapper.style.cursor = 'grab';
                    },

                    handleKeyDown(e) {
                        switch (e.key) {
                            case 'Escape': this.close(); break;
                            case '+': case '=': this.zoom(1); break;
                            case '-': this.zoom(-1); break;
                            case 'r': case '0': this.reset(); break;
                        }
                    }
                },
                showContextMenu(x, y, menuHtml) {
                    this.hideContextMenu();
                    const container = document.getElementById('context-menu-container');
                    container.innerHTML = `<div class="context-menu" style="left: ${x}px; top: ${y}px;">${menuHtml}</div>`;
                },
                hideContextMenu() { document.getElementById('context-menu-container').innerHTML = ''; },

                showToast(message, options = {}) {
                    if (typeof options === 'string') { options = { type: options }; }
                    const { type = 'info', duration = 4000, action = null } = options;

                    const container = document.getElementById('toast-container');
                    const toast = document.createElement('div');
                    toast.className = `toast ${type}`;
                    toast.id = `toast-${crypto.randomUUID()}`; // Assign a unique ID for updating

                    // Intelligently handle HTML content vs. plain text.
                    if (/<[a-z][\s\S]*>/i.test(message)) {
                        toast.innerHTML = message;
                    } else {
                        const messageSpan = document.createElement('span');
                        messageSpan.textContent = message;
                        toast.appendChild(messageSpan);
                    }

                    if (action && action.label && action.callback) {
                        const actionButton = document.createElement('button');
                        actionButton.className = 'btn btn-secondary';
                        actionButton.textContent = action.label;
                        actionButton.onclick = () => { action.callback(); this.hideToast(toast); };
                        actionButton.style.marginLeft = 'auto';
                        toast.appendChild(actionButton);
                    }

                    container.appendChild(toast);
                    setTimeout(() => toast.classList.add('show'), 100);

                    if (duration > 0) {
                        setTimeout(() => {
                            this.hideToast(toast);
                        }, duration);
                    }
                    return toast;
                },


                updateToast(toastIdOrEl, message, options = {}) {
                    const toast = (typeof toastIdOrEl === 'string') ? document.getElementById(toastIdOrEl) : toastIdOrEl;
                    if (toast) {
                        const messageHolder = toast.querySelector('span') || toast;
                        if (/<[a-z][\s\S]*>/i.test(message)) {
                            messageHolder.innerHTML = message;
                        } else {
                            messageHolder.textContent = message;
                        }

                        // Handle duration option - auto-hide toast after duration
                        if (options.duration && options.duration > 0) {
                            setTimeout(() => {
                                toast.classList.remove('show');
                                setTimeout(() => toast.remove(), 400);
                            }, options.duration);
                        }

                        // Handle type option - update toast class
                        if (options.type) {
                            toast.className = toast.className.replace(/toast-(success|error|info|warning)/g, '');
                            toast.classList.add(`toast-${options.type}`);
                        }
                    }
                },

                hideToast(toastIdOrEl) {
                    const toast = (typeof toastIdOrEl === 'string') ? document.getElementById(toastIdOrEl) : toastIdOrEl;
                    if (toast) {
                        toast.classList.remove('show');
                        setTimeout(() => toast.remove(), 400);
                    }
                },

                showSettingsModal() {
                    const isPremium = App.license.isPremium();

                    const navItems = [
                        { id: 'profile', icon: 'fa-user-circle', label: 'Profile & License', action: 'showLicenseModal', isLocked: false },
                        { id: 'appearance', icon: 'fa-palette', label: 'Appearance Model', action: 'showAppearanceModal', isLocked: false },
                        { id: 'categories', icon: 'fa-folder-tree', label: 'Category Manager', action: 'showCategoryManagerModal', isLocked: false },
                        { id: 'storage', icon: 'fa-database', label: 'Storage & Sync', action: 'showStorageModal', isLocked: false },
                        { id: 'audio', icon: 'fa-microphone-lines', label: 'Audio & Scribe', action: 'showAudioSettingsModal', isLocked: false },
                        { id: 'ai', icon: 'fa-wand-magic-sparkles', label: 'NoteKash AI', action: 'showAiSettingsModal', isLocked: !isPremium },
                        { id: 'shortcuts', icon: 'fa-keyboard', label: 'Shortcut Manual', action: 'showShortcutsModal', isLocked: false },
                    ];

                    const navItemsHTML = navItems.map(item => `
                    <a class="settings-nav-item ${item.isLocked ? 'locked' : ''}" 
                       onclick="if (!this.classList.contains('locked')) { App.ui.closeModal(); App.ui.${item.action}(); } else { App.ui.showAscensionModal(); }"
                       style="justify-content: flex-start;">
                        <i class="fa-solid ${item.icon}" style="width: 24px;"></i> 
                        <span>${item.label}</span>
                    </a>
                `).join('');

                    const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div class="modal-content ui-card" style="max-width: 420px;" onclick="event.stopPropagation()">
                            <h3 style="text-align: center;">Settings</h3>
                            <nav class="settings-nav" style="border: none; padding: 0.5rem;">
                                ${navItemsHTML}
                            </nav>
                            <div class="modal-buttons">
                                <button class="btn btn-primary" onclick="App.ui.closeModal()">Close</button>
                            </div>
                        </div>
                    </div>`;

                    document.getElementById('modal-container').innerHTML = modalHTML;
                },

                toggleKeyVisibility(inputId, iconId) {
                    const input = document.getElementById(inputId);
                    const icon = document.getElementById(iconId);
                    if (input.type === 'password') {
                        input.type = 'text';
                        icon.classList.remove('fa-eye');
                        icon.classList.add('fa-eye-slash');
                    } else {
                        input.type = 'password';
                        icon.classList.remove('fa-eye-slash');
                        icon.classList.add('fa-eye');
                    }
                },

                switchAiProvider() {
                    const select = document.getElementById('ai-provider-select');
                    if (!select) return;
                    const provider = select.value;
                    document.querySelectorAll('.provider-content').forEach(c => c.style.display = 'none');
                    const active = document.getElementById(`provider-${provider}`);
                    if (active) active.style.display = 'block';
                },

                toggleKeyVisibility(inputId, iconId) {
                    const input = document.getElementById(inputId);
                    const icon = document.getElementById(iconId);
                    if (!input || !icon) return;
                    if (input.type === 'password') {
                        input.type = 'text';
                        icon.classList.replace('fa-eye', 'fa-eye-slash');
                    } else {
                        input.type = 'password';
                        icon.classList.replace('fa-eye-slash', 'fa-eye');
                    }
                },

                deleteAiKey(providerId) {
                    if (confirm('Delete this API key?')) {
                        App.settings.set(`${providerId}Key`, null);
                        App.ui.showAiSettingsModal();
                    }
                },

                showAiSettingsModal() {
                    const savedProvider = App.settings.get('aiProvider') || 'openrouter';

                    const providers = [
                        { id: 'openrouter', name: 'OpenRouter', key: App.settings.get('openRouterKey'), model: App.settings.get('openRouterModel') || 'mistralai/mistral-7b-instruct:free', keyPlaceholder: 'sk-or-...', modelPlaceholder: 'e.g. openai/gpt-4o' },
                        { id: 'gemini', name: 'Google Gemini', key: App.settings.get('geminiKey'), model: App.settings.get('geminiModel') || 'gemini-2.5-flash', keyPlaceholder: 'AIzaSy...' },
                        { id: 'openai', name: 'OpenAI', key: App.settings.get('openaiKey'), model: App.settings.get('openaiModel') || 'gpt-4o-mini', keyPlaceholder: 'sk-...', modelPlaceholder: 'e.g. gpt-4o' },
                        { id: 'huggingface', name: 'Hugging Face', key: App.settings.get('huggingfaceKey'), model: App.settings.get('huggingfaceModel') || 'mistralai/Mistral-7B-Instruct-v0.2', keyPlaceholder: 'hf_...', modelPlaceholder: 'user/model-name' }
                    ];

                    const providerOptionsHTML = providers.map(p => `<option value="${p.id}" ${savedProvider === p.id ? 'selected' : ''}>${p.name}</option>`).join('');

                    const contentSectionsHTML = providers.map(p => {
                        const isVisible = savedProvider === p.id ? 'block' : 'none';
                        const hasKey = !!p.key;

                        let modelHTML = '';
                        if (p.id === 'gemini') {
                            modelHTML = `
                                <div class="settings-grid">
                                    <label for="gemini-model-select">Model</label>
                                    <select id="gemini-model-select" class="btn btn-secondary">
                                        <option value="gemini-2.5-flash-live" ${p.model === 'gemini-2.5-flash-live' ? 'selected' : ''}>Live (Flash Live)</option>
                                        <option value="gemini-2.5-flash" ${p.model === 'gemini-2.5-flash' ? 'selected' : ''}>Medium (Flash)</option>
                                        <option value="gemini-2.5-flash-lite" ${p.model === 'gemini-2.5-flash-lite' ? 'selected' : ''}>Air (Lite)</option>
                                        <option value="gemma-3-27b" ${p.model === 'gemma-3-27b' ? 'selected' : ''}>Heavy (Gemma)</option>
                                    </select>
                                </div>`;
                        } else {
                            modelHTML = `
                                <div class="settings-grid">
                                    <label for="${p.id}-model-input">Model</label>
                                    <input type="text" id="${p.id}-model-input" class="text-input" value="${p.model}" placeholder="${p.modelPlaceholder || 'Model ID'}">
                                </div>`;
                        }

                        return `
                        <div id="provider-${p.id}" class="provider-content" style="display: ${isVisible};">
                            <div class="settings-grid" style="margin-bottom: 0.5rem;">
                                <label for="${p.id}-key-input">API Key</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <div style="position: relative; flex: 1;">
                                        <input type="password" id="${p.id}-key-input" class="text-input" value="${p.key || ''}" placeholder="${p.keyPlaceholder}" style="padding-right: 2.5rem;">
                                        <i class="fa-solid fa-eye" id="${p.id}-eye-icon" onclick="App.ui.toggleKeyVisibility('${p.id}-key-input', '${p.id}-eye-icon')" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; color: var(--text-muted);"></i>
                                    </div>
                                    ${hasKey ? `<button class="btn btn-danger" onclick="App.ui.deleteAiKey('${p.id}')" title="Delete Key"><i class="fa-solid fa-trash"></i></button>` : ''}
                                </div>
                            </div>
                            ${modelHTML}
                        </div>`;
                    }).join('');

                    const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div class="modal-content ui-card" onclick="event.stopPropagation()">
                            <h3>NoteKash AI (BYOK)</h3>

                            <div class="settings-section">
                                <h4>AI Provider</h4>
                                <div class="settings-grid">
                                    <label for="ai-provider-select">Select Provider</label>
                                    <select id="ai-provider-select" class="btn btn-secondary" onchange="App.ui.switchAiProvider()">
                                        ${providerOptionsHTML}
                                    </select>
                                </div>
                                <small style="color: var(--text-muted); display: block; margin-top: 0.5rem;">
                                    <i class="fa-solid fa-circle-info"></i> Bring your own API Key, that are stored locally. Check "Openrouter" for free AI Keys.
                                </small>
                            </div>

                            <div class="settings-section">
                                <h4>Configuration</h4>
                                ${contentSectionsHTML}
                            </div>

                            <div class="modal-buttons">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back</button>
                                <button class="btn btn-primary" onclick="App.events.ai.saveAiSettings()">Save</button>
                            </div>
                        </div>
                    </div>`;

                    document.getElementById('modal-container').innerHTML = modalHTML;
                },

                showAudioSettingsModal() {
                    const currentBitrate = App.settings.get('audioBitrate');

                    const bitrateOptions = [
                        { value: 16000, label: 'Mini (To Save Space)' },
                        { value: 32000, label: 'Low (Voice Memo)' },
                        { value: 64000, label: 'Medium (Podcast - Recommended)' },
                        { value: 128000, label: 'High (Music)' }
                    ].map(opt => `<option value="${opt.value}" ${currentBitrate === opt.value ? 'selected' : ''}>${opt.label}</option>`).join('');

                    const models = [
                        { id: 'tiny', name: 'Smooth', size: '75 MB' }, { id: 'base', name: 'Good', size: '142 MB' },
                        { id: 'small', name: 'Better', size: '466 MB' }, { id: 'medium', name: 'Excellent', size: '1.42 GB' }
                    ];
                    const modelsHTML = models.map(model => `
                    <div class="settings-item">
                        <div class="settings-label"><b>${model.name} Model</b><small>${model.size} download</small></div>
                        <button class="btn btn-secondary" id="download-model-${model.id}" onclick="App.audio.downloadTranscriptionModel('Xenova/whisper-${model.id}')">Download</button>
                    </div>
                `).join('');

                    const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div id="audio-settings-modal-content" class="modal-content ui-card" onclick="event.stopPropagation()">
                            <h3>Audio & Transcription</h3>

                            <div class="settings-section">
                                <h4>Audio Configuration</h4>
                                <div class="settings-grid">
                                    <label for="audio-bitrate-select">Recording Quality</label>
                                    <select id="audio-bitrate-select" class="btn btn-secondary" onchange="App.settings.set('audioBitrate', parseInt(this.value, 10))">${bitrateOptions}</select>
                                </div>
                                <div id="ascension-witty-message" class="witty-gradient-text" style="text-align: left; margin-top: 1rem; font-size: 1.1em;">Premium Offline Transcription</div>
                                <div class="settings-label" style="padding: 2px 0;">
                                    <small>Download a model to enable offline, private audio transcription.</small>
                                </div>
                                ${modelsHTML}
                                <div class="settings-item" style="margin-top: 1rem;">
                                    <div class="settings-label"><b>Current Status</b><small id="transcription-model-status">No model downloaded.</small></div>
                                    <button class="btn btn-danger" id="delete-models-btn" style="display:none;" onclick="App.audio.deleteTranscriptionModels()">Delete Models</button>
                                </div>
                            </div>

                            <div class="modal-buttons">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back</button>
                                <button class="btn btn-primary" onclick="App.ui.closeModal()">Done</button>
                            </div>
                        </div>
                    </div>`;

                    document.getElementById('modal-container').innerHTML = modalHTML;
                    App.audio.updateModelStatusUI();
                },

                showAppearanceModal() {
                    const currentTheme = App.settings.get('theme');
                    const themeOptions = App.config.themes.map(t => {
                        const isPremium = t.id === 'custom';
                        const isDisabled = isPremium && !App.license.isPremium();
                        return `<option value="${t.id}" ${currentTheme === t.id ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}>${t.name}${isDisabled ? ' ' : ''}</option>`;
                    }).join('');

                    const currentFont = App.settings.get('fontFamily');
                    const fontOptions = App.config.fonts.map(font => {
                        const freeFonts = ['Arial, Helvetica, sans-serif', 'Cambria, Cochin, Georgia, Times, "Times New Roman", serif', "'Courier New', Courier, monospace", 'Garamond, serif', 'Georgia, serif', 'Helvetica, Arial, sans-serif', 'Monaco, "Lucida Console", monospace', 'Palatino, "Palatino Linotype", serif', 'sans-serif', "'Times New Roman', Times, serif", 'Verdana, Geneva, sans-serif'];
                        const isPremium = !freeFonts.includes(font.value);
                        const isDisabled = isPremium && !App.license.isPremium();
                        return `<option value="${font.value}" ${currentFont === font.value ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}>${font.name}${isDisabled ? ' ' : ''}</option>`;
                    }).join('');

                    const currentSize = parseFloat(App.settings.get('fontSize'));
                    const currentLineHeight = App.settings.get('lineHeight');
                    const currentOpacity = App.settings.get('uiOpacity');
                    const ocrThreshold = App.settings.get('ocrThreshold') || 128;
                    const customThemeBase = App.settings.get('customThemeBase');
                    const isMobileViewEnabled = App.settings.get('mobileViewEnabled');
                    const mobileViewLabel = isMobileViewEnabled ? 'Switch to Desktop View' : 'Switch to Mobile View';
                    const mobileViewDescription = isMobileViewEnabled ? 'For utilizing the full power of the app.' : 'Optimized for small screens & touch.';
                    const libraryTitle = App.settings.get('libraryTitle') || 'My Library';

                    const captionThemes = [
                        { id: 'sharp-light', name: 'Sharp Light (Default)' },
                        { id: 'sharp-dark', name: 'Sharp Dark' },
                        { id: 'forest', name: 'Forest Green Text' },
                        { id: 'navy', name: 'Navy Blue Text' },
                        { id: 'maroon', name: 'Maroon Text' },
                        { id: 'chocolate', name: 'Chocolate Text' },
                        { id: 'charcoal', name: 'Charcoal Text' },
                        { id: 'sunbeam', name: 'Sunbeam Yellow' },
                        { id: 'aqua', name: 'Aqua Blue' },
                        { id: 'lime', name: 'Lime Green' },
                        { id: 'rose', name: 'Rose Pink' },
                        { id: 'lavender', name: 'Lavender' },
                        { id: 'soft-glow', name: 'Soft Glow' },
                        { id: 'letterpress', name: 'Letterpress (Carved)' },
                        { id: 'gold-leaf', name: 'Gold Leaf (Glow)' }
                    ];
                    const currentCaptionTheme = App.settings.get('captionTheme') || 'sharp-light';
                    const captionThemeOptions = captionThemes.map(t => `<option value="${t.id}" ${currentCaptionTheme === t.id ? 'selected' : ''}>${t.name}</option>`).join('');

                    const captionAlignments = [
                        { id: 'bottom', name: 'Bottom' }, { id: 'middle', name: 'Middle' }, { id: 'top', name: 'Top' }
                    ];
                    const currentCaptionAlign = App.settings.get('captionAlign') || 'bottom';
                    const captionAlignOptions = captionAlignments.map(a => `<option value="${a.id}" ${currentCaptionAlign === a.id ? 'selected' : ''}>${a.name}</option>`).join('');


                    const modalHTML = `
                <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                    <div class="modal-content ui-card" style="max-width: 600px;" onclick="event.stopPropagation()">
                        <h3 style="text-align: center;">Appearance</h3>
                        
                        <div class="settings-section">
                            <h4><i class="fa-solid fa-swatchbook"></i> Theme & Layout</h4>
                            <div class="settings-grid">
                                <label for="theme-select">Theme</label>
                                <select id="theme-select" class="btn btn-secondary">${themeOptions}</select>

                                <label for="library-title-input">Library Title</label>
                                <input type="text" id="library-title-input" class="text-input" value="${App.util.escapeHtml(libraryTitle)}" placeholder="e.g., My Knowledge Garden">
                            </div>
                        </div>

                        <div id="custom-theme-controls" style="display: ${currentTheme === 'custom' ? 'block' : 'none'};" class="settings-section">
                            <h4><i class="fa-solid fa-image"></i> Custom Background</h4>
                            <div class="settings-grid">
                                <label for="custom-theme-base">UI Base</label>
                                <select id="custom-theme-base" class="btn btn-secondary">
                                    <option value="light" ${customThemeBase === 'light' ? 'selected' : ''}>Light UI</option>
                                    <option value="dark" ${customThemeBase === 'dark' ? 'selected' : ''}>Dark UI</option>
                                </select>
                                <div class="control-span" style="grid-column: 1 / -1;">
                                    <button id="change-bg-btn" class="btn btn-secondary" style="width:100%">Change Background Image</button>
                                </div>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h4><i class="fa-solid fa-font"></i> Typography</h4>
                            <div class="settings-grid">
                                <label for="font-family-select">Font Family</label>
                                <select id="font-family-select" class="btn btn-secondary">${fontOptions}</select>
                                
                                <div class="settings-label" title="Controls the default text size within notes."><b>Font Size</b></div>
                                <div class="slider-control-wrapper"><input type="range" id="font-size-slider" min="0.8" max="2.2" step="0.05" value="${currentSize}"><span id="font-size-value">${currentSize.toFixed(2)}rem</span></div>

                                <div class="settings-label" title="Adjusts the vertical spacing between lines of text for better readability."><b>Line Spacing</b></div>
                                <div class="slider-control-wrapper"><input type="range" id="line-height-slider" min="1.4" max="2.2" step="0.05" value="${currentLineHeight}"><span id="line-height-value">${currentLineHeight}</span></div>
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <h4><i class="fa-solid fa-closed-captioning"></i> Image Caption Style</h4>
                            <div class="settings-grid">
                                <label for="caption-theme-select">Caption Color</label>
                                <select id="caption-theme-select" class="btn btn-secondary">${captionThemeOptions}</select>

                                <label for="caption-align-select">Caption Position</label>
                                <select id="caption-align-select" class="btn btn-secondary">${captionAlignOptions}</select>
                            </div>
                        </div>

                        <div class="settings-section">
                             <h4><i class="fa-solid fa-sliders"></i> UI & Image Settings</h4>
                             <div class="settings-grid">
                                <div class="settings-label" title="Adjusts the transparency of UI elements like modals and toolbars. Set to 0% for a fully transparent look."><b>UI Opacity</b></div>
                                <div class="slider-control-wrapper"><input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="${currentOpacity}"><span id="opacity-value">${Math.round(currentOpacity * 100)}%</span></div>

                                <div class="settings-label" title="Controls the compression level for pasted or dropped images. Lower quality means smaller file sizes."><b>Import Image Quality</b></div>
                                <div class="slider-control-wrapper"><input type="range" id="image-quality-slider" min="0.1" max="1" step="0.05" value="${App.settings.get('jpegQuality')}"><span id="image-quality-value">${Math.round(App.settings.get('jpegQuality') * 100)}%</span></div>
                                
                                <div class="settings-label" title="Choose image format: JPEG for smaller file sizes, PNG for reliability (prevents corruption, keeps transparency)."><b>Image Format</b></div>
                                <select id="image-format-select" class="btn btn-secondary">
                                    <option value="jpeg" ${App.settings.get('imageFormat') === 'jpeg' ? 'selected' : ''}>Compressed (JPEG)</option>
                                    <option value="png" ${App.settings.get('imageFormat') === 'png' ? 'selected' : ''}>Reliable (PNG)</option>
                                </select>
                                <div class="settings-label" title="Adjusts the black/white contrast for OCR. Higher values work for light text on dark backgrounds; lower values for dark text on light backgrounds."><b>OCR Contrast</b></div>
                                <div class="slider-control-wrapper"><input type="range" id="ocr-threshold-slider" min="50" max="200" step="1" value="${ocrThreshold}"><span id="ocr-threshold-value">${ocrThreshold}</span></div>
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <h4><i class="fa-solid fa-mobile-screen-button"></i> View Mode</h4>
                            <div class="settings-item">
                                <div class="settings-label" id="mobile-view-label-container"><b>${mobileViewLabel}</b><small>${mobileViewDescription}</small></div>
                                <div id="mobile-view-toggle" class="toggle-switch ${isMobileViewEnabled ? 'active' : ''}"></div>
                            </div>
                        </div>

                        <div class="modal-buttons">
                            <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back to Settings</button>
                        </div>
                    </div>
                </div>`;

                    document.getElementById('modal-container').innerHTML = modalHTML;
                    document.getElementById('theme-select').addEventListener('change', (e) => App.events.handleThemeChange(e.target.value));
                    document.getElementById('library-title-input').addEventListener('input', App.events.changeLibraryTitle);
                    document.getElementById('font-family-select').addEventListener('input', App.events.changeFontFamily);
                    document.getElementById('font-size-slider').addEventListener('input', App.events.changeFontSize);
                    document.getElementById('line-height-slider').addEventListener('input', App.events.changeLineHeight);
                    document.getElementById('custom-theme-base').addEventListener('input', App.events.handleCustomThemeBaseChange);
                    document.getElementById('opacity-slider').addEventListener('input', App.events.changeUiOpacity);
                    document.getElementById('mobile-view-toggle').addEventListener('click', App.events.toggleMobileView);
                    document.getElementById('image-quality-slider').addEventListener('input', App.events.changeImageQuality);
                    document.getElementById('ocr-threshold-slider').addEventListener('input', App.events.changeOcrThreshold);
                    document.getElementById('change-bg-btn').addEventListener('click', () => App.events.triggerBgImageUpload());

                    document.getElementById('caption-theme-select').addEventListener('change', (e) => App.settings.set('captionTheme', e.target.value));
                    document.getElementById('caption-align-select').addEventListener('change', (e) => App.settings.set('captionAlign', e.target.value));
                    document.getElementById('image-format-select').addEventListener('change', (e) => App.settings.set('imageFormat', e.target.value));
                },

                showFlashcardSettingsModal() {
                    const currentFim = App.settings.get('intervalModifier');
                    const currentSessionSize = App.settings.get('studySessionSize');

                    this.showConfirmationModal({
                        title: 'Flashcard Settings ',
                        message: `
                        <div class="settings-grid" style="gap: 1.5rem;">
                            <div class="control-span" title="Set the number of cards to study in a standard session.">
                                <label for="session-size-input" style="flex-grow: 1;">Study Session Size</label>
                                <input type="number" id="session-size-input" class="text-input" value="${currentSessionSize}" min="1" style="width: 80px; text-align: center;">
                            </div>
                            <div class="control-span" title="Adjust the speed of all review intervals. >100% is longer, <100% is shorter.">
                                <label for="interval-modifier-slider">Spaced Recall Controller</label>
                                <input type="range" id="interval-modifier-slider" min="0.3" max="2.5" step="0.05" value="${currentFim}">
                                <span id="interval-modifier-value" style="min-width: 50px; text-align: right;">${Math.round(currentFim * 100)}%</span>
                            </div>
                        </div>
                    `,
                        confirmText: 'Done',
                        showCancel: false,
                        onConfirm: () => { }, // The button will just close the modal
                        modalClass: 'flashcard-settings-modal'
                    });

                    // Add live event listeners for the new controls
                    document.getElementById('session-size-input').addEventListener('change', (e) => {
                        const newLimit = parseInt(e.target.value, 10);
                        if (newLimit > 0) {
                            App.settings.set('studySessionSize', newLimit);
                        }
                    });

                    document.getElementById('interval-modifier-slider').addEventListener('input', (e) => {
                        const modifier = parseFloat(e.target.value);
                        document.getElementById('interval-modifier-value').textContent = `${Math.round(modifier * 100)}%`;
                        App.settings.set('intervalModifier', modifier);
                    });
                },

                showChartModal() {
                    App.state.savedRange = window.getSelection().getRangeAt(0).cloneRange(); // Save cursor position

                    this.showConfirmationModal({
                        title: 'Create Chart',
                        message: `
                        <div class="settings-grid" style="gap: 1rem;">
                            <label for="chart-type-select">Chart Type</label>
                            <select id="chart-type-select" class="btn btn-secondary">
                                <option value="bar">Bar Chart</option>
                                <option value="bar-vertical">Bar (Vertical)</option>
                                <option value="line">Line Chart</option>
                                <option value="doughnut">Doughnut Chart</option>
                            </select>
                            <label for="chart-data-input" style="align-self: start; padding-top: 8px;">Data</label>
                            <textarea id="chart-data-input" class="text-input" rows="6" placeholder="Enter data, one item per line.\nFormat: Label,Value\n\nExample:\nApples,12\nOranges,9\nBananas,5"></textarea>
                        </div>
                    `,
                        confirmText: 'Insert Chart',
                        onConfirm: () => App.ui.insertChartFromModal(),
                        modalClass: 'chart-modal'
                    });
                    App.util.trapFocus(document.querySelector('.chart-modal'));
                    setTimeout(() => {
                        const dataInput = document.getElementById('chart-data-input');
                        if (dataInput) {
                            dataInput.focus();
                            dataInput.select();
                        }
                    }, 50);
                },


                async insertChartFromModal() {
                    if (!window.Chart) {
                        App.ui.showToast("Chart library is not available.", { type: 'error' });
                        return;
                    }

                    const typeInput = document.getElementById('chart-type-select').value;
                    const dataText = document.getElementById('chart-data-input').value;
                    const lines = dataText.trim().split('\n').filter(line => line.includes(','));

                    if (lines.length === 0) {
                        App.ui.showToast("Invalid data format.", { type: 'error' });
                        return;
                    }

                    const labels = lines.map(line => line.split(',')[0].trim());
                    const data = lines.map(line => parseFloat(line.split(',')[1].trim()));

                    if (data.some(isNaN)) {
                        App.ui.showToast("Data contains non-numeric values.", { type: 'error' });
                        return;
                    }


                    let chartType;
                    switch (typeInput) {
                        case 'line':
                            chartType = 'line';
                            break;
                        case 'doughnut':
                            chartType = 'doughnut';
                            break;
                        case 'bar':
                        case 'bar-vertical':
                        default:
                            chartType = 'bar';
                            break;
                    }



                    const chartConfig = {

                        type: chartType,
                        data: {
                            labels: labels,
                            datasets: [{
                                data: data
                            }]
                        },
                        options: {

                            indexAxis: typeInput === 'bar-vertical' ? 'y' : 'x',
                        }
                    };

                    const canvasId = `chart-${crypto.randomUUID()}`;
                    const chartConfigString = App.util.escapeHtml(JSON.stringify(chartConfig));

                    const html = `<div class="chart-container" contenteditable="false"><canvas id="${canvasId}" data-chart-config="${chartConfigString}" width="600" height="400" style="max-width: 100%; height: auto;"></canvas></div>`;

                    App.util.restoreSelection();
                    App.util.insertGuardianBlock(`<p>${html}</p>`); // Use the helper

                    setTimeout(() => {
                        const newCanvas = document.getElementById(canvasId);
                        if (newCanvas) {
                            App.ui.renderChartOnCanvas(newCanvas);
                        }
                        App.state.isArticleDirty = true; // Ensure autosave picks up the change
                    }, 100);
                },

                updateSettingsUIState() {
                    const modalContent = document.querySelector('.modal-content');
                    if (!modalContent) return;
                    const themeSelect = modalContent.querySelector('#theme-select');
                    if (!themeSelect) return;
                    const currentTheme = themeSelect.value;
                    modalContent.classList.toggle('is-custom-theme', currentTheme === 'custom');
                },

                showCategoryManagerModal() {
                    const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div id="category-manager-modal" class="modal-content ui-card" style="max-width: 500px;" onclick="event.stopPropagation()">
                            <h3>Manage Categories</h3>
                            <div id="category-list-container" style="max-height: 50vh; overflow-y: auto; margin: 1.5rem 0; display: flex; flex-direction: column; gap: 0.75rem;">
                                </div>
                            <div class="settings-section" style="padding-top: 1rem; margin-top: 1rem;">
                                <h4 style="margin-top: 0;">Add New Category</h4>
                                <div style="display: flex; gap: 0.75rem;">
                                    <input type="text" id="new-category-name" class="text-input" placeholder="Enter new category name...">
                                    <button class="btn btn-primary" id="add-category-btn">Add</button>
                                </div>
                            </div>
                            <div class="modal-buttons">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back to Settings</button>
                            </div>
                        </div>
                    </div>`;

                    document.getElementById('modal-container').innerHTML = modalHTML;
                    App.events.categories.refreshManager();

                    document.getElementById('add-category-btn').onclick = () => {
                        const input = document.getElementById('new-category-name');
                        if (input.value) {
                            App.events.categories.add(input.value);
                            input.value = '';
                        }
                    };
                    document.getElementById('new-category-name').onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            document.getElementById('add-category-btn').click();
                        }
                    };
                },


                async showStorageModal() {
                    // --- 1. GET CURRENT STATE ---
                    const isPremium = App.license.isPremium();
                    const clientId = App.settings.get('dropboxClientId') || '';
                    const isConnected = App.state.isDropboxReady;
                    const hasKey = !!clientId.trim();
                    const syncEnabled = App.settings.get('enableDropboxSync');
                    const lastSyncTime = App.util.formatTimestamp(App.settings.get('lastSyncTimestamp'));

                    // --- 2. BUILD THE CLOUD SYNC SECTION HTML ---

                    // This class locks the entire section if the user is not premium.
                    const premiumLockClass = !isPremium ? 'premium-feature-locked' : '';
                    let cloudSyncHTML = '';

                    if (!isPremium) {
                        // --- STATE A: SPARK (FREE) USER ---
                        // Show a clear upsell message.
                        cloudSyncHTML = `
                        <div class="premium-cta-text" style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: var(--border-radius-lg);">
                            Cloud Sync is a Premium feature.
                            <button class="btn btn-primary" style="margin-top: 0.75rem;" onclick="App.ui.showAscensionModal()">Unlock All Features</button>
                        </div>
                    `;
                    } else {
                        // --- STATE B-E: PREMIUM USER ---
                        // The user is Premium, so we show the step-by-step setup.

                        // STEP 1: API Key Input (Always visible for premium users)
                        const step1_ApiKeyHTML = `
                        <div class="settings-item">
                            <div class="settings-label">
                                <b>Step 1: Set Your API Key</b>
                                <small>Get this from your Dropbox App Console.</small>
                            </div>
                        </div>
                        <div style="display:flex; gap: 8px; align-items: stretch; margin-top: -0.5rem; margin-bottom: 1rem;">
                            <input type="password" id="dropbox-client-id-input" class="text-input" placeholder="Paste your App Key (Client ID) here" value="${clientId}">
                            <button class="btn btn-secondary" onclick="${hasKey ? 'App.events.removeDropboxClientId()' : 'App.events.saveDropboxClientId()'}">${hasKey ? 'Remove' : 'Save'}</button>
                        </div>
                    `;

                        // STEP 2: Connect Button (Enabled only if key is saved)
                        const step2_ConnectHTML = `
                        <div class="settings-item">
                            <div class="settings-label">
                                <b>Step 2: Connect to Dropbox</b>
                                <small>${isConnected ? `Connected as ${App.state.dropboxUser.email}` : 'Please save an API key and connect.'}</small>
                            </div>
                            ${isConnected ?
                                `<button class="btn btn-danger" onclick="App.dropbox.disconnect(); App.ui.showStorageModal();">Disconnect</button>` :
                                `<button class="btn btn-primary" onclick="App.dropbox.connect()" ${!hasKey ? 'disabled' : ''}>Connect</button>`
                            }
                        </div>
                    `;

                        // STEP 3: Enable Toggle (Enabled only if connected)
                        const step3_EnableHTML = `
                        <div class="settings-item" style="${!isConnected ? 'opacity: 0.5; pointer-events: none;' : ''}">
                            <div class="settings-label">
                                <b>Step 3: Enable Sync</b>
                                <small>${!isConnected ? 'You must be connected to enable sync.' : 'Turn on automatic syncing.'}</small>
                            </div>
                            <div id="sync-toggle" class="toggle-switch ${syncEnabled ? 'active' : ''} ${!isConnected ? 'is-disabled' : ''}"></div>
                        </div>
                    `;

                        // STEP 4: Manual Sync Button (Visible only if enabled)
                        const step4_ManualSyncHTML = (isConnected && syncEnabled) ? `
                        <div class="settings-item">
                            <div class="settings-label">
                                <b>Manual Sync</b>
                                <small>Last sync: ${lastSyncTime}</small>
                            </div>
                            <button id="sync-now-btn" class="btn btn-primary" onclick="App.dropbox.syncChanges()" ${!App.state.directoryHandle && App.state.storageMode !== 'browser' ? 'disabled' : ''} title="${!App.state.directoryHandle && App.state.storageMode !== 'browser' ? 'Please select a folder or use browser storage first.' : 'Sync Now'}">
                                ${App.state.isSyncing ? `<i class="fa-solid fa-arrows-rotate spin"></i> Syncing...` : 'Sync Now'}
                            </button>
                        </div>
                    ` : '';

                        // HELP GUIDE: Separate from the inputs, always available at the bottom.
                        const helpGuideHTML = `
                        <div class="settings-item" style="margin-top: 1rem; border-top: 1px solid var(--border-color); padding-top: 1rem;">
                            <div class="settings-label">
                                <b>Need help?</b>
                                <small>Follow these steps to get your API key.</small>
                            </div>
                            <button class="btn btn-secondary" onclick="document.getElementById('dropbox-guide-content').style.display = document.getElementById('dropbox-guide-content').style.display === 'block' ? 'none' : 'block';">
                                Show Setup Guide
                            </button>
                        </div>
                        <div class="guide-content" id="dropbox-guide-content" style="display: none;">
                            <h3>1. Create Dropbox App</h3>
                            <ol>
                                <li>Go to the <a href="https://www.dropbox.com/developers/apps" target="_blank" rel="noopener noreferrer">Dropbox App Console</a> and click <strong>Create app</strong>.</li>
                                <li>Select <strong>Scoped access</strong> &rarr; <strong>App folder</strong>. Name your app (e.g., "NoteKashSync").</li>
                                <li>In <strong>Permissions</strong>, check <code>files.content.read</code> and <code>files.content.write</code>. Click Submit. (you can allow more items as well)</li>
                                <li>In <strong>Settings</strong>, find "Redirect URIs" and add this exact URL: <code>https://notekash.com</code> or you can copy from "web address" as well. </li> 
                                <li>Copy the <strong>App key (Client ID)</strong> from this page.</li>
                            </ol>
                            <h3>2. Save Your Key</h3>
                            <p>Paste the <strong>App key (Client ID)</strong> into the "Step 1" input box above and click <strong>Save</strong> then click <strong> Connect </strong> and you have sucessfully connected the <strong> powerful Automatic Multi Device Sync </strong>.</p>
                        </div>
                    `;

                        // Combine all parts for the premium user
                        cloudSyncHTML = step1_ApiKeyHTML + step2_ConnectHTML + step3_EnableHTML + step4_ManualSyncHTML + helpGuideHTML;
                    }

                    // --- 3. ASSEMBLE THE FINAL MODAL ---
                    const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div class="modal-content ui-card" style="max-width: 550px;" onclick="event.stopPropagation()">
                            <h3 style="text-align: center;">Storage & Sync</h3>

                            <div class="settings-section">
                                <h4><i class="fa-solid fa-folder-open"></i> Local Storage</h4>
                                <div class="settings-item">
                                    <div class="settings-label"><b>Notes Folder</b><small>${App.state.directoryHandle ? `Using folder: '${App.state.directoryHandle.name}'` : 'Using Browser Storage.'}</small></div>
                                    <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.router.navigateTo('welcome');">Change</button>
                                </div>
                                <div class="settings-item">
                                    <div class="settings-label"><b>Backup</b><small>Save or Restore your Note or All Data files.</small></div>
                                    <div style="display:flex; gap: 8px;">
                                        <button class="btn btn-secondary" onclick="App.events.triggerZipImport()">Import</button>
                                        <button class="btn btn-secondary" onclick="App.services.backup.exportToZip()">Export</button>
                                    </div>
                                </div>
                            </div>


                            <div classs="settings-section ${premiumLockClass}">
                                <h4><i class="fa-brands fa-dropbox"></i> Cloud Sync</h4>
                                ${cloudSyncHTML}
                            </div>

                            <!-- NEW: App Updater Section -->
                            <div class="setting-group" style="margin-top: 2rem; border-top: 1px solid var(--border-color); padding-top: 1.5rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                    <h3 style="margin: 0; font-size: 1.1rem; color: var(--text-main);">App Update</h3>
                                </div>
                                <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 1rem;">
                                    If you aren't seeing new features, you might be viewing older version.
                                </p>
                                
                                <button onclick="App.ui.showUpdateConfirmationModal()" class="btn-primary" style="width: 100%; background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); border: none; padding: 12px; display: flex; align-items: center; justify-content: center; gap: 8px; font-weight: 600;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                                        <path d="M3 3v5h5"></path>
                                        <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"></path>
                                        <path d="M16 21h5v-5"></path>
                                    </svg>
                                    Check for Updates
                                </button>
                            </div>

                            <div class="modal-buttons">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back to Settings</button>
                            </div>
                        </div>
                    </div>`;

                    document.getElementById('modal-container').innerHTML = modalHTML;

                    // --- 4. RE-ATTACH LISTENERS ---
                    const syncToggle = document.getElementById('sync-toggle');
                    if (syncToggle && !syncToggle.classList.contains('is-disabled')) {
                        syncToggle.addEventListener('click', App.events.handleSyncToggle);
                    }
                },

                showUpdateConfirmationModal() {
                    this.showConfirmationModal({
                        title: ' Force Update NoteKash',
                        message: `
                            <div style="text-align: center;">
                                <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                                <p style="margin-bottom: 1rem;"><b>This will fetch the latest version from the server.</b></p>
                                <p style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 1.5rem;">
                                    This action clears your app cache to ensure you get the newest features. 
                                    Your notes (stored in the database) are safe, but it is always good practice to backup first as certain Updates might clear Data.
                                </p>
                                <div style="background: color-mix(in srgb, var(--danger-color) 10%, transparent); padding: 1rem; border-radius: var(--border-radius); border: 1px solid var(--danger-color); margin-bottom: 1rem;">
                                    <strong style="color: var(--danger-color);">Are you sure you want to proceed?</strong>
                                </div>
                            </div>
                        `,
                        confirmText: 'Yes, I am sure',
                        confirmClass: 'btn-danger',
                        onConfirm: async () => {
                            App.ui.closeModal();
                            // Trigger backup download for safety before nuking
                            // We don't force it, but we trigger it as a "courtesy" download if possible
                            // Actually, let's just stick to the plan: buttons in the modal itself?
                            // showConfirmationModal usually only has one confirm button.
                            // Let's rely on the user having done backup via the Storage modal just before this.
                            // BUT, the plan said: Buttons: "Download Backup", "Yes", "Cancel".
                            // showConfirmationModal is likely limited.
                            // I should probably create a custom modal HTML here instead of using showConfirmationModal 
                            // if I want multiple action buttons (Backup AND Update).
                            // OR, I can just chain them: "Download Backup" button in the message body?

                            // Let's try inserting a button in the message body for backup.
                            App.Updater.nukeCacheAndReload();
                        }
                    });
                    // Let's overwrite the message to include a backup button if I can't customize buttons easily.
                    // Actually, I'll write a full custom modal for this since "Danger Zone" deserves it.
                    const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div class="modal-content ui-card" style="max-width: 450px; text-align: center;" onclick="event.stopPropagation()">
                            <h3 style="color: var(--danger-color); margin-bottom: 0.5rem;"><i class="fa-solid fa-triangle-exclamation"></i> Force Update</h3>
                            
                            <p style="margin-bottom: 1rem;"><b>Get the latest version of NoteKash.</b></p>
                            
                            <p style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 1.5rem;">
                                This will clear your browser cache and reload the app from the server.
                                <br><br>
                                <b>Your notes are stored in the database and should be safe.</b><br>
                                However, we highly recommend downloading a backup first.
                            </p>

                            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                                <button class="btn btn-secondary" style="width: 100%; justify-content: center;" onclick="App.services.backup.exportToZip()">
                                    <i class="fa-solid fa-file-zipper"></i> Download Full Backup
                                </button>
                                
                                <button class="btn btn-danger" style="width: 100%; justify-content: center;" onclick="App.Updater.nukeCacheAndReload()">
                                    Yes, I am sure - Update Now
                                </button>
                                
                                <button class="btn btn-secondary" style="width: 100%; justify-content: center;" onclick="App.ui.closeModal()">
                                    Cancel
                                </button>
                            </div>
                        </div>
                    </div>`;
                    document.getElementById('modal-container').innerHTML = modalHTML;
                },


                showShortcutsModal() {
                    const cmdKey = App.util.getCommandKey();
                    this.showConfirmationModal({
                        title: 'Keyboard Shortcuts & Manual',
                        message: `<div class="shortcut-modal-content" style="font-size: 0.9rem; max-height: 70vh; overflow-y: auto;">
                        <h4>Global & Navigation</h4>
                        <ul>
                            <li><b>New Article:</b> <kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>N</kbd></li>
                            <li><b>Open Productivity Hub:</b> <kbd>${cmdKey}</kbd> + <kbd>K</kbd></li>
                            <li><b>Open/Change Notes Folder:</b> <kbd>Alt</kbd> + <kbd>O</kbd></li>
                            <li><b>Close Modal / Exit View:</b> <kbd>Esc</kbd></li>
                        </ul><hr>
                        
                        <h4>Task Window (Productivity Hub)</h4>
                        <p>These shortcuts work when you are not typing in an input field.</p>
                        <ul style="list-style: none; padding-left: 0;">
                            <li style="font-weight: bold; margin-bottom: 4px;"><u>Timer Controls</u></li>
                            <ul style="padding-left: 20px; margin-top: 4px;">
                                <li><b>Play / Pause Timer:</b> <kbd>S</kbd></li>
                                <li><b>Stop / Reset Timer:</b> <kbd>A</kbd></li>
                                <li><b>Timer Settings:</b> <kbd>T</kbd></li>
                                <li><b>Toggle Zen Mode:</b> <kbd>Z</kbd></li>
                            </ul>
                            <li style="font-weight: bold; margin-top: 1rem; margin-bottom: 4px;"><u>Task Composer</u></li>
                            <ul style="padding-left: 20px; margin-top: 4px;">
                                <li><b>Focus Date Input:</b> <kbd>D</kbd></li>
                                <li><b>Select Category:</b> <kbd>G</kbd></li>
                                <li><b>Cycle Priority:</b> <kbd>F</kbd></li>
                                <li><b>Increment Pomo Goal:</b> <kbd>C</kbd></li>
                                <li><b>Reset Pomo Goal:</b> <kbd>X</kbd></li>
                                <li><b>Add Task:</b> <kbd>Enter</kbd></li>
                            </ul>
                            <li style="font-weight: bold; margin-top: 1rem; margin-bottom: 4px;"><u>Quick Start Timer</u></li>
                            <ul style="padding-left: 20px; margin-top: 4px;">
                                <li><b>Start Timer for 1st Task:</b> <kbd>Q</kbd></li>
                                <li><b>Start Timer for 2nd Task:</b> <kbd>W</kbd></li>
                                <li><b>Start Timer for 3rd Task:</b> <kbd>E</kbd></li>
                                <li><b>Start Timer for 4th Task:</b> <kbd>R</kbd></li>
                            </ul>
                        </ul><hr>
                    
                        <h4>Library & Search Bar</h4>
                        <ul>
                            <li><b>Focus Search Box:</b> Press <kbd>S</kbd> (in Library or Flashcard view)</li>
                            <li><b>Filter by Category:</b> <kbd>*sci</kbd> (filters for 'Science')</li>
                            <li><b>Quick Commands (type in search and press Enter):</b>
                                <ul style="margin-top: 0.5rem; list-style-type: ' '; padding-left: 20px;">
                                    <li><kbd>%new</kbd> or <kbd>%+</kbd> &mdash; Create a new article</li>
                                    <li><kbd>%flash</kbd> &mdash; Go to Flashcards</li>
                                    <li><kbd>%study</kbd> &mdash; Start a study session</li>
                                    <li><kbd>!task</kbd> &mdash; Open Productivity Hub</li>
                                    <li><kbd>!stats</kbd> &mdash; Open Stats Dashboard</li>
                                    <li><kbd>!quiz</kbd> &mdash; Start a new Quiz</li>
                                </ul>
                            </li>
                        </ul><hr>
                        <h4>Write Mode: Formatting Shortcuts</h4>
                        <ul>
                            <li><b>Save Article:</b> <kbd>${cmdKey}</kbd> + <kbd>S</kbd></li>
                            <li><b>Insert Accordion/Flashcard:</b> <kbd>${cmdKey}</kbd> + <kbd>J</kbd></li>
                            <li><b>Bold / Italic / Underline:</b> <kbd>${cmdKey}</kbd> + <kbd>B</kbd> / <kbd>I</kbd> / <kbd>U</kbd></li>
                            <li><b>Create Cloze Flashcard:</b> Select text + <kbd>${cmdKey}</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></li>
                            <li><b>Create Visual Tag [[...]]:</b> <kbd>${cmdKey}</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></li>
                            <li><b>Cycle All Highlights/Colors:</b> Select text + <kbd>${cmdKey}</kbd> + <kbd>Shift</kbd> + <kbd>1</kbd></li>
                            <li><b>Specific Highlights:</b> Select text + <kbd>${cmdKey}</kbd> + <kbd>Shift</kbd> + <kbd>2</kbd> through <kbd>7</kbd></li>
                            <li><b>Color Text (Green/Red/Blue/Magenta):</b> Select text + <kbd>${cmdKey}</kbd> + <kbd>Shift</kbd> + <kbd>8</kbd> / <kbd>9</kbd> / <kbd>0</kbd> / <kbd>-</kbd></li>
                        </ul><hr>
                        <h4>Write Mode: Markdown-Style Shortcuts</h4>
                        <p>Type these at the start of a new line, then press space.</p>
                        <ul>
                            <li><b>Visual Tag:</b> <kbd>[[Your Tag]]</kbd></li>
                            <li><b>Bulleted List:</b> <kbd>*</kbd> or <kbd>-</kbd> + <kbd>Space</kbd></li>
                            <li><b>Numbered List:</b> <kbd>1.</kbd> + <kbd>Space</kbd></li>
                            <li><b>Blockquote:</b> <kbd>&gt;</kbd> + <kbd>Space</kbd></li>
                            <li><b>Heading:</b> <kbd>##</kbd> + <kbd>Space</kbd></li>
                            <li><b>Horizontal Line:</b> <kbd>---</kbd> + <kbd>Enter</kbd></li>
                            <li><b>Custom Highlights:</b>
                                <ul style="margin-top: 0.5rem; list-style-type: ' '; padding-left: 20px;">
                                    <li><kbd>==text==</kbd> for <span class="highlight-1">Yellow</span></li>
                                    <li><kbd>==text==g</kbd> for <span class="highlight-2">Green</span></li>
                                    <li><kbd>==text==b</kbd> for <span class="highlight-3">Blue</span></li>
                                    <li><kbd>==text==r</kbd> for <span class="highlight-4">Red</span></li>
                                    <li><kbd>==text==p</kbd> for <span class="highlight-5">Purple</span></li>
                                    <li><kbd>==text==c</kbd> for <span class="highlight-6">Cyan</span></li>
                                    <li><kbd>==text==m</kbd> for <span class="highlight-7">Magenta</span> (Rendered Tag style)</li>
                                </ul>
                            </li>
                            <li><b>Color Text:</b>
                                <ul style="margin-top: 0.5rem; list-style-type: ' '; padding-left: 20px;">
                                    <li><kbd>::text_r::</kbd> for <span class="text-red">Red Text</span></li>
                                    <li><kbd>::text_g::</kbd> for <span class="text-green">Green Text</span></li>
                                    <li><kbd>::text_b::</kbd> for <span class="text-blue">Blue Text</span></li>
                                    <li><kbd>::text_m::</kbd> for <span class="text-magenta">Magenta Text</span></li>
                                </ul>
                            </li>
                        </ul><hr>
                        <h4>Visual Map View</h4>
                        <p>These shortcuts work when the search bar is not focused.</p>
                        <ul>
                            <li><b>Focus Search:</b> <kbd>S</kbd></li>
                            <li><b>Save Snapshot & Export Image:</b> <kbd>F</kbd></li>
                            <li><b>Zoom:</b> <kbd>Spacebar</kbd> / <kbd>Shift</kbd>+<kbd>Spacebar</kbd> or <kbd>+</kbd> / <kbd>-</kbd></li>
                            <li><b>Pan View:</b> <kbd>Arrow Keys</kbd></li>
                            <li><b>Reset View:</b> <kbd>R</kbd></li>
                            <li><b>Toggle Lasso Tool:</b> <kbd>L</kbd></li>
                            <li><b>Cycle Category Focus:</b> <kbd>C</kbd></li>
                            <li><b>Exit Focus Mode / Clear Search:</b> <kbd>Esc</kbd></li>
                        </ul><hr>
                        <h4>Mind Map View</h4>
                        <p>These shortcuts work when the search bar is not focused.</p>
                        <ul>
                            <li><b>Focus Search:</b> <kbd>S</kbd></li>
                            <li><b>Save Snapshot & Export Image:</b> <kbd>F</kbd></li>
                            <li><b>Next / Previous Map:</b> <kbd>K</kbd> / <kbd>J</kbd></li>
                            <li><b>Zoom:</b> <kbd>Spacebar</kbd> / <kbd>Shift</kbd>+<kbd>Spacebar</kbd></li>
                            <li><b>Exit Focus Mode / Clear Search:</b> <kbd>Esc</kbd></li>
                        </ul><hr>
                        <h4>Study & Quiz Mode</h4>
                        <ul>
                            <li><b>Flip Card:</b> <kbd>Spacebar</kbd></li>
                            <li><b>Previous / Next Card:</b> <kbd></kbd> / <kbd></kbd></li>
                            <li><b>Rate Again/Hard/Hold/Good/Easy:</b> <kbd>A</kbd> / <kbd>4</kbd> / <kbd>3</kbd> / <kbd>2</kbd> / <kbd>1</kbd></li>
                        </ul>
                    </div>`,
                        confirmText: 'Close', showCancel: false
                    });
                },

                showAudioConfigModal() {
                    const currentBitrate = App.settings.get('audioBitrate');
                    // ADDED: New "Mini" option with a 16000 bitrate
                    const bitrateOptions = [
                        { value: 16000, label: 'Mini (To Save Space)' },
                        { value: 32000, label: 'Low (Voice Memo - Smallest File)' },
                        { value: 64000, label: 'Medium (Podcast - Recommended)' },
                        { value: 128000, label: 'High (Music - Largest File)' }
                    ].map(opt => `<option value="${opt.value}" ${currentBitrate === opt.value ? 'selected' : ''}>${opt.label}</option>`).join('');

                    const models = [
                        { id: 'tiny', name: 'Smooth', size: '75 MB' },
                        { id: 'base', name: 'Good', size: '142 MB' },
                        { id: 'small', name: 'Better', size: '466 MB' },
                        { id: 'medium', name: 'Excellent', size: '1.42 GB' }
                    ];
                    // ... (The rest of the function remains exactly the same) ...
                    const modelsHTML = models.map(model => `
                    <div class="settings-item">
                        <div class="settings-label">
                            <b>${model.name} Model</b>
                            <small>${model.size} download</small>
                        </div>
                        <button class="btn btn-secondary" id="download-model-${model.id}" onclick="App.audio.downloadTranscriptionModel('Xenova/whisper-${model.id}')">Download</button>
                    </div>
                `).join('');

                    const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div id="audio-config-modal" class="modal-content ui-card" onclick="event.stopPropagation()">
                            <h3>Audio Configuration</h3>
                            <div class="settings-section">
                                <h4>Recording Quality</h4>
                                <div class="settings-grid">
                                    <label for="audio-bitrate-select">Audio Quality</label>
                                    <select id="audio-bitrate-select" class="btn btn-secondary">${bitrateOptions}</select>
                                </div>
                            </div>
                            <div class="settings-section">
                                <div id="ascension-witty-message" class="witty-gradient-text">Only for Premium Users</div>
                                <h4>Audio Transcription (by AI Model)</h4>
                                <div class="settings-label" style="padding: 2px 0;">
                                    <small>Download a model to enable offline, private audio transcription. Larger models are more accurate but require more storage and processing power.</small>
                                </div>
                                ${modelsHTML}
                                <div class="settings-item" style="margin-top: 1rem;">
                                    <div class="settings-label">
                                        <b>Current Status</b>
                                        <small id="transcription-model-status">No model downloaded.</small>
                                    </div>
                                    <button class="btn btn-danger" id="delete-models-btn" style="display:none;" onclick="App.audio.deleteTranscriptionModels()">Delete</button>
                                </div>
                            </div>
                            <div class="modal-buttons" style="margin-top: 1.5rem;">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back</button>
                            </div>
                        </div>
                    </div>`;

                    document.getElementById('modal-container').innerHTML = modalHTML;
                    document.getElementById('audio-bitrate-select').addEventListener('change', (e) => App.settings.set('audioBitrate', parseInt(e.target.value, 10)));
                    App.audio.updateModelStatusUI();
                },

                showLicenseModal() {
                    const isPremium = App.license.isPremium();
                    const tierName = App.license.state.tier || 'Spark';
                    const userName = App.license.state.userName || '';
                    const userBio = App.settings.get('userBio') || '';

                    let licenseViewHTML;

                    if (isPremium) {
                        const expiryDate = new Date(App.license.state.expiry).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                        licenseViewHTML = `
                        <div class="settings-section">
                            <h4 class="witty-gradient-text" style="text-align:center; font-size: 1.2em;">You are in the ${tierName} League!</h4>
                            <p style="text-align:center; color: var(--text-secondary);">Enjoy unlimited features until <strong>${expiryDate}</strong>.</p>
                        </div>
                        <div class="modal-buttons" style="margin-top: 1.5rem; justify-content: space-between;">
                            <button class="btn btn-danger" onclick="App.license.delete()">Downgrade to Spark</button>
                            <button class="btn btn-secondary" onclick="App.license.revalidate()">Re-validate License</button>
                        </div>`;
                    } else {
                        licenseViewHTML = `
                        <div class="settings-section">
                             <div class="license-form-grid">
                                <label for="license-name-input">Your Name</label>
                                <input type="text" id="license-name-input" class="text-input" value="${userName}" placeholder="e.g., Alex Doe">

                                <label for="license-status-input">Your Bio</label>
                                <textarea id="license-status-input" class="text-input" rows="2" placeholder="A short bio... (e.g., Lifelong Learner)">${userBio}</textarea>

                                <label for="license-tier-select">Desired Tier</label>
                                <select id="license-tier-select" class="btn btn-secondary">
                                    <option value="bronze">Bronze (3 Months)</option>
                                    <option value="silver">Silver (6 Months)</option>
                                    <option value="gold">Gold (1 Year)</option>
                                    <option value="diamond">Diamond (Lifetime)</option>
                                </select>

                                <label for="license-key-input">License Key</label>
                                <input type="text" id="license-key-input" class="text-input" placeholder="Paste your unique license key here">
                            </div>
                            <div class="modal-buttons" style="margin-top: 1.5rem; justify-content: space-between;">
                                <button class="btn btn-secondary" onclick="App.events.generateLicenseRequestEmail()">Get a License Key</button>
                                <button class="btn btn-primary" onclick="App.license.activate()">Activate License</button>
                            </div>
                        </div>`;
                    }

                    const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div id="license-modal-content" class="modal-content ui-card" style="max-width: 550px;" onclick="event.stopPropagation()">
                            <h3 style="text-align:center;">Profile & License</h3>
                            <div class="license-header-info" style="margin-top: 1rem;">
                                ${App.util.getTierBadgeHTML(tierName)}
                            </div>
                            ${licenseViewHTML}
                            <div class="modal-buttons" style="margin-top: 1.5rem; border-top: 1px solid var(--border-color); padding-top: 1rem;">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back to Settings</button>
                            </div>
                        </div>
                    </div>`;
                    document.getElementById('modal-container').innerHTML = modalHTML;
                },

                showQuizResultModal(score, total) {
                    // RATIONALE: User requested "aggressive" and "catchy" feedback to push them harder.
                    let feedbackQuote = "";
                    const percentage = (score / total) * 100;
                    if (percentage === 100) feedbackQuote = "King mode Activated! You are incredible.";
                    else if (percentage > 80) feedbackQuote = "Surgical Precision. Nearly Flawless.";
                    else if (percentage > 65) feedbackQuote = "Solid Grind. But you can do better.";
                    else if (percentage > 45) feedbackQuote = "Going Okay, you need to Push Harder .";
                    else if (percentage > 25) feedbackQuote = "Too low. Time to Bleed or Die.";
                    else feedbackQuote = "Poor, Ask yourself why you Started?.";

                    // RATIONALE: The Power Quote is now fetched as an *additional* message.
                    const powerQuote = App.util.getPowerQuote();

                    const modalHTML = `
                    <div class="modal-backdrop" onclick="App.ui.closeModal()">
                        <div class="modal-content ui-card quiz-result-card" onclick="event.stopPropagation()">
                            <h3>Quiz Complete!</h3>
                            <div class="quiz-score-display">${score.toFixed(1)} / ${total}</div>
                            <p class="quiz-motivational-quote">"${feedbackQuote}"</p>

                            <p class="power-quote-gradient" style="font-size: 1.2rem; margin-top: 1rem;">
                                &ldquo;${powerQuote}&rdquo;
                            </p>

                            <div class="modal-buttons" style="margin-top: 1.5rem;">
                                <button class="btn btn-primary" onclick="App.ui.closeModal()">Awesome!</button>
                            </div>
                        </div>
                    </div>`;
                    document.getElementById('modal-container').innerHTML = modalHTML;
                },

                showCustomModal({ title, message, buttons = [] }) {
                    const modalContainer = document.getElementById('modal-container');
                    const buttonsHTML = buttons.map((btn, index) =>
                        `<button class="btn ${btn.className || 'btn-secondary'}" id="custom-modal-btn-${index}">${btn.text}</button>`
                    ).join('');

                    modalContainer.innerHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div class="modal-content ui-card">
                            <h3>${title}</h3>
                            <div>${message}</div>
                            <div class="modal-buttons">${buttonsHTML}</div>
                        </div>
                    </div>`;

                    buttons.forEach((btn, index) => {
                        document.getElementById(`custom-modal-btn-${index}`).onclick = () => {
                            if (btn.onClick) btn.onClick();
                        };
                    });
                },

                showConfirmationModal({ title, message, onConfirm, confirmText = 'Confirm', showCancel = true, modalClass = '', onCancel }) {
                    const modalContainer = document.getElementById('modal-container');
                    modalContainer.innerHTML = `
                    <div class="modal-backdrop">
                        <div class="modal-content ui-card ${modalClass}" role="dialog" aria-modal="true" aria-labelledby="modal-title">
                            <h3 id="modal-title">${title}</h3>
                            <div>${message}</div>
                            <div class="modal-buttons">
                                ${showCancel ? `<button class="btn btn-secondary" id="modal-cancel">Cancel</button>` : ''}
                                <button class="btn ${confirmText === 'Delete' || confirmText === 'Reset' || confirmText === 'Overwrite' || confirmText === 'Remove' ? 'btn-danger' : 'btn-primary'}" id="modal-confirm">${confirmText}</button>
                            </div>
                        </div>
                    </div>`;
                    const modal = modalContainer.querySelector('.modal-content');
                    const backdrop = modalContainer.querySelector('.modal-backdrop');
                    const confirmBtn = modalContainer.querySelector('#modal-confirm');
                    const cancelBtn = modalContainer.querySelector('#modal-cancel');

                    const closeModalAction = () => { if (onCancel) onCancel(); this.closeModal(); };

                    backdrop.addEventListener('click', (e) => { if (e.target === backdrop) { closeModalAction(); } });
                    confirmBtn.addEventListener('click', () => { if (onConfirm) onConfirm(); this.closeModal(); });

                    if (cancelBtn) cancelBtn.addEventListener('click', closeModalAction);
                    App.util.trapFocus(modal);
                },

                showTemplateHubModal() {
                    const preDefinedTemplates = [
                        { id: 'cornell-notes', icon: '', title: 'Cornell Notes 2.0', desc: 'A robust system for structured note-taking and review.' },
                        { id: 'vocab-card', icon: '', title: 'Vocabulary Card', desc: 'Build your lexicon with structured vocabulary cards.' },
                        { id: 'upsc-analysis', icon: '', title: 'UPSC Analysis', desc: 'For Current Affairs & syllabus linkage.' },
                        { id: 'meeting-agenda', icon: '', title: 'Meeting Agenda', desc: 'A clean, professional structure for any meeting.' },
                        { id: 'daily-planner', icon: '', title: 'Daily Planner', desc: 'Organize your day with tasks and priorities.' },
                        { id: 'smart-goals', icon: '', title: 'SMART Goals', desc: 'Define Specific, Measurable, Relevant goals.' },
                        { id: 'kwl-chart', icon: '', title: 'KWL Chart', desc: 'Track what you Know, Want, and Learned.' },
                        { id: 'pros-cons', icon: '', title: 'Pros & Cons', desc: 'A balanced matrix for informed decisions.' },
                        { id: 'swot-analysis', icon: '', title: 'SWOT Analysis', desc: 'Analyze Strengths, Weaknesses, Opportunities, Threats.' },
                        { id: 'content-planner', icon: '', title: 'Content Planner', desc: 'A simple Kanban board to track your ideas.' }
                    ];

                    const cardsHTML = preDefinedTemplates.map(t => `
                    <div class="template-hub-card" onclick="App.events.ai.executeKashTemplate('${t.id}')">
                        <div class="template-card-icon">${t.icon}</div>
                        <div class="template-card-text">
                            <h3 class="template-card-title">${t.title}</h3>
                            <p class="template-card-desc">${t.desc}</p>
                        </div>
                    </div>
                `).join('');

                    const isPremium = App.license.isPremium();
                    const premiumLockClass = isPremium ? '' : 'premium-feature-locked';

                    const modalHTML = `
                <style>
                    .template-hub-card {
                        background-color: var(--bg-secondary);
                        padding: 1rem;
                        border: 1px solid var(--border-color);
                        border-radius: var(--border-radius-lg);
                        display: flex;
                        align-items: flex-start;
                        gap: 1rem;
                        cursor: pointer;
                        transition: all 0.2s ease-in-out;
                    }
                    .template-hub-card:hover {
                        transform: translateY(-4px);
                        border-color: var(--primary-color);
                        box-shadow: 0 0 15px 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
                    }
                    .template-card-icon {
                        width: 40px;
                        height: 40px;
                        flex-shrink: 0;
                        background-color: var(--bg-tertiary);
                        border-radius: 10px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 1.5rem;
                        color: var(--text-primary);
                    }
                    .template-card-text { flex-grow: 1; }
                    .template-card-title {
                        font-size: 1rem;
                        font-weight: 600;
                        margin: 0 0 0.25rem 0;
                        color: var(--text-primary);
                    }
                    .template-card-desc {
                        font-size: 0.85rem;
                        color: var(--text-secondary);
                        line-height: 1.4;
                        margin: 0;
                    }
                </style>
                <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                    <div class="modal-content ui-card" style="max-width: 900px;" onclick="event.stopPropagation()">
                        <button class="modal-close-btn" onclick="App.ui.closeModal()">&times;</button>
                        <div style="text-align: center;">
                            <h3 class="witty-gradient-text" style="font-size: 1.8rem;">Template Hub</h3>
                            <p style="color: var(--text-secondary);">Choose a pre-made template or ask AI to create a custom one for you.</p>
                        </div>
                        
                        <div class="settings-section ${premiumLockClass}">
                            <h4><i class="fa-solid fa-wand-magic-sparkles" style="color: var(--primary-color);"></i> Create with AI</h4>
                            <div style="display: flex; gap: 0.75rem;">
                                <input type="text" id="custom-template-prompt" class="text-input" placeholder="e.g., a simple weekly meal planner...">
                                <button class="btn btn-primary" id="generate-custom-template-btn">Generate</button>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h4><i class="fa-solid fa-star" style="color: var(--primary-color);"></i> Curated Templates</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1rem; margin-top: 1rem;">
                                ${cardsHTML}
                            </div>
                        </div>
                    </div>
                </div>`;

                    document.getElementById('modal-container').innerHTML = modalHTML;

                    const customInput = document.getElementById('custom-template-prompt');
                    const generateBtn = document.getElementById('generate-custom-template-btn');

                    const generateAction = () => {
                        const prompt = customInput.value.trim();
                        if (prompt) {
                            if (isPremium) {
                                App.events.ai.executeKashTemplate(prompt);
                            } else {
                                App.ui.showAscensionModal();
                            }
                        } else {
                            App.ui.showToast("Please describe the template you want.", "warning");
                        }
                    };

                    generateBtn.addEventListener('click', generateAction);
                    customInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            generateAction();
                        }
                    });
                },

                toggleProfileNotification() {
                    const notificationCard = document.getElementById('profile-notification-card');
                    const profileBadge = document.getElementById('profile-badge');

                    if (!notificationCard || !profileBadge) return;

                    if (notificationCard.style.display === 'flex') {
                        this.closeProfileNotification();
                    } else {
                        this.renderProfileNotification();
                        notificationCard.style.display = 'flex';
                        profileBadge.classList.add('active'); // Indicate active state
                        // Add a global listener to close when clicking outside
                        setTimeout(() => { // Small delay to prevent immediate close if click initiated toggle
                            document.addEventListener('click', this.closeProfileNotificationOutside, { once: true });
                        }, 100);
                    }
                },

                closeProfileNotification() {
                    const notificationCard = document.getElementById('profile-notification-card');
                    const profileBadge = document.getElementById('profile-badge');
                    if (notificationCard) {
                        notificationCard.style.display = 'none';
                    }
                    if (profileBadge) {
                        profileBadge.classList.remove('active');
                    }
                    document.removeEventListener('click', App.ui.closeProfileNotificationOutside);
                },

                closeProfileNotificationOutside(event) {
                    const profileHub = document.getElementById('profile-hub');
                    if (profileHub && !profileHub.contains(event.target)) {
                        App.ui.closeProfileNotification();
                    } else {
                        // Re-add listener if click was inside profile hub but not on card itself
                        document.addEventListener('click', App.ui.closeProfileNotificationOutside, { once: true });
                    }
                },

                renderProfileNotification() {
                    const tierName = App.license.state.tier || 'Spark';
                    const isPremium = App.license.isPremium();
                    const userName = App.license.state.userName || 'Valued User';

                    const notificationBadgeIcon = document.getElementById('notification-badge-icon');
                    const notificationTitle = document.getElementById('notification-title');
                    const notificationMessage = document.getElementById('notification-message');
                    const notificationLink = document.getElementById('notification-link');

                    const powerQuote = App.util.getPowerQuote();

                    if (notificationBadgeIcon) {
                        notificationBadgeIcon.innerHTML = App.util.getTierBadgeHTML(tierName);
                        // ENABLE DRAG INTERACTION
                        this.enableBadgeDrag(notificationBadgeIcon);
                    }

                    // Always show the Power Quote in the main body
                    if (notificationMessage) {
                        notificationMessage.innerHTML = `&ldquo;${powerQuote}&rdquo;`;
                        notificationMessage.style.display = 'block';
                    }

                    // Hide the link section completely (Developer Upsell is gone)
                    if (notificationLink) {
                        notificationLink.style.display = 'none';
                    }

                    if (isPremium) {
                        if (notificationTitle) {
                            notificationTitle.innerHTML = App.util.getAppreciationMessage(userName, tierName);
                        }
                    } else {
                        if (notificationTitle) {
                            notificationTitle.innerHTML = `You are in the <strong>Spark League</strong>`;
                        }
                    }
                },

                enableBadgeDrag(element) {
                    if (!element || element.dataset.dragEnabled) return;
                    element.dataset.dragEnabled = 'true';

                    let isDragging = false;
                    let isDetached = element.dataset.detached === 'true';
                    let startX, startY;
                    let hasMoved = false;
                    let placeholder = document.getElementById('notification-badge-placeholder');

                    // Animation defaults
                    element.style.transition = 'transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s ease';

                    // --- FUN: Spark Animation ---
                    const triggerSpark = () => {
                        const colors = ['#FFD700', '#FFA500', '#FF4500', '#00BFFF', '#ADFF2F', '#FF69B4', '#ffffff', '#ffd700'];
                        const rect = element.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;

                        // Increased particle count for "Grand" effect
                        for (let i = 0; i < 40; i++) {
                            const spark = document.createElement('div');
                            spark.className = 'spark-particle';
                            spark.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];

                            // Slight size variation
                            const size = 6 + Math.random() * 6;
                            spark.style.width = size + 'px';
                            spark.style.height = size + 'px';

                            spark.style.left = centerX + 'px';
                            spark.style.top = centerY + 'px';
                            document.body.appendChild(spark);

                            // Random explosive direction
                            const angle = Math.random() * Math.PI * 2;
                            // Larger velocity range
                            const velocity = 80 + Math.random() * 120;
                            const tx = Math.cos(angle) * velocity;
                            const ty = Math.sin(angle) * velocity;

                            const anim = spark.animate([
                                { transform: 'translate(-50%, -50%) scale(1)', opacity: 1 },
                                { transform: `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px)) scale(0)`, opacity: 0 }
                            ], {
                                // Slower duration
                                duration: 1000 + Math.random() * 500,
                                easing: 'cubic-bezier(0, .9, .57, 1)'
                            });
                            anim.onfinish = () => spark.remove();
                        }
                    };

                    const detach = (rect) => {
                        if (isDetached) return;
                        isDetached = true;
                        element.dataset.detached = 'true';

                        // Create placeholder if not exists
                        const parent = element.parentNode;
                        if (parent) {
                            placeholder = document.createElement('div');
                            placeholder.id = 'notification-badge-placeholder';
                            placeholder.style.width = '48px';
                            placeholder.style.height = '48px';
                            placeholder.style.flexShrink = '0';
                            parent.insertBefore(placeholder, element);
                        }

                        // Move to body
                        document.body.appendChild(element);

                        // Set fixed position at current visual location
                        element.style.position = 'fixed';
                        element.style.left = rect.left + 'px';
                        element.style.top = rect.top + 'px';
                        element.style.zIndex = '2147483647'; // Maximum Z-Index to stay on top of EVERYTHING
                        element.style.width = '48px';
                        element.style.height = '48px';
                        element.style.margin = '0';
                    };

                    const resetDocking = () => {
                        if (!isDetached) return;

                        // Find placeholder again (it might be in the hidden card)
                        const currentPlaceholder = document.getElementById('notification-badge-placeholder');
                        if (currentPlaceholder && currentPlaceholder.parentNode) {
                            currentPlaceholder.parentNode.insertBefore(element, currentPlaceholder);
                            currentPlaceholder.remove();
                        } else {
                            // Fallback if placeholder is gone
                            const header = document.querySelector('#profile-notification-card .notification-header');
                            if (header) header.prepend(element);
                        }

                        element.style.position = '';
                        element.style.left = '';
                        element.style.top = '';
                        element.style.zIndex = '';
                        element.style.margin = '';
                        element.dataset.detached = 'false';
                        isDetached = false;
                        placeholder = null; // Reset ref

                        // Reset animation
                        element.animate([
                            { transform: 'scale(1.2)' },
                            { transform: 'scale(1.0)' }
                        ], { duration: 300, easing: 'ease-out' });
                    };

                    // --- SMOOTH RETURN ANIMATION ---
                    const animateBackToHome = () => {
                        if (!isDetached) return;

                        // Locate Target
                        let targetRect;
                        const currentPlaceholder = document.getElementById('notification-badge-placeholder');
                        if (currentPlaceholder) {
                            targetRect = currentPlaceholder.getBoundingClientRect();
                        } else {
                            const header = document.querySelector('#profile-notification-card .notification-header');
                            if (header) targetRect = header.getBoundingClientRect();
                        }

                        if (!targetRect) { resetDocking(); return; }

                        const startRect = element.getBoundingClientRect();
                        const deltaX = targetRect.left - startRect.left;
                        const deltaY = targetRect.top - startRect.top;

                        // Animate from current fixed pos to delta
                        const anim = element.animate([
                            { transform: 'translate(0, 0) scale(1)' },
                            { transform: `translate(${deltaX}px, ${deltaY}px) scale(1)` }
                        ], {
                            duration: 1200, // Slower for visibility
                            easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)' // Springy
                        });

                        anim.onfinish = () => {
                            resetDocking();
                        };
                    };

                    // Double click to reset
                    element.addEventListener('dblclick', (e) => {
                        e.stopPropagation(); // Prevent closing card
                        animateBackToHome();
                    });

                    element.addEventListener('mousedown', (e) => {
                        // Left click only
                        if (e.button !== 0) return;

                        // Prevent default interactions
                        e.preventDefault();
                        e.stopPropagation();

                        const rect = element.getBoundingClientRect();
                        startX = e.clientX;
                        startY = e.clientY;
                        hasMoved = false; // Reset
                        const offsetX = e.clientX - rect.left;
                        const offsetY = e.clientY - rect.top;

                        // Detach immediately on interaction if not already detached
                        if (!isDetached) {
                            detach(rect);
                        }

                        isDragging = true;
                        element.style.cursor = 'grabbing';

                        // Disable transition during drag for responsiveness
                        element.style.transition = 'none';

                        const onMouseMove = (moveEvent) => {
                            if (!isDragging) return;
                            moveEvent.preventDefault();

                            // Check movement threshold
                            if (!hasMoved && (Math.abs(moveEvent.clientX - startX) > 4 || Math.abs(moveEvent.clientY - startY) > 4)) {
                                hasMoved = true;
                            }

                            // Calculate raw position
                            let x = moveEvent.clientX - offsetX;
                            let y = moveEvent.clientY - offsetY;

                            // BOUNDARY CHECKS
                            // Ensure it never goes off-screen (with 5px buffer)
                            const maxX = window.innerWidth - element.offsetWidth - 5;
                            const maxY = window.innerHeight - element.offsetHeight - 5;
                            const minX = 5;
                            const minY = 5;

                            x = Math.max(minX, Math.min(x, maxX));
                            y = Math.max(minY, Math.min(y, maxY));

                            element.style.left = x + 'px';
                            element.style.top = y + 'px';
                        };

                        const onMouseUp = () => {
                            isDragging = false;
                            element.style.cursor = 'grab';
                            // Restore transition for hover effects
                            element.style.transition = 'transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s ease';

                            document.removeEventListener('mousemove', onMouseMove);
                            document.removeEventListener('mouseup', onMouseUp);

                            // IF CLICKED (Not Dragged) -> SPARK
                            if (!hasMoved) {
                                triggerSpark();
                            }
                        };

                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    });

                    // Safety: Ensure it stays on screen if window resizes
                    window.addEventListener('resize', () => {
                        if (!isDetached) return;
                        const rect = element.getBoundingClientRect();
                        const maxX = window.innerWidth - element.offsetWidth - 5;
                        const maxY = window.innerHeight - element.offsetHeight - 5;

                        if (rect.left > maxX) element.style.left = maxX + 'px';
                        if (rect.top > maxY) element.style.top = maxY + 'px';
                    });
                },

                closeModal() {
                    Object.values(App.state.chartInstances).forEach(chart => chart?.destroy());
                    App.state.chartInstances = {};
                    document.removeEventListener('keydown', App.events.handleProductivityHubKeyDown, true);
                    if (App.ui.aiMagicModal.state.isOpen) {
                        App.ui.aiMagicModal.close();
                    }

                    document.getElementById('modal-container').innerHTML = '';
                },

                updateTheLine(progress) {
                    const line = document.getElementById('the-line');
                    if (line) {
                        line.style.transform = `scaleX(${progress})`;
                    }
                },

                async showLibraryLoadingScreenAndLoadData() {
                    await App.loadInitialData();
                    App.router.navigateTo('library');
                },


                renderChartOnCanvas(canvas) {
                    if (!canvas || !canvas.dataset.chartConfig) return;

                    try {
                        // 1. Get the theme-agnostic config we saved earlier.
                        const config = JSON.parse(canvas.dataset.chartConfig);

                        // 2. Get fresh styling information based on the CURRENT theme.
                        const themeColors = App.util.getChartColors();
                        const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
                        const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color');
                        const secondaryBg = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');

                        // 3. Dynamically apply all styling to the config object in memory.
                        if (config.type === 'line') {
                            // --- FIX: Add specific styling for Line charts ---
                            // RATIONALE: Line charts need a colored 'borderColor' for the line itself
                            // and a semi-transparent 'backgroundColor' for the area fill.
                            const primaryColor = themeColors[0] || '#0d9488';
                            const primaryRgb = App.util.colorToRgb(primaryColor);

                            config.data.datasets[0].borderColor = primaryColor;
                            config.data.datasets[0].backgroundColor = primaryRgb ? `rgba(${primaryRgb.join(',')}, 0.2)` : '#0d948833';
                            config.data.datasets[0].fill = true; // Creates the modern "area chart" look.
                            config.data.datasets[0].tension = 0.4; // Adds a nice curve to the line.
                            config.data.datasets[0].pointBackgroundColor = primaryColor; // Ensure points are visible
                            config.data.datasets[0].pointBorderColor = secondaryBg; // Give points a nice border
                            config.data.datasets[0].pointBorderWidth = 2;

                        } else {
                            // This is the existing logic for Bar and Doughnut charts
                            config.data.datasets[0].backgroundColor = themeColors;
                            config.data.datasets[0].borderColor = secondaryBg;
                            config.data.datasets[0].borderWidth = config.type === 'doughnut' ? 4 : 1;
                            config.data.datasets[0].borderRadius = config.type === 'bar' ? 6 : 0;
                        }

                        config.options = {
                            ...config.options, // Keep structural options like indexAxis
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: config.type === 'doughnut', // Only show legend for doughnut charts
                                    position: 'right',
                                    labels: { color: textColor }
                                }
                            },
                            scales: (config.type !== 'doughnut') ? {
                                x: { ticks: { color: textColor }, grid: { color: gridColor } },
                                y: { ticks: { color: textColor }, grid: { color: gridColor } }
                            } : {}
                        };

                        // 4. If a chart instance already exists on this canvas, destroy it first.
                        if (typeof Chart !== 'undefined' && Chart.getChart(canvas)) {
                            Chart.getChart(canvas).destroy();
                        }

                        // 5. Create the new Chart.js instance with the freshly styled config.
                        App.offline.safeChart(canvas.getContext('2d'), config);

                    } catch (e) {
                        console.error("Failed to render chart from data attribute:", e);
                        canvas.parentElement.innerHTML = '<p style="color:var(--danger-color);">[Chart data is corrupted]</p>';
                    }
                },


                updateStudyProgressUI() {
                    const s = App.state.studySession;
                    const progressBar = document.getElementById('study-progress-bar');
                    let progress = 0;
                    if (s.isActive && s.cards.length > 0) {
                        progress = (s.currentIndex + 1) / s.cards.length;
                    } else {
                        progress = 1;
                    }

                    this.updateTheLine(progress);
                    if (progressBar) {
                        progressBar.value = s.currentIndex + 1;
                        progressBar.max = s.cards.length;
                    }
                }
            },

            // ==========================================================================
            // 3.11. PWA LOGIC
            // ==========================================================================
            pwa: {
                init() {
                    if ('serviceWorker' in navigator) {
                        navigator.serviceWorker.register('./service-worker.js').then(reg => {
                            console.log('Service Worker registered successfully.');
                            reg.addEventListener('updatefound', () => {
                                const newWorker = reg.installing;
                                console.log('New service worker found, installing.');
                                newWorker.addEventListener('statechange', () => {
                                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                        console.log('New service worker installed, ready for activation.');
                                        this.showUpdatePrompt(newWorker);
                                    }
                                });
                            });
                        }).catch(error => {
                            console.error('Service Worker registration failed:', error);
                        });

                        navigator.serviceWorker.addEventListener('controllerchange', () => {
                            window.location.reload();
                        });
                    }
                },
                handleInstallPrompt(e) {
                    e.preventDefault();
                    App.state.pwa.installPromptEvent = e;
                    const installBtn = document.getElementById('install-pwa-btn');
                    if (installBtn) {
                        installBtn.style.display = 'inline-flex';
                    }
                },
                showUpdatePrompt(worker) {
                    App.ui.showToast('A new version is available!', {
                        type: 'info',
                        duration: 10000,
                        action: {
                            label: 'Reload',
                            callback: () => {
                                worker.postMessage({ type: 'SKIP_WAITING' });
                            }
                        }
                    });
                }
            },


            // ==========================================================================
            // 3.12. EVENT HANDLERS
            // ==========================================================================
            events: {

                transitionToLibrary(loadFunction) {
                    const welcomeView = document.getElementById('welcome-view');
                    if (welcomeView && welcomeView.classList.contains('active')) {
                        welcomeView.classList.add('fading-out');
                        setTimeout(() => {
                            loadFunction();
                        }, 350);
                    } else {
                        loadFunction();
                    }
                },

                useBrowserStorage() {
                    this.transitionToLibrary(async () => {
                        // Clear all previous state
                        await App.settings.set('lastStorageMode', 'browser');
                        App.state.isInitialLoadComplete = false;
                        App.state.isHydrated = false;
                        App.state.articles = [];

                        App.state.storageMode = 'browser';
                        App.state.directoryHandle = null;
                        await App.indexedDB.setHandle('directory', null);

                        await App.settings.load();

                        App.ui.applyTheme(App.settings.get('theme'));
                        await App.loadInitialData();
                        App.router.navigateTo('library');
                    });
                },


                handlePopState(event) {
                    if (event.state) {
                        App.router.navigateTo(event.state.viewId, event.state.data, true);
                    }
                },
                changeLibraryTitle(event) {
                    let newTitle = event.target.value.trim();
                    if (!newTitle) {
                        newTitle = 'My Library'; // Fallback to default if empty
                    }
                    App.settings.set('libraryTitle', newTitle);

                    // Live update the title if the library view is active
                    const libraryTitleEl = document.querySelector('#library-view .library-title');
                    if (libraryTitleEl) {
                        libraryTitleEl.textContent = newTitle;
                    }
                },
                changeLibrarySort(event) {
                    App.settings.set('librarySortBy', event.target.value);
                    App.ui.filterAndRenderArticles();
                },

                cycleReaderTheme(goBack = false) {
                    const themes = App.events.presentation.themes;
                    const currentIndex = themes.indexOf(App.state.activeReaderTheme);
                    const nextIndex = goBack
                        ? (currentIndex - 1 + themes.length) % themes.length
                        : (currentIndex + 1) % themes.length;
                    const newTheme = themes[nextIndex];

                    App.state.activeReaderTheme = newTheme;
                    App.settings.set('readerTheme', newTheme); // Remember the choice
                    App.ui.applyReaderTheme();

                    const themeName = newTheme.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    App.ui.showToast(`${themeName} Theme`, { type: 'info', duration: 1500 });
                },
                resetReaderTheme() {
                    App.state.activeReaderTheme = 'default';
                    App.settings.set('readerTheme', 'default');
                    App.ui.applyReaderTheme();
                    App.ui.showToast('Theme reset to default', { type: 'success', duration: 2000 });
                },


                handleGlobalClickInterceptor(event) {
                    // --- COLLAPSIBLE HEADINGS INTERACTION ---
                    const collapsibleHeading = event.target.closest('.collapsible-heading');
                    const collapsibleIcon = event.target.closest('[data-collapsible-icon]');

                    if (collapsibleHeading && collapsibleHeading.closest('#article-content, #read-view')) {
                        // Determine if we should toggle
                        let shouldToggle = false;

                        if (collapsibleIcon) {
                            // Always toggle if clicking the icon directly
                            shouldToggle = true;
                        } else if (App.state.currentMode === 'read') {
                            // In read mode, toggle when clicking anywhere on the heading
                            shouldToggle = true;
                        } else if (App.state.currentMode === 'write') {
                            // In write mode, only toggle if clicking the left gutter area (before the text)
                            const rect = collapsibleHeading.getBoundingClientRect();
                            const iconElement = collapsibleHeading.querySelector('[data-collapsible-icon]');
                            if (iconElement) {
                                const iconRect = iconElement.getBoundingClientRect();
                                // If click is within or to the left of the icon
                                if (event.clientX <= iconRect.right + 5) {
                                    shouldToggle = true;
                                }
                            }
                        }

                        if (!shouldToggle) return;

                        const heading = collapsibleHeading;
                        const level = parseInt(heading.tagName.substring(1));
                        const isCollapsed = heading.getAttribute('data-collapsed') === 'true';

                        const newState = !isCollapsed;
                        heading.setAttribute('data-collapsed', newState);

                        let next = heading.nextElementSibling;
                        while (next) {
                            // Stop if we hit a heading of same or higher importance
                            if (['H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(next.tagName)) {
                                const nextLevel = parseInt(next.tagName.substring(1));
                                if (nextLevel <= level) break;
                            }

                            if (newState) {
                                next.classList.add('collapsible-hidden');
                            } else {
                                next.classList.remove('collapsible-hidden');
                            }
                            next = next.nextElementSibling;
                        }

                        event.preventDefault();
                        event.stopPropagation();
                        return;
                    }

                    const lockedElement = event.target.closest('.premium-feature-locked');

                    if (lockedElement && event.target.closest('.stage-mode-controls')) return;
                    if (lockedElement && !App.license.isPremium()) {
                        event.preventDefault();
                        event.stopPropagation();
                        App.ui.showAscensionModal();
                    }
                },

                generateLicenseRequestEmail() {
                    const name = document.getElementById('license-name-input')?.value || '[Name not provided]';
                    const status = document.getElementById('license-status-input')?.value || '[Status not provided]';
                    const tierSelect = document.getElementById('license-tier-select');
                    const tier = tierSelect.options[tierSelect.selectedIndex].text;

                    const subject = `NoteKash License Key Request - ${tier}`;
                    const body = `Hi there,\n\nMyself, ${name} am applying for a license key.\n\nStatus/Bio: ${status}\n\nKindly provide me with a License Key for the ${tier}.\n\nThank you!`;

                    const mailtoLink = `mailto:learningmarvel@gmail.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

                    window.location.href = mailtoLink;
                },

                // New function to handle the command palette button click
                openCommandPaletteFromButton() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv) return;

                    // Re-focus the editor to ensure we have an active cursor position.
                    contentDiv.focus();

                    // Use a tiny delay to allow the browser to process the focus event.
                    setTimeout(() => {
                        const selection = window.getSelection();
                        const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
                        App.commandPalette.open(range);
                    }, 10);
                },

                handleSyncToggle() {
                    if (!App.license.isPremium()) {
                        App.ui.showAscensionModal();
                        return;
                    }
                    const syncEnabled = App.settings.get('enableDropboxSync');
                    App.settings.set('enableDropboxSync', !syncEnabled);
                    App.ui.showStorageModal();
                    if (!syncEnabled && App.dropbox.isReady()) {
                        App.dropbox.syncChanges(true);
                    }
                },


                handleProductivityHubKeyDown(e) {
                    const modal = document.getElementById('productivity-modal');
                    if (!modal) {
                        document.removeEventListener('keydown', App.events.handleProductivityHubKeyDown, true);
                        return;
                    }

                    if (e.key === 'Enter') {
                        const titleInput = document.getElementById('composer-title-input');
                        if (titleInput && titleInput.value.trim() !== '' && !document.getElementById('pomodoro-settings-popup')) {
                            e.preventDefault();
                            e.stopPropagation();
                            App.hub.tasks.add();
                            return;
                        }
                    }

                    const activeEl = document.activeElement;
                    const isTyping = activeEl && (
                        (activeEl.tagName === 'INPUT' && activeEl.type !== 'checkbox') ||
                        activeEl.tagName === 'SELECT' ||
                        activeEl.tagName === 'TEXTAREA'
                    );

                    if (isTyping) return;

                    let shortcutHandled = false;
                    const startTaskTimer = (index) => {
                        const startButtons = document.querySelectorAll('.task-item [data-action="start-pomodoro"]');
                        startButtons[index]?.click();
                    };

                    switch (e.key.toLowerCase()) {
                        case 'a': modal.querySelector('.pomodoro-controls button[title="Stop & Reset"]')?.click(); shortcutHandled = true; break;
                        case 's': modal.querySelector('.pomodoro-controls button[title*="Play"], .pomodoro-controls button[title*="Pause"]')?.click(); shortcutHandled = true; break;
                        case 't': App.hub.ui.showPomodoroSettings(); shortcutHandled = true; break;
                        case 'z': App.hub.pomodoro.toggleZenMode(); shortcutHandled = true; break;
                        case 'd': document.getElementById('composer-date-input')?.focus(); shortcutHandled = true; break;
                        case 'g': document.getElementById('category-select')?.focus(); shortcutHandled = true; break;
                        case 'f': document.getElementById('priority-btn')?.click(); shortcutHandled = true; break;
                        case 'c': document.getElementById('pomo-goal-btn')?.click(); shortcutHandled = true; break;
                        case 'x': const pomoBtn = document.getElementById('pomo-goal-btn'); if (pomoBtn) { pomoBtn.dispatchEvent(new MouseEvent('contextmenu', { bubbles: true, cancelable: true, view: window })); } shortcutHandled = true; break;
                        case 'q': startTaskTimer(0); shortcutHandled = true; break;
                        case 'w': startTaskTimer(1); shortcutHandled = true; break;
                        case 'e': startTaskTimer(2); shortcutHandled = true; break;
                        case 'r': startTaskTimer(3); shortcutHandled = true; break;
                    }

                    if (shortcutHandled) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                },

                setupGlobalListeners() {
                    document.body.addEventListener('click', this.handleGlobalClickInterceptor, true);
                    document.getElementById('profile-badge')?.addEventListener('click', (event) => {
                        event.stopPropagation(); // Prevent immediate closing by closeProfileNotificationOutside
                        App.ui.toggleProfileNotification();
                    });
                    // Listen for the browser's back/forward button events.
                    window.addEventListener('popstate', this.handlePopState);

                    document.addEventListener('mousedown', (e) => {
                        if (!e.target.closest('#selection-toolbar')) App.ui.hideSelectionToolbar();
                        if (!e.target.closest('#image-toolbar')) App.ui.hideImageToolbar();
                        if (!e.target.closest('.context-menu')) App.ui.hideContextMenu();


                    });

                    document.addEventListener('click', (e) => {
                        // Specifically check for backlink clicks within the article content in read mode
                        const link = e.target.closest('#article-content a[data-link-type]');
                        if (link && App.state.currentMode === 'read') {
                            e.preventDefault();
                            e.stopPropagation(); // Stop other click events
                            const { linkType, linkId, articleId } = link.dataset;
                            if (linkType === 'article') {
                                App.router.navigateTo('article', { id: linkId, mode: 'read' });
                            } else if (linkType === 'snippet') {
                                App.router.navigateTo('article', { id: articleId, mode: 'read', scrollToSnippetId: linkId });
                            }
                        }
                    });

                    document.addEventListener('keydown', this.handleGlobalKeyDown);
                    window.addEventListener('pagehide', () => { App.hub.data.saveTasks(); App.hub.data.savePomodoroStats(); App.quiz.saveStats(); App.settings.save(); });
                    window.addEventListener('beforeinstallprompt', App.pwa.handleInstallPrompt);
                    document.getElementById('install-pwa-btn')?.addEventListener('click', this.installPwa);

                    const header = document.querySelector('header');
                    if (header) {
                        header.addEventListener('click', (e) => {
                            // This logic is only for mobile view
                            if (!document.body.classList.contains('mobile-view')) {
                                return;
                            }
                            // Check if the hub is open and the click was on a header button that ISN'T the hub button itself
                            if (document.getElementById('productivity-modal') && e.target.closest('button') && !e.target.closest('#todo-btn')) {
                                App.hub.ui.closeModal();
                            }
                        });
                    }
                },

                // Located in App.events
                mountViewListeners(viewId) {
                    const setupDebouncedSearch = (inputId, filterFunction) => {
                        const input = document.getElementById(inputId);
                        if (input) {
                            // Use the new generic debounce, ensuring 'this' context if needed (though App.ui methods are bound usually)
                            const debouncedHandler = App.util.debounce(() => {
                                filterFunction.call(App.ui);
                            }, 300);

                            input.addEventListener('input', debouncedHandler);
                        }
                    };

                    switch (viewId) {
                        case 'library':
                            const grid = document.getElementById('article-grid');
                            const gridContainer = document.getElementById('article-grid-container'); // Just in case we need container-level events

                            // Initialize with empty state or wait for filterAndRender
                            if (grid) grid.innerHTML = '';

                            // --- Event Delegation ---
                            if (grid) {
                                grid.addEventListener('click', (e) => {
                                    // Handle Premium Card
                                    const premiumCard = e.target.closest('.library-premium-card');
                                    if (premiumCard) {
                                        App.router.navigateTo('article', { articleObject: DUMMY_TUTORIAL_ARTICLE, mode: 'read' });
                                        return;
                                    }

                                    // Handle Regular Cards
                                    const card = e.target.closest('.article-card');
                                    if (card) {
                                        const articleId = card.dataset.id;
                                        if (articleId) {
                                            App.router.navigateTo('article', { id: articleId, mode: 'read' });
                                        }
                                    }
                                });

                                // Accessibility for Delegation
                                grid.addEventListener('keydown', (e) => {
                                    if (e.key === 'Enter') {
                                        const card = e.target.closest('.article-card');
                                        if (card) {
                                            // Trigger click logic
                                            if (card.classList.contains('library-premium-card')) {
                                                App.router.navigateTo('article', { articleObject: DUMMY_TUTORIAL_ARTICLE, mode: 'read' });
                                            } else if (card.dataset.id) {
                                                App.router.navigateTo('article', { id: card.dataset.id, mode: 'read' });
                                            }
                                        }
                                    }
                                });
                            }

                            setupDebouncedSearch('search-input', App.ui.filterAndRenderArticles);
                            document.getElementById('sort-filter')?.addEventListener('change', (e) => App.events.changeLibrarySort(e));

                            document.getElementById('search-input')?.addEventListener('keydown', (e) => {
                                const { searchResults, selectedIndex } = App.state.libraryRender;
                                if (!searchResults || searchResults.length === 0) return;
                                let newIndex = selectedIndex;
                                let handled = false;
                                if (e.key === 'ArrowDown' || e.key === 'ArrowRight') { newIndex = (selectedIndex + 1) % searchResults.length; handled = true; }
                                else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') { newIndex = (selectedIndex - 1 + searchResults.length) % searchResults.length; handled = true; }
                                else if (e.key === 'Enter') {
                                    e.preventDefault();
                                    const selectedCard = searchResults[selectedIndex];
                                    // With delegation, we can't just .click() because the listener is on the grid?
                                    // Actually .click() propagates up, so the grid listener WILL catch it!
                                    if (selectedCard) selectedCard.click();
                                    return;
                                }
                                if (handled) { e.preventDefault(); if (selectedIndex > -1) searchResults[selectedIndex].classList.remove('search-selected-card'); searchResults[newIndex].classList.add('search-selected-card'); searchResults[newIndex].scrollIntoView({ behavior: 'smooth', block: 'center' }); App.state.libraryRender.selectedIndex = newIndex; }
                            });
                            break;
                        case 'article':
                            document.getElementById('article-controls').addEventListener('mousedown', this.handleArticleControlsClick);
                            const mainEl = document.querySelector('main');
                            if (mainEl) mainEl.addEventListener('scroll', App.events.updateReadingProgress, { passive: true });
                            const contentDiv = document.getElementById('article-content');

                            contentDiv.addEventListener('click', this.handleContentClick);
                            const exportBtn = document.getElementById('export-popover-btn');
                            if (exportBtn) {
                                const popoverGroup = exportBtn.parentElement;

                                const closePopover = (e) => {
                                    if (!popoverGroup.contains(e.target)) {
                                        popoverGroup.classList.remove('popover-active');
                                        document.removeEventListener('click', closePopover);
                                    }
                                };

                                exportBtn.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    const isActive = popoverGroup.classList.toggle('popover-active');
                                    if (isActive) {
                                        document.addEventListener('click', closePopover);
                                    }
                                });
                            }

                            if (App.state.currentMode === 'write') {
                                const titleInput = document.getElementById('article-title');
                                const setDirty = () => { App.state.isArticleDirty = true; };
                                let audioInitTimeout;

                                titleInput.addEventListener('input', setDirty);

                                // NEW: Debounced Autosave (Replaces Interval)
                                const debouncedAutosave = App.util.debounce(() => {
                                    if (App.state.isArticleDirty) {
                                        App.events.saveArticle({ isAutosave: true });
                                    }
                                }, 1000);

                                contentDiv.addEventListener('input', () => {
                                    setDirty();
                                    contentDiv.classList.remove('is-empty');
                                    clearTimeout(audioInitTimeout);
                                    audioInitTimeout = setTimeout(() => {
                                        App.audio.initializePlayersIn(contentDiv);
                                    }, 500); // 500ms delay after last input
                                });
                                App.state.autosaveInterval = setInterval(() => { if (App.state.isArticleDirty) App.events.saveArticle({ isAutosave: true }); }, 11000);
                                const guardianCallback = () => { if (contentDiv.childElementCount === 0 || (contentDiv.childElementCount === 1 && contentDiv.firstElementChild.tagName === 'BR')) { contentDiv.innerHTML = '<p><br></p>'; } };
                                App.state.guardianObserver = new MutationObserver(guardianCallback);
                                App.state.guardianObserver.observe(contentDiv, { childList: true });
                                guardianCallback();
                                contentDiv.addEventListener('mouseup', App.events.handleSelection);

                                contentDiv.addEventListener('focusin', (e) => {
                                    if (document.body.classList.contains('mobile-view') && App.util.isMobile()) {
                                        setTimeout(() => {
                                            e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                        }, 300); // A small delay allows the keyboard to animate in
                                    }
                                });
                                contentDiv.addEventListener('paste', App.events.handlePaste);
                                contentDiv.addEventListener('keydown', (e) => {
                                    const trigger = document.activeElement.closest('.nk-accordion-trigger');
                                    if ((e.key === 'Enter' || e.key === ' ') && trigger && !document.activeElement.isContentEditable) {
                                        e.preventDefault();
                                        trigger.click();
                                        return;
                                    }
                                    App.events.handleWriterShortcuts(e);
                                });
                                contentDiv.addEventListener('focusin', App.events.handleFocusIn);
                                contentDiv.addEventListener('dragover', App.events.handleDragOver);
                                contentDiv.addEventListener('dragleave', App.events.handleDragLeave);
                                contentDiv.addEventListener('drop', App.events.handleImageDrop);
                            }
                            break;
                        case 'tags':
                            setupDebouncedSearch('tag-search-input', App.events.filterAndRenderTags);
                            document.getElementById('tag-sort-filter')?.addEventListener('change', App.events.changeTagSort);
                            break;
                        case 'flashcard':
                            document.getElementById('flashcard-sort')?.addEventListener('change', App.events.changeFlashcardSort);
                            setupDebouncedSearch('flashcard-search-input', App.ui.filterAndRenderFlashcards);
                            document.getElementById('flashcard-search-input')?.addEventListener('keydown', (e) => {
                                const { searchResults, selectedIndex } = App.state.flashcardRender;
                                if (!searchResults || searchResults.length === 0) return;
                                let newIndex = selectedIndex;
                                let handled = false;
                                if (e.key === 'ArrowDown' || e.key === 'ArrowRight') { newIndex = (selectedIndex + 1) % searchResults.length; handled = true; }
                                else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') { newIndex = (selectedIndex - 1 + searchResults.length) % searchResults.length; handled = true; }
                                else if (e.key === 'Enter') { e.preventDefault(); const selectedCard = searchResults[selectedIndex]; if (selectedCard) selectedCard.click(); return; }
                                if (handled) { e.preventDefault(); if (selectedIndex > -1) searchResults[selectedIndex].classList.remove('search-selected-card'); searchResults[newIndex].classList.add('search-selected-card'); searchResults[newIndex].scrollIntoView({ behavior: 'smooth', block: 'center' }); App.state.flashcardRender.selectedIndex = newIndex; }
                            });
                            break;
                    }
                },


                typewriter: {
                    intervalId: null,

                    start(element) {
                        this.reset(); // Stop any previous typewriter effect
                        if (!element) return;

                        const words = element.querySelectorAll('.reveal-word');
                        if (words.length === 0) return; // Nothing to type

                        let wordIndex = 0;
                        this.intervalId = setInterval(() => {
                            if (wordIndex < words.length) {
                                words[wordIndex].classList.add('visible');
                                wordIndex++;
                            } else {
                                this.reset(); // Effect finished, clear the timer
                            }
                        }, 50); // Adjust typing speed here (milliseconds)
                    },

                    // This function clears any active typewriter timer
                    reset() {
                        if (this.intervalId) {
                            clearInterval(this.intervalId);
                            this.intervalId = null;
                        }
                    }
                },

                // --- Stage Timer Feature (Enhanced & Premium) ---
                stageTimer: {
                    state: {
                        duration: 5,
                        timeLeft: 5,
                        interval: null,
                        isRunning: false,
                        dragData: { isDragging: false, startX: 0, startY: 0, offsetX: 0, offsetY: 0 }
                    },

                    toggle() {
                        const overlay = document.getElementById('focus-mode-overlay');
                        if (!overlay) return;

                        let widget = document.getElementById('stage-timer-widget');
                        if (!widget) {
                            this.render(overlay);
                            widget = document.getElementById('stage-timer-widget');
                            void widget.offsetWidth; // Force Reflow
                            requestAnimationFrame(() => {
                                widget.classList.remove('hidden');
                                widget.style.display = 'flex';
                                widget.style.opacity = '1';
                                widget.style.transform = 'scale(1)';
                            });
                        } else {
                            if (widget.classList.contains('hidden') || widget.style.display === 'none') {
                                widget.classList.remove('hidden');
                                widget.style.display = 'flex';
                                requestAnimationFrame(() => {
                                    widget.style.opacity = '1';
                                    widget.style.transform = 'scale(1)';
                                });
                            } else {
                                widget.style.opacity = '0';
                                widget.style.transform = 'scale(0.8)';
                                setTimeout(() => {
                                    widget.classList.add('hidden');
                                    widget.style.display = 'none';
                                    this.stop(); // Stop if hidden
                                }, 300);
                            }
                        }
                    },

                    render(overlay) {
                        const div = document.createElement('div');
                        div.id = 'stage-timer-widget';
                        div.className = 'stage-timer-widget hidden';
                        div.style.display = 'none'; // Start hidden

                        // Load saved duration from localStorage
                        const savedDuration = localStorage.getItem('nk-stage-timer-duration');
                        if (savedDuration) {
                            const duration = parseInt(savedDuration);
                            if (!isNaN(duration) && duration > 0) {
                                this.state.duration = duration;
                                this.state.timeLeft = duration;
                            }
                        }

                        // Load saved position from localStorage
                        const savedPos = localStorage.getItem('nk-stage-timer-position');
                        if (savedPos) {
                            try {
                                const pos = JSON.parse(savedPos);
                                div.style.top = pos.top;
                                div.style.right = pos.right;
                            } catch (e) { }
                        }

                        div.innerHTML = `
                            <svg class="stage-timer-progress-svg" viewBox="0 0 100 100">
                                <circle class="stage-timer-progress-bg" cx="50" cy="50" r="45"></circle>
                                <circle class="stage-timer-progress-fg" cx="50" cy="50" r="45" transform="rotate(-90 50 50)"></circle>
                            </svg>
                            <span class="stage-timer-label" style="z-index: 1;">TIMER</span>
                            <div id="stage-timer-display-visual" class="stage-timer-display-visual" style="z-index: 1;"></div>
                            <input type="number" id="stage-timer-input" class="stage-timer-input" value="${this.state.duration}" min="1" max="999" style="z-index: 1;" />
                            <div class="stage-timer-status" id="stage-timer-status" style="z-index: 1;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445z"/></svg> 
                                <span>Click to Start</span>
                            </div>
                        `;
                        overlay.appendChild(div);

                        const input = document.getElementById('stage-timer-input');

                        // Setup drag functionality
                        this.setupDrag(div);

                        // Single click to toggle (only on widget, not input)
                        let clickTimeout = null;
                        div.addEventListener('click', (e) => {
                            if (e.target.tagName === 'INPUT' || this.state.dragData.isDragging) return;

                            if (clickTimeout) {
                                clearTimeout(clickTimeout);
                                clickTimeout = null;
                                return; // This is part of a double-click
                            }

                            clickTimeout = setTimeout(() => {
                                this.toggleRun();
                                clickTimeout = null;
                            }, 250);
                        });

                        // Double click to reset
                        div.addEventListener('dblclick', (e) => {
                            if (e.target.tagName === 'INPUT') return;
                            if (clickTimeout) {
                                clearTimeout(clickTimeout);
                                clickTimeout = null;
                            }
                            this.reset();
                            App.ui.showToast('Timer reset', { type: 'info' });
                        });

                        input.onfocus = () => {
                            this.stop(); // Stop timer when editing
                            div.classList.add('editing');
                        };

                        input.onblur = () => {
                            div.classList.remove('editing');
                            let val = parseInt(input.value);
                            if (isNaN(val) || val < 1) val = this.state.duration;
                            if (val > 999) val = 999;
                            input.value = val;

                            // Save the new duration persistently
                            this.state.duration = val;
                            this.state.timeLeft = val;
                            localStorage.setItem('nk-stage-timer-duration', val.toString());

                            this.updateStatusText('Ready');
                        };

                        input.onkeydown = (e) => {
                            if (e.key === 'Enter') {
                                input.blur();
                                this.start();
                            }
                        };
                    },

                    setupDrag(widget) {
                        let startX, startY, initialTop, initialRight;
                        let hasMoved = false;

                        const onMouseDown = (e) => {
                            // Don't drag if clicking on input
                            if (e.target.tagName === 'INPUT') return;

                            hasMoved = false;
                            this.state.dragData.isDragging = true;

                            startX = e.clientX;
                            startY = e.clientY;

                            const rect = widget.getBoundingClientRect();
                            initialTop = rect.top;
                            initialRight = window.innerWidth - rect.right;

                            widget.style.transition = 'none';
                            widget.style.cursor = 'grabbing';

                            document.addEventListener('mousemove', onMouseMove);
                            document.addEventListener('mouseup', onMouseUp);

                            e.preventDefault();
                        };

                        const onMouseMove = (e) => {
                            if (!this.state.dragData.isDragging) return;

                            const deltaX = e.clientX - startX;
                            const deltaY = e.clientY - startY;

                            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                                hasMoved = true;
                            }

                            const newTop = initialTop + deltaY;
                            const newRight = initialRight - deltaX;

                            // Constrain to viewport
                            const maxTop = window.innerHeight - widget.offsetHeight - 20;
                            const maxRight = window.innerWidth - widget.offsetWidth - 20;

                            widget.style.top = Math.max(20, Math.min(newTop, maxTop)) + 'px';
                            widget.style.right = Math.max(20, Math.min(newRight, maxRight)) + 'px';
                        };

                        const onMouseUp = () => {
                            this.state.dragData.isDragging = false;
                            widget.style.transition = '';
                            widget.style.cursor = 'grab';

                            // Save position
                            if (hasMoved) {
                                localStorage.setItem('nk-stage-timer-position', JSON.stringify({
                                    top: widget.style.top,
                                    right: widget.style.right
                                }));
                            }

                            document.removeEventListener('mousemove', onMouseMove);
                            document.removeEventListener('mouseup', onMouseUp);

                            setTimeout(() => { hasMoved = false; }, 100);
                        };

                        widget.addEventListener('mousedown', onMouseDown);
                    },

                    toggleRun() {
                        if (this.state.isRunning) {
                            this.stop();
                        } else {
                            // If finished, reset first
                            if (this.state.timeLeft <= 0) {
                                this.reset();
                            }
                            this.start();
                        }
                    },

                    start() {
                        const widget = document.getElementById('stage-timer-widget');
                        const input = document.getElementById('stage-timer-input');
                        const visual = document.getElementById('stage-timer-display-visual');

                        // Save the current duration when starting
                        const currentVal = parseInt(input.value);
                        if (!isNaN(currentVal) && currentVal > 0) {
                            this.state.duration = currentVal;
                            this.state.timeLeft = currentVal;
                            localStorage.setItem('nk-stage-timer-duration', currentVal.toString());
                        }

                        if (this.state.timeLeft <= 0) this.state.timeLeft = this.state.duration;

                        this.state.isRunning = true;
                        widget?.classList.add('running');
                        widget?.classList.remove('finished');
                        this.updateStatusText('Running');

                        // Initial Visual Update
                        if (visual) {
                            visual.innerHTML = `<span class="stage-timer-digit">${this.state.timeLeft}</span>`;
                        }

                        if (this.state.interval) clearInterval(this.state.interval);

                        this.state.interval = setInterval(() => {
                            this.state.timeLeft--;

                            // Update Visual Display with animation
                            if (visual) {
                                // Re-injecting HTML forces animation restart
                                visual.innerHTML = `<span class="stage-timer-digit">${this.state.timeLeft}</span>`;
                            }

                            // Keep input synced in background just in case
                            if (input) {
                                input.value = this.state.timeLeft;
                            }

                            // Update Progress Ring
                            this.updateProgress();

                            // Play subtle tick sound each second
                            this.playTickSound();

                            if (this.state.timeLeft <= 0) {
                                this.finish();
                            }
                        }, 1000);
                    },

                    updateProgress() {
                        const widget = document.getElementById('stage-timer-widget');
                        const progressCircle = widget?.querySelector('.stage-timer-progress-fg');

                        if (progressCircle && this.state.duration > 0) {
                            const percent = this.state.timeLeft / this.state.duration;
                            const circumference = 283;
                            const offset = circumference - (percent * circumference);
                            progressCircle.style.strokeDashoffset = offset;

                            // Critical state (last 25%)
                            if (percent <= 0.25) {
                                widget.classList.add('critical');
                            } else {
                                widget.classList.remove('critical');
                            }
                        }
                    },

                    stop() {
                        this.state.isRunning = false;
                        const widget = document.getElementById('stage-timer-widget');
                        widget?.classList.remove('running');
                        // Don't remove critical class here so it stays red if paused in critical zone

                        this.updateStatusText(this.state.timeLeft <= 0 ? 'Finished' : 'Paused');

                        if (this.state.interval) clearInterval(this.state.interval);
                        this.state.interval = null;
                    },

                    reset() {
                        this.stop();
                        this.state.timeLeft = this.state.duration;
                        const input = document.getElementById('stage-timer-input');
                        const widget = document.getElementById('stage-timer-widget');
                        if (input) input.value = this.state.timeLeft;
                        widget?.classList.remove('finished');
                        widget?.classList.remove('critical');

                        // Reset ring
                        const progressCircle = widget?.querySelector('.stage-timer-progress-fg');
                        if (progressCircle) progressCircle.style.strokeDashoffset = 0;

                        const label = widget?.querySelector('.stage-timer-label');
                        if (label) label.textContent = 'TIMER';
                        this.updateStatusText('Ready');
                    },

                    finish() {
                        this.stop();
                        const widget = document.getElementById('stage-timer-widget');
                        const visual = document.getElementById('stage-timer-display-visual');
                        const label = widget?.querySelector('.stage-timer-label');
                        const status = widget?.querySelector('.stage-timer-status span'); // Select the text span within status

                        widget?.classList.add('finished');
                        widget?.classList.add('critical'); // Ensure fully red

                        // Reset Label to Timer (user wanted "Time's Up" at bottom)
                        if (label) {
                            label.textContent = "TIMER";
                            label.style.opacity = '1'; // Ensure visible on finish
                            label.style.transform = 'translateY(0)';
                        }

                        // Set Bottom Text
                        if (status) status.textContent = "TIME'S UP";

                        // Ensure ring is empty
                        const progressCircle = widget?.querySelector('.stage-timer-progress-fg');
                        if (progressCircle) progressCircle.style.strokeDashoffset = 283;

                        // Keep visual visible but change style slightly via class
                        if (visual) {
                            visual.innerHTML = `<span class="stage-timer-digit" style="color: var(--danger-color);">0</span>`;
                        }

                        this.playCompletionChime();
                    },

                    // Shared AudioContext for better performance
                    getAudioContext() {
                        if (!this.audioContext) {
                            const AudioContext = window.AudioContext || window.webkitAudioContext;
                            if (!AudioContext) return null;
                            this.audioContext = new AudioContext();
                        }
                        return this.audioContext;
                    },

                    playTickSound() {
                        try {
                            const ctx = this.getAudioContext();
                            if (!ctx) return;

                            // Subtle analog clock tick sound
                            const osc = ctx.createOscillator();
                            const gain = ctx.createGain();

                            osc.connect(gain);
                            gain.connect(ctx.destination);

                            // High frequency for crisp tick
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(1200, ctx.currentTime);

                            gain.gain.setValueAtTime(0.08, ctx.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.03);

                            osc.start(ctx.currentTime);
                            osc.stop(ctx.currentTime + 0.03);
                        } catch (e) {
                            console.error('Tick sound error:', e);
                        }
                    },

                    playCompletionChime() {
                        try {
                            const ctx = this.getAudioContext();
                            if (!ctx) return;

                            // Create a pleasant melodic chime with harmonious tones
                            const masterGain = ctx.createGain();
                            masterGain.connect(ctx.destination);
                            masterGain.gain.setValueAtTime(0.55, ctx.currentTime);
                            masterGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 1.6);

                            // Three harmonically related frequencies (C major chord: C5, E5, G5)
                            const frequencies = [523.25, 659.25, 783.99];
                            const delays = [0, 0.08, 0.16];

                            frequencies.forEach((freq, i) => {
                                const osc = ctx.createOscillator();
                                const gain = ctx.createGain();

                                osc.connect(gain);
                                gain.connect(masterGain);

                                osc.type = 'sine';
                                osc.frequency.setValueAtTime(freq, ctx.currentTime);

                                const startTime = ctx.currentTime + delays[i];
                                gain.gain.setValueAtTime(0.3, startTime);
                                gain.gain.exponentialRampToValueAtTime(0.01, startTime + 1.4);

                                osc.start(startTime);
                                osc.stop(startTime + 1.6);
                            });

                        } catch (e) {
                            console.error('Timer audio error:', e);
                        }
                    },

                    updateStatusText(text) {
                        const el = document.getElementById('stage-timer-status');
                        if (!el) return;

                        let icon = '';
                        if (text === 'Running') icon = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>`;
                        else if (text === 'Ready' || text === 'Paused') icon = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M10.804 8 5 4.633v6.734L10.804 8zm.792-.696a.802.802 0 0 1 0 1.392l-6.363 3.692C4.713 12.69 4 12.345 4 11.692V4.308c0-.653.713-.998 1.233-.696l6.363 3.692z"/></svg>`;
                        else if (text === 'Time\'s Up!' || text === 'Done') icon = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/></svg>`;
                        else icon = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445z"/></svg>`;

                        // Show only icon when running (no text)
                        if (text === 'Running') {
                            el.innerHTML = icon;
                            el.style.justifyContent = 'center';
                        } else {
                            el.innerHTML = `${icon} <span>${text}</span>`;
                            el.style.justifyContent = '';
                        }
                    }
                },
                presentation: {
                    state: { duration: 10, timeLeft: 10, interval: null, isRunning: false },

                    toggle() {
                        const overlay = document.getElementById('focus-mode-overlay');
                        if (!overlay) return;

                        let widget = document.getElementById('stage-timer-widget');
                        if (!widget) {
                            this.render(overlay);
                            widget = document.getElementById('stage-timer-widget');
                            void widget.offsetWidth;
                            widget.classList.add('visible');
                        } else {
                            if (widget.classList.contains('hidden')) {
                                widget.classList.remove('hidden');
                                widget.style.display = 'flex';
                                requestAnimationFrame(() => {
                                    widget.style.opacity = '1';
                                    widget.style.transform = 'scale(1)';
                                });
                            } else {
                                widget.style.opacity = '0';
                                widget.style.transform = 'scale(0.9)';
                                setTimeout(() => {
                                    widget.classList.add('hidden');
                                    widget.style.display = 'none';
                                }, 300);
                            }
                        }
                    },

                    render(overlay) {
                        const div = document.createElement('div');
                        div.id = 'stage-timer-widget';
                        div.className = 'stage-timer-widget';
                        div.innerHTML = `
                             <div class="stage-timer-header">
                                <span class="stage-timer-label">Timer</span>
                                <div class="stage-timer-presets">
                                    <div class="stage-timer-preset" onclick="App.events.stageTimer.setDuration(10)">10s</div>
                                    <div class="stage-timer-preset" onclick="App.events.stageTimer.setDuration(30)">30s</div>
                                    <div class="stage-timer-preset" onclick="App.events.stageTimer.setDuration(60)">1m</div>
                                </div>
                            </div>
                            <div class="stage-timer-display" id="stage-timer-display">10</div>
                            <div class="stage-timer-controls">
                                <button class="stage-timer-btn" onclick="App.events.stageTimer.reset()" title="Reset" id="stage-timer-reset-btn">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                                </button>
                                <button class="stage-timer-btn primary" id="stage-timer-action-btn" onclick="App.events.stageTimer.toggleRun()">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z" /></svg>
                                </button>
                            </div>
                        `;
                        overlay.appendChild(div);
                        this.updateDisplay();
                    },

                    setDuration(seconds) {
                        this.stop();
                        this.state.duration = seconds;
                        this.state.timeLeft = seconds;
                        this.updateDisplay();
                    },

                    toggleRun() {
                        if (this.state.isRunning) {
                            this.stop();
                        } else {
                            this.start();
                        }
                    },

                    start() {
                        if (this.state.timeLeft <= 0) this.state.timeLeft = this.state.duration;
                        this.state.isRunning = true;
                        this.updateBtnState();

                        // Play a soft start sound? Maybe not needed.
                        if (this.state.interval) clearInterval(this.state.interval);

                        this.state.interval = setInterval(() => {
                            this.state.timeLeft--;
                            this.updateDisplay(true); // pass true to animate

                            if (this.state.timeLeft <= 0) {
                                this.finish();
                            }
                        }, 1000);
                    },

                    stop() {
                        this.state.isRunning = false;
                        if (this.state.interval) clearInterval(this.state.interval);
                        this.state.interval = null;
                        this.updateBtnState();
                    },

                    reset() {
                        this.stop();
                        this.state.timeLeft = this.state.duration;
                        this.updateDisplay(); // no animation on reset
                    },

                    finish() {
                        this.stop();
                        this.playCompletionSound();

                        // Aesthetic completion effect
                        const display = document.getElementById('stage-timer-display');
                        const widget = document.getElementById('stage-timer-widget');
                        if (widget) {
                            widget.style.boxShadow = '0 0 40px rgba(var(--danger-color-rgb), 0.5), 0 20px 25px -5px rgba(0, 0, 0, 0.1)';
                            widget.style.borderColor = 'var(--danger-color)';

                            const oldColor = display.style.color;
                            display.style.color = 'var(--danger-color)';

                            // Pulse animation for widget
                            widget.animate([
                                { transform: 'scale(1)' },
                                { transform: 'scale(1.05)' },
                                { transform: 'scale(1)' }
                            ], { duration: 300, iterations: 2 });

                            setTimeout(() => {
                                widget.style.boxShadow = '';
                                widget.style.borderColor = '';
                                display.style.color = oldColor;
                            }, 2500);
                        }
                    },

                    playCompletionSound() {
                        try {
                            const AudioContext = window.AudioContext || window.webkitAudioContext;
                            if (!AudioContext) return;
                            const ctx = new AudioContext();

                            const playTone = (freq, type, duration, delay, vol = 0.2) => {
                                const osc = ctx.createOscillator();
                                const gain = ctx.createGain();
                                osc.connect(gain);
                                gain.connect(ctx.destination);
                                osc.type = type;
                                osc.frequency.setValueAtTime(freq, ctx.currentTime + delay);
                                gain.gain.setValueAtTime(vol, ctx.currentTime + delay);
                                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + delay + duration);
                                osc.start(ctx.currentTime + delay);
                                osc.stop(ctx.currentTime + delay + duration);
                            };

                            // "Beep Beep" - Pleasant but alert
                            // E5 then E5
                            playTone(659.25, 'sine', 0.15, 0, 0.3);
                            setTimeout(() => playTone(659.25, 'sine', 0.4, 0), 200);

                        } catch (e) { console.error("Audio error", e); }
                    },

                    updateDisplay(animate = false) {
                        const el = document.getElementById('stage-timer-display');
                        if (!el) return;

                        el.textContent = this.state.timeLeft;

                        if (animate && this.state.timeLeft > 0) {
                            el.classList.remove('animate');
                            void el.offsetWidth; // force reflow
                            el.classList.add('animate');
                        }
                    },

                    updateBtnState() {
                        const btn = document.getElementById('stage-timer-action-btn');
                        if (!btn) return;
                        if (this.state.isRunning) {
                            // Pause/Stop icon
                            btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><rect x="6" y="4" width="4" height="16" rx="1" /><rect x="14" y="4" width="4" height="16" rx="1" /></svg>`;
                            btn.title = "Stop";
                        } else {
                            // Play icon
                            btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z" /></svg>`;
                            btn.title = "Start";
                        }
                    }
                },
                presentation: {
                    themes: [
                        'default',
                        'lime-ink', 'goldenrod-pad', 'mint-chip', 'aqua-sky', 'peach-sorbet', 'powder-snow',
                        'terminal', 'crimson-night', 'royal-indigo', 'emerald-tablet', 'obsidian-ruby', 'blueprint', 'midnight-sun',
                        'evergreen', 'clay-sky', 'sandstone-agave', 'stone-moss', 'mahogany', 'riverbed', 'matrix',
                        'rosewater', 'azure-depth', 'olive-grove', 'sterling', 'greyscale'
                    ],
                    currentThemeIndex: 0,
                    currentSnippetIndex: -1,
                    _revealFirstVisibleSnippet() {
                        const overlay = document.getElementById('focus-mode-overlay');
                        if (!overlay) return;

                        const allItems = Array.from(overlay.querySelectorAll('.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-accordion'));

                        const visibleItems = allItems.filter(el => el.classList.contains('is-visible'));

                        if (visibleItems.length > 0) {
                            const firstItemOnNewSlide = visibleItems[0];
                            // Un-reveal everything first
                            allItems.forEach(item => item.classList.remove('is-revealing', 'spotlight-key-focus'));
                            // Reveal just the first one on the new slide
                            firstItemOnNewSlide.classList.add('is-revealing', 'spotlight-key-focus');
                            App.events.typewriter.start(firstItemOnNewSlide);
                        }
                    },

                    cycleAmbiance(goBack = false) {
                        const session = App.state.focusSession;
                        if (!session.isActive) return;

                        const overlay = document.getElementById('focus-mode-overlay');
                        if (!overlay) return;

                        const currentIndex = this.themes.indexOf(session.activeTheme);
                        const nextIndex = goBack
                            ? (currentIndex - 1 + this.themes.length) % this.themes.length
                            : (currentIndex + 1) % this.themes.length;
                        const newTheme = this.themes[nextIndex];

                        // Manually remove any old theme classes
                        overlay.className = overlay.className.replace(/\bambiance-\S+/g, '').trim();

                        if (newTheme !== 'default') {
                            overlay.classList.add(`ambiance-${newTheme}`);
                        }

                        session.activeTheme = newTheme;

                        const themeName = newTheme.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        App.ui.showToast(`${themeName}`, { type: 'info', duration: 1500 });
                    },

                    // This function now correctly resets the theme using direct, reliable logic.
                    resetAmbiance() {
                        const session = App.state.focusSession;
                        if (!session.isActive) return;

                        const overlay = document.getElementById('focus-mode-overlay');
                        if (!overlay) return;

                        overlay.className = overlay.className.replace(/\bambiance-\S+/g, '').trim();
                        session.activeTheme = 'default';

                        App.ui.showToast('Theme reset to default', { type: 'success', duration: 2000 });
                    },

                    toggleCinematicMotion(buttonEl) {
                        const session = App.state.focusSession;
                        if (!session.isActive) return;
                        session.isCinematicActive = !session.isCinematicActive;
                        const overlay = document.getElementById('focus-mode-overlay');
                        overlay?.classList.toggle('cinematic-active', session.isCinematicActive);
                        if (buttonEl) buttonEl.classList.toggle('active', session.isCinematicActive);
                        const currentSlideSnippets = session.isStageMode
                            ? Array.from(overlay.querySelectorAll('.snippet.is-visible, .nk-mcq-block.is-visible'))
                            : Array.from(overlay.querySelectorAll('.snippet, .nk-mcq-block'));

                        // Reliability Polish: Clear any old spotlights when toggling
                        overlay.querySelectorAll('.spotlight-key-focus').forEach(el => el.classList.remove('spotlight-key-focus'));

                        if (session.isCinematicActive) {
                            currentSlideSnippets.forEach(s => s.classList.remove('is-revealing'));
                            this.currentSnippetIndex = -1;
                            this.navigateCinematic(1); // Reveal first snippet
                            App.ui.showToast('Cinematic Reveal Enabled', { type: 'info' });
                        } else {
                            currentSlideSnippets.forEach(s => s.classList.add('is-revealing'));
                            App.events.typewriter.reset();
                            App.ui.showToast('Cinematic Reveal Disabled', { type: 'info' });
                        }
                    },

                    navigateCinematic(direction) {
                        const overlay = document.getElementById('focus-mode-overlay');

                        const snippets = Array.from(overlay.querySelectorAll('.snippet.is-visible, .nk-mcq-block.is-visible, .nk-accordion.is-visible'));

                        if (snippets.length === 0) return;

                        // Clear any previous spotlight
                        overlay.querySelectorAll('.spotlight-key-focus').forEach(el => el.classList.remove('spotlight-key-focus'));

                        let newIndex = this.currentSnippetIndex + direction;

                        // Clamp the new index to be within the valid range of snippets
                        newIndex = Math.max(0, Math.min(snippets.length - 1, newIndex));

                        const targetSnippet = snippets[newIndex];

                        if (targetSnippet) {
                            snippets.forEach(s => s.classList.remove('is-revealing'));
                            targetSnippet.classList.add('is-revealing');

                            // Add the spotlight effect to the newly revealed snippet
                            targetSnippet.classList.add('spotlight-key-focus');
                            targetSnippet.scrollIntoView({ behavior: 'smooth', block: 'center' });

                            // Apply the typewriter effect
                            App.events.typewriter.start(targetSnippet);
                        }

                        this.currentSnippetIndex = newIndex;
                    },


                    _handleTeleprompterDragStart(e) {
                        e.preventDefault();
                        e.stopPropagation();

                        const resizer = document.getElementById('teleprompter-resizer');
                        if (resizer) resizer.classList.add('is-resizing');

                        document.addEventListener('mousemove', App.events.presentation._handleTeleprompterDrag);
                        document.addEventListener('mouseup', App.events.presentation._handleTeleprompterDragEnd);
                        document.addEventListener('touchmove', App.events.presentation._handleTeleprompterDrag, { passive: false });
                        document.addEventListener('touchend', App.events.presentation._handleTeleprompterDragEnd);
                    },

                    _handleTeleprompterDrag(e) {
                        e.preventDefault();
                        e.stopPropagation();

                        const session = App.state.focusSession;
                        if (!session.teleprompterActive) return;

                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                        const sidebar = document.getElementById('teleprompter-sidebar');
                        const content = document.querySelector('.focus-mode-overlay.teleprompter-active .focus-mode-content');
                        if (!sidebar || !content) return;

                        let newPercentage = 30;

                        if (document.body.classList.contains('mobile-view')) {
                            // Mobile: Vertical resize (based on height)
                            const headerHeight = document.querySelector('header')?.offsetHeight || 48;
                            const newHeight = clientY - headerHeight;
                            newPercentage = (newHeight / window.innerHeight) * 100;
                            newPercentage = Math.max(15, Math.min(85, newPercentage)); // Clamp between 15% and 85% height

                            sidebar.style.height = `${100 - newPercentage}%`;
                            content.style.height = `${newPercentage}%`;
                        } else {
                            // Desktop: Horizontal resize (based on width)
                            newPercentage = (clientX / window.innerWidth) * 100;
                            newPercentage = Math.max(15, Math.min(60, newPercentage)); // Clamp between 15% and 60% width

                            sidebar.style.width = `${newPercentage}%`;
                            content.style.width = `${100 - newPercentage}%`;
                        }

                        session.teleprompterSize = newPercentage;

                        // Recalculate stage mode layout *after* the DOM has updated
                        requestAnimationFrame(() => {
                            const bodyEl = document.querySelector('.focus-mode-body');
                            if (bodyEl && session.isStageMode) {
                                session.scrollStops = App.ui._calculateScrollStops(bodyEl);
                            }
                        });
                    },

                    _handleTeleprompterDragEnd(e) {
                        const resizer = document.getElementById('teleprompter-resizer');
                        if (resizer) resizer.classList.remove('is-resizing');

                        document.removeEventListener('mousemove', App.events.presentation._handleTeleprompterDrag);
                        document.removeEventListener('mouseup', App.events.presentation._handleTeleprompterDragEnd);
                        document.removeEventListener('touchmove', App.events.presentation._handleTeleprompterDrag);
                        document.removeEventListener('touchend', App.events.presentation._handleTeleprompterDragEnd);

                        // Final recalculation to ensure scroll stops are perfect
                        const session = App.state.focusSession;
                        const bodyEl = document.querySelector('.focus-mode-body');
                        if (bodyEl && session.isStageMode) {
                            session.scrollStops = App.ui._calculateScrollStops(bodyEl);
                        }
                    },

                    adjustTeleprompterFont(delta) {
                        const session = App.state.focusSession;
                        const sidebar = document.getElementById('teleprompter-sidebar');
                        if (!session.isActive || !session.teleprompterActive || !sidebar) return;
                        const currentSizeString = getComputedStyle(sidebar).getPropertyValue('--teleprompter-font-size') || '1.1rem';

                        let currentSizeNum = parseFloat(currentSizeString);
                        if (isNaN(currentSizeNum)) {
                            currentSizeNum = 1.1;
                        }
                        let newSize = currentSizeNum + delta;
                        newSize = Math.max(0.5, Math.min(3.0, newSize)); // Clamp size

                        session.teleprompterFontSize = newSize; // Store the new number
                        sidebar.style.setProperty('--teleprompter-font-size', `${newSize}rem`);
                    },

                    toggleTeleprompter() {
                        const session = App.state.focusSession;
                        if (!session.isActive) return;

                        session.teleprompterActive = !session.teleprompterActive;
                        const overlay = document.getElementById('focus-mode-overlay');
                        const toggleBtn = document.getElementById('teleprompter-toggle-btn');
                        const contentEl = overlay.querySelector('.focus-mode-content');

                        overlay.classList.toggle('teleprompter-active', session.teleprompterActive);
                        if (toggleBtn) {
                            toggleBtn.classList.toggle('active', session.teleprompterActive);
                        }

                        let sidebar = document.getElementById('teleprompter-sidebar');

                        if (session.teleprompterActive) {
                            if (!sidebar) {
                                sidebar = document.createElement('div');
                                sidebar.id = 'teleprompter-sidebar';
                                overlay.insertBefore(sidebar, contentEl);
                            }

                            const size = session.teleprompterSize || 30;
                            const contentSize = 100 - size;

                            if (document.body.classList.contains('mobile-view')) {
                                // Mobile: Apply height
                                sidebar.style.height = `${contentSize}%`; // Teleprompter is on bottom
                                contentEl.style.height = `${size}%`;     // Content is on top
                            } else {
                                // Desktop: Apply width
                                sidebar.style.width = `${size}%`;
                                contentEl.style.width = `${contentSize}%`;
                            }

                            sidebar.style.setProperty('--teleprompter-font-size', `${session.teleprompterFontSize}rem`);

                            const article = App.storage.getArticle(session.articles[session.currentIndex].id);
                            if (article && article.content) {
                                let parsedContent = App.util.parseShortcuts(article.content);
                                let teleprompterFriendlyContent = App.util._transformMcqsForTeleprompter(parsedContent);
                                teleprompterFriendlyContent = App.util._transformAccordionsForTeleprompter(teleprompterFriendlyContent);
                                let finalContentHTML = App.util.sanitizeForTeleprompter(teleprompterFriendlyContent);

                                sidebar.innerHTML = finalContentHTML;
                            } else {
                                sidebar.innerHTML = "<p>Could not load article content.</p>";
                            }

                            const controlsHTML = `
                            <div id="teleprompter-controls">
                                <button class="btn-icon" id="tp-font-dec" onclick="App.events.presentation.adjustTeleprompterFont(-0.1)" title="Decrease Font Size (-)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M1 8a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13A.5.5 0 0 1 1 8z"/></svg>
                                </button>
                                <button class="btn-icon" id="tp-font-inc" onclick="App.events.presentation.adjustTeleprompterFont(0.1)" title="Increase Font Size (+)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>
                                </button>
                            </div>
                        `;
                            sidebar.insertAdjacentHTML('afterbegin', controlsHTML);

                            const resizer = document.createElement('div');
                            resizer.id = 'teleprompter-resizer';
                            sidebar.appendChild(resizer); // Append to sidebar for correct positioning

                            resizer.addEventListener('mousedown', App.events.presentation._handleTeleprompterDragStart);
                            resizer.addEventListener('touchstart', App.events.presentation._handleTeleprompterDragStart, { passive: false });

                            App.ui.showToast('Teleprompter On', 'info');

                        } else {
                            if (sidebar) {
                                sidebar.remove(); // This removes the sidebar and its child resizer
                            }
                            if (document.body.classList.contains('mobile-view')) {
                                contentEl.style.height = '100%';
                            } else {
                                contentEl.style.width = '100%';
                            }

                            App.ui.showToast('Teleprompter Off', 'info');
                        }

                        setTimeout(() => {
                            const bodyEl = overlay.querySelector('.focus-mode-body');
                            if (bodyEl) {
                                session.scrollStops = App.ui._calculateScrollStops(bodyEl);
                                bodyEl.scrollTo({ top: session.scrollStops[session.currentSlideIndex], behavior: 'auto' });
                            }
                        }, 100);
                    },
                },

                // --- Annotation Namespace for Stage Mode ---
                annotation: {
                    async toggleWhiteboard() {
                        // Close if already open
                        if (App.whiteboard.state.isOpen) {
                            App.whiteboard.close();
                            return;
                        }

                        const session = App.state.focusSession;

                        // CASE 1: Stage Mode (Capture Screenshot)
                        if (session.isActive && session.isStageMode) {
                            try {
                                // Use the shared robust capture function
                                const dataUrl = await App.events.captureVisibleStage();

                                if (!dataUrl) {
                                    console.warn("Capture returned null. Opening blank whiteboard.");
                                    App.ui.showToast('Background capture unavailable. Opening blank board.', { type: 'info', duration: 2000 });
                                    const currentArticle = session.articles[session.currentIndex];
                                    const articleId = currentArticle?.id || null;
                                    App.whiteboard.open('end', articleId);
                                    return;
                                }

                                // Get current article ID Context
                                const currentArticle = session.articles[session.currentIndex];
                                const articleId = currentArticle?.id || null;

                                // Calculate dimensions (based on viewport, as that's what we captured)
                                const ratio = window.devicePixelRatio || 1;
                                const width = window.innerWidth * ratio;
                                const height = window.innerHeight * ratio;

                                // Open whiteboard with the screenshot
                                await App.whiteboard.openWithScreenshot(dataUrl, width, height, articleId, true);

                            } catch (err) {
                                console.error("Whiteboard capture failed:", err);
                                App.ui.showToast('Capture error. Opening blank board.', { type: 'warning' });
                                const currentArticle = session.articles[session.currentIndex];
                                const articleId = currentArticle?.id || null;
                                App.whiteboard.open('end', articleId);
                            }
                        }
                        // CASE 2: Normal Mode
                        else {
                            App.whiteboard.open('end');
                        }
                    },
                    toggle() {
                        App.annotationEngine.toggle('focus');
                    },
                    clear() {
                        App.annotationEngine.clearCurrentPage();
                    }
                },

                unmountViewListeners() {

                    const oldContentDiv = document.getElementById('article-content');
                    if (oldContentDiv) {
                        const newContentDiv = oldContentDiv.cloneNode(true);
                        oldContentDiv.parentNode.replaceChild(newContentDiv, oldContentDiv);
                    }


                    const mainEl = document.querySelector('main');
                    if (mainEl) {
                        mainEl.removeEventListener('scroll', App.events.updateReadingProgress);
                    }

                    const controls = document.getElementById('article-controls');
                    if (controls && controls.parentElement !== document.body) {
                        document.body.appendChild(controls);
                    }

                    if (App.state.autosaveInterval) {
                        clearInterval(App.state.autosaveInterval);
                        App.state.autosaveInterval = null;
                        App.state.isArticleDirty = false;
                    }
                    if (App.state.guardianObserver) {
                        App.state.guardianObserver.disconnect();
                        App.state.guardianObserver = null;
                    }


                    if (App.visualMap && App.visualMap.destroy) App.visualMap.destroy();
                    if (App.mindMap && App.mindMap.destroy) App.mindMap.destroy();
                },

                async installPwa() {
                    const promptEvent = App.state.pwa.installPromptEvent;
                    if (!promptEvent) return;

                    promptEvent.prompt();
                    const { outcome } = await promptEvent.userChoice;
                    console.log(`User response to the install prompt: ${outcome}`);

                    App.state.pwa.installPromptEvent = null;
                    const installBtn = document.getElementById('install-pwa-btn');
                    if (installBtn) {
                        installBtn.style.display = 'none';
                    }
                },

                toggleCategoryNameStyle() {
                    const currentStyle = App.settings.get('categoryNameStyle') || 'full';
                    const newStyle = currentStyle === 'full' ? 'short' : 'full';
                    App.settings.set('categoryNameStyle', newStyle);
                    // Re-render the library view to apply the change instantly
                    App.router.navigateTo('library');
                },

                handleGlobalKeyDown(e) {
                    if (e.key === 'Escape' && App.commandPalette.state.isPreviewActive) {
                        e.preventDefault();
                        e.stopPropagation();
                        App.commandPalette.close(); // This triggers our robust _restoreEditor logic
                        return;
                    }

                    // --- ROBUST VIDEO DELETION (Simplified & Strong) ---
                    if ((e.key === 'Backspace' || e.key === 'Delete') && App.router.getActiveView() === 'article' && App.state.mode === 'write') {
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);

                            // 1. If selection is NOT collapsed (user selected the video or text around it)
                            if (!range.collapsed) {
                                let node = range.commonAncestorContainer;
                                if (node.nodeType === Node.TEXT_NODE) node = node.parentNode;

                                const embeddedVideo = node.querySelector ? node.querySelector('.nk-video-embed') : null;
                                const closestVideo = node.closest('.nk-video-embed');

                                if (closestVideo) {
                                    e.preventDefault();
                                    closestVideo.remove();
                                    App.state.isArticleDirty = true;
                                    App.ui.showToast('Video removed', { type: 'info' });
                                    return;
                                }
                                if (embeddedVideo && range.intersectsNode(embeddedVideo)) {
                                    embeddedVideo.remove();
                                    App.state.isArticleDirty = true;
                                }
                            }

                            // 2. Cursor is collapsed (Caret)
                            else {
                                let targetVideo = null;

                                if (e.key === 'Backspace') {
                                    const isAtStart = (range.startContainer.nodeType === Node.TEXT_NODE && range.startOffset === 0) ||
                                        (range.startContainer.nodeType === Node.ELEMENT_NODE && range.startOffset === 0);

                                    if (isAtStart) {
                                        // Current block's previous sibling
                                        let block = range.startContainer;
                                        while (block && block.style && block.style.display === 'inline') block = block.parentElement; // Walk up inline elements
                                        if (block.nodeType === Node.TEXT_NODE) block = block.parentElement;

                                        if (block.previousElementSibling && block.previousElementSibling.classList.contains('nk-video-embed')) {
                                            targetVideo = block.previousElementSibling;
                                        }
                                    } else {
                                        // Might be right after the video in the SAME container? (Unlikely for block video)
                                        // Check immediate child before cursor if in Element
                                        if (range.startContainer.nodeType === Node.ELEMENT_NODE) {
                                            const childBefore = range.startContainer.childNodes[range.startOffset - 1];
                                            if (childBefore && childBefore.classList && childBefore.classList.contains('nk-video-embed')) {
                                                targetVideo = childBefore;
                                            }
                                        }
                                    }
                                }
                                else if (e.key === 'Delete') {
                                    // Look Forwards (Fn+Backspace)
                                    let block = range.startContainer;
                                    if (block.nodeType === Node.TEXT_NODE) block = block.parentElement;

                                    if (block.nextElementSibling && block.nextElementSibling.classList.contains('nk-video-embed')) {
                                        const isAtEnd = (range.startContainer.nodeType === Node.TEXT_NODE && range.startOffset === range.startContainer.length) ||
                                            (range.startContainer.nodeType === Node.ELEMENT_NODE && range.startOffset === range.startContainer.childNodes.length);

                                        if (isAtEnd && block.nextElementSibling.classList.contains('nk-video-embed')) {
                                            targetVideo = block.nextElementSibling;
                                        }
                                    }
                                }

                                if (targetVideo) {
                                    e.preventDefault();
                                    targetVideo.remove();
                                    App.state.isArticleDirty = true;
                                    App.ui.showToast('Video removed', { type: 'info' });
                                    return;
                                }
                            }
                        }
                    }

                    const cmdKey = App.util.getCommandKey() === 'Cmd' ? e.metaKey : e.ctrlKey;
                    const isModalOpen = document.getElementById('modal-container').hasChildNodes();
                    const target = e.target;
                    const isEditable = target.isContentEditable || ['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName);

                    if (cmdKey && e.key === ';') {
                        e.preventDefault();
                        App.hub.ui.showProductivityModal();
                        return;
                    }
                    if (e.key.toLowerCase() === 'h' && App.router.getActiveView() === 'category' && !isEditable) {
                        e.preventDefault();
                        App.events.toggleCategoryHighlights();
                        return;
                    }
                    if (e.key === 'Enter' && !isEditable) {
                        const welcomeView = document.getElementById('welcome-view');
                        if (welcomeView && welcomeView.classList.contains('active')) {
                            e.preventDefault();
                            const resumeBtn = document.getElementById('resume-btn');
                            if (resumeBtn) resumeBtn.click();
                            else document.getElementById('select-folder-btn')?.click();
                        }
                    }

                    if (e.key === 'Escape') {
                        if (document.body.classList.contains('canvas-focus-mode')) {
                            App.events.toggleCanvasFocusMode();
                            e.preventDefault();
                            return;
                        }

                        const activeViewId = App.router.getActiveView();
                        if (isModalOpen) App.ui.closeModal();
                        else if (document.querySelector('.zen-mode-overlay')) App.hub.pomodoro.toggleZenMode();
                        else if (App.state.isFullscreen) App.events.toggleFocusMode();
                        else if (App.state.studySession.isActive) App.events.study.exit();
                        else if (activeViewId && activeViewId !== 'library') App.router.navigateTo('library');
                    }
                    if (e.altKey && e.key.toLowerCase() === 'a') {
                        e.preventDefault();
                        const coPilotToggle = document.getElementById('kash-copilot-toggle');
                        if (coPilotToggle && coPilotToggle.style.display !== 'none') {
                            App.coPilot.toggle();
                        }
                        return;
                    }
                    // ... (The rest of the function remains identical) ...
                    if (cmdKey && e.key.toLowerCase() === 'k') { e.preventDefault(); App.globalSearch.openSearch(); }
                    if (e.altKey && e.shiftKey && e.key.toLowerCase() === 'n') { e.preventDefault(); if (!document.getElementById('new-article-btn').disabled) App.events.createNewArticle(); }
                    if (cmdKey && e.key.toLowerCase() === 's') { if (App.state.currentMode === 'write') { e.preventDefault(); App.events.saveArticle(false); } }
                    if (e.altKey && e.key.toLowerCase() === 'o' && !cmdKey && !e.shiftKey) { const isWelcomeActive = document.getElementById('welcome-view')?.classList.contains('active'); const isLibraryActive = document.getElementById('library-view')?.classList.contains('active'); if (isWelcomeActive || isLibraryActive) { e.preventDefault(); App.events.selectDirectory(true); } }
                    if (e.key.toLowerCase() === 's' && !cmdKey && !e.altKey && !e.shiftKey && !isEditable) {
                        const isLibraryActive = document.getElementById('library-view')?.classList.contains('active');
                        const isFlashcardActive = document.getElementById('flashcard-view')?.classList.contains('active');
                        if (isLibraryActive) { e.preventDefault(); document.getElementById('search-input')?.focus(); document.getElementById('search-input')?.select(); }
                        else if (isFlashcardActive) { e.preventDefault(); document.getElementById('flashcard-search-input')?.focus(); document.getElementById('flashcard-search-input')?.select(); }
                    }
                    if (App.state.currentMode === 'read' && document.getElementById('article-view')?.classList.contains('active') && !document.body.classList.contains('pdf-viewer-active')) {
                        if (e.key.toLowerCase() === 'f' && !cmdKey && !e.altKey && !e.shiftKey && !isEditable) {
                            e.preventDefault();
                            App.events.toggleFocusMode();
                        }
                        if (e.key.toLowerCase() === 'c' && !cmdKey && !e.altKey && !e.shiftKey && !isEditable) {
                            e.preventDefault();
                            App.events.cycleReaderTheme();
                        }
                        if (e.key.toLowerCase() === 'e' && !cmdKey && !e.altKey && !e.shiftKey && !isEditable) {
                            e.preventDefault();
                            App.events.switchToMode('write');
                        }
                        if (e.key.toLowerCase() === 's' && !cmdKey && !e.altKey && !e.shiftKey && !isEditable) {
                            e.preventDefault();
                            const now = new Date().getTime();
                            if (now - App.state.lastHeartKeyPressTime < 400) { // Double-press detected
                                App.events.resetReadCount();
                                App.state.lastHeartKeyPressTime = 0; // Reset timer to prevent triple-press issues
                            } else { // Single-press
                                App.events.finishArticle();
                                App.state.lastHeartKeyPressTime = now;
                            }
                        }

                        // NEW: Laser Toggle (L) in Read Mode
                        if (e.key.toLowerCase() === 'l' && !isEditable && !isModalOpen && !cmdKey && !e.shiftKey) {
                            e.preventDefault();
                            App.events.toggleSharedLaser('read');
                            return;
                        }
                    }
                    if (App.state.studySession.isActive) App.events.study.handleKeyboard(e);
                },

                async selectDirectory(isChange = false) {
                    if ('showDirectoryPicker' in window) {
                        try {
                            const handle = await window.showDirectoryPicker();
                            const hasPermission = await App.storage.verifyPermission(handle);

                            if (hasPermission) {
                                const migrationResult = await App.services.migration.browserToFolder(handle);

                                if (migrationResult === 'error' || migrationResult === 'cancelled') {
                                    return;
                                }


                                this.transitionToLibrary(async () => {
                                    App.state.isInitialLoadComplete = false;
                                    App.state.isHydrated = false;
                                    App.state.articles = [];

                                    await App.settings.set('lastStorageMode', 'fileSystem');
                                    App.state.directoryHandle = handle;
                                    await App.indexedDB.setHandle('directory', handle);
                                    await App.util.requestDurableStorage();
                                    App.state.storageMode = 'fileSystem';

                                    await App.settings.load();
                                    App.ui.applyTheme(App.settings.get('theme'));

                                    await App.loadInitialData();
                                    App.router.navigateTo('library');

                                    App.ui.showToast(`Switched to Folder Mode: '${handle.name}' selected.`, { type: 'success' });
                                });
                            } else {
                                throw new Error("Permission was denied after selection.");
                            }
                        } catch (err) {
                            if (err.name !== 'AbortError') {
                                App.ui.showToast('Could not access the selected directory.', { type: 'error' });
                            }
                        }
                    } else {
                        App.ui.showToast('Select your note files to import.', 'info');
                        document.getElementById('mobile-import-input').click();
                    }
                },

                async requestStoredPermission() {
                    if (!App.state.directoryHandle) {
                        App.ui.showToast("No folder handle found. Please select a new folder.", { type: 'error' });
                        App.router.navigateTo('welcome', { permissionState: 'none' });
                        return;
                    }
                    try {
                        const permission = await App.state.directoryHandle.requestPermission({ mode: 'readwrite' });
                        if (permission === 'granted') {
                            window.location.reload();
                        } else {
                            App.ui.showToast("Permission was denied. Please select the folder again.", { type: 'error' });
                            App.router.navigateTo('welcome', { permissionState: 'denied' });
                        }
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.error("Error requesting permission:", err);
                            App.ui.showToast("Could not get permission for the folder.", { type: 'error' });
                        }
                    }
                },
                async createNewArticle() {
                    if (!App.license.isPremium() && App.state.articles.length >= App.config.sparkTierLimit) {
                        App.ui.showAscensionModal();
                        App.ui.showToast('Note limit reached. Go Premium for unlimited notes.', 'warning');
                        return;
                    }
                    // Create a temporary, in-memory article object without saving a file.
                    const tempArticle = {
                        id: 'temp_new_article', // A special, temporary ID
                        title: 'Untitled Article',
                        content: '<p><br></p>',
                        category: (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name,
                        readCount: 0,
                        readHistory: [],
                        tags: [],
                        flashcards: {},
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };
                    // Navigate to the editor, passing the temporary object directly.
                    App.router.navigateTo('article', { articleObject: tempArticle, mode: 'write' });
                },

                switchToMode(mode) { App.router.navigateTo('article', { id: App.state.activeArticleId, mode }); },

                toggleCanvasFocusMode() {
                    document.body.classList.toggle('canvas-focus-mode');
                    // Give the browser a moment to apply CSS changes before resizing
                    setTimeout(() => {
                        const activeViewId = App.router.getActiveView();
                        if (activeViewId === 'visual-map' && App.visualMap.triggerResize) {
                            App.visualMap.triggerResize();
                        } else if (activeViewId === 'mindmap' && App.mindMap.triggerResize) {
                            App.mindMap.triggerResize();
                        }
                    }, 100);
                },

                async saveArticle(options = {}) {
                    // --- OPTIMIZATION: Hash-based "Virtual Save" ---
                    const { content: newContent, switchToRead = false, isAutosave = false, force = false } = options;

                    let savingToast = null;
                    if (switchToRead) savingToast = App.ui.showToast("Saving...", { type: 'info', duration: 0 });

                    const id = App.state.activeArticleId;
                    if (!id) {
                        if (savingToast) App.ui.hideToast(savingToast);
                        return;
                    }

                    const titleInput = document.getElementById('article-title');
                    const contentDiv = document.getElementById('article-content');
                    if (!titleInput || !contentDiv) {
                        if (savingToast) App.ui.hideToast(savingToast);
                        if (!isAutosave) App.ui.showToast("Save failed. Editor not found.", { type: 'error' });
                        return;
                    }

                    const title = titleInput.value.trim();

                    // --- FIX: Handle Fullscreen Maps before getting content ---
                    const fullscreenMaps = Array.from(document.querySelectorAll('.nk-map-embed.is-viewport-fullscreen'));
                    const restoredMaps = [];

                    if (!newContent) {
                        fullscreenMaps.forEach(map => {
                            const placeholderId = map.dataset.placeholderId;
                            if (placeholderId) {
                                const placeholder = document.getElementById(placeholderId);
                                // Ensure placeholder is within the content we are saving
                                if (placeholder && contentDiv.contains(placeholder)) {
                                    placeholder.replaceWith(map);
                                    restoredMaps.push({ map, placeholder });
                                }
                            }
                        });
                    }

                    let content = newContent ?? contentDiv.innerHTML.trim();

                    // --- Restore Fullscreen Maps state (so user doesn't see them disappear) ---
                    restoredMaps.forEach(({ map, placeholder }) => {
                        map.replaceWith(placeholder);
                        document.body.appendChild(map);
                    });


                    // Prepare content for saving (normalization)
                    content = App.util.parseShortcuts(content);
                    content = App.contentTools.updateDataTagsInContent(content);

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = content;
                    App.util.cleanPlyrForSave(tempDiv);

                    tempDiv.querySelectorAll('.nk-map-embed.is-viewport-fullscreen').forEach(map => {
                        map.classList.remove('is-viewport-fullscreen');
                        map.style.zIndex = '';
                        delete map.dataset.placeholderId;
                    });
                    tempDiv.querySelectorAll('.nk-map-placeholder').forEach(ph => ph.remove());

                    // Get in-memory attachments to include in hash calculation
                    const articleInMemory = App.storage.getArticle(id) || {};
                    let attachments = articleInMemory.attachments || [];

                    // --- Fix: Hoist Category Logic so it's included in Hash ---
                    const defaultCategoryName = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                    let category = document.getElementById('category-selector')?.value;
                    if (!category && id !== 'temp_new_article') {
                        const existingArticle = App.storage.getArticle(id);
                        if (existingArticle) category = existingArticle.category;
                    }
                    category = category || defaultCategoryName;

                    // --- HASH CHECK ---
                    // Simple DJB2 hash for string content
                    const hashString = (str) => {
                        let hash = 5381;
                        for (let i = 0; i < str.length; i++) {
                            hash = ((hash << 5) + hash) + str.charCodeAt(i); /* hash * 33 + c */
                        }
                        return hash.toString();
                    };

                    // Include category in the hash!
                    const currentDataString = title + content + category + JSON.stringify(attachments);
                    const currentHash = hashString(currentDataString);

                    if (!force && !switchToRead && App.state.lastSavedHash === currentHash) {
                        if (!isAutosave) {
                            App.ui.showToast("No changes to save.", { type: 'info' });
                        } else {
                            console.log("Autosave skipped: content unchanged.");
                        }
                        return;
                    }

                    // Proceed with full save logic...

                    let attachmentsUpdated = false;

                    tempDiv.querySelectorAll('.pdf-attachment-pill[data-pdf-id]').forEach(pill => {
                        const attachmentId = pill.dataset.pdfId;
                        const nameSpan = pill.querySelector('.pdf-attachment-name');
                        const newName = nameSpan ? nameSpan.textContent.trim() : '';

                        const attachmentIndex = attachments.findIndex(att => att.id === attachmentId);

                        if (attachmentIndex > -1 && newName) {
                            const originalName = attachments[attachmentIndex].name;
                            const extension = originalName.slice(originalName.lastIndexOf('.'));
                            const newFullName = `${newName}${extension}`;

                            if (originalName !== newFullName) {
                                attachments[attachmentIndex].name = newFullName;
                                attachmentsUpdated = true;
                            }
                        }
                    });

                    const seenIds = new Set();
                    const snippetSelector = '[class*="highlight-"], [class*="text-"]';
                    tempDiv.querySelectorAll(snippetSelector).forEach(el => {
                        if (!el.id || seenIds.has(el.id)) {
                            el.id = `snip-${crypto.randomUUID().slice(0, 12)}`;
                        }
                        seenIds.add(el.id);
                    });
                    tempDiv.querySelectorAll('.rendered-tag').forEach(el => {
                        if (!el.id || seenIds.has(el.id)) {
                            el.id = `tag-snip-${crypto.randomUUID().slice(0, 12)}`;
                        }
                        seenIds.add(el.id);
                    });

                    content = tempDiv.innerHTML; // Re-read content after ID updates

                    const isContentEmpty = content === '' || content === '<p><br></p>' || contentDiv.textContent.trim() === '';
                    if (!title && isContentEmpty) {
                        if (!isAutosave) { App.ui.showToast("Cannot save an empty article.", { type: 'warning' }); }
                        return;
                    }

                    const handleSaveSuccess = async (savedArticle) => {
                        App.state.isArticleDirty = false;
                        App.state.lastSavedHash = currentHash; // UPDATE HASH

                        await App.contentTools.updateTagsIndex();
                        App.contentTools.buildDataCache();
                        App.commandPalette.state.fuse.links = null;

                        App.ui.updateArticleMetadata(content, savedArticle.createdAt);
                        if (switchToRead) {
                            if (savingToast) App.ui.hideToast(savingToast);
                            if (!isAutosave) App.ui.showToast('Saved!', { type: 'success' });
                            this.switchToMode('read');
                        } else if (!isAutosave) {
                            App.ui.showToast('Saved!', { type: 'success' });
                        }
                        if (App.dropbox.isReady() && App.settings.get('enableDropboxSync')) {
                            App.dropbox.syncChanges(true);
                        }
                    };

                    if (id === 'temp_new_article') {
                        const articleData = { title, content, category, attachments };
                        const newArticle = await App.storage.createArticle(articleData);
                        if (newArticle) {
                            App.state.activeArticleId = newArticle.id;
                            await handleSaveSuccess(newArticle);
                        }
                    } else {
                        const article = App.storage.getArticle(id);
                        const existingFlashcards = article.flashcards || {};
                        const newFlashcards = App.util.extractFlashcards(content, id, category, existingFlashcards);
                        const newTags = App.contentTools.extractTagsFromHTML(content);

                        const updates = { title, content, category, flashcards: newFlashcards, tags: newTags, attachments: attachments };

                        const result = await App.storage.updateArticle(id, updates);
                        if (result.success) {
                            await handleSaveSuccess(result.article);
                        }
                    }
                },

                async finishArticle() {
                    const id = App.state.activeArticleId;
                    if (!id) return;

                    const articleIndex = App.state.articles.findIndex(a => a.id === id);
                    if (articleIndex === -1) return;
                    const article = App.state.articles[articleIndex];
                    const newCount = (article.readCount || 0) + 1;
                    const newHistory = [...(article.readHistory || []), new Date().toISOString()];
                    const updatedArticle = { ...article, readCount: newCount, readHistory: newHistory };
                    App.state.articles[articleIndex] = updatedArticle;
                    App.ui.renderArticleControls(updatedArticle);
                    setTimeout(() => {
                        const heartButton = document.querySelector('.read-mode-controls [data-action="finishArticle"]');
                        if (heartButton) {
                            heartButton.classList.add('done-btn-animated');
                            heartButton.addEventListener('animationend', () => {
                                heartButton.classList.remove('done-btn-animated');
                            }, { once: true });
                        }
                    }, 50);
                    await App.storage.updateArticle(id, { readCount: newCount, readHistory: newHistory });
                },

                async resetReadCount() {
                    await App.storage.updateArticle(App.state.activeArticleId, { readCount: 0, readHistory: [] });
                    App.ui.showToast("Article progress reset.");
                    App.ui.renderArticleControls(App.storage.getArticle(App.state.activeArticleId));
                },

                deleteArticleWithConfirmation() {
                    const id = App.state.activeArticleId;
                    const article = App.storage.getArticle(id);
                    App.ui.showConfirmationModal({
                        title: 'Delete Article',
                        message: `Are you sure you want to delete "${article.title}"? This will be deleted from your folder and synced.`,
                        confirmText: 'Delete',
                        onConfirm: async () => {
                            await App.storage.deleteArticle(id);
                            App.ui.showToast('Article deleted.');

                            App.commandPalette.state.fuse.links = null;

                            App.router.navigateTo('library');
                            if (App.dropbox.isReady() && App.settings.get('enableDropboxSync')) {
                                App.dropbox.syncChanges(true);
                            }
                        }
                    });
                },

                handleWriteModeImageUpload(event) {
                    const file = event.target.files[0];
                    if (file) {
                        if (file.type.startsWith('image/')) {
                            App.services.image.processAndInsert(file);
                        } else {
                            App.ui.showToast('Please select an image file.', { type: 'info' });
                        }
                    }
                    event.target.value = '';
                },

                insertAccordionCard() {
                    const cardId = 'acc_' + crypto.randomUUID();
                    const contentId = 'acc-content-' + cardId;
                    const cardHTML = `
                    <div class="nk-accordion" data-state="closed" data-id="${cardId}" data-reversible="false">
                        <div class="nk-accordion-trigger" role="button" tabindex="0" aria-expanded="false" aria-controls="${contentId}">
                            <span class="nk-accordion-title" contenteditable="true" data-placeholder="Question..."></span>
                            <div class="nk-accordion-controls">
                                <button class="nk-accordion-control-btn nk-accordion-hint-btn" title="Add/Edit Hint">${App.util.icons.hint}</button>
                                <button class="nk-accordion-control-btn nk-accordion-reversible-toggle" title="Make Reversible">${App.util.icons.reversible}</button>
                                <svg class="nk-accordion-chevron" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"></polyline></svg>
                            </div>
                        </div>
                        <div id="${contentId}" class="nk-accordion-content" contenteditable="true" data-placeholder="Answer..."><p><br></p></div>
                    </div>`;
                    App.util.insertGuardianBlock(cardHTML); // Use the helper
                },

                handleSearchCommand(e) {
                    if (e.key !== 'Enter') return;
                    const command = e.target.value.trim().toLowerCase();

                    let commandExecuted = false;

                    if (command.startsWith('!')) {
                        e.preventDefault();
                        const action = command.substring(1);
                        switch (action) {
                            case 'task': App.hub.ui.showProductivityModal(); commandExecuted = true; break;
                            case 'stats': App.router.navigateTo('stats-dashboard'); commandExecuted = true; break;
                            case 'quiz': App.quiz.start(); commandExecuted = true; break;
                        }
                    }
                    else if (command.startsWith('%')) {
                        e.preventDefault();
                        const action = command.substring(1);

                        if (action === '+' || action === 'new') { App.events.createNewArticle(); commandExecuted = true; }
                        else if (action === 'study') { App.events.study.start(); commandExecuted = true; }
                        else if (action === 'flash' || action === 'flashcards') { App.router.navigateTo('flashcard'); commandExecuted = true; }
                        else {
                            const foundCategory = App.settings.get('userCategories').find(c => c.toLowerCase() === action || App.util.getCategoryDisplayName(c).toLowerCase() === action);
                            if (foundCategory) { App.router.navigateTo('category', foundCategory); commandExecuted = true; }
                        }
                    }

                    if (commandExecuted) e.target.value = '';
                },

                async handlePaste(e) {
                    e.preventDefault();
                    const clipboardData = e.clipboardData || window.clipboardData;

                    const imageFile = Array.from(clipboardData.items).find(item => item.kind === 'file' && item.type.startsWith('image/'));
                    if (imageFile) {
                        App.services.image.processAndInsert(imageFile.getAsFile());
                        return;
                    }

                    const pastedHTML = clipboardData.getData('text/html');
                    const pastedText = clipboardData.getData('text/plain');
                    const PASTE_THRESHOLD = 50000;
                    const shouldShowProgress = (pastedText && pastedText.length > PASTE_THRESHOLD) || (pastedHTML && pastedHTML.length > PASTE_THRESHOLD);

                    if (shouldShowProgress) {
                        App.ui.migrationScreen.show("Pasting Content");
                        App.ui.migrationScreen.update(10, "Analyzing clipboard...");
                    }

                    setTimeout(() => {
                        try {

                            if (pastedHTML) {
                                if (shouldShowProgress) App.ui.migrationScreen.update(50, "Formatting rich text...");

                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = App.util.sanitizeHTML(pastedHTML);
                                App.util.cleanPastedStyles(tempDiv);

                                tempDiv.querySelectorAll('.nk-accordion').forEach(accordion => {
                                    const newId = 'acc_' + crypto.randomUUID();
                                    const oldContentId = accordion.querySelector('.nk-accordion-trigger')?.getAttribute('aria-controls');
                                    const newContentId = 'acc-content-' + newId;
                                    accordion.dataset.id = newId;
                                    const trigger = accordion.querySelector('.nk-accordion-trigger');
                                    if (trigger) trigger.setAttribute('aria-controls', newContentId);
                                    const content = tempDiv.querySelector(`#${oldContentId}`);
                                    if (content) content.id = newContentId;
                                });

                                const finalHtml = tempDiv.innerHTML;
                                document.execCommand('insertHTML', false, finalHtml);

                                App.state.isArticleDirty = true;

                                if (shouldShowProgress) {
                                    App.ui.migrationScreen.update(100, "Done!");
                                    setTimeout(() => App.ui.migrationScreen.hide(), 200);
                                }
                                return;
                            }

                            if (pastedText) {
                                if (pastedText.length > PASTE_THRESHOLD) {
                                    this._insertLargeTextInChunks(pastedText);
                                } else {
                                    document.execCommand('insertHTML', false, App.util.textToHtml(pastedText));
                                    App.state.isArticleDirty = true;
                                    if (App.ui.migrationScreen) App.ui.migrationScreen.hide();
                                }
                                return;
                            }

                            if (App.ui.migrationScreen) App.ui.migrationScreen.hide();

                        } catch (err) {
                            console.error("Paste error:", err);
                            if (App.ui.migrationScreen) App.ui.migrationScreen.hide();
                            App.ui.showToast("Paste failed.", "error");
                        }
                    }, 50); // Slight delay to ensure popup renders
                },


                _insertLargeTextInChunks(text) {
                    const originalLength = text.length;
                    let remainingText = text;

                    App.ui.migrationScreen.show("Pasting Large Text");

                    const processNextChunk = () => {
                        if (App.ui.migrationScreen.state.isCancelled) {
                            App.ui.migrationScreen.hide();
                            App.ui.showToast("Paste cancelled.", "info");
                            return;
                        }
                        if (remainingText.length === 0) {
                            App.ui.migrationScreen.update(100, "Finalizing...");
                            setTimeout(() => {
                                App.ui.migrationScreen.hide();
                                App.ui.showToast('Paste complete!', { type: 'success' });
                                App.state.isArticleDirty = true;
                            }, 200); // Small delay to let user see 100%
                            return;
                        }

                        const progress = Math.round((1 - (remainingText.length / originalLength)) * 100);
                        App.ui.migrationScreen.update(progress, `Processing... ${progress}%`);

                        const chunkSize = 8000;
                        let chunk = remainingText.substring(0, chunkSize);

                        let lastNewline = chunk.lastIndexOf('\n');
                        if (lastNewline > 0 && remainingText.length > chunkSize) {
                            chunk = chunk.substring(0, lastNewline + 1);
                        }

                        const htmlChunk = App.util.textToHtml(chunk);
                        if (htmlChunk.trim() !== '') {
                            document.execCommand('insertHTML', false, htmlChunk);
                        }

                        remainingText = remainingText.substring(chunk.length);

                        setTimeout(processNextChunk, 0);
                    };

                    processNextChunk();
                },

                handleDragOver(e) { e.preventDefault(); e.stopPropagation(); e.target.closest('#article-content').classList.add('drag-over'); },
                handleDragLeave(e) { e.preventDefault(); e.stopPropagation(); e.target.closest('#article-content').classList.remove('drag-over'); },

                async handleImageDrop(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.target.closest('#article-content').classList.remove('drag-over');

                    // This part handles files dragged from your local computer and works correctly.
                    const files = e.dataTransfer.files;
                    if (files && files.length > 0) {
                        for (const file of files) {
                            if (file.type.startsWith('image/')) {
                                App.services.image.processAndInsert(file);
                            }
                        }
                        return; // Exit after handling local files
                    }

                    // --- NEW ROBUST LOGIC for images dragged from other websites ---
                    const html = e.dataTransfer.getData('text/html');
                    if (html) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = html;
                        const img = tempDiv.querySelector('img');

                        if (img && img.src) {
                            // Case 1: The image source is a data URL (very common).
                            if (img.src.startsWith('data:')) {
                                const blob = App.util.dataURLtoBlob(img.src);
                                if (blob) {
                                    App.services.image.processAndInsert(blob);
                                } else {
                                    App.ui.showToast('Could not read dragged image data.', { type: 'error' });
                                }
                            }
                            // Case 2: The image source is a regular web URL.
                            else {
                                try {
                                    App.ui.showToast('Downloading image...', { type: 'info' });
                                    const response = await fetch(img.src);
                                    if (!response.ok) throw new Error('Network response was not ok.');
                                    const blob = await response.blob();
                                    App.services.image.processAndInsert(blob);
                                    App.ui.showToast('Image inserted!', { type: 'success' });
                                } catch (error) {
                                    console.error('Error fetching dragged image:', error);
                                    App.ui.showToast('Website blocked action (Copy/Download Image and Paste )', { type: 'error' });
                                }
                            }
                        }
                    }
                },

                handleFocusIn(e) {
                    const target = e.target;
                    const imageContainer = target.closest('.image-container');
                    if (!imageContainer) App.events.deselectImage();
                },

                async handleContentClick(e) {
                    const target = e.target;
                    const isWriteMode = App.state.currentMode === 'write';

                    // --- NEW LOGIC FOR FOCUS/STAGE MODE ACCORDIONS ---
                    const focusOverlay = target.closest('.focus-mode-overlay');
                    if (focusOverlay) {
                        const accordionTrigger = target.closest('.nk-accordion-trigger');
                        if (accordionTrigger) {
                            e.preventDefault();
                            e.stopPropagation();
                            const accordion = accordionTrigger.closest('.nk-accordion');
                            if (accordion) {
                                const isOpening = accordion.dataset.state === 'closed';
                                accordion.dataset.state = isOpening ? 'open' : 'closed';
                                accordionTrigger.setAttribute('aria-expanded', String(isOpening));
                            }
                            return; // Stop further processing in this case
                        }
                        // --- END NEW LOGIC ---

                        const session = App.state.focusSession;
                        if (session.isCinematicActive && session.isStageMode) {
                            const wordRevealed = App.events.typewriter.revealNext();
                            if (wordRevealed) {
                                e.preventDefault();
                                e.stopPropagation();
                                return;
                            }
                        }

                        const mcqBlock = target.closest('.nk-mcq-block');
                        if (mcqBlock) {
                            App.events.handleMcqAnswer(e, false);
                        }
                        return;
                    }

                    // Handle Visual Flashcard (Image Occlusion) flip or edit
                    const visualFlashcard = target.closest('.nk-visual-flashcard');
                    if (visualFlashcard) {
                        // Check if edit button was clicked
                        const editBtn = target.closest('.nk-vfc-edit-btn');
                        if (editBtn) {
                            e.preventDefault();
                            e.stopPropagation();
                            // Open whiteboard for editing this VFC using existing reopenFromEmbed
                            App.whiteboard.reopenFromEmbed(visualFlashcard);
                            return;
                        }

                        if (!isWriteMode) {
                            // In read mode: flip the card
                            e.preventDefault();
                            e.stopPropagation();
                            visualFlashcard.classList.toggle('flipped');
                            return;
                        } else {
                            // In write mode: select the flashcard for resizing
                            App.events.selectImage(visualFlashcard);
                            e.stopPropagation();
                            return;
                        }
                    }

                    if (!isWriteMode) {
                        const imageContainer = e.target.closest('.image-container');
                        if (imageContainer) {
                            App.events.selectImage(imageContainer);
                            e.stopPropagation();
                        } else if (App.state.selectedImageContainer && !e.target.closest('#image-toolbar')) {
                            App.events.deselectImage();
                        }
                    }

                    const pdfPill = target.closest('.pdf-attachment-pill');
                    if (pdfPill && !isWriteMode) {
                        e.preventDefault();
                        e.stopPropagation();
                        const attachmentId = pdfPill.dataset.pdfId;
                        if (attachmentId) {
                            App.pdf.viewer.open(attachmentId);
                        }
                        return;
                    }

                    const audioPlayer = target.closest('.nk-audio-player');
                    const transcribeBtn = target.closest('.nk-transcribe-container .btn');

                    if (audioPlayer) {
                        e.preventDefault();
                        const playPauseBtn = target.closest('.audio-play-pause-btn');
                        const progressBar = target.closest('.audio-progress-bar');
                        const speedBtn = target.closest('.audio-speed-btn');


                        if (playPauseBtn) {
                            App.audio.handlePlayPause(playPauseBtn);
                        } else if (progressBar) {
                            const audio = audioPlayer.querySelector('audio');
                            if (audio) audio.currentTime = progressBar.value;
                        } else if (speedBtn) {
                            App.audio.handleSpeedChange(speedBtn);
                        }
                        return;
                    } else if (transcribeBtn) {
                        e.preventDefault();
                        if (App.license.isPremium()) {
                            App.audio.transcribeAudioBlock(transcribeBtn);
                        } else {
                            App.ui.showAscensionModal();
                        }
                        return;
                    }

                    const addTileBtn = target.closest('.deck-add-tile-btn');
                    if (addTileBtn) {
                        e.preventDefault();
                        const solidColors = App.commandPalette.state.textileColors.filter(c => !isNaN(c));
                        const randomColor = solidColors[Math.floor(Math.random() * solidColors.length)];
                        const newTileHTML = `
                    <div class="nk-text-tile color-${randomColor}" contenteditable="false" data-color="${randomColor}">
                        <span class="nk-text-tile-icon"></span>
                        <div class="nk-text-tile-color-cycler" title="Cycle Color"><i class="fa-solid fa-palette fa-xs"></i></div>
                        <div class="nk-text-tile-content" contenteditable="true" data-placeholder="New tile..."></div>
                    </div>`;
                        addTileBtn.insertAdjacentHTML('beforebegin', newTileHTML);
                        App.state.isArticleDirty = true;
                        return;
                    }
                    const layoutToggleBtn = target.closest('.deck-layout-toggle');
                    if (layoutToggleBtn) {
                        e.preventDefault();
                        const deck = layoutToggleBtn.closest('.nk-textile-deck');
                        deck.classList.toggle('layout-stack');
                        const isStack = deck.classList.contains('layout-stack');
                        layoutToggleBtn.innerHTML = isStack ? '<i class="fa-solid fa-grip"></i>' : '<i class="fa-solid fa-table-cells"></i>';
                        layoutToggleBtn.title = isStack ? 'Switch to Grid' : 'Switch to Stack';
                        if (isWriteMode) App.state.isArticleDirty = true;
                        return;
                    }

                    const textTile = target.closest('.nk-text-tile');
                    if (textTile) {
                        if (textTile.textContent.trim() === '') return;

                        if (App.state.currentMode === 'read') {
                            e.preventDefault();
                            textTile.classList.toggle('faded');
                        } else if (isWriteMode) {
                            const colorCycler = target.closest('.nk-text-tile-color-cycler');
                            if (colorCycler) {
                                e.preventDefault();
                                const colors = App.commandPalette.state.textileColors;
                                const currentColor = textTile.dataset.color || '1';
                                const currentIndex = colors.indexOf(currentColor);
                                const nextColor = colors[(currentIndex + 1) % colors.length];
                                textTile.classList.remove(`color-${currentColor}`);
                                textTile.classList.add(`color-${nextColor}`);
                                textTile.dataset.color = nextColor;
                                App.state.isArticleDirty = true;
                            }
                        }
                        return;
                    }
                    const mcqBlock = target.closest('.nk-mcq-block');
                    if (mcqBlock) {
                        if (App.state.currentMode === 'read') {
                            App.events.handleMcqAnswer(e, false);
                        }
                        else if (App.state.currentMode === 'write') {
                            // Handle delete block button
                            const deleteBlockBtn = target.closest('.nk-mcq-delete-block');
                            if (deleteBlockBtn) {
                                e.preventDefault();
                                const newP = document.createElement('p');
                                newP.innerHTML = '<br>';
                                mcqBlock.parentNode.replaceChild(newP, mcqBlock);
                                App.util.placeCursor(newP);
                                App.state.isArticleDirty = true;
                                return;
                            }

                            // Handle copy block button
                            const copyBlockBtn = target.closest('.nk-mcq-copy-block');
                            if (copyBlockBtn) {
                                e.preventDefault();

                                // Create a clean clone for clipboard
                                const clonedBlock = mcqBlock.cloneNode(true);
                                clonedBlock.removeAttribute('id'); // Remove ID to prevent duplicates on paste
                                clonedBlock.removeAttribute('data-answered');

                                // Reset option states
                                clonedBlock.querySelectorAll('.nk-mcq-option').forEach(opt => {
                                    opt.classList.remove('correct', 'incorrect');
                                });

                                const htmlContent = clonedBlock.outerHTML;
                                const textContent = clonedBlock.innerText;

                                try {
                                    // Write HTML to clipboard for rich paste support
                                    const blobHtml = new Blob([htmlContent], { type: 'text/html' });
                                    const blobText = new Blob([textContent], { type: 'text/plain' });
                                    const data = [new ClipboardItem({
                                        'text/html': blobHtml,
                                        'text/plain': blobText
                                    })];

                                    navigator.clipboard.write(data).then(() => {
                                        App.ui.showToast('MCQ copied to clipboard!', { type: 'success' });
                                    }).catch(err => {
                                        console.warn("Clipboard HTML write failed, falling back to text", err);
                                        navigator.clipboard.writeText(htmlContent); // Fallback
                                        App.ui.showToast('MCQ HTML copied!', { type: 'success' });
                                    });
                                } catch (err) {
                                    console.error("Clipboard access error", err);
                                    App.ui.showToast('Failed to copy MCQ.', { type: 'error' });
                                }
                                return;
                            }

                            const addBtn = target.closest('.nk-mcq-add-option');
                            if (addBtn) {
                                e.preventDefault();
                                const optionsContainer = mcqBlock.querySelector('.nk-mcq-options');
                                if (optionsContainer.children.length >= 6) {
                                    App.ui.showToast("Maximum of 6 options reached.", { type: 'warning' });
                                    return;
                                }
                                const newOption = document.createElement('div');
                                newOption.className = 'nk-mcq-option';
                                newOption.dataset.isCorrect = 'false';
                                newOption.innerHTML = `<div class="nk-mcq-option-radio"></div><div class="nk-mcq-option-text" contenteditable="true" data-placeholder="New Option"></div><button class="nk-mcq-delete-option" title="Delete Option">&times;</button>`;
                                optionsContainer.appendChild(newOption);
                                App.state.isArticleDirty = true;
                            } else {
                                const optionDiv = target.closest('.nk-mcq-option');
                                if (optionDiv) {
                                    e.preventDefault();
                                    const deleteBtn = target.closest('.nk-mcq-delete-option');
                                    const radioBtn = target.closest('.nk-mcq-option-radio');
                                    if (deleteBtn) {
                                        if (mcqBlock.querySelectorAll('.nk-mcq-option').length > 2) {
                                            optionDiv.remove();
                                            App.state.isArticleDirty = true;
                                        } else {
                                            App.ui.showToast("An MCQ must have at least two options.", { type: 'warning' });
                                        }
                                    } else if (radioBtn) {
                                        mcqBlock.querySelectorAll('.nk-mcq-option').forEach(opt => opt.dataset.isCorrect = 'false');
                                        optionDiv.dataset.isCorrect = 'true';
                                        App.state.isArticleDirty = true;
                                    }
                                }
                            }
                        }
                        return;
                    }
                    const accordionTrigger = target.closest('.nk-accordion-trigger');
                    const tagSuggestion = target.closest('.tag-suggestion');
                    const checkboxBox = target.closest('.nk-checkbox-box');
                    const timelineAddButton = target.closest('.nk-timeline-add button');
                    if (accordionTrigger) {
                        const accordion = accordionTrigger.closest('.nk-accordion');
                        const reversibleToggle = target.closest('.nk-accordion-reversible-toggle');
                        const hintBtn = target.closest('.nk-accordion-hint-btn');
                        if (reversibleToggle && isWriteMode) {
                            e.preventDefault();
                            const isReversible = accordion.dataset.reversible === 'true';
                            accordion.dataset.reversible = String(!isReversible);
                            reversibleToggle.classList.toggle('active', !isReversible);
                            App.state.isArticleDirty = true;
                        } else if (hintBtn) {
                            e.preventDefault();
                            let hintEditor = accordion.querySelector('.nk-accordion-hint-editor');
                            if (hintEditor) {
                                const isHidden = hintEditor.style.display === 'none';
                                hintEditor.style.display = isHidden ? 'block' : 'none';
                            } else if (isWriteMode) {
                                hintEditor = document.createElement('div');
                                hintEditor.className = 'nk-accordion-hint-editor';
                                const hintContent = document.createElement('div');
                                hintContent.className = 'nk-accordion-hint-content';
                                hintContent.contentEditable = true;
                                hintContent.dataset.placeholder = 'Type your hint here...';
                                hintEditor.appendChild(hintContent);
                                accordion.appendChild(hintEditor);
                                hintContent.focus();
                            }
                            if (isWriteMode) App.state.isArticleDirty = true;
                        } else {
                            accordion.dataset.state = accordion.dataset.state === 'closed' ? 'open' : 'closed';
                            accordionTrigger.setAttribute('aria-expanded', accordion.dataset.state !== 'closed');
                        }
                        return;
                    }
                    if (tagSuggestion) {
                        clearTimeout(App.state.suggestionTimeout);
                        App.contentTools.tagSelection(tagSuggestion);
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv) return;
                        const newContent = contentDiv.innerHTML;
                        await App.events.saveArticle({ content: newContent });
                        App.contentTools.autoSuggestTags(contentDiv);
                        return;
                    }
                    if (checkboxBox) {
                        const wrapper = checkboxBox.closest('.nk-checkbox-wrapper');
                        // Allow interactivity in both write AND read mode
                        if (wrapper && (App.state.currentMode === 'write' || App.state.currentMode === 'read')) {
                            const isChecked = wrapper.getAttribute('data-checked') === 'true';
                            wrapper.setAttribute('data-checked', String(!isChecked));

                            // In write mode, just mark dirty. In read mode, we might need to save explicitly or ensure dirty state is picked up.
                            App.state.isArticleDirty = true;

                            if (App.state.currentMode === 'read') {
                                // In read mode, we want the interaction to feel responsive and save.
                                // Since we modified the DOM directly, we should trigger a save if we are viewing the active article.
                                const contentDiv = document.getElementById('article-content');
                                if (contentDiv) {
                                    // Debounce saving or save immediately depending on preference. 
                                    // For checkboxes, saving immediately (or triggering autosave logic) is good.
                                    // We'll rely on the dirty flag pickup if 'read' mode supports autosave, 
                                    // otherwise we force a save after a short delay to batch clicks.
                                    clearTimeout(this._checkboxSaveTimeout);
                                    this._checkboxSaveTimeout = setTimeout(() => {
                                        const currentContent = contentDiv.innerHTML;
                                        App.events.saveArticle({ content: currentContent }, true); // true for silent save
                                    }, 500);
                                }
                            }
                        }
                        return;
                    }
                    if (timelineAddButton) {
                        const timelineBlock = timelineAddButton.closest('.nk-timeline-block');
                        if (timelineBlock) {
                            const newEntry = document.createElement('div');
                            newEntry.className = 'nk-timeline-entry';
                            newEntry.innerHTML = `<div class="nk-timeline-content"><div class="nk-timeline-date" contenteditable="true">New Date...</div><div class="nk-timeline-title" contenteditable="true">New Event...</div></div>`;
                            timelineBlock.querySelector('.nk-timeline-add').insertAdjacentElement('beforebegin', newEntry);
                            const newDateEl = newEntry.querySelector('.nk-timeline-date');
                            if (newDateEl) { App.util.placeCursor(newDateEl); window.getSelection().selectAllChildren(newDateEl); }
                        }
                        return;
                    }
                    if (target.tagName === 'IMG') {
                        const container = target.closest('.image-container');
                        if (container) App.events.selectImage(container);
                    } else if (!target.closest('.image-container')) {
                        App.events.deselectImage();
                    }
                },

                handleSelection() {
                    // Use a small timeout to let the browser finalize the selection
                    setTimeout(() => {
                        const selection = window.getSelection();
                        if (!selection || selection.isCollapsed || selection.rangeCount === 0) {
                            // If selection is lost or collapsed, hide all toolbars
                            App.ui.hideSelectionToolbar();
                            App.ui.aiMagic.hide();
                            return;
                        }

                        const range = selection.getRangeAt(0);
                        const container = range.commonAncestorContainer;
                        const parentElement = container.nodeType === 3 ? container.parentNode : container;

                        // Ensure the selection is within our main editor
                        const editor = document.getElementById('article-content');
                        if (!editor || !editor.contains(parentElement) || !editor.isContentEditable) {
                            return;
                        }

                        // Check if the selection is purely whitespace
                        if (selection.toString().trim() === '') {
                            App.ui.hideSelectionToolbar();
                            App.ui.aiMagic.hide();
                            return;
                        }

                        // Show the standard formatting toolbar
                        App.ui.showSelectionToolbar(range);

                        // Show our new AI Magic Toolbox
                        App.ui.aiMagic.show(range);

                    }, 10);
                },

                applyFormatting(type, value) {
                    const selection = window.getSelection();
                    if (!selection || !selection.rangeCount || selection.isCollapsed) return false; // Return false on failure
                    let range = selection.getRangeAt(0);
                    const container = range.commonAncestorContainer;
                    const parentElement = container.nodeType === 3 ? container.parentNode : container;

                    if (parentElement.closest('#pdf-text-view-content')) {
                        const text = selection.toString().trim();
                        if (text && type === 'class' && value.startsWith('highlight-')) {
                            App.pdf.highlights.add(text, value);
                        }
                        return true; // Assume success for PDF context
                    }

                    if (!parentElement || !parentElement.closest('#article-content')) return false; // Return false on failure

                    if (type === 'cloze') {
                        const paragraph = parentElement.closest('p, div, li, h1, h2, h3, h4, h5, h6, blockquote, td, th');
                        if (!paragraph) { App.ui.showToast("Cloze can only be created within a block of text.", { type: 'warning' }); return false; }

                        const existingClozes = (paragraph.innerHTML.match(/{{c\d+::/g) || []).length;

                        const range = selection.getRangeAt(0);
                        const fragment = range.cloneContents();
                        const tempDiv = document.createElement('div');
                        tempDiv.appendChild(fragment);
                        if (tempDiv.children.length === 0) {
                            const parentNode = range.commonAncestorContainer.nodeType === 3
                                ? range.commonAncestorContainer.parentElement
                                : range.commonAncestorContainer;
                            if (parentNode && (parentNode.style.color || parentNode.classList.length > 0)) {
                                const wrapper = document.createElement('span');
                                if (parentNode.style.color) wrapper.style.color = parentNode.style.color;
                                if (parentNode.style.backgroundColor) wrapper.style.backgroundColor = parentNode.style.backgroundColor;
                                if (parentNode.className) wrapper.className = parentNode.className;
                                if (wrapper.style.length > 0 || wrapper.className !== '') {
                                    wrapper.innerHTML = tempDiv.innerHTML;
                                    tempDiv.innerHTML = '';
                                    tempDiv.appendChild(wrapper);
                                }
                            }
                        }
                        const selectedHTML = tempDiv.innerHTML;
                        document.execCommand('insertHTML', false, `{{c${existingClozes + 1}::${selectedHTML}}}`);
                    } else {
                        document.execCommand('styleWithCSS', false, true);
                        const span = document.createElement('span');
                        span.className = value;
                        if (App.config.highlightClasses.includes(value) || App.config.textClasses.includes(value)) {
                            span.id = `snip-${crypto.randomUUID().slice(0, 12)}`;
                        }
                        try {
                            span.appendChild(range.extractContents());
                            range.insertNode(span);
                        } catch (e) { App.ui.showToast("Could not apply formatting.", { type: 'error' }); console.error("Formatting error:", e); return false; }
                        document.execCommand('styleWithCSS', false, false);
                    }
                    selection.collapseToEnd();
                    App.ui.hideSelectionToolbar();
                    return true; // Return true on success
                },


                cycleColorFormatting() {
                    let currentIndex = App.settings.get('colorCycleIndex');
                    this.applyFormatting('class', App.config.colorCycle[currentIndex]);
                    App.settings.set('colorCycleIndex', (currentIndex + 1) % App.config.colorCycle.length);
                },
                async removeFormatting() {
                    const selection = window.getSelection();
                    if (!selection || !selection.rangeCount || selection.isCollapsed) {
                        App.ui.hideSelectionToolbar();
                        return;
                    }

                    const range = selection.getRangeAt(0);
                    const elementsToUnwrap = new Set();
                    const formattingSelector = 'span[class*="highlight-"], span[class*="text-"], b, i, u, strong, em, del, .rendered-tag';

                    // 1. Check Ancestors: If selection is inside a formatted element
                    const checkAncestors = (node) => {
                        let curr = node.nodeType === 3 ? node.parentElement : node;
                        // Walk up until we hit a block container or the editor root
                        while (curr && curr.id !== 'article-content' && !curr.matches('p, div, li, h1, h2, h3, h4, h5, h6, blockquote, td, th, section, main, article')) {
                            if (curr.matches(formattingSelector)) {
                                elementsToUnwrap.add(curr);
                            }
                            curr = curr.parentElement;
                        }
                    };

                    checkAncestors(range.startContainer);
                    checkAncestors(range.endContainer);

                    // 2. Check Intersecting Nodes: If selection covers/intersects formatted elements
                    let safeAncestor = range.commonAncestorContainer;
                    if (safeAncestor.nodeType === 3) safeAncestor = safeAncestor.parentElement;

                    if (safeAncestor) {
                        const candidates = safeAncestor.querySelectorAll(formattingSelector);
                        candidates.forEach(el => {
                            if (selection.containsNode(el, true)) {
                                elementsToUnwrap.add(el);
                            }
                        });
                    }

                    if (elementsToUnwrap.size > 0) {
                        elementsToUnwrap.forEach(el => {
                            if (document.body.contains(el)) {
                                App.util.unwrapNode(el);
                            }
                        });
                        if (safeAncestor) safeAncestor.normalize();
                    } else {
                        // Fallback to native
                        document.execCommand('removeFormat', false, null);
                    }

                    App.state.isArticleDirty = true;
                    App.ui.hideSelectionToolbar();
                },


                handleWriterShortcuts(e) {
                    const selection = window.getSelection();
                    if (!selection || !selection.rangeCount) return;
                    const range = selection.getRangeAt(0);

                    const cmdKey = App.util.getCommandKey() === 'Cmd' ? e.metaKey : e.ctrlKey;

                    // Enter key handler for Collapsible Headings
                    if (e.key === 'Enter') {
                        const focusNode = selection.focusNode;
                        const element = focusNode.nodeType === 3 ? focusNode.parentElement : focusNode;

                        // Check if we are inside a collapsible heading
                        const collapsibleHeading = element.closest('.collapsible-heading');

                        if (collapsibleHeading) {
                            e.preventDefault();

                            // Create new paragraph
                            const p = document.createElement('p');
                            p.innerHTML = '<br>';

                            // Insert after the heading
                            if (collapsibleHeading.nextSibling) {
                                collapsibleHeading.parentNode.insertBefore(p, collapsibleHeading.nextSibling);
                            } else {
                                collapsibleHeading.parentNode.appendChild(p);
                            }

                            // Move cursor to the new paragraph
                            const newRange = document.createRange();
                            newRange.setStart(p, 0);
                            newRange.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(newRange);

                            App.state.isArticleDirty = true;
                            return;
                        }
                    }

                    // Tab key handler for list indentation (industry standard behavior)
                    if (e.key === 'Tab') {
                        const focusNode = selection.focusNode;
                        const listItem = focusNode?.nodeType === 3
                            ? focusNode.parentElement?.closest('li')
                            : focusNode?.closest('li');

                        // Case 1: Inside a list item - handle bullet nesting
                        if (listItem) {
                            e.preventDefault();

                            if (e.shiftKey) {
                                // Shift+Tab: Outdent (decrease nesting)
                                document.execCommand('outdent', false, null);
                            } else {
                                // Tab: Indent (increase nesting)
                                document.execCommand('indent', false, null);
                            }
                            App.state.isArticleDirty = true;
                            return;
                        }

                        // Case 2: Standard Paragraph Indentation (User Request)
                        const container = range.commonAncestorContainer;
                        const parentElement = container.nodeType === 3 ? container.parentNode : container;
                        const blockElement = parentElement.closest('p, div, h1, h2, h3, h4, h5, h6, blockquote, pre');

                        if (blockElement && blockElement.closest('#article-content')) {
                            e.preventDefault();

                            const currentMargin = parseInt(window.getComputedStyle(blockElement).marginLeft) || 0;
                            const indentSize = 40; // 40px indent per level

                            if (e.shiftKey) {
                                // Shift+Tab: Outdent (decrease margin)
                                const newMargin = Math.max(0, currentMargin - indentSize);
                                blockElement.style.marginLeft = newMargin > 0 ? `${newMargin}px` : '';
                            } else {
                                // Tab: Indent (increase margin)
                                blockElement.style.marginLeft = `${currentMargin + indentSize}px`;
                            }
                            App.state.isArticleDirty = true;
                            return;
                        }
                    }

                    if (cmdKey && e.key.toLowerCase() === 'j') {
                        e.preventDefault();
                        App.commandPalette.open(range);
                        return;
                    }

                    if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && selection.isCollapsed) {
                        const container = range.startContainer;
                        const tileContent = container.nodeType === 1 ? container.closest('.nk-text-tile-content') : container.parentElement.closest('.nk-text-tile-content');

                        if (tileContent) {
                            const textLength = tileContent.textContent.length;
                            const atStart = range.startOffset === 0;
                            const atEnd = range.startOffset === textLength;

                            if (e.key === 'ArrowLeft' && atStart) {
                                const tile = tileContent.closest('.nk-text-tile');
                                if (tile) { e.preventDefault(); range.setStartBefore(tile); range.collapse(true); selection.removeAllRanges(); selection.addRange(range); return; }
                            } else if (e.key === 'ArrowRight' && atEnd) {
                                const tile = tileContent.closest('.nk-text-tile');
                                if (tile) { e.preventDefault(); range.setStartAfter(tile); range.collapse(true); selection.removeAllRanges(); selection.addRange(range); return; }
                            }
                        }
                    }

                    // --- DEFINITIVE FIX FOR DELETION & UNDO/REDO ---
                    if (e.key === 'Backspace' && selection.isCollapsed) {
                        // NEW: Delete empty textile on backspace (like bullet points/blockquotes)
                        const tileContent = selection.focusNode?.parentElement?.closest('.nk-text-tile-content') ||
                            (selection.focusNode?.nodeType === 1 && selection.focusNode.closest('.nk-text-tile-content'));
                        if (tileContent && tileContent.textContent.trim() === '' && selection.focusOffset === 0) {
                            e.preventDefault();
                            const tile = tileContent.closest('.nk-text-tile');
                            if (tile) {
                                const newP = document.createElement('p');
                                newP.innerHTML = '<br>';
                                tile.parentNode.replaceChild(newP, tile);
                                App.util.placeCursor(newP);
                                App.state.isArticleDirty = true;
                            }
                            return;
                        }

                        // Check for deleting an empty accordion title first
                        const accordion = selection.focusNode.parentElement?.closest('.nk-accordion');
                        const title = accordion?.querySelector('.nk-accordion-title');
                        if (accordion && title && title.contains(selection.focusNode) && selection.focusOffset === 0 && title.textContent.trim() === '') {
                            e.preventDefault(); const newP = document.createElement('p'); newP.innerHTML = '<br>'; accordion.parentNode.replaceChild(newP, accordion); App.util.placeCursor(newP); return;
                        }

                        // Unified Deletion for ALL custom blocks
                        if (range.startOffset === 0) {
                            const container = range.startContainer;
                            const currentBlock = (container.nodeType === 3 ? container.parentElement : container).closest('p, li, h1, h2, h3, h4, h5, h6, div');

                            if (currentBlock) {
                                const elementToDelete = currentBlock.previousElementSibling;
                                // This selector now covers ALL complex, non-editable blocks
                                const customBlockSelector = '.nk-mcq-block, .nk-timeline-block, .nk-textile-deck, .chart-container, .nk-accordion';

                                if (elementToDelete && elementToDelete.matches(customBlockSelector)) {
                                    e.preventDefault();

                                    const sel = window.getSelection();
                                    const newRange = document.createRange();
                                    newRange.selectNode(elementToDelete);
                                    sel.removeAllRanges();
                                    sel.addRange(newRange);
                                    document.execCommand('delete', false, null);

                                    return; // Deletion handled, stop further processing.
                                }
                            }
                        }
                    }

                    if (App.commandPalette.state.isOpen) {
                        if (['ArrowUp', 'ArrowDown', 'Enter', 'Escape', 'Backspace', '/'].includes(e.key)) {
                            e.preventDefault(); e.stopPropagation();
                        }
                        return;
                    }

                    if (e.key === '/' && selection.isCollapsed) {
                        e.preventDefault();
                        App.commandPalette.open(range);
                        return;
                    }

                    if (e.key === 'Enter') {
                        const focusNode = selection.focusNode;
                        const checkboxWrapper = focusNode?.parentElement.closest('.nk-checkbox-wrapper');
                        if (checkboxWrapper) {
                            e.preventDefault();
                            const checkboxText = checkboxWrapper.querySelector('.nk-checkbox-text');
                            if (checkboxText && checkboxText.textContent.trim() === '') {
                                const newP = document.createElement('p'); newP.innerHTML = '<br>';
                                checkboxWrapper.insertAdjacentElement('afterend', newP); checkboxWrapper.remove(); App.util.placeCursor(newP);
                            } else {
                                const newCheckboxHTML = `<div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text"><br></span></div>`;
                                checkboxWrapper.insertAdjacentHTML('afterend', newCheckboxHTML);
                                const newCheckbox = checkboxWrapper.nextElementSibling; if (newCheckbox) App.util.placeCursor(newCheckbox.querySelector('.nk-checkbox-text'));
                            }
                            App.state.isArticleDirty = true; return;
                        }
                    }

                    if (cmdKey && e.shiftKey) {
                        let shortcutApplied = true;
                        switch (e.key.toLowerCase()) {
                            case 't': App.contentTools.tagSelection(); break; case 'f': App.events.applyFormatting('cloze'); break; case '1': App.events.cycleColorFormatting(); break;
                            case '2': App.events.applyFormatting('class', 'highlight-1'); break; case '3': App.events.applyFormatting('class', 'highlight-2'); break; case '4': App.events.applyFormatting('class', 'highlight-3'); break;
                            case '5': App.events.applyFormatting('class', 'highlight-4'); break; case '6': App.events.applyFormatting('class', 'highlight-5'); break; case '7': App.events.applyFormatting('class', 'highlight-6'); break;
                            case '8': App.events.applyFormatting('class', 'text-green'); break; case '9': App.events.applyFormatting('class', 'text-red'); break; case '0': App.events.applyFormatting('class', 'text-blue'); break; case '-': App.events.applyFormatting('class', 'text-magenta'); break;
                            default: shortcutApplied = false;
                        }
                        if (shortcutApplied) { e.preventDefault(); return; }
                    }

                    if (cmdKey && (e.key.toLowerCase() === 'b' || e.key.toLowerCase() === 'i' || e.key.toLowerCase() === 'u')) {
                        e.preventDefault();
                        const command = { 'b': 'bold', 'i': 'italic', 'u': 'underline' }[e.key.toLowerCase()];
                        document.execCommand(command);
                        return;
                    }

                    if (!range || !range.startContainer) return;

                    if (e.key === 'Enter') {
                        const container = range.commonAncestorContainer;
                        const parentElement = container.nodeType === 3 ? container.parentNode : container;
                        const blockToExit = parentElement.closest('blockquote, li');
                        if (blockToExit && parentElement.textContent.trim() === '') {
                            e.preventDefault();
                            document.execCommand('outdent', false, null);
                            return;
                        }
                    }

                    const textNode = range.startContainer;
                    if (e.key === 'Enter' && textNode.nodeType === 3 && textNode.textContent.substring(0, range.startOffset).trim() === '---') {
                        e.preventDefault();
                        const p = textNode.parentElement;
                        p.innerHTML = '';
                        document.execCommand('insertHorizontalRule', false, null);
                        const newP = document.createElement('p'); newP.innerHTML = '<br>';
                        p.insertAdjacentElement('afterend', newP);
                        App.util.placeCursor(newP);
                        return;
                    }

                    if (e.key === ' ' && textNode.nodeType === 3) {
                        const text = textNode.textContent.substring(0, range.startOffset);
                        const trimmedText = text.trim();
                        const shortcuts = {
                            '*': 'insertUnorderedList',
                            '-': () => { document.execCommand('insertUnorderedList'); setTimeout(() => { const list = window.getSelection().focusNode.parentElement.closest('ul'); if (list) list.className = 'bullet-hyphen'; }, 0); },
                            '>': () => document.execCommand('formatBlock', false, 'blockquote'),
                            '##': () => document.execCommand('formatBlock', false, 'h2')
                        };
                        const listMatch = text.match(/(\d+)\.$/);
                        const action = shortcuts[trimmedText];

                        if (action) {
                            e.preventDefault();
                            textNode.textContent = text.slice(0, text.length - trimmedText.length) + '\u00A0';
                            range.setStart(textNode, text.length - trimmedText.length + 1);
                            selection.removeAllRanges(); selection.addRange(range);
                            if (typeof action === 'string') document.execCommand(action, false); else action();
                        } else if (listMatch) {
                            e.preventDefault();
                            textNode.textContent = text.slice(0, -listMatch[0].length) + '\u00A0';
                            range.setStart(textNode, text.length - listMatch[0].length + 1);
                            selection.removeAllRanges(); selection.addRange(range);
                            document.execCommand('insertOrderedList', false);
                        }
                    }
                },

                handleListClick() {
                    const now = new Date().getTime();
                    if (now - App.state.lastClickTime < 300) { document.execCommand('insertOrderedList', false); }
                    else {
                        const selection = window.getSelection(); if (!selection.focusNode) return;
                        const focusElement = selection.focusNode.nodeType === Node.TEXT_NODE ? selection.focusNode.parentElement : selection.focusNode;
                        const list = focusElement.closest('ul');
                        if (list) { const currentStyleIndex = App.config.bulletCycle.indexOf(list.className); const nextStyleIndex = (currentStyleIndex + 1) % App.config.bulletCycle.length; list.className = App.config.bulletCycle[nextStyleIndex]; }
                        else { document.execCommand('insertUnorderedList', false); }
                    }
                    App.state.lastClickTime = now;
                },
                showTableModal() {
                    const selection = window.getSelection(); const contentDiv = document.getElementById('article-content');
                    if (selection.rangeCount === 0 || !contentDiv.contains(selection.getRangeAt(0).commonAncestorContainer)) { App.ui.showToast("Please place your cursor in the editor first.", { type: 'error' }); return; }

                    // Insert a temporary marker to hold the cursor position
                    const range = selection.getRangeAt(0);
                    const markerId = `nk-cursor-marker-${Date.now()}`;
                    const markerNode = document.createElement('span');
                    markerNode.id = markerId;
                    range.insertNode(markerNode);
                    App.state.cursorMarkerId = markerId;

                    const table = markerNode.closest('table');
                    let currentRows = 2, currentCols = 2; let title = 'Create Table';
                    if (table) { title = 'Update Table Dimensions'; currentRows = table.rows.length; currentCols = table.rows[0] ? table.rows[0].cells.length : 0; }
                    const message = `<p>${table ? 'Enter new dimensions for the table.' : 'Enter table dimensions. Press Enter for 2x2.'}</p><div class="settings-grid" style="grid-template-columns: auto 1fr; gap: 0.5rem 1rem;"><label for="table-rows-input">Rows</label><input type="number" id="table-rows-input" class="text-input" value="${currentRows}" min="1" style="width:100%;"><label for="table-cols-input">Columns</label><input type="number" id="table-cols-input" class="text-input" value="${currentCols}" min="1" style="width:100%;"></div>`;
                    App.ui.showConfirmationModal({ title, message, confirmText: table ? 'Update' : 'Create', onConfirm: () => { const rows = parseInt(document.getElementById('table-rows-input').value, 10); const cols = parseInt(document.getElementById('table-cols-input').value, 10); if (isNaN(rows) || isNaN(cols) || rows < 1 || cols < 1) { App.ui.showToast("Invalid dimensions.", { type: 'error' }); return; } App.events.table.createOrUpdate(rows, cols); } });
                    const rowsInput = document.getElementById('table-rows-input'); const colsInput = document.getElementById('table-cols-input'); const confirmBtn = document.getElementById('modal-confirm'); const handleEnter = e => { if (e.key === 'Enter') { e.preventDefault(); confirmBtn.click(); } };
                    rowsInput.addEventListener('keydown', handleEnter); colsInput.addEventListener('keydown', handleEnter); rowsInput.focus(); rowsInput.select();
                },
                table: {
                    // FIX: Added a dedicated `create` function for commands to call directly.
                    create(rows, cols) {
                        let tableHTML = '<table><thead><tr>';
                        for (let c = 0; c < cols; c++) tableHTML += `<th><br></th>`;
                        tableHTML += '</tr></thead><tbody>';
                        for (let r = 1; r < rows; r++) {
                            tableHTML += '<tr>';
                            for (let c = 0; c < cols; c++) tableHTML += `<td><br></td>`;
                            tableHTML += '</tr>';
                        }
                        tableHTML += '</tbody></table><p><br></p>';
                        document.execCommand('insertHTML', false, tableHTML);
                        App.state.isArticleDirty = true;
                    },

                    createTile() {
                        const tileHTML = `<table class="tile-box-table"><tbody><tr><td class="tile-cell"><b><br></b></td></tr></tbody></table><p><br></p>`;
                        document.execCommand('insertHTML', false, tileHTML);
                        App.state.isArticleDirty = true;
                    },

                    update(table, newRows, newCols) {
                        const newTable = document.createElement('table'); newTable.className = table.className;
                        const newTHead = newTable.createTHead(); const newTBody = newTable.createTBody();
                        for (let r = 0; r < newRows; r++) {
                            const newRow = document.createElement('tr');
                            for (let c = 0; c < newCols; c++) {
                                const isHeaderRow = (r === 0 && table.tHead && table.tHead.rows.length > 0);
                                const newCell = document.createElement(isHeaderRow ? 'th' : 'td');
                                if (table.rows[r] && table.rows[r].cells[c]) newCell.innerHTML = table.rows[r].cells[c].innerHTML;
                                else newCell.innerHTML = '<br>';
                                newRow.appendChild(newCell);
                            }
                            if (r === 0 && table.tHead && table.tHead.rows.length > 0) newTHead.appendChild(newRow); else newTBody.appendChild(newRow);
                        }
                        const parent = table.parentNode; const nextSibling = table.nextElementSibling;
                        parent.removeChild(table);
                        if (nextSibling) parent.insertBefore(newTable, nextSibling); else parent.appendChild(newTable);
                        let trailingP = newTable.nextElementSibling;
                        if (!trailingP || trailingP.tagName !== 'P') { trailingP = document.createElement('p'); trailingP.innerHTML = '<br>'; newTable.insertAdjacentElement('afterend', trailingP); }
                        App.util.placeCursor(trailingP, true);
                        App.state.isArticleDirty = true;
                    },

                    createOrUpdate(newRows, newCols) {
                        const markerId = App.state.cursorMarkerId;
                        if (!markerId) { App.ui.showToast("Editor selection lost. Please try again.", { type: 'error' }); return; }

                        const markerNode = document.getElementById(markerId);
                        if (!markerNode) { App.ui.showToast("Cursor marker not found. Please try again.", { type: 'error' }); return; }

                        const table = markerNode.closest('table');

                        const sel = window.getSelection();
                        const range = document.createRange();
                        range.setStartBefore(markerNode);
                        range.collapse(true);
                        sel.removeAllRanges();
                        sel.addRange(range);
                        markerNode.parentNode.removeChild(markerNode);
                        App.state.cursorMarkerId = null;

                        if (table && table.classList.contains('tile-box-table')) { App.ui.showToast("You already created a Box Tile. It cannot be expanded.", { type: 'warning' }); return; }
                        if (!table && newRows === 1 && newCols === 1) this.createTile();
                        else if (table) this.update(table, newRows, newCols);
                        else this.create(newRows, newCols);
                    }
                },

                ai: {
                    saveAiSettings() {
                        // Save Provider from dropdown
                        const providerSelect = document.getElementById('ai-provider-select');
                        if (providerSelect && providerSelect.value) {
                            App.settings.set('aiProvider', providerSelect.value);
                        }

                        // Helper to save key/model
                        const saveField = (provider, keyId, modelId) => {
                            const keyInput = document.getElementById(keyId);
                            if (keyInput) {
                                const val = keyInput.value.trim();
                                if (val) App.settings.set(provider + 'Key', val);
                            }

                            const modelInput = document.getElementById(modelId);
                            if (modelInput) {
                                const mVal = modelInput.value.trim();
                                if (mVal) App.settings.set(provider + 'Model', mVal);
                            }
                        };

                        saveField('openrouter', 'openrouter-key-input', 'openrouter-model-input');
                        saveField('gemini', 'gemini-key-input', 'gemini-model-select');
                        saveField('openai', 'openai-key-input', 'openai-model-input');
                        saveField('huggingface', 'huggingface-key-input', 'huggingface-model-input');

                        App.ui.showToast('AI Hub settings saved!', 'success');
                        App.ui.closeModal();
                    },

                    clearConversation() {
                        if (this.state.history.length > 0) {
                            App.ui.showConfirmationModal({
                                title: 'Clear Conversation?',
                                message: 'Are you sure you want to delete this conversation history?',
                                confirmText: 'Clear',
                                onConfirm: () => {
                                    this.state.history = [];
                                    this.renderConversation();
                                }
                            });
                        }
                    },

                    async saveConversationAsNote() {
                        if (this.state.history.length === 0) {
                            App.ui.showToast("Nothing to save.", "warning");
                            return;
                        }
                        const title = `Co-Pilot Conversation: ${new Date().toLocaleString()}`;
                        let contentHTML = ``;
                        this.state.history.forEach(msg => {
                            const cleanedContent = msg.content.replace(/<div class="copilot-bubble-actions">.*?<\/div>/s, '');
                            if (msg.role === 'user') {
                                contentHTML += `<blockquote><p><b>You:</b> ${cleanedContent}</p></blockquote>`;
                            } else {
                                contentHTML += `<div>${cleanedContent}</div>`;
                            }
                        });
                        const defaultCategory = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                        const newNote = await App.storage.createArticle({ title, content: contentHTML, category: defaultCategory });
                        if (newNote) {
                            App.ui.showToast('Conversation saved!', {
                                type: 'success',
                                action: { label: 'Open Note', callback: () => App.router.navigateTo('article', { id: newNote.id, mode: 'read' }) }
                            });
                            this.state.history = [];
                            this.renderConversation();
                        } else {
                            App.ui.showToast("Failed to save conversation.", "error");
                        }
                    },

                    async executeKashAsk(prompt) {
                        if (!prompt) {
                            App.ui.showToast("Please provide a question for the AI.", "warning");
                            return;
                        }

                        const systemPrompt = `You are 'Kash, the Content Architect,' an expert AI integrated into the NoteKash app. Your mission is to analyze the user's context (the article and any selected text) and their prompt, adopt the persona of a subject matter expert, to write most reliable and meaningful response to Query. Then Act as content architect to generate a beautiful, structured, and aesthetic response using the best components from your HTML Toolkit.

                        **MANDATORY Core Logic Flow (Synthesis Model):**

                        1.  **Analyze the User's Goal:** First, understand the core question in the [User Prompt]. What is the user's primary intent? what he wants from you? Does he mention his answer to be in any particular format/template?

                        2.  **Analyze Provided Context:** Second, review the provided [Article Content]. Does it contain information directly relevant to the user's question?

                        3.  **Synthesize and Respond (CRITICAL):**
                            * IMPORTANT: In both "if and else" cases remember You MUST ALWAYS Act as Subject Matter Expert (SME) (e.g an elite economist for finance, a Indian Historian for Gupta Empire, An Polity Expert for Consitution, Top notch Financial advisor for Mutual funds etc.) So you inshort develop the most relevant and Best Persona according to what is being Asked to Answer in precise, authoritative, logical, purposeful and contextually appropriate manner, reflecting the depth of your knowledge and experience in that domain
                            * **IF the user's question is general knowledge** (e.g., "What happens when we die?", "Explain quantum physics") and is unrelated to the [Article Content], you MUST answer using your own vast, general knowledge base. Do NOT mention the article's context if it's irrelevant.
                            * **ELSE (if the question IS related to the context):** You MUST formulate a comprehensive answer by intelligently combining your own expert knowledge with the specific details, facts, and nuances found in the [Article Content]. This creates a richer, more personalized response.
                           
                        4.  **Format the Output:** After formulating your expert answer, act as a 'Content Architect'. Choose the single best component from your HTML toolkit to present the information in the most beautiful and effective way.
                        **Core Principle: Text Styling**
                        This is critical for readability. In ALL your responses, you MUST use \`<b>\` tags to bolden the most important keywords, names, dates, and facts. Use \`<em>\` (italic) for secondary emphasis. This makes notes visually aesthetic an skimmable.

                        **Your Component Toolkit to USE (Must Use):**

                        1.  **Accordion (\`<div class="nk-accordion">\`):**
                            * **Use Case:** Your primary tool for any explicit or implicit Question & Answer. If the user asks "What is...", "How does...", or "Explain...", this is almost always the best choice.
                            * **HTML:** \`<div class="nk-accordion" data-state="open"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>USER_QUESTION_HERE</b></span>...</div><div class="nk-accordion-content"><p>YOUR_ANSWER_HERE</p></div></div>\`

                        2.  **Decktile with Text Tiles (\`<div class="nk-textile-deck">\`):**
                            * **Use Case:** Use this to group several related, short pieces of information. Excellent for listing key features, components, or related concepts (e.g., "list the types of...", "what are the main pillars of...").
                            * **HTML:** \`<div class="nk-textile-deck" contenteditable="false"><div class="nk-text-tile color-1">...</div><div class="nk-text-tile color-2">...</div></div>\`

                        3.  **Textile (\`<div class="nk-text-tile">\`):**
                            * **Use Case:** Use sparingly for a single, high-impact fact, definition, or key takeaway that needs to stand out on its own.
                            * **HTML:** \`<div class="nk-text-tile color-default"><span class="nk-text-tile-icon"></span><div class="nk-text-tile-content">YOUR_ANSWER_HERE</div></div>\`

                        4.  **Table (\`<table>\`):**
                            * **Use Case:** When the user asks for a comparison, a list of items with multiple properties, or structured data (e.g., "list the pros and cons", "table of planets and their moons").
                            * **Action:** Generate a standard HTML \`<table>\` with \`<th>\` headers.

                        5.  **Bulleted/Numbered List (\`<ul>\`/\`<ol>\`):**
                            * **Use Case:** When the user asks to "list the steps", "outline the reasons", or any request for multiple distinct points where a table is overly complex.

                        6.  **Default (Blockquote):**
                            * **Use Case:** Your fallback for general statements, opinions, or when no other component fits perfectly.
                            * **HTML:** \`<blockquote><p>YOUR_ANSWER_HERE</p></blockquote>\`
                            
                        7.  **Colored Text:** For styled sentences and short paragraphs (for most important sentences and parts of our content).
                            * **Triggers:** "in red text", "in green", "in blue color", "in magenta".
                            * **Classes:** \`text-red\`, \`text-green\`, \`text-blue\`, \`text-magenta\`.
                            * **HTML Structure:** \`<p class="CLASS_NAME_HERE">YOUR_ANSWER_HERE</p>\`

                        **Final Rules (CRITICAL):**
                        * Respond ONLY with the final, complete HTML snippet.
                        * Do NOT include any conversational filler, greetings, or explanations outside of the HTML you generate.`;

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, prompt);

                        if (result && result.trim()) {
                            const answerHtml = result.trim().replace(/^```(html)?\n?/, '').replace(/\n?```$/, '');

                            // --- Smart Insertion Logic ---
                            const selection = window.getSelection();
                            if (selection && selection.rangeCount > 0) {
                                const range = selection.getRangeAt(0);
                                const container = range.commonAncestorContainer;
                                const parentBlock = (container.nodeType === 3 ? container.parentElement : container)
                                    .closest('p, li, h1, h2, h3, h4, h5, h6, blockquote, div');

                                if (parentBlock && document.getElementById('article-content').contains(parentBlock)) {
                                    parentBlock.insertAdjacentHTML('afterend', answerHtml);
                                } else {
                                    document.execCommand('insertHTML', false, answerHtml);
                                }
                            } else {
                                document.execCommand('insertHTML', false, answerHtml);
                            }

                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("The AI did not provide an answer. Please try again.", "warning");
                        }
                    },

                    async executeKashTranslate(language) {
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();
                        if (!selectedText) {
                            App.ui.showToast("Please select text to translate.", "warning");
                            return;
                        }

                        const systemPrompt = `You are an expert translator. Translate the following text to ${language}. Respond ONLY with the translated text, without any explanations, quotes, or conversational filler.`;
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);

                        if (result && result.trim()) {
                            // Collapse the selection to the end to paste after it
                            selection.collapseToEnd();
                            const translationHtml = `<br><i>(${language} translation: ${App.util.escapeHtml(result.trim())})</i>`;
                            document.execCommand('insertHTML', false, translationHtml);
                            App.state.isArticleDirty = true;
                        }
                    },


                    async executeKashTags() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Article is empty, nothing to tag.", "warning");
                            return;
                        }

                        const systemPrompt = `You are an expert indexer for a knowledge base. Your task is to analyze the article and identify the 5-9 most important and representative phrases to be turned into tags.

                        CRITICAL: Do not just list keywords. You must return a valid JSON array of objects. Each object must have a key named "tag_text" containing the exact, verbatim phrase from the article that should be tagged.

                        RULES:
                        1. Choose the most complete and representative instance of a concept (e.g., tag "collegium system" instead of just "collegium", also "article 312" instead of "article 312 of the constitution" since its clear in itself and short).
                        2. Do not return duplicate "tag_text" values. Each short phrase must be Unique.
                        3. Be selective; only choose 5-9 of the most crucial concepts for tagging.

                        Example Response:
                        [{"tag_text": "women representation"},{"tag_text": "article 312"}, {"tag_text": "All India Judicial Service"}]

                        Respond ONLY with the JSON array.`;

                        const userPrompt = contentDiv.innerText;
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (result && result.trim()) {
                            try {
                                // Find the JSON array within the AI's response, even if it adds extra text
                                const jsonMatch = result.match(/\[\s*\{[\s\S]*?\}\s*\]/s);
                                if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");

                                const tagsToApply = JSON.parse(jsonMatch[0]);
                                if (!Array.isArray(tagsToApply)) throw new Error("AI did not return an array.");

                                let contentHTML = contentDiv.innerHTML;
                                let tagsAppliedCount = 0;

                                App.ui.showToast(`Applying ${tagsToApply.length} smart tags...`, { type: 'info' });

                                tagsToApply.forEach(tagObj => {
                                    if (tagObj && tagObj.tag_text) {
                                        const phraseToTag = tagObj.tag_text;
                                        // This check prevents re-tagging something that's already a tag
                                        if (contentHTML.includes(phraseToTag)) {
                                            const slug = App.contentTools.slugify(phraseToTag);
                                            const replacement = `<span class="rendered-tag" data-tag="${slug}">${phraseToTag}</span>`;

                                            contentHTML = contentHTML.replace(phraseToTag, replacement);
                                            tagsAppliedCount++;
                                        }
                                    }
                                });

                                if (tagsAppliedCount > 0) {
                                    contentDiv.innerHTML = contentHTML;
                                    App.ui.showToast(`${tagsAppliedCount} smart tags were applied!`, 'success');
                                    App.state.isArticleDirty = true;
                                } else {
                                    App.ui.showToast("AI suggested tags, but none could be applied.", "info");
                                }

                            } catch (error) {
                                console.error("KashTags Error:", error, "AI Response:", result);
                                App.ui.showToast("AI returned an invalid format for tagging.", "error");
                            }
                        } else {
                            App.ui.showToast("AI could not identify any tags to apply.", "warning");
                        }
                    },

                    async executeKashSummary() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Nothing to summarize.", "warning");
                            return;
                        }
                        const systemPrompt = "You are a practical, reliable summarizer for a note-taking app. Given a user-provided text, produce a compact, useful summary optimized for quick reading and recall: output a one-line descriptive title (if identifiable) followed by 412 concise bullet points that capture the most important facts, conclusions, and action items; each bullet should be short (about 2035 words). Prefer extractive phrasing (use exact words/short phrases from the text) to avoid hallucination; paraphrase only to improve clarity. Do NOT invent facts  if a requested detail is missing, write 'didn't specify ...' If the source is very short (2 sentences), return a 12 sentence condensed summary instead of multiple bullets. If the user requests a focus (e.g., 'action items', 'key facts', 'summary for meeting'), prioritize that focus in the bullets. Output only the title and markdown bullet list (no extra explanation, headings, or metadata). Keep tone neutral, language simple, and make the result immediately copy-ready for notes.";
                        const userPrompt = contentDiv.innerText;

                        const summary = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (summary && summary.trim()) {

                            const summaryHtml = summary.split('\n').map(line => line.trim().replace(/^[\*\-]\s*/, '')).filter(line => line).map(line => `<li>${line}</li>`).join('');

                            const finalHtml = `
                            <div class="nk-text-tile color-ghost-1 ai-summary-tile" contenteditable="true" data-color="ghost-1">
                                <div class="nk-text-tile-content" contenteditable="true">
                                    <h4 style="margin-top: 0; font-weight: 600;" contenteditable="false">Short AI Summary</h4>
                                    <ul style="padding-left: 20px; margin-bottom: 0;">${summaryHtml}</ul>
                                </div>
                            </div><p><br></p>`;


                            const existingSummary = contentDiv.querySelector('.ai-summary-tile');
                            if (existingSummary) {
                                if (existingSummary.nextElementSibling && existingSummary.nextElementSibling.innerHTML === '<br>') {
                                    existingSummary.nextElementSibling.remove();
                                }
                                existingSummary.remove();
                            }

                            contentDiv.insertAdjacentHTML('afterbegin', finalHtml);
                            App.ui.showToast("Summary generated!", "success");
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("AI returned an empty summary. Please try again.", "warning");
                        }
                    },

                    async executeKashFlash() {
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();

                        if (!selectedText) {
                            App.ui.showToast("Please select text to generate flashcards from.", "warning");
                            return;
                        }

                        // --- NEW "LEARNING SCIENTIST" PROMPT ---
                        const systemPrompt = `You are an expert educator and Cloze Deletion Specialist integrated into the NoteKash app. Your mission is to transform a user's selected text into the most Effective Active Recall Flashcard possible by creating surgical, High-value/quality Cloze deletions.

                    **Core Philosophy:**
                    Your goal is not just to hide words, but to identify and test the most critical pieces of information that are essential for understanding and memorization.

                    **Your Thought Process & Selection Criteria (Follow this hierarchy):**

                    1.  **Identify the Core Concepts:** Read the entire text to understand its meaning. What are the 1-4 most important "nuggets" of knowledge here?
                    2.  **Prioritize What to Cloze:**
                        * **Priority #1 (Key Terms & Definitions):** If the text defines a term, cloze the term itself. **Example:** \`{{c1::The Collegium System}}\` is the body responsible for judicial appointments.
                        * **Priority #2 (Cause & Effect):** Cloze the result of an action or the reason for a state. **Example:** The non-enforceability of DPSPs is due to them being \`{{c1::non-justiciable}}\`.
                        * **Priority #3 (Specific Data):** Cloze crucial numbers, dates, names, or statistics. **Example:** The DPSPs are found in \`{{c1::Part IV}}\` of the Constitution.
                        * **Priority #4 (Crucial Phrases):** If a multi-word phrase represents a single, vital concept, cloze the entire phrase. **Example:** The ultimate goal is to create a \`{{c1::Welfare State}}\`.

                    **Dynamic Cloze Count:**
                    * Analyze the text's length and density.
                    * For short selections (1-2 sentences), create **1-3** powerful clozes.
                    * For longer paragraphs, create **2-7** clozes, ensuring each one tests a distinct, important concept.

                    **CRITICAL Final Output Rules:**
                    1.  You MUST use the exact \`{{c1::text to hide}}\`, \`{{c2::...}}\` syntax for cloze deletions.
                    2.  Your response MUST be ONLY the fully modified text.
                    3.  You MUST preserve the original sentence structure and surrounding context perfectly.
                    4.  Do NOT include any explanations, conversational text, or markdown formatting. Your output should be ready to be inserted directly into an editor.`;

                        const userPrompt = selectedText;
                        const toastId = App.ui.showToast(' KashFlash is thinking...', { type: 'info', duration: 0 });

                        try {
                            const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);
                            App.ui.hideToast(toastId);

                            if (result && result.trim()) {
                                const cleanedText = result.trim().replace(/^```(\w+\n)?/, '').replace(/\n?```$/, '');
                                document.execCommand('insertHTML', false, cleanedText);
                                App.ui.showToast("KashFlash created!", 'success');
                                App.state.isArticleDirty = true;
                            } else {
                                throw new Error("AI returned an empty response.");
                            }
                        } catch (error) {
                            App.ui.hideToast(toastId);
                            App.ui.showToast("AI could not generate a flashcard. Please try again.", "warning");
                            console.error("KashFlash Error:", error);
                        }
                    },

                    async executeKashQuestion() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Nothing in the article to ask questions about.", "warning");
                            return;
                        }
                        const systemPrompt = "You are an AI that generates insightful questions based on a text. Your goal is to create 5 thought-provoking questions that test the reader's comprehension of the main arguments, key facts, and underlying assumptions. Frame them as open-ended questions. Respond ONLY with the questions, each on a new line, formatted as a numbered list.";
                        const userPrompt = contentDiv.innerText;

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (result && result.trim()) {
                            // Convert numbered list from AI into an HTML ordered list
                            const questionsHtml = `<ol>${result.trim().split('\n').map(line => `<li>${line.replace(/^\d+\.\s*/, '')}</li>`).join('')}</ol>`;
                            const finalHtml = `<div class="nk-text-tile color-ghost-2" contenteditable="true"><div class="nk-text-tile-content" contenteditable="true"><h4 style="margin-top:0;" contenteditable="false">Key Questions</h4>${questionsHtml}</div></div><p><br></p>`;
                            contentDiv.insertAdjacentHTML('beforeend', finalHtml);
                            App.ui.showToast("5 Key Questions Generated!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("AI could not generate questions.", "warning");
                        }
                    },

                    async executeKashDebate() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Article is empty, nothing to debate.", "warning");
                            return;
                        }
                        const systemPrompt = "You are an expert debater and critical analyst. Read the following article content, identify its central argument or tone, and then construct a two-column debate table. The first column should powerfully argue FOR the article's position. The second column should present a strong, well-reasoned counter-argument or the opposing perspective. Each column should have a clear heading. Conclude with a persuasive summary for each side. Respond ONLY with the complete HTML for the table, using the app's standard table styling.";
                        const userPrompt = contentDiv.innerText;

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (result && result.trim()) {
                            const cleanedHtml = result.trim().replace(/^```html\n?/, '').replace(/\n?```$/, '');
                            contentDiv.insertAdjacentHTML('beforeend', `<p><br></p>${cleanedHtml}<p><br></p>`);
                            App.ui.showToast("Debate table created!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("AI could not generate a debate.", "warning");
                        }
                    },

                    async executeKashLong() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Nothing to summarize.", "warning");
                            return;
                        }
                        const systemPrompt = "You are an expert summarizer tasked with creating a detailed, comprehensive summary of the provided text. Unlike a brief summary, this summary must capture all key arguments, supporting details, important data points, and named entities without missing any crucial information. The summary should be significantly shorter than the original article but much longer and more detailed than a short summary. Structure the output in well-organized paragraphs. Respond ONLY with the summary text.";
                        const userPrompt = contentDiv.innerText;

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (result && result.trim()) {
                            const paragraphsHtml = result.trim().split('\n').map(p => `<p>${p}</p>`).join('');
                            const finalHtml = `<div class="nk-text-tile color-default" contenteditable="false"><div class="nk-text-tile-content"><h4 style="margin-top:0;">Detailed Summary</h4>${paragraphsHtml}</div></div><p><br></p>`;
                            contentDiv.insertAdjacentHTML('afterbegin', finalHtml);
                            App.ui.showToast("Detailed summary generated!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("AI could not generate a detailed summary.", "warning");
                        }
                    },

                    async executeKashCurate() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("There is no content in the note to beautify.", "warning");
                            return;
                        }

                        const systemPrompt = `You are 'KashCurate', an expert AI Content Architect and Designer for the NoteKash app. Your mission is to transform raw text into a beautiful, hierarchical, and effective learning document that uses ALL of NoteKash's powerful features.

                        **Core Directives:**
                        1.  **HIERARCHY & VARIETY ARE MANDATORY:** Your primary goal is to create a visually appealing and easy-to-read document. Do not just put every sentence in a box. You **must** use a rich mix of paragraphs, accordions, MCQs, tables, and a limited number of textiles.
                        2.  **ACTIVE LEARNING FIRST:** Your output must be an active learning tool. Actively create cloze flashcards, Q&A accordions, and multiple-choice questions.

                        **Your Component Toolkit & Curation Rules:**

                        1.  **Paragraphs (<p>):** **This is your default.** Use standard paragraphs for the main narrative, explanations, and connecting information.
                            * **Within paragraphs, you MUST:**
                                * Use \`<b>\` for important keywords.
                                * For key facts, numbers, or terms, create a cloze flashcard. **Example:** The report found that {{c1::14%}} of judges are women.
                                * Use \`==highlight==\` for phrases that deserve visual emphasis but are not flashcards. Highlights and cloze deletions can be used together. **Example:** It's critical to note that ==the conviction rate is {{c1::under 50%}}==.

                        2.  **Accordion (<div class="nk-accordion">):** **Your primary duty is to create these.** Accordions are for short Q&A which you derive after analyzing text. Aim for **at least 3-5 accordions**.
                            * **Use Case:** Actively look for implicit or explicit questions in the text. Convert these into interactive Q&A accordions to promote active recall.
                            * **EXACT HTML STRUCTURE:**
                                \`\`\`html
                                <div class="nk-accordion" data-state="closed">
                                    <div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>What is the main reason for this disparity?</b></span>...</div>
                                    <div class="nk-accordion-content"><p>The primary reason is the collegium system...</p></div>
                                </div>
                                \`\`\`

                        3.  **MCQ Block (<div class="nk-mcq-block">):** Generate **1-2 MCQs** if the text contains suitable factual questions with clear distractors.
                            * **Use Case:** To test specific knowledge points with clear correct and incorrect answers.
                            * **EXACT HTML STRUCTURE:**
                                \`\`\`html
                                <div class="nk-mcq-block" contenteditable="false">
                                    <div class="nk-mcq-toolbar">
                                        <button class="nk-mcq-copy-block" title="Copy MCQ"><i class="fa-solid fa-copy"></i></button>
                                        <button class="nk-mcq-delete-block" title="Delete MCQ"><i class="fa-solid fa-trash"></i></button>
                                    </div>
                                    <div class="nk-mcq-question" contenteditable="true">Which report highlighted the low representation of women?</div>
                                    <div class="nk-mcq-options">
                                        <div class="nk-mcq-option" data-is-correct="true">
                                            <div class="nk-mcq-option-radio"></div>
                                            <div class="nk-mcq-option-text" contenteditable="true">India Justice Report</div>
                                            <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                                        </div>
                                        <div class="nk-mcq-option" data-is-correct="false">
                                            <div class="nk-mcq-option-radio"></div>
                                            <div class="nk-mcq-option-text" contenteditable="true">National Judicial Data Grid</div>
                                            <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                                        </div>
                                    </div>
                                    <button class="btn btn-secondary nk-mcq-add-option">+ Add Option</button>
                                    <div class="nk-mcq-explanation" contenteditable="true" data-placeholder="Add answer explanation (optional)..."></div>
                                </div>
                                \`\`\`

                        4.  **Textile (<div class="nk-text-tile ...">):** Use these **SPARINGLY (4-7 per document)** for spotlighting the most critical, standalone information.
                            * **Use Case:** For high-impact facts or conclusions that need to be visually distinct. **AVOID using these for every sentence.**
                            * **Example:** \`<div class="nk-text-tile color-2"><div class="nk-text-tile-content">Women constitute nearly <b>38%</b> of the lower judiciary.</div></div>\`

                        5.  **Tables (<table>):** For structured, comparative data.
                            * **Use Case:** If you find data comparing two or more things (e.g., lower vs. higher judiciary stats, pros vs. cons), you **should** structure it in a simple 2-column table.

                        6.  **Blockquote (<blockquote>):** For direct quotes.
                            * **Use Case:** If the text contains a direct quote from a person (e.g., "War is too important..."), you **must** use a blockquote.

                        **Your Thought Process (Follow these steps meticulously):**
                        1.  Read the entire text to understand the core narrative.
                        2.  Write the main story using standard **paragraphs**.
                        3.  Go back through your paragraphs and embed **{{c1::cloze}}** flashcards on all key statistics and facts.
                        4.  Also embed important visual highlights using \`==highlight==\` in paragraphs.
                        5.  Identify any questions or cause-and-effect statements and convert them into **Accordions**.
                        6.  Find suitable facts to test and create **MCQ Blocks**.
                        7.  Find any direct quotes and format them as **Blockquotes**.
                        8.  Look for comparative data points and structure them in a **Table**.
                        9.  Select 4-7 of the most important, standalone facts and pull them out into visually distinct **Textiles**.
                        10. Finally, perform a polish pass, adding \`<b>\`, \`<i>\`, and \`<u>\` to add a final layer of emphasis.

                        Your goal is an elegant, readable document that guides the user's focus and enhances learning, not a cluttered page of boxes. Respond ONLY with the generated HTML.`;

                        const userPrompt = contentDiv.innerText;
                        const msgId = App.ui.showToast("NoteKash AI is curating your note...", { type: 'info', duration: 0 });

                        try {
                            const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);
                            App.ui.hideToast(msgId);

                            if (result && result.trim()) {
                                const cleanedHtml = result.trim().replace(/^```(html)?\n?/, '').replace(/\n?```$/, '');
                                const separatorHtml = `
                                <div style="text-align: center; margin: 2rem 0;">
                                    <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 0 auto;">
                                    <div style="font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-top: 0.5rem;">
                                         NoteKash AI Version 
                                    </div>
                                </div>
                                `;
                                contentDiv.insertAdjacentHTML('beforeend', separatorHtml + cleanedHtml);
                                contentDiv.querySelectorAll('canvas[data-chart-config]').forEach(canvas => {
                                    App.ui.renderChartOnCanvas(canvas);
                                });
                                const finalElement = contentDiv.lastElementChild;
                                if (finalElement) {
                                    finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                                App.ui.showToast("NoteKash AI has curated your note!", 'success');
                                App.state.isArticleDirty = true;
                            } else {
                                App.ui.showToast("AI could not generate a detailed summary.", "warning");
                            }
                        } catch (e) {
                            App.ui.hideToast(msgId);
                            console.error(e);
                            App.ui.showToast("Error curating note.", "error");
                        }
                    },

                    async executeKashPresent() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("There is no content to present.", "warning");
                            return;
                        }

                        const systemPrompt = `You are 'KashPresent', an expert Note Architect and Presentation Designer for the NoteKash app. Your mission is to take the provided content and present it beautifully using NoteKash's native capabilities, creating a ready-to-record presentation script.

                        **Core Directives:**
                        1.  **NO Structural Changes:** You must NOT change the structure, storytelling, narration, or writing manner of the article.
                        2.  **NO Repetition:** Do NOT repeat information. If you present something as an MCQ or Accordion, do not repeat it in a paragraph.
                        3.  **Visual Elegance:** The output must be colorful and beautiful, a "delight to watch".
                        4.  **"Note Architect" Role:** You are building a presentation.
                        5.  **NO Lists:** Do NOT use bullet points (ul) or numbered lists (ol) at all.
                        6.  **RICH FORMATTING (Important):** You MUST use <b>bold</b>, <i>italics</i>, and <u>underline</u> tags generously. A presentation should not be a wall of plain text. emphasize key terms, names, and punchlines.
                            *   Example: "The <b>mitochondria</b> is the <i>powerhouse</i> of the cell."

                        **Your Design Toolkit (Use these specific interactive features):**


                        *   **Headings:** PREFERRED: Use **Red Color** for headings. Example: <h3 class="text-red">Heading Name</h3>.
                        *   **Text Colors:** Use a variety of colors (text-blue, text-green, text-magenta, text-orange, text-teal, text-slate) for important concepts and points. Make it colorful!


                        *   **Essential Sentence Highlights:** Use these specific classes to highlight **ENTIRE sentences** that are critical takeaways worth remembering.
                            *   **Classes:** 'highlight-1' (Yellow), 'highlight-2' (Green), 'highlight-3' (Blue), 'highlight-4' (Red).
                            *   **Usage:** <span class="highlight-1">This is a critical sentence that the user needs to remember.</span>
                            *   **Rule:** Use these for full thoughts/sentences, NOT just single words.
                            *   **Variety:** Do NOT just use one color. Use Red for alerts, Green for positive facts, Yellow/Blue for general info.


                        *   **Accordions (Interactive Question & Answer):**
                            *   Use this for distinct questions found in the text.
                            *   **EXACT HTML STRUCTURE:**
                            \`\`\`html
                            <div class="nk-accordion" data-state="closed">
                                <div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>What is the question?</b></span><i class="fa-solid fa-chevron-down"></i></div>
                                <div class="nk-accordion-content"><p>The answer goes here with <b>bold</b> concepts...</p></div>
                            </div>
                            \`\`\`

                        *   **MCQs (Native Interactive Block):**
                            *   Use this for specific fact-checking logic.
                            *   **EXACT HTML STRUCTURE:**
                            \`\`\`html
                            <div class="nk-mcq-block" contenteditable="false">
                                <div class="nk-mcq-toolbar">
                                    <button class="nk-mcq-copy-block" title="Copy MCQ"><i class="fa-solid fa-copy"></i></button>
                                    <button class="nk-mcq-delete-block" title="Delete MCQ"><i class="fa-solid fa-trash"></i></button>
                                </div>
                                <div class="nk-mcq-question" contenteditable="true">The Question text here?</div>
                                <div class="nk-mcq-options">
                                    <div class="nk-mcq-option" data-is-correct="true">
                                        <div class="nk-mcq-option-radio"></div>
                                        <div class="nk-mcq-option-text" contenteditable="true">Correct Answer</div>
                                        <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                                    </div>
                                    <div class="nk-mcq-option" data-is-correct="false">
                                        <div class="nk-mcq-option-radio"></div>
                                        <div class="nk-mcq-option-text" contenteditable="true">Wrong Answer 1</div>
                                        <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                                    </div>
                                </div>
                                <div class="nk-mcq-explanation" contenteditable="true" data-placeholder="Explanation...">Explanation text here.</div>
                            </div>
                            \`\`\`

                        *   **Textiles (Visual Tiles - Your Slides):**
                            *   **CRITICAL - VARIETY IS REQUIRED:** You have access to \`color-1\` through \`color-8\`. **USE THEM ALL.**
                            *   **RULE:** NEVER use the same color class for two Textiles in a row. If you used \`color-3\`, the next one MUST be different (e.g., \`color-6\`). Randomize your choices.
                            *   **Content:** The text inside should be punchy and use <b>bold</b> or <i>italics</i>.
                            *   **EXACT HTML STRUCTURE:**
                            \`\`\`html
                            <div class="nk-text-tile color-3">
                                <div class="nk-text-tile-content">
                                    The Content Text Here (No Headings!)
                                </div>
                            </div>
                            \`\`\`

                        *   **Tables:** Use for structured comparisons (Pros vs Cons, Data points).

                        **Strategic Toolkit Usage (The "Note Architect" Strategy):**
                        *   **Exhaust Your Options:** Don't just stick to text. A premium presentation uses EVERY tool in the box.
                        *   **Flow:** Start with a **Textile**, follow with text/highlights, then an **Accordion** for a deep dive, and an **MCQ** to test knowledge.
                        *   **Aesthetics:** Your goal is to make the user say "Wow, this looks premium."

                        **Output Format:**
                        *   Respond ONLY with the generated HTML.
                        *   Do not include markdown code fences (\`\`\`html).
                        *   Ensure all HTML structure (divs, classes, buttons) is exactly as prescribed above.`;

                        const userPrompt = contentDiv.innerText;
                        const msgId = App.ui.showToast("Note Architect is designing your presentation...", { type: 'info', duration: 0 });

                        try {
                            const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);
                            App.ui.hideToast(msgId);

                            if (result && result.trim()) {
                                const cleanedHtml = result.trim().replace(/^```(html)?\n?/, '').replace(/\n?```$/, '');
                                const separatorHtml = `
                                <div style="text-align: center; margin: 3rem 0;">
                                    <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 0 auto;">
                                    <div style="font-family: var(--font-body); font-weight: 700; color: var(--text-red); margin-top: 0.8rem; font-size: 1.1em; letter-spacing: 0.5px;">
                                         PRESENTATION MODE 
                                    </div>
                                </div>
                                `;
                                contentDiv.insertAdjacentHTML('beforeend', separatorHtml + cleanedHtml);

                                // Re-initialize charts if any
                                contentDiv.querySelectorAll('canvas[data-chart-config]').forEach(canvas => {
                                    App.ui.renderChartOnCanvas(canvas);
                                });

                                const finalElement = contentDiv.lastElementChild;
                                if (finalElement) {
                                    finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                                App.ui.showToast("Your presentation is ready!", 'success');
                                App.state.isArticleDirty = true;
                            } else {
                                App.ui.showToast("The Architect couldn't finish the design. Please try again.", "warning");
                            }
                        } catch (e) {
                            App.ui.hideToast(msgId);
                            console.error(e);
                            App.ui.showToast("Error generating presentation.", "error");
                        }
                    },

                    async executeKashTable() {
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();

                        if (!selectedText) {
                            App.ui.showToast("Please select text to generate a revision table from.", "warning");
                            return;
                        }

                        const systemPrompt = "You are an AI specializing in creating structured revision tables for students. Analyze the selected text and convert its key information into a concise, well-organized two-column HTML table. The first column should contain the main concepts, terms, or topics. The second column should contain the corresponding definitions, explanations, or key details. Use clear headings for the columns. Respond ONLY with the complete HTML for the table.";

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);

                        if (result && result.trim()) {
                            const cleanedHtml = result.trim().replace(/^```html\n ? /, '').replace(/```$/, '');

                            document.execCommand('insertHTML', false, cleanedHtml + '<p><br></p>');
                            App.ui.showToast("Revision table created!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("AI could not generate a table.", "warning");
                        }
                    },

                    async executeKashComedy() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("There's no material to work with! The article is empty.", "warning");
                            return;
                        }

                        const systemPrompt = `You are a sharp, witty stand - up comedian in the style of John Oliver or Hasan Minhaj.Your audience is primarily Hindi / Urdu speakers who understand simple, conversational English.Your job is to take a serious article and turn it into a short(200 - 300 word), hilarious, and memorable comedy routine.

                        ** Your Method:**
                            1. ** Opener:** Start with a relatable, everyday observation that connects to the article's main topic. Invent a personal anecdote. For example: "You know, this whole thing reminds me of my uncle trying to use a smartphone..."
                        2. ** Breakdown with Humor:** Identify 2 - 3 key, serious points from the article.Explain them using funny analogies, exaggeration, and fictional scenarios.Simplify complex ideas.
                        3.  ** The "Desi" Angle:** Connect the topic back to a common experience in an Indian household or society.For example, compare a complex bureaucratic process to trying to get a new gas cylinder or dealing with a government office.
                        4.  ** Closer:** End with a strong punchline that summarizes the absurdity of the situation.

                        ** Rules:**
                        * ** Simple English:** Use easy - to - understand, conversational words.No jargon.
                        * ** Formatting:** Format the output like a script.Use < b > tags for emphasis on punchlines.Do NOT use markdown like **.
                        * ** Response:** Respond ONLY with the comedy routine script, wrapped in a single \`<blockquote>\`.

                        **Example Persona Snippet:**
                        "So I'm reading this thing about... 'gender equity in the judiciary'. Sounds serious, right? My dad heard the word 'judiciary' and immediately asked if I was in trouble with the law again. No, Dad, I'm just trying to write jokes! "`;

                        const userPrompt = contentDiv.innerText;
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (result && result.trim()) {
                            // AI is now instructed to return a blockquote, so we can insert it directly.
                            const comedyHtml = result.trim() + '<p><br></p>';

                            const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                            <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                 KashComedy Version 
                            </div>
                        `;

                            contentDiv.insertAdjacentHTML('beforeend', separatorHtml + comedyHtml);

                            const finalElement = contentDiv.lastElementChild;
                            if (finalElement) {
                                finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                            App.ui.showToast("And now for something completely different...", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("The AI is having writer's block. Please try again.", "warning");
                        }
                    },

                    async executeKashKeywords() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("The article is empty. Add some content first!", "warning");
                            return;
                        }

                        const systemPrompt = `You are an expert academic analyst. Your task is to read the provided article and extract the 7-16 most important, unique, or conceptual keywords and short phrases that are essential for understanding the text.

                        CRITICAL: You MUST respond ONLY with a valid JSON array of strings. Do not include any introductory text, explanations, or markdown.

                        Example Response: (e.g in Polity likewise do same for other subject Articles)
                        ["Judicial Appointments", "Collegium System", "Gender Imbalance", "All India Judicial Service", "Article 312", "Representation of Women", "Constitutional Mandate"]`;

                        const userPrompt = contentDiv.innerText;
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (result && result.trim()) {
                            try {
                                const jsonMatch = result.match(/\[[\s\S]*?\]/);
                                if (!jsonMatch) throw new Error("AI did not return a valid JSON array.");

                                const keywords = JSON.parse(jsonMatch[0]);

                                if (!Array.isArray(keywords) || keywords.length === 0) {
                                    App.ui.showToast("AI could not identify any key concepts.", "info");
                                    return;
                                }

                                const solidColors = App.commandPalette.state.textileColors.filter(c => !isNaN(c));
                                const tilesHTML = keywords.map((keyword, index) => {
                                    const color = solidColors[index % solidColors.length];
                                    const escapedKeyword = App.util.escapeHtml(keyword.trim());
                                    return `
                                    <div class="nk-text-tile color-${color}" data-color="${color}" contenteditable="false">
                                        <div class="nk-text-tile-content" contenteditable="true">${escapedKeyword}</div>
                                    </div>`;
                                }).join('');

                                const deckHTML = `
                                <div class="nk-textile-deck" contenteditable="false">
                                    <div class="deck-layout-toggle" title="Toggle Layout"><i class="fa-solid fa-table-cells"></i></div>
                                    ${tilesHTML}
                                </div>`;

                                const separatorHtml = `
                                <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                                <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                     Key Concepts 
                                </div>
                            `;

                                contentDiv.insertAdjacentHTML('beforeend', separatorHtml + deckHTML + '<p><br></p>');

                                const finalElement = contentDiv.lastElementChild.previousElementSibling; // a bit of a hack to target the deck
                                if (finalElement) {
                                    finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                                App.ui.showToast("Key concepts have been extracted!", 'success');
                                App.state.isArticleDirty = true;

                            } catch (error) {
                                console.error("KashKeywords Error:", error, "AI Response:", result);
                                App.ui.showToast("AI returned an invalid format for keywords.", "error");
                            }
                        } else {
                            App.ui.showToast("The AI could not extract any keywords. Please try again.", "warning");
                        }
                    },

                    async executeKashScript() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("The script needs a story! The article is empty.", "warning");
                            return;
                        }

                        const systemPrompt = `You are a focused, friendly, and witty scriptwriter for a short social media video, like a writer for a top Indian YouTuber. Your job is to turn a serious article into a short, punchy, and funny video script. Your audience is from the Indian subcontinent, so the humor should be relatable.

                        **Your Method:**
                        1.  Read the entire article, but focus on the SINGLE most interesting, surprising, or absurd story. Ignore everything else.
                        2.  Produce a copy-ready spoken script of approximately 250 words (~120 seconds).

                        **Strict Script Rules:**
                        1.  **Hook (CRITICAL):** You MUST begin with a strong, funny, one-line hook (under 24 words) that cleverly summarizes the whole topic. For example, if the topic is complex bureaucracy, a hook could be: "You think getting your Aadhaar card updated was hard? Wait till you hear about this..."
                        2.  **Body:** Write in a conversational style with short, easy-to-say sentences. Structure it into 3-5 clear 'beats' or mini-sections.
                        3.  **Humor:** Scatter 2-4 light, relatable punchlines. Compare complex topics to simple things like cricket, Bollywood, or dealing with family.
                        4.  **Ending:** End with a final, memorable, and funny punchline that leaves a strong impression.

                        **Final Output Rules:**
                        - Do NOT invent facts. Stick to the article's information.
                        - Avoid jargon and complicated words.
                        - Output ONLY the final script text. No titles, no "(Scene start)", no character names, no timestamps, no captions, no metadata. Just the spoken words, ready for a teleprompter.`;

                        const userPrompt = contentDiv.innerText;
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (result && result.trim()) {
                            const scriptText = result.trim();
                            // Convert the plain text script with newlines into proper HTML paragraphs
                            const scriptHtml = App.util.textToHtml(scriptText);

                            const finalHtml = `
                            <div class="nk-text-tile color-ghost-1" contenteditable="false" style="margin-top: 1em; display: block; max-width: 100%;">
                                <span class="nk-text-tile-icon"></span>
                                <div class="nk-text-tile-content" contenteditable="true" style="white-space: normal;">
                                    ${scriptHtml}
                                </div>
                            </div>`;

                            const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">`;

                            contentDiv.insertAdjacentHTML('beforeend', separatorHtml + finalHtml + '<p><br></p>');

                            const finalElement = contentDiv.lastElementChild.previousElementSibling;
                            if (finalElement) {
                                finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                            App.ui.showToast("Your script is ready!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("The AI couldn't find a good story. Please try again.", "warning");
                        }
                    },
                    async executeKashStory() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Can't tell a story about an empty page!", "warning");
                            return;
                        }

                        const systemPrompt = `You are 'Kash, the Story-Weaver,' a creative and witty storyteller for the NoteKash app. Your unique talent is transforming dry, factual articles into short, funny, and highly memorable fictional stories. Your audience is students who need to remember complex information in an engaging way.

                        **Core Mission:**
                        Carefully read the provided article. Identify the single most important subject and create a vivid, fictional narrative to explain it, embedding the article's facts naturally. A great technique is to personify the core concept as a quirky character (e.g., 'The Collegium System was a very exclusive club...').

                        **Storytelling Rules (Checklist):**
                        1.  **Factual Core:** All facts, dates, numbers, and definitions MUST come directly from the article. Use exact phrases where possible. If a fact is missing, state 'Not specified.'
                        2.  **Creative & Funny Fiction:** Weave the facts into a humorous, fictional story. Invent harmless details and funny scenarios to make the facts stick.
                        3.  **Visual Punchlines:** Include 2-3 short, visual, and funny moments to keep the story engaging.
                        4.  **Structure & Length:** The story must be 200-500 words with a clear beginning, middle, and end.
                        5.  **Handling Multiple Subjects:** If the article clearly covers different topics with the same name, create a separate story for each, prefixed with \`Subject: <name>\`.

                        **Final Output Format (CRITICAL):**
                        - Respond ONLY with the story text (and the \`Subject:\` prefix if needed).
                        - DO NOT include titles, headings, explanations, or any text other than the story itself.
                        - Keep story interesting, vivid, memorable, catchy, without using too much jargon.
                        - DO NOT use markdown or code fences.`;

                        const userPrompt = contentDiv.innerText;
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (result && result.trim()) {
                            const storyText = result.trim();
                            const storyHtml = App.util.textToHtml(storyText);

                            const finalHtml = `
                            <div class="nk-text-tile color-ghost-2" contenteditable="false" style="margin-top: 1em; display: block; max-width: 100%;">
                                <span class="nk-text-tile-icon"></span>
                                <div class="nk-text-tile-content" contenteditable="true" style="white-space: normal;">
                                    ${storyHtml}
                                </div>
                            </div>`;

                            const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">`;

                            contentDiv.insertAdjacentHTML('beforeend', separatorHtml + finalHtml + '<p><br></p>');

                            const finalElement = contentDiv.lastElementChild.previousElementSibling;
                            if (finalElement) {
                                finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                            App.ui.showToast("A new story has been written!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("The AI couldn't spin a tale from this. Please try again.", "warning");
                        }
                    },
                    async executeKashExplain() {
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();

                        if (!selectedText) {
                            App.ui.showToast("Please select text to explain.", "warning");
                            return;
                        }

                        const systemPrompt = `You are 'Kash, the Clarifier,' an AI expert integrated into a note-taking app. Your unique skill is to instantly become a world-class specialist on the subject of the user's selected text and then explain it with unparalleled clarity and lucidity for a student.

                        **Your Two-Step Process:**
                        1.  **Act as an Expert:** First, deeply analyze the selected text. If the topic is 'Quantum Physics,' you are a physicist. If it's 'Monetary Policy,' you are an economist.
                        2.  **Teach with Clarity:** Second, use your expertise to generate a compact, copy-ready explanation. Use simple analogies to explain complex topics.

                        **Strict Output Structure (Checklist):**
                        Your response MUST contain ONLY the following, in this exact order:
                        1.  **(Optional) Title:** A one-line title if a clear subject is present.
                        2.  **Summary:** A 1-2 sentence plain-language summary of the core idea.
                        3.  **In-Depth Explanation:** 3-6 short bullet points (\`\`) covering: what it is, how it works, why it's important, and any key limitations.
                        4.  **Practical Examples:** 2-4 numbered examples. If the topic allows, must be most relevant examples with applications too.

                        **Guiding Principles:**
                        - **Source Fidelity:** Base your explanation strictly on the provided text. Use exact phrases when possible. If a detail is missing, add it from reliable source but make sure you clear the concept to Student.
                        - **Multiple Subjects:** If needed, create separate sections prefixed with \`Subject: <name>\`.

                        **Final Output Format (CRITICAL):**
                        - Respond ONLY with the plain text explanation.
                        - DO NOT include headings (like 'Summary'), explanations about your process, markdown, or code fences.`;

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);

                        if (result && result.trim()) {
                            const explanationText = App.util.escapeHtml(result.trim());
                            const finalHtml = `
                            <div class="nk-text-tile color-ghost-1" contenteditable="false" style="margin-top: 1em; display: block; max-width: 100%;">
                                <span class="nk-text-tile-icon"></span>
                                <div class="nk-text-tile-content" contenteditable="true" style="white-space: pre-wrap; font-family: var(--font-body); font-size: 0.9em; line-height: 1.6;">${explanationText}</div>
                            </div>`;

                            selection.collapseToEnd();
                            document.execCommand('insertHTML', false, finalHtml + '<p><br></p>');
                            App.ui.showToast("Explanation generated!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("AI could not generate an explanation.", "warning");
                        }
                    },
                    async executeKashMnemonic() {
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();

                        if (!selectedText) {
                            App.ui.showToast("Please select text to create a mnemonic from.", "warning");
                            return;
                        }

                        const systemPrompt = `You are a focused mnemonic-maker for a note-taking app. Your task is to analyze the user's selected text, extract the core concept, and generate a compact, copy-ready output for memorization. Use only the provided text and reliable, general knowledge. Prefer using exact phrases from the text ('extractive phrasing').

                        Your response MUST have structure of :
                            **Optional Title:** A single, descriptive title if a clear concept is identifiable. If not, omit this line.
                            **Mnemonics:** Exactly three mnemonic options, labeled precisely as follows:
                            1) Simple & Catchy: [Mnenomic try 1- In english while being catchy]
                            Usage: [An explanation note]
                            2) Subcontinent-Flavored: [Mnenomic try 2- with a basic South Asian cultural flavor]
                            Usage: [An explanation note]
                            3) Acronym/Rhyme: [A short acronym or rhyming phrase].
                            Usage: [An explanation note]

                        **RULES:**
                        - DO NOT include any headings like "Title", "Bullet Points", or "Mnemonics".
                        - DO NOT use jargon, vivid stories, or invent facts. If a detail is missing, write 'Not specified.'
                        - DO NOT wrap your response in code fences or markdown.`;

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);

                        if (result && result.trim()) {
                            const mnemonicText = App.util.escapeHtml(result.trim());
                            // Use a <pre> tag inside a styled div to perfectly preserve the line breaks and spacing from the AI's response.
                            const finalHtml = `
                            <div class="nk-text-tile color-ghost-2" contenteditable="false" style="margin-top: 1em; display: block; max-width: 100%;">
                                <div class="nk-text-tile-content" contenteditable="true" style="white-space: pre-wrap; font-family: var(--font-body); font-size: 0.9em; line-height: 1.6;">${mnemonicText}</div>
                            </div>`;


                            selection.collapseToEnd();
                            document.execCommand('insertHTML', false, finalHtml + '<p><br></p>');
                            App.ui.showToast("Mnemonic generated!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("AI could not generate a mnemonic. Please try again.", "warning");
                        }
                    },



                    async executeKashAccordion() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Your note is empty. Add some content first!", "warning");
                            return;
                        }

                        const toastId = App.ui.showToast(' AI is generating insightful Q&A...', { type: 'info', duration: 0 });
                        const articleContent = contentDiv.innerText;

                        const systemPrompt = `You are an expert educator (of subject you writing QnA on) and content architect for the NoteKash app. Your task is to analyze the provided [Article Content] and, by synthesizing it with your own vast but reliable knowledge base, generate a set of 3 to 8 insightful Question & Answer pairs.

                    **Core Directives:**
                    1.  The questions should probe for deeper understanding, asking "why", "how", and exploring implications.
                    2.  The answers should be concise, clear, and directly address the question, acting as perfect revision material.
                    3.  You must use both the provided text and your own vast knowledge to create the best possible Q&A set for a student.

                    **CRITICAL OUTPUT FORMAT:**
                    Your ENTIRE response MUST be a single, valid JSON array of objects. Do NOT include any other text or markdown.
                    Each object in the array represents one accordion and MUST have two keys:
                    1.  "question": A string for the accordion title.
                    2.  "answer": A string for the accordion content.

                    **Example JSON Response:**
                    [
                        {
                            "question": "What is the primary function of mitochondria?",
                            "answer": "The primary function of mitochondria is to generate most of the cell's energy in the form of adenosine triphosphate (ATP)."
                        },
                        {
                            "question": "How does the collegium system impact judicial appointments?",
                            "answer": "It gives primacy to the Chief Justice of India and the senior-most judges of the Supreme Court in the appointment and transfer of judges, aiming to ensure judicial independence."
                        }
                    ]`;

                        try {
                            const result = await App.services.ai.queryGenerativeAI(systemPrompt, articleContent);
                            App.ui.hideToast(toastId);

                            if (!result || !result.trim()) {
                                throw new Error("AI returned an empty response.");
                            }

                            const jsonMatch = result.match(/\[\s*\{[\s\S]*?\}\s*\]/s);
                            if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");

                            const qaPairs = JSON.parse(jsonMatch[0]);
                            if (!Array.isArray(qaPairs) || qaPairs.length === 0) {
                                throw new Error("Parsed data is not a valid array of Q&A pairs.");
                            }

                            const accordionsHTML = qaPairs.map(item => {
                                if (!item.question || !item.answer) return '';
                                const cleanQuestion = App.util.escapeHtml(item.question.trim());
                                const cleanAnswer = App.util.escapeHtml(item.answer.trim());
                                const cardId = 'acc_' + crypto.randomUUID();
                                const contentId = 'acc-content-' + cardId;

                                return `
                                <div class="nk-accordion" data-state="closed" data-id="${cardId}">
                                    <div class="nk-accordion-trigger" role="button" tabindex="0" aria-expanded="false" aria-controls="${contentId}">
                                        <span class="nk-accordion-title" contenteditable="true"><b>${cleanQuestion}</b></span>
                                        <div class="nk-accordion-controls">
                                            <button class="nk-accordion-control-btn nk-accordion-hint-btn" title="Add/Edit Hint">${App.util.icons.hint}</button>
                                            <button class="nk-accordion-control-btn nk-accordion-reversible-toggle" title="Make Reversible">${App.util.icons.reversible}</button>
                                            <svg class="nk-accordion-chevron" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"></polyline></svg>
                                        </div>
                                    </div>
                                    <div id="${contentId}" class="nk-accordion-content" contenteditable="true"><p>${cleanAnswer}</p></div>
                                </div>`;
                            }).join('');

                            if (!accordionsHTML.trim()) {
                                throw new Error("Failed to generate HTML from AI response.");
                            }

                            const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                            <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                 AI Generated Q&A 
                            </div>`;

                            contentDiv.insertAdjacentHTML('beforeend', separatorHtml + accordionsHTML + '<p><br></p>');
                            App.ui.showToast(`${qaPairs.length} Q&A accordions generated!`, 'success');
                            App.state.isArticleDirty = true;

                            const finalElement = contentDiv.lastElementChild;
                            if (finalElement) {
                                finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }

                        } catch (error) {
                            App.ui.hideToast(toastId);
                            App.ui.showToast(`AI failed: ${error.message}`, "error");
                            console.error("KashAccordion Generation Error:", error);
                        }
                    },

                    async executeKashHighlight() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Article is empty, nothing to highlight.", "warning");
                            return;
                        }

                        const systemPrompt = `You are an intelligent highlighting tool for a note-taking app. Your task is to analyze the provided article and identify ONLY the most crucial phrases, sentences, or data points (5-10 key points). For each identified piece of text, you must return a JSON object with two keys: "text" (the exact, verbatim text from the article to be highlighted) and "color" (a number from 1 to 6). Use can use different colors contextually (not necessary): 1 for main ideas, 2 for supporting evidence, 3 for names/dates, 4 for warnings/negatives, 5 for key terms, 6 for conclusions. Be very selective and brief. Respond ONLY with a valid JSON array of these objects. Example: [{"text": "the central thesis is...", "color": 1}, {"text": "a critical disadvantage", "color": 4}]`;

                        const userPrompt = contentDiv.innerText;

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (result && result.trim()) {
                            try {
                                const jsonMatch = result.match(/\[\s*\{[\s\S]*?\}\s*\]/);
                                if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");

                                const highlights = JSON.parse(jsonMatch[0]);
                                if (!Array.isArray(highlights)) throw new Error("AI did not return an array.");

                                const walker = document.createTreeWalker(contentDiv, NodeFilter.SHOW_TEXT);
                                const textNodes = [];
                                while (walker.nextNode()) textNodes.push(walker.currentNode);

                                let highlightsApplied = 0;
                                highlights.forEach(highlight => {
                                    if (!highlight.text || !highlight.color) return;

                                    const textToHighlight = highlight.text.trim();
                                    const colorClass = `highlight-${highlight.color}`;
                                    const snippetId = `snip-${crypto.randomUUID().slice(0, 12)}`;

                                    for (const node of textNodes) {
                                        const index = node.nodeValue.indexOf(textToHighlight);
                                        if (index !== -1 && !node.parentElement.closest('span[class*="highlight-"]')) {
                                            const range = document.createRange();
                                            range.setStart(node, index);
                                            range.setEnd(node, index + textToHighlight.length);

                                            const highlightSpan = document.createElement('span');
                                            highlightSpan.className = colorClass;
                                            highlightSpan.id = snippetId;
                                            range.surroundContents(highlightSpan);

                                            highlightsApplied++;
                                            break;
                                        }
                                    }
                                });

                                if (highlightsApplied > 0) {
                                    App.ui.showToast(`${highlightsApplied} key sections highlighted!`, 'success');
                                    App.state.isArticleDirty = true;
                                } else {
                                    App.ui.showToast("AI found highlights, but they could not be applied to the text.", "warning");
                                }


                            } catch (error) {
                                console.error("KashHighlight Error:", error, "AI Response:", result);
                                App.ui.showToast("AI returned an invalid format for highlighting.", "error");
                            }
                        } else {
                            App.ui.showToast("AI could not generate highlights.", "warning");
                        }
                    },

                    async executeImproveWriting() {
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();
                        if (!selectedText) {
                            App.ui.showToast("Please select text to get writing suggestions.", "warning");
                            return;
                        }

                        const systemPrompt = `You are an expert writing assistant. A user has selected a piece of text and wants alternative phrasings. Produce rewrites in these tones: "Simpler" (most concise while preserving meaning), "Friendly" (warm, conversational), "Confident" (direct and assertive), "Persuasive" (engaging and influential), "Poetic" (lyrical, using metaphor or rhythm), and "Funny" (witty and humourous with touch of subcontinent). Respond ONLY with a valid JSON array of objects in this exact form: [{"tone":"Simpler","text":"..."}, {"tone":"Friendly","text":"..."}, ...]. The "Simpler" object must be the first item. Preserve the original meaning, avoid inventing facts, keep each rewrite natural and ready to use, and include no extra fields, commentary, or surrounding text.`;

                        const userPrompt = selectedText;
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (result && result.trim()) {
                            try {
                                // Robustly find and parse the JSON array from the AI's response
                                const jsonMatch = result.match(/\[\s*\{[\s\S]*?\}\s*\]/);
                                if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");

                                const alternatives = JSON.parse(jsonMatch[0]);
                                if (!Array.isArray(alternatives)) throw new Error("AI did not return an array of suggestions.");

                                // Format the output into a clean, readable blockquote
                                let suggestionsHtml = alternatives.map(alt =>
                                    `<h4>${App.util.escapeHtml(alt.tone)}</h4>
                                <p>${App.util.escapeHtml(alt.text)}</p>`
                                ).join('<hr style="border-top: 1px solid var(--border-color); margin: 0.5em 0;">');

                                const finalHtml = `
                                <blockquote contenteditable="false" style="margin-top: 1em;">
                                    <h4 style="font-weight: 600;">Original Text</h4>
                                    <p><em>${App.util.escapeHtml(selectedText)}</em></p>
                                    <hr style="border-top: 2px solid var(--border-color); margin: 1em 0;">
                                    ${suggestionsHtml}
                                </blockquote>
                                <p><br></p>`;

                                // Collapse the selection to the end and insert the HTML after it
                                selection.collapseToEnd();
                                document.execCommand('insertHTML', false, finalHtml);

                                App.ui.showToast("Writing suggestions generated!", 'success');
                                App.state.isArticleDirty = true;

                            } catch (error) {
                                console.error("KashWriting Error:", error, "AI Response:", result);
                                App.ui.showToast("AI returned an invalid format for suggestions.", "error");
                            }
                        } else {
                            App.ui.showToast("AI could not generate suggestions.", "warning");
                        }
                    },
                    async executeKashListify() {
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();
                        if (!selectedText) {
                            App.ui.showToast("Please select text to convert to a list.", "warning");
                            return;
                        }

                        const systemPrompt = "Analyze the following text. Identify the main distinct points and restructure them as a concise markdown bulleted list. Respond ONLY with the markdown list, with each item on a new line starting with `* `.";
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);

                        if (result && result.trim()) {
                            const listItems = result.trim().split('\n').map(line => {
                                const cleanLine = line.replace(/^\s*[\*\-]\s*/, '').trim();
                                return `<li>${App.util.escapeHtml(cleanLine)}</li>`;
                            }).join('');
                            const listHtml = `<ul>${listItems}</ul><p><br></p>`;
                            document.execCommand('insertHTML', false, listHtml);
                            App.ui.showToast("Text converted to list!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("AI could not create a list from the selected text.", "warning");
                        }
                    },

                    async executeKashTimeline() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("The article is empty. Add some content to create a timeline from.", "warning");
                            return;
                        }

                        const articleContent = contentDiv.innerText;
                        const toastId = App.ui.showToast(' AI is synthesizing your timeline...', { type: 'info', duration: 0 });

                        const systemPrompt = `You are 'Kash, the Chronicler,' an expert AI historian and Data Visualizer and TimeLine Maker. Your mission is to analyze an article and extract the most important information as a structured list of timeline events.

                        **Your Core Directive:**
                        1.  **Act as an Expert:** Use your own knowledge as a subject matter expert on the topic to understand the key sequence of events, concepts, or stages within the user's [Article Content].
                        2.  **Extract Data:** Identify the 5-16 most critical points and extract the data for each point into a pair of values: a "date" and a "title".
                            * The "date" can be an actual date (e.g., "1978"), a concept (e.g., "Article 20"), or a stage (e.g., "Step 1"). So Date changes according to Article content and use your Creativity to break Article down into Steps (which can be anything from Articles in polity to Questions). "Date" could be questionslike "why","who","when","how" etc. 
                            * The "title" is the description of the event or concept or explanation or example or detail etc..
                            * So you can be creative to embedd the most rigid information in the form of structured Timeline. Innovation is key to success and you have to innovate if content doesnt follow any structure, to put it in structure , use your all ability and knowledge to make a revision timeline.

                        **Strict Output Format (CRITICAL):**
                        Your entire response MUST be a single, valid JSON array of objects. Each object must have exactly two keys: "date" (which can even not be a date got it?) and "title".

                        **Example Response:**
                        [ {"date": "1978", "title": "The landmark Maneka Gandhi vs. Union of India case significantly broadened the scope of Article 21."},
                        {"date": "Article 20", "title": "Provides safeguards against arbitrary and excessive punishment, including protections against ex post facto laws, double jeopardy, and self-incrimination."},
                        {"date": "Article 21", "title": "Guarantees the protection of life and personal liberty, which the Supreme Court has interpreted to include the right to live with dignity and privacy."},
                        {"date": "What is life", "title":"Biology is the scientific study of life and living organisms, encompassing their structure, function, growth, origin, evolution, and distribution"}, 
                        ]`;

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, articleContent);
                        App.ui.hideToast(toastId);

                        if (result && result.trim()) {
                            try {
                                // Find the JSON array within the AI's response
                                const jsonMatch = result.match(/\[\s*\{[\s\S]*?\}\s*\]/s);
                                if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");

                                const timelineData = JSON.parse(jsonMatch[0]);
                                if (!Array.isArray(timelineData) || timelineData.length === 0) {
                                    throw new Error("AI did not return any timeline entries.");
                                }

                                const timelineEntriesHTML = timelineData.map(entry => {
                                    if (!entry.date || !entry.title) return ''; // Skip invalid entries
                                    const cleanDate = App.util.escapeHtml(entry.date);
                                    const cleanTitle = App.util.escapeHtml(entry.title);
                                    return `
                                    <div class="nk-timeline-entry">
                                        <div class="nk-timeline-content">
                                            <div class="nk-timeline-date" contenteditable="true">${cleanDate}</div>
                                            <div class="nk-timeline-title" contenteditable="true">${cleanTitle}</div>
                                        </div>
                                    </div>
                                `;
                                }).join('');

                                if (!timelineEntriesHTML) throw new Error("Generated timeline data was empty or invalid.");

                                const separatorHtml = `<hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                                            <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                                 NoteKash AI Timeline 
                                            </div>`;

                                const finalTimelineHtml = `
                                <div class="nk-timeline-block" contenteditable="false">
                                    ${timelineEntriesHTML}
                                </div>`;


                                contentDiv.insertAdjacentHTML('beforeend', separatorHtml + finalTimelineHtml + '<p><br></p>');

                                const newTimeline = contentDiv.querySelector('.nk-timeline-block:last-of-type');
                                if (newTimeline) {
                                    newTimeline.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }

                                App.ui.showToast("AI-generated timeline inserted!", 'success');
                                App.state.isArticleDirty = true;

                            } catch (error) {
                                App.ui.showToast("AI could not generate a valid timeline from the text.", "warning");
                                console.error("Timeline Generation Failed:", error, "AI Response:", result);
                            }
                        } else {
                            App.ui.showToast("AI returned an empty response.", "warning");
                        }
                    },

                    async executeKashOutline(topic) {
                        if (!topic) {
                            App.ui.showToast("Please provide a topic for the outline.", "warning");
                            return;
                        }

                        const systemPrompt = "You are an expert academic planner with expertise in given Topic. Generate a structured and hierarchical outline for the given Topic. The outline should be detailed, with main points and several sub-points for each. Use nested HTML unordered lists (<ul> and <li>). Respond ONLY with the complete HTML list structure, without any surrounding text or markdown fences.";

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, topic);

                        if (result && result.trim().startsWith('<ul>')) {
                            const outlineHtml = result.trim() + '<p><br></p>';
                            document.execCommand('insertHTML', false, outlineHtml);
                            App.ui.showToast(`Outline for "${topic}" generated!`, 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("AI could not generate an outline for this topic.", "warning");
                        }
                    },

                    async executeKashExpand() {
                        const selection = window.getSelection();
                        if (!selection || selection.rangeCount === 0) {
                            App.ui.showToast("Place your cursor where you want the AI to continue writing.", "warning");
                            return;
                        }

                        const range = selection.getRangeAt(0);
                        const container = range.startContainer;

                        // Find the parent block element (p, li, h1, etc.) to get the full context. This part remains the same.
                        const parentBlock = (container.nodeType === 3 ? container.parentElement : container).closest('p, li, h1, h2, h3, h4, h5, h6, blockquote, div');

                        if (!parentBlock || !document.getElementById('article-content').contains(parentBlock)) {
                            App.ui.showToast("AI can only continue writing within a text block.", "warning");
                            return;
                        }

                        const contextRange = document.createRange();
                        contextRange.setStart(parentBlock, 0);
                        contextRange.setEnd(range.startContainer, range.startOffset);
                        const contextText = contextRange.toString();


                        if (contextText.trim() === '') {
                            App.ui.showToast("There isn't enough context for the AI to continue. Please write something first.", "warning");
                            return;
                        }

                        const systemPrompt = `You are an intelligent writing assistant who completely understands and has expertise in subject matter the user is writing about. The user has provided text they have written so far. Your task is to seamlessly continue writing from where they left off.
                    - If the user stopped mid-sentence, complete that sentence naturally and then write 3 more related sentences.
                    - If the user stopped at the end of a sentence, write 4 new sentences that logically follow.
                    - Maintain the original tone, style, and topic of the provided text.
                    - Respond ONLY with the newly generated text. Do not repeat the user's original text in your response.`;

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, contextText);

                        if (result && result.trim()) {
                            const generatedText = " " + result.trim();

                            // Use the original live range to insert the AI's response at the cursor
                            range.insertNode(document.createTextNode(generatedText));

                            range.setStartAfter(range.endContainer);
                            range.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(range);

                            App.ui.showToast("AI continued writing!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("The AI couldn't think of what to write next. Please try again.", "warning");
                        }
                    },
                    async executeKashQuote() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Your note is empty. Add some content for the AI to analyze.", "warning");
                            return;
                        }
                        const userPrompt = contentDiv.innerText;

                        const systemPrompt = `You are 'Kash, the Quote Master,' an AI expert with the combined knowledge of a historian, a philosopher, and a literary scholar. Your sole purpose is to analyze a user's text and find the single most insightful and contextually relevant quote to enhance their writing. You must adhere to a strict process and output format.

                        **Your Thought Process (Follow these steps internally):**

                        1.  **Thematic Distillation:** First, read the entire article content to distill its core theme, central argument, and overall tone. Are you reading a critical analysis of a government policy, a philosophical reflection on learning, or a historical account of an event?

                        2.  **Conceptual Extraction:** Second, based on the theme, identify 3-5 key concepts, nouns, or abstract ideas that are central to the text (e.g., 'judicial independence', 'bureaucracy', 'economic reform', 'the nature of memory', 'creative struggle').

                        3.  **Intelligent Search & Selection:** Third, search your vast internal library of quotations. Your goal is to find a quote that doesn't just match a keyword, but one that **resonates with the underlying argument, tension, or situation** described in the text.
                            * **Prioritize insight over fame:** A lesser-known but perfectly relevant quote is far better than a famous but generic one.
                            * The best quote is one that offers a profound summary, a sharp counterpoint, a piece of timeless wisdom, or a witty perspective on the article's specific theme.

                        **Strict Output Format:**

                        After completing your internal thought process, you MUST respond ONLY with a single, valid JSON object containing the quote and the author.

                        * The JSON object must have two keys: "quote" and "author".
                        * Do NOT include any explanations, greetings, conversational text, or markdown formatting. Your entire response must be just the JSON object.

                        **Example Response Format:**
                        {"quote": "The art of writing is the art of discovering what you believe.", "author": "Gustave Flaubert"}`;

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                        if (result && result.trim()) {
                            try {
                                const jsonMatch = result.match(/\{\s*"quote"[\s\S]*?\}/s);
                                if (!jsonMatch) throw new Error("AI response did not contain a valid JSON object.");

                                const parsedQuote = JSON.parse(jsonMatch[0]);

                                if (!parsedQuote.quote || !parsedQuote.author) {
                                    throw new Error("JSON response is missing 'quote' or 'author' key.");
                                }
                                const quoteHtml = `
                                <blockquote contenteditable="false" style="margin: 1.5em 0; border-left: 3px solid var(--primary-color); padding-left: 1.5em; font-style: italic;">
                                    <p style="font-size: 1.1em; line-height: 1.6;">${App.util.escapeHtml(parsedQuote.quote)}</p>
                                    <footer style="text-align: right; font-size: 1em; font-style: normal; color: var(--text-secondary); margin-top: 0.5em;"> ${App.util.escapeHtml(parsedQuote.author)}</footer>
                                </blockquote>`;

                                App.util.insertGuardianBlock(quoteHtml); // Use our helper for clean insertion
                                App.ui.showToast("Contextual quote inserted!", 'success');
                                App.state.isArticleDirty = true;

                            } catch (error) {
                                console.error("KashQuote Error:", error, "AI Response:", result);
                                App.ui.showToast("AI returned an invalid format for the quote.", "error");
                            }
                        } else {
                            App.ui.showToast("The AI couldn't find a suitable quote. Please try again.", "warning");
                        }
                    },

                    async executeKashExtract(subCommand) {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Your note is empty. Add some content for the AI to analyze.", "warning");
                            return;
                        }
                        const articleContent = contentDiv.innerText;

                        const systemPrompt = `You are 'KashExtractor', a hyper-intelligent research assistant embedded within the NoteKash app. Your entire universe of knowledge is strictly limited to the user-provided 'Article Content'. You will be given a [Sub-command] and the [Article Content]. Your task is to follow the logic below precisely and respond ONLY with a single, complete HTML block.

                        **Core Logic Flow:**

                        1.  **IF the [Sub-command] is 'default', empty, or just whitespace:**
                            * Provide a single, dense paragraph that summarizes the core thesis and main points of the article.
                            * **HTML Output:** Wrap this summary in \`<p>...\</p>\`.

                        2.  **ELSE IF the [Sub-command] is a structured request ('dates', 'names', 'stats', 'acronyms', 'laws', 'arguments'):**
                            * Scour the [Article Content] for the requested data type.
                            * For each item found, provide a brief, context-aware description based **only** on the information present in the article.
                            * **HTML Output:** Format the entire response as a single HTML unordered list \`<ul>\`. Each item must be \`<li><b>[Extracted Item]:</b> [Contextual description from article]</li>\`.

                        3.  **ELSE (treat any other [Sub-command] as a Natural Language Query):**
                            * This is your most important task. Follow this two-step process meticulously:
                            * **Step A: Internal Search.** First, you MUST scour the [Article Content] to find a direct answer to the user's query.
                            * **Step B: Formulate Response.**
                                * **If an answer is found:** Your response MUST begin with the exact phrase "<strong>From the Article: </strong>". Then, provide the answer, quoting the relevant part if possible.
                                * **If NO answer is found:** Your response MUST begin with the exact phrase "<strong>Not in Article: </strong>". Put this in braces. Then, you may use your general knowledge to provide a brief answer, prefacing it with "However, according to reliable sources...".
                            * **HTML Output:** Format your response as a simple \`<p>...\</p>\` or \`<blockquote>...</blockquote>\`.

                        **CRITICAL FINAL RULES:**
                        * Your ENTIRE response must be ONLY the generated HTML content.
                        * Do NOT include \`\`\`html\` or any other markdown fences.
                        * Do NOT include any conversational text, greetings, or explanations outside of the required HTML.
                        * If the article is empty or irrelevant to the query, simply respond with \`<p>The article does not contain enough information to answer this query.</p>\`.`;

                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, `[Sub-command]: ${subCommand}\n\n[Article Content]:\n${articleContent}`);

                        if (result && result.trim()) {
                            const cleanedHtml = result.trim().replace(/^```(html)?\n?/, '').replace(/\n?```$/, '');

                            const titleText = subCommand === 'default' ? 'Article Summary' : `Extraction: "${subCommand}"`;

                            const finalHtml = `
                            <div class="nk-text-tile color-ghost-2" contenteditable="true" data-color="ghost-2">
                                <div class="nk-text-tile-content" contenteditable="true" style="white-space: normal;">
                                    <h4 style="margin-top: 0; font-weight: 600;" contenteditable="false">${App.util.escapeHtml(titleText)}</h4>
                                    ${cleanedHtml}
                                </div>
                            </div>`;

                            App.util.insertGuardianBlock(finalHtml);
                            App.ui.showToast("Extraction complete!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("The AI could not extract the requested information.", "warning");
                        }
                    },

                    async executeKashLink(topic) {
                        if (!topic) {
                            App.ui.showToast("Please provide a topic to create and link.", "warning");
                            return;
                        }

                        const contentDiv = document.getElementById('article-content');
                        const existingNoteContext = (contentDiv && contentDiv.textContent.trim())
                            ? contentDiv.innerText
                            : "The user's current note is empty.";

                        const generationToast = App.ui.showToast(` AI is writing about "${topic}"...`, { type: 'info', duration: 0 });

                        const generationPrompt = `You are a distinguished academic writer and subject matter expert. Your goal is to create a new, linked note for the user that is contextually aware of what they are already writing. Your new written note should be factually accurate and reliable.

                        **You will be given two inputs:**
                        1.  **[Existing Note Context]:** The text from the note the user is currently writing.
                        2.  **[New Note Topic]:** The topic for the new note, which may include specific instructions.

                        **Your Primary Directive (A 3-Step Process):**

                        1.  **Analyze Context:** First, carefully read the [Existing Note Context] to understand its main theme, arguments, and the specific facts already mentioned.

                        2.  **Analyze Intent:** Second, analyze the [New Note Topic] string.
                            * **If it contains specific instructions** (e.g., 'create a table', 'list key points', 'short 2 tables on...'): Fulfill that request precisely and concisely. Your output should be exactly what the user asked for. For example, if the topic is "a short table on the Mauryan Kings," you MUST generate only a short HTML table and nothing else Similarly if user Request is "Long Table on Gupta Kings", you must generate a most exaustive and detailed table on all Gupta Kings.
                            * **If it's a general topic** (e.g., "The Ashokan Empire"): You will default to generating a comprehensive, well-structured introductory article. This default article MUST follow this structure:
                                1.  **Introduction:** A concise introductory paragraph most relevant to topic and have catchy words to attract users attention (hooks etc.).
                                2.  **Key Sections:** 2 to 5 distinct sections with \`<h2>\` catchy headings. Under those headings comprehsive content well-formatted.
                                3.  **Conclusion:** A summary paragraph for key-takeaways from content which you wrote.

                        3.  **Generate Context-Aware Content:** This is your most important task. When generating the content for the new note:
                            * **Tailor Relevance:** Focus on aspects of the [New Note Topic] that directly relate to or expand upon the [Existing Note Context].
                            * **DO NOT REPEAT:** You MUST AVOID repeating facts, definitions, or specific data points that are already present in the [Existing Note Context]. Your goal is to provide new, complementary information.

                        **Content & Formatting Rules (Apply to ALL responses):**
                        * Prioritize factual accuracy and reliability above everything else.
                        * Use a Neutral, Objective, Unbiased and Academic tone.
                        * Use clean HTML. Bold key terms with \`<b>\`. Use \`<ul>\` for lists and \`<table>\` for tables where appropriate (short tables should be used more often when possible, since they are good for presentation of content and revision).
                        * Respond ONLY with the required HTML content. Do NOT include \`<html>\`, \`<body>\`, markdown fences, or any conversational text.`;

                        const userPrompt = `[Existing Note Context]:\n${existingNoteContext}\n\n---\n\n[New Note Topic]:\n${topic}`;
                        const generatedContent = await App.services.ai.queryGenerativeAI(generationPrompt, userPrompt);

                        if (!generatedContent || !generatedContent.trim()) {
                            App.ui.hideToast(generationToast);
                            App.ui.showToast(`AI failed to generate content for "${topic}".`, "error");
                            return;
                        }

                        App.ui.updateToast(generationToast, ` AI is categorizing the new note...`);
                        const userCategoryNames = App.settings.get('userCategories').map(c => c.name);
                        const categorizationPrompt = `You are an expert librarian AI. Your task is to categorize a given text into one of the following user-provided categories. Analyze the text and respond with ONLY the single most appropriate category name from the list.

                **Available Categories:**
                ${userCategoryNames.join(', ')}`;

                        const suggestedCategory = await App.services.ai.queryGenerativeAI(categorizationPrompt, generatedContent);
                        const finalCategory = (suggestedCategory && userCategoryNames.includes(suggestedCategory.trim()))
                            ? suggestedCategory.trim()
                            : (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;

                        App.ui.updateToast(generationToast, ` Saving new note...`);
                        const newNoteTitle = topic.length > 100 ? topic.substring(0, 100) + '...' : topic;
                        const noteData = { title: newNoteTitle, content: generatedContent, category: finalCategory };
                        const newNote = await App.storage.createArticle(noteData);

                        if (!newNote) {
                            App.ui.hideToast(generationToast);
                            App.ui.showToast(`Failed to save the new note for "${topic}".`, "error");
                            return;
                        }

                        const linkHtml = `<a href="#" data-link-type="article" data-link-id="${newNote.id}">${App.util.escapeHtml(newNoteTitle)}</a>&nbsp;`;

                        App.util.restoreSelection();
                        document.execCommand('insertHTML', false, linkHtml);
                        App.state.isArticleDirty = true;

                        App.ui.hideToast(generationToast);
                        App.ui.showToast(`Created and linked new note: "${newNoteTitle}"!`, "success");
                    },


                    async executeKashSplit() {
                        const contentDiv = document.getElementById('article-content');
                        const originalArticle = App.storage.getArticle(App.state.activeArticleId);

                        if (!contentDiv || !originalArticle || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Cannot split an empty or unsaved note.", "warning");
                            return;
                        }
                        const originalContent = contentDiv.innerHTML;

                        const splitToast = App.ui.showToast(' AI is analyzing the best way to split your note...', { type: 'info', duration: 0 });

                        const splitPrompt = `You are an expert AI editor and content strategist named 'KashSplit'. Your sole purpose is to intelligently split a single long article into two shorter, thematically coherent, and self-contained notes.

                        **Your 4-Step Thought Process (Follow these steps internally):**

                        1.  **Full Comprehension:** First, read and fully comprehend the entire [Article Content] to understand its main narrative, key arguments, and overall structure.

                        2.  **Identify the Breakpoint:** Second, identify the single most logical and natural breakpoint in the article. This could be a transition between major topics, a chronological shift, or a move from a foundational concept to its applications. Do not simply split in the middle.

                        3.  **Rewrite & Refactor (Most Important Step):** Third, rewrite the content into two distinct parts.
                            * **Part 1:** This part must be a complete note. If you've split in the middle of a section, you MUST write a proper concluding sentence or paragraph for it.
                            * **Part 2:** This part must also be a complete note. You MUST write a proper introductory sentence or paragraph to provide context, as it will become a new, standalone note.
                            * **Preserve Everything:** You must not lose any facts, data, or key information from the original article. All content must be retained and correctly placed in either Part 1 or Part 2.
                            * **Strucute & Beautify:** While Refactoring content you can use <b>, <i>, and other formatting tools to beautify the content. Also CRITICALLY use TABLES for presentation and Revision, wherever possible.

                        4.  **Generate a New Title:** Fourth, create a new, concise, and descriptive title for the second part of the content. This title should accurately reflect the main topic of the new note.

                        **Strict Output Format (CRITICAL):**
                        Your response MUST be a single, valid JSON object. Do NOT include any other text, markdown, or explanations. The JSON object must have three keys:
                        1.  \`part1_html\`: A string containing the full, rewritten HTML content for the first note.
                        2.  \`part2_title\`: A string containing the new title for the second note.
                        3.  \`part2_html\`: A string containing the full, rewritten HTML content for the new, second note.`;

                        const result = await App.services.ai.queryGenerativeAI(splitPrompt, originalContent);

                        if (!result || !result.trim()) {
                            App.ui.hideToast(splitToast);
                            App.ui.showToast("AI could not split the note. Please try again.", "error");
                            return;
                        }

                        try {
                            const jsonMatch = result.match(/\{\s*"part1_html"[\s\S]*?\}/s);
                            if (!jsonMatch) throw new Error("AI response did not contain a valid JSON object.");
                            const splitData = JSON.parse(jsonMatch[0]);

                            if (!splitData.part1_html || !splitData.part2_title || !splitData.part2_html) {
                                throw new Error("JSON response is missing required keys.");
                            }

                            App.ui.updateToast(splitToast, ` Creating new note: "${splitData.part2_title}"...`);

                            // Create the second note
                            const newNote = await App.storage.createArticle({
                                title: splitData.part2_title,
                                content: splitData.part2_html,
                                category: originalArticle.category
                            });

                            if (!newNote) throw new Error("Failed to save the new split note.");

                            const linkHtml = `<p><br></p><blockquote><p><em>Continued in: <a href="#" data-link-type="article" data-link-id="${newNote.id}">${App.util.escapeHtml(newNote.title)}</a></em></p></blockquote>`;

                            const finalContentPart1 = splitData.part1_html + linkHtml;
                            const updateResult = await App.storage.updateArticle(originalArticle.id, {
                                title: originalArticle.title, // Keep original title
                                content: finalContentPart1
                            });

                            if (!updateResult.success) throw new Error("Failed to update the original note.");

                            App.ui.hideToast(splitToast);
                            App.ui.showToast("Note split successfully!", "success");
                            App.router.navigateTo('article', { id: originalArticle.id, mode: 'write' });


                        } catch (error) {
                            console.error("KashSplit Error:", error, "AI Response:", result);
                            App.ui.hideToast(splitToast);
                            App.ui.showToast("AI returned an invalid format. Could not split note.", "error");
                        }
                    },

                    async executeKashMcqGenerator() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Your note is empty. Add some content first!", "warning");
                            return;
                        }

                        const toastId = App.ui.showToast(' AI is crafting your questions...', { type: 'info', duration: 0 });
                        const articleContent = contentDiv.innerText;

                        const systemPrompt = `You are an expert educator and quiz designer integrated into the NoteKash app. Your task is to analyze the provided [Article Content] and, by synthesizing it with your own expert knowledge, create a set of 4 to 9 high-quality Multiple-Choice Questions (MCQs).

                    **Core Directives:**
                    1.  The questions must test deep comprehension of the material, not just surface-level facts.
                    2.  You must create plausible distractors (incorrect options) that are related to the topic but clearly wrong.
                    3.  Each question must have exactly one correct answer.
                    4.  The content should be a mix of information directly from the text and related concepts from your own knowledge base.

                    **Randomization Rule (CRITICAL):**
                    You MUST randomly distribute the position of the correct answer. The \`correct_index\` should have an equal chance of being 0, 1, 2, or 3. Do not favor any specific position.

                    **CRITICAL OUTPUT FORMAT:**
                    Your ENTIRE response MUST be a single, valid JSON array of objects. Do NOT include any other text, markdown, or explanations.
                    Each object in the array represents one MCQ and MUST have three keys:
                    1.  "question": A string containing the question text.
                    2.  "options": An array of 4 strings representing the choices.
                    3.  "correct_index": A number (0-based index) indicating which option in the "options" array is the correct one.

                    **Example JSON Response:**
                    [
                      {
                        "question": "According to the DPSP, what is the State's primary goal in India?",
                        "options": [
                          "To establish a military superpower.",
                          "To create a 'Welfare State' promoting social and economic justice.",
                          "To enforce Fundamental Rights exclusively.",
                          "To remain neutral in all social and economic matters."
                        ],
                        "correct_index": 1
                      }
                    ]`;

                        try {
                            const result = await App.services.ai.queryGenerativeAI(systemPrompt, articleContent);
                            App.ui.hideToast(toastId);

                            if (!result || !result.trim()) {
                                throw new Error("AI returned an empty response.");
                            }

                            const jsonMatch = result.match(/\`\`\`json\s*([\s\S]*?)\s*\`\`\`|(\[[\s\S]*\])/);
                            if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");

                            const mcqs = JSON.parse(jsonMatch[1] || jsonMatch[2]);
                            if (!Array.isArray(mcqs) || mcqs.length === 0) {
                                throw new Error("Parsed data is not a valid array of MCQs.");
                            }

                            const mcqBlocksHTML = mcqs.map(mcq => {
                                if (!mcq.question || !mcq.options || mcq.correct_index === undefined) return '';

                                const optionsHTML = mcq.options.map((option, index) => {
                                    const isCorrect = index === mcq.correct_index;
                                    return `
                                    <div class="nk-mcq-option" data-is-correct="${isCorrect}">
                                        <div class="nk-mcq-option-radio"></div>
                                        <div class="nk-mcq-option-text" contenteditable="true">${App.util.escapeHtml(option)}</div>
                                        <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                                    </div>
                                `;
                                }).join('');

                                return `
                                <div class="nk-mcq-block" contenteditable="false">
                                    <div class="nk-mcq-toolbar">
                                        <button class="nk-mcq-copy-block" title="Copy MCQ"><i class="fa-solid fa-copy"></i></button>
                                        <button class="nk-mcq-delete-block" title="Delete MCQ"><i class="fa-solid fa-trash"></i></button>
                                    </div>
                                    <div class="nk-mcq-question" contenteditable="true">${App.util.escapeHtml(mcq.question)}</div>
                                    <div class="nk-mcq-options">${optionsHTML}</div>
                                    <button class="btn btn-secondary nk-mcq-add-option">+ Add Option</button>
                                    <div class="nk-mcq-explanation" contenteditable="true" data-placeholder="Add answer explanation (optional)..."></div>
                                </div>`;
                            }).join('');

                            if (!mcqBlocksHTML.trim()) {
                                throw new Error("Failed to generate HTML from AI response.");
                            }

                            const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                            <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                 AI Generated MCQs 
                            </div>`;

                            contentDiv.insertAdjacentHTML('beforeend', separatorHtml + mcqBlocksHTML + '<p><br></p>');
                            App.ui.showToast(`${mcqs.length} MCQs generated!`, 'success');
                            App.state.isArticleDirty = true;

                            // Scroll to the new content
                            const finalElement = contentDiv.lastElementChild;
                            if (finalElement) {
                                finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }

                        } catch (error) {
                            App.ui.hideToast(toastId);
                            App.ui.showToast(`AI failed: ${error.message}`, "error");
                            console.error("KashMCQ Generation Error:", error);
                        }
                    },

                    async executeKashMcqReviser() {
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();

                        if (!selectedText) {
                            App.ui.showToast("Please select the MCQs you want to revise.", "warning");
                            return;
                        }

                        const toastId = App.ui.showToast(' AI is revising and coloring your MCQs...', { type: 'info', duration: 0 });

                        const systemPrompt = `You are an Expert Educator and MCQ specialist for NoteKash. Your task is to REVISE and ENHANCE a set of raw Multiple Choice Questions (MCQs) provided by the user.

                        **Input:** A text containing one or more MCQs. They might have answers/explanations or just be raw text.

                        **Your Mission:**
                        1.  **Parse & Identify:** Identify each distinct MCQ in the text.
                        2.  **Solve & Verify:** Determine the correct answer. If an answer/explanation is already provided, verify it. If not, solve it yourself.
                        3.  **Enhance Question (IMPORTANT):** Retain the full question text but use avaialable formatting tools to present important keywrods in it well (e.g B/I/U and Text-Colors as well shown below).
                        4.  **Enhance Concise Explanation (CRITICAL):** Write a **concise**, very short, well-structured explanation, with no bluff (i.e directly tries to answer).
                            *   **Mandatory Formatting:** You MUST use these colors and formatting options (Bold/italics) for  important keywords/terms and points (etc.) to make explanations memorizable and beautiful.
                                *  Available text color options to you are "text-red, text-blue, text-green, text-teal, text-orange, text-slate, text-magenta". Use as many of Text coloring option in classes as possible to make it colorful. 
                                *  e.g <span class="text-magenta"><b>Kaktiya dynasty</b></span> 
                                *  Use different colors according to your choice to span differnet important points in explanation to make it colorful.
                        5.  **Format:** Return the data in the specific JSON format NoteKash requires.

                        **CRITICAL OUTPUT FORMAT:**
                        Your ENTIRE response MUST be a single, valid JSON array of objects. Do NOT include any other text.
                        [
                        {
                            "question": "The formatted question HTML string...",
                            "options": ["Option A", "Option B", "Option C", "Option D"],
                            "correct_index": 0, // 0-based index of correct option
                            "explanation": "The formatted explanation HTML string here..."
                        }
                        ]`;

                        try {
                            const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);
                            App.ui.hideToast(toastId);

                            if (!result || !result.trim()) throw new Error("AI returned an empty response.");

                            const jsonMatch = result.match(/\`\`\`json\s*([\s\S]*?)\s*\`\`\`|(\[[\s\S]*\])/);
                            if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");

                            const mcqs = JSON.parse(jsonMatch[1] || jsonMatch[2]);
                            if (!Array.isArray(mcqs) || mcqs.length === 0) throw new Error("Parsed data is not a valid array of MCQs.");

                            const mcqBlocksHTML = mcqs.map(mcq => {
                                if (!mcq.question || !mcq.options || mcq.correct_index === undefined) return '';

                                const optionsHTML = mcq.options.map((option, index) => {
                                    const isCorrect = index === mcq.correct_index;
                                    return `
                                    <div class="nk-mcq-option" data-is-correct="${isCorrect}">
                                        <div class="nk-mcq-option-radio"></div>
                                        <div class="nk-mcq-option-text" contenteditable="true">${App.util.escapeHtml(option)}</div>
                                        <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                                    </div>
                                `;
                                }).join('');

                                const explanationHtml = mcq.explanation ? mcq.explanation : '';

                                // Question is now TRUSTED HTML from AI to allow formatting
                                const questionHtml = mcq.question;

                                return `
                                <div class="nk-mcq-block" contenteditable="false">
                                    <div class="nk-mcq-toolbar">
                                        <button class="nk-mcq-copy-block" title="Copy MCQ"><i class="fa-solid fa-copy"></i></button>
                                        <button class="nk-mcq-delete-block" title="Delete MCQ"><i class="fa-solid fa-trash"></i></button>
                                    </div>
                                    <div class="nk-mcq-question" contenteditable="true">${questionHtml}</div>
                                    <div class="nk-mcq-options">${optionsHTML}</div>
                                    <button class="btn btn-secondary nk-mcq-add-option">+ Add Option</button>
                                    <div class="nk-mcq-explanation" contenteditable="true" data-placeholder="Add answer explanation (optional)...">${explanationHtml}</div>
                                </div>`;
                            }).join('');

                            if (!mcqBlocksHTML.trim()) throw new Error("Failed to generate HTML from AI response.");

                            document.execCommand('insertHTML', false, mcqBlocksHTML + '<p><br></p>');
                            App.ui.showToast(`${mcqs.length} MCQs revised and styled!`, 'success');
                            App.state.isArticleDirty = true;

                        } catch (error) {
                            App.ui.hideToast(toastId);
                            App.ui.showToast(`Revision failed: ${error.message}`, "error");
                            console.error("KashMCQ Reviser Error:", error);
                        }
                    },

                    async executeKashTemplate(templateRequest) {
                        App.ui.closeModal(); // Close the Template Hub
                        const toastId = App.ui.showToast(' Generating template...', { type: 'info', duration: 0 });

                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv) {
                            App.ui.hideToast(toastId);
                            App.ui.showToast("Please open a note first.", "error");
                            return;
                        }

                        const preDefinedTemplates = {
                            'cornell-notes': `
                            <table style="width:100%; border-collapse: collapse; border: 1px solid var(--border-color); border-radius: var(--border-radius); overflow: hidden;">
                                <thead style="background-color: var(--bg-tertiary);">
                                    <tr>
                                        <th style="width: 70%; padding: 1rem; text-align: left;">Main Notes</th>
                                        <th style="width: 30%; padding: 1rem; text-align: left; border-left: 1px solid var(--border-color);">Cues & Questions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td style="padding: 1rem; border-right: 1px solid var(--border-color); vertical-align: top; height: 300px;" data-placeholder="Capture your notes during the lecture or meeting here..."><p><br></p></td>
                                        <td style="padding: 1rem; vertical-align: top;" data-placeholder="After, pull out key terms, questions, or main ideas here..."><p><br></p></td>
                                    </tr>
                                    <tr style="background-color: var(--bg-tertiary);">
                                        <td colspan="2" style="padding: 1rem; border-top: 1px solid var(--border-color); vertical-align: top;" data-placeholder="Finally, write a 1-2 sentence summary of the entire page..."><p><b>Summary:</b> </p></td>
                                    </tr>
                                </tbody>
                            </table>`,
                            'swot-analysis': `<h2>SWOT Analysis</h2><div class="nk-textile-deck" contenteditable="false"><div class="nk-text-tile color-10"><div class="nk-text-tile-content" contenteditable="true"><b>Strengths:</b> What do we do well internally?</div></div><div class="nk-text-tile color-4"><div class="nk-text-tile-content" contenteditable="true"><b>Weaknesses:</b> Where can we improve internally?</div></div><div class="nk-text-tile color-2"><div class="nk-text-tile-content" contenteditable="true"><b>Opportunities:</b> What are the external chances to grow?</div></div><div class="nk-text-tile color-8"><div class="nk-text-tile-content" contenteditable="true"><b>Threats:</b> What external factors could harm us?</div></div></div>`,
                            'meeting-agenda': `<h2>Meeting Agenda</h2><div class="nk-text-tile color-7"><div class="nk-text-tile-content"><b>Date:</b> ${new Date().toLocaleDateString()}</div></div><div class="nk-text-tile color-7"><div class="nk-text-tile-content"><b>Attendees:</b> </div></div><hr><h3>Topics for Discussion:</h3><div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text">Topic 1...</span></div><div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text">Topic 2...</span></div><h3>Action Items:</h3><ul><li><br></li></ul>`,
                            'daily-planner': `<h2>Daily Plan: ${new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}</h2><div class="nk-text-tile color-ghost-1"><div class="nk-text-tile-content"><b>Top Priority for Today:</b> </div></div><h3>To-Do List:</h3><div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text">Task 1...</span></div><div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text">Task 2...</span></div><div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text">Task 3...</span></div><h3>Notes:</h3><p><br></p>`,
                            'smart-goals': `<h2>SMART Goal Setting</h2><div class="nk-text-tile color-ghost-1"><div class="nk-text-tile-content"><b>Goal:</b> </div></div><hr><div class="nk-accordion" data-state="open"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>(S)pecific</b></span></div><div class="nk-accordion-content" data-placeholder="What exactly do I want to achieve?"><p><br></p></div></div><div class="nk-accordion" data-state="closed"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>(M)easurable</b></span></div><div class="nk-accordion-content" data-placeholder="How will I know when I have achieved it?"><p><br></p></div></div><div class="nk-accordion" data-state="closed"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>(A)chievable</b></span></div><div class="nk-accordion-content" data-placeholder="Is this goal realistic with my current resources?"><p><br></p></div></div><div class="nk-accordion" data-state="closed"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>(R)elevant</b></span></div><div class="nk-accordion-content" data-placeholder="Why is this goal important to me right now?"><p><br></p></div></div><div class="nk-accordion" data-state="closed"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>(T)ime-bound</b></span></div><div class="nk-accordion-content" data-placeholder="What is the deadline for this goal?"><p><br></p></div></div>`,
                            'kwl-chart': `<h2>KWL Chart</h2><table style="width:100%;"><thead><tr><th>What I Know</th><th>What I Want to Know</th><th>What I Learned</th></tr></thead><tbody><tr><td data-placeholder="List prior knowledge..."><p><br></p></td><td data-placeholder="List questions..."><p><br></p></td><td data-placeholder="List new learnings..."><p><br></p></td></tr></tbody></table>`,
                            'pros-cons': `<h2>Pros & Cons: Decision Matrix</h2><div class="nk-text-tile color-7"><div class="nk-text-tile-content"><b>Decision to make:</b> </div></div><table style="width:100%;"><thead><tr><th style="background-color: color-mix(in srgb, var(--success-color) 10%, transparent);">Pros (Arguments For)</th><th style="background-color: color-mix(in srgb, var(--danger-color) 10%, transparent);">Cons (Arguments Against)</th></tr></thead><tbody><tr><td data-placeholder="List advantages..."><p><br></p></td><td data-placeholder="List disadvantages..."><p><br></p></td></tr></tbody></table>`,
                            'content-planner': `<h2>Content Planner</h2><div class="nk-textile-deck layout-stack" contenteditable="false"><div class="nk-text-tile color-5"><div class="nk-text-tile-content" contenteditable="true"><b>Ideas :</b> </div></div><div class="nk-text-tile color-6"><div class="nk-text-tile-content" contenteditable="true"><b>In Progress :</b> </div></div><div class="nk-text-tile color-10"><div class="nk-text-tile-content" contenteditable="true"><b>Published :</b> </div></div></div>`,

                            // --- NEW BEAUTIFUL VOCAB CARD ---
                            'vocab-card': `
                            <div class="nk-text-tile color-ghost-1" data-color="ghost-1" style="display: block; width: 100%;">
                                <div class="nk-text-tile-content" style="width: 100%;">
                                    <h2 contenteditable="true" style="margin-top:0; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem;" data-placeholder="Enter Word..."></h2>
                                    <p><b>Meaning:</b></p>
                                    <blockquote contenteditable="true" data-placeholder="Enter the definition here..."><p><br></p></blockquote>
                                    <p><b>Example Sentence:</b></p>
                                    <blockquote contenteditable="true" data-placeholder="Use the word in a sentence..."><p><br></p></blockquote>
                                    <table style="width:100%; margin-top: 1rem;">
                                        <thead style="background-color: var(--bg-tertiary);">
                                            <tr>
                                                <th style="width:50%; text-align: left; padding: 0.5rem 1rem;">Synonyms</th>
                                                <th style="width:50%; text-align: left; padding: 0.5rem 1rem; border-left: 1px solid var(--border-color);">Antonyms</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td style="vertical-align: top; padding: 0.5rem 1rem;" data-placeholder="List synonyms..."><ul style="padding-left: 20px; margin-top: 0;"><li><br></li></ul></td>
                                                <td style="vertical-align: top; padding: 0.5rem 1rem; border-left: 1px solid var(--border-color);" data-placeholder="List antonyms..."><ul style="padding-left: 20px; margin-top: 0;"><li><br></li></ul></td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>`,
                            'upsc-analysis': `<h2>Current Affairs Analysis</h2><div class="nk-textile-deck" contenteditable="false"><div class="nk-text-tile color-2"><div class="nk-text-tile-content" contenteditable="true"><b>Date:</b> ${new Date().toLocaleDateString()}</div></div><div class="nk-text-tile color-5"><div class="nk-text-tile-content" contenteditable="true"><b>Source:</b> The Hindu</div></div><div class="nk-text-tile color-9"><div class="nk-text-tile-content" contenteditable="true"><b>GS Paper:</b> GS-2</div></div></div><h3>Summary of the Issue</h3><blockquote data-placeholder="Write a concise summary of the news article or topic..."><p><br></p></blockquote><hr><h3>Analysis Matrix</h3><table style="width:100%;"><thead><tr><th>Key Arguments / Facts</th><th>Counterarguments / Nuances</th></tr></thead><tbody><tr><td data-placeholder="List the main points, data, and arguments presented..."><p><br></p></td><td data-placeholder="List opposing views, limitations, or alternative perspectives..."><p><br></p></td></tr></tbody></table><h3>Linkages with Static Syllabus</h3><ul data-placeholder="Connect this topic to the core UPSC syllabus..."><li><br></li></ul><h3>Practice Question</h3><blockquote data-placeholder="Formulate a Mains-style practice question based on this topic..."><p><br></p></blockquote>`
                        };

                        let templateHTML = '';

                        if (preDefinedTemplates[templateRequest]) {
                            templateHTML = preDefinedTemplates[templateRequest];
                        } else {
                            // This is a custom AI request, now locked for free users.
                            const systemPrompt = `You are a master productivity expert and document designer named 'KashTemplate'. Your purpose is to translate a user's request into a beautifully structured and aesthetically pleasing note template using NoteKash's native HTML components.

                        **CRITICAL RULES:**
                        1.  You MUST use ONLY the components listed in the 'Component Toolkit' below.
                        2.  You MUST NOT use form elements like \`<input>\`, \`<textarea>\`, or \`<label>\`. The entire template must be editable. Use stylized \`<div>\`s or table cells with placeholder text inside.
                        3.  Your response MUST BE ONLY the complete, clean HTML for the template. Do NOT include any other text, markdown, or explanations.

                        **Your Component Toolkit:**
                        * \`<table>\`: For structured data like schedules or comparison charts. Use \`<thead>\` and \`<th>\`.
                        * \`<div class="nk-textile-deck">\` with child \`<div class="nk-text-tile color-X">\`: For modular blocks of ideas. Use different colors (e.g., color-1 to color-10).
                        * \`<div class="nk-checkbox-wrapper">\`: For checklists and to-do lists.
                        * \`<div class="nk-accordion">\`: For Q&A sections or collapsible sections.
                        * Standard HTML: Use \`<h2>\`, \`<h3>\`, \`<blockquote>\`, \`<ul>\`, \`<hr>\` for clear hierarchy.

                        **Examples of Excellent NoteKash Templates (Learn From These):**

                        ---
                        **User Request:** "a swot analysis"
                        **Correct Output:**
                        \`\`\`html
                        <h2>SWOT Analysis</h2>
                        <div class="nk-textile-deck" contenteditable="false">
                            <div class="nk-text-tile color-10"><div class="nk-text-tile-content" contenteditable="true"><b>Strengths:</b></div></div>
                            <div class="nk-text-tile color-4"><div class="nk-text-tile-content" contenteditable="true"><b>Weaknesses:</b></div></div>
                            <div class="nk-text-tile color-2"><div class="nk-text-tile-content" contenteditable="true"><b>Opportunities:</b></div></div>
                            <div class="nk-text-tile color-8"><div class="nk-text-tile-content" contenteditable="true"><b>Threats:</b></div></div>
                        </div>
                        \`\`\`
                        ---
                        **User Request:** "a template for cornell notes"
                        **Correct Output:**
                        \`\`\`html
                        <table style="width:100%;">
                            <thead><tr><th>Main Notes</th><th>Cues & Questions</th></tr></thead>
                            <tbody>
                                <tr>
                                    <td data-placeholder="Capture notes..."><p><br></p></td>
                                    <td data-placeholder="Pull out key terms..."><p><br></p></td>
                                </tr>
                                <tr>
                                    <td colspan="2" data-placeholder="Write a summary..."><p><b>Summary:</b></p></td>
                                </tr>
                            </tbody>
                        </table>
                        \`\`\`
                        ---

                        **Your Task:** Now, generate a new template based on the user's latest request. Think visually and use a combination of components to create a template that is both functional and beautiful.`;

                            try {
                                const result = await App.services.ai.queryGenerativeAI(systemPrompt, templateRequest);
                                if (!result || !result.trim()) throw new Error("AI returned an empty response.");
                                templateHTML = result;
                            } catch (error) {
                                App.ui.hideToast(toastId);
                                App.ui.showToast(`AI failed to generate template: ${error.message}`, "error");
                                return;
                            }
                        }

                        const separatorHtml = `<hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">`;
                        contentDiv.insertAdjacentHTML('beforeend', separatorHtml + templateHTML + '<p><br></p>');

                        const finalElement = contentDiv.lastElementChild;
                        if (finalElement) {
                            finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }

                        App.ui.hideToast(toastId);
                        App.ui.showToast("Template inserted!", "success");
                        App.state.isArticleDirty = true;
                    },

                    async executeKashCraft() {
                        const contentDiv = document.getElementById('article-content');
                        if (!contentDiv || !contentDiv.textContent.trim()) {
                            App.ui.showToast("Your note is empty. Add some content to craft!", "warning");
                            return;
                        }

                        const toastId = App.ui.showToast(' KashCraft AI is analyzing your note...', { type: 'info', duration: 0 });
                        const articleContent = contentDiv.innerText;

                        const baseTemplate = `
                        <h2>Topic Title (AI will generate this)</h2>
                        <div class="nk-textile-deck" contenteditable="false">
                            <div class="nk-text-tile color-5" data-color="5"><div class="nk-text-tile-content" contenteditable="true"><b>Source:</b> </div></div>
                            <div class="nk-text-tile color-9" data-color="9"><div class="nk-text-tile-content" contenteditable="true"><b>Relevance:</b> </div></div>
                        </div>
                        <h3> Context & Key Takeaways</h3>
                        <ul data-placeholder="AI will generate a bulleted list summarizing the key points..."><li_witt_br></li></ul>
                        <hr>
                        <h3> Deep Dive Analysis</h3>
                        <table style="width:100%;">
                            <thead>
                                <tr>
                                    <th style="background-color: color-mix(in srgb, var(--success-color) 10%, transparent);">Arguments For / Positives</th>
                                    <th style="background-color: color-mix(in srgb, var(--danger-color) 10%, transparent);">Challenges / Negatives</th>
                                </tr>
                            </thead>
                            <tbody><tr>
                                <td data-placeholder="List the main points, data, and arguments presented..."><p><br></p></td>
                                <td data-placeholder="List opposing views, limitations, or alternative perspectives..."><p><br></p></td>
                            </tr></tbody>
                        </table>
                        <h4>Way Forward:</h4>
                        <blockquote data-placeholder="AI will provide solution-oriented suggestions..."><p><br></p></blockquote>
                        <hr>
                        <h3> Connections & Context</h3>
                        <table style="width:100%;">
                            <thead><tr><th style="width:30%;">Foundational Topic</th><th>Linkage/Relevance</th></tr></thead>
                            <tbody><tr>
                                <td data-placeholder="e.g., Judicial Review"><p><br></p></td>
                                <td data-placeholder="Explain how the current topic impacts the foundational topic..."><p><br></p></td>
                            </tr></tbody>
                        </table>
                        <hr>
                        <h3> Practice Questions</h3>
                        <h4>Objective Question:</h4>
                        <div class="nk-mcq-block" contenteditable="false">
                            <div class="nk-mcq-question" contenteditable="true">AI will generate a relevant objective-style MCQ here.</div>
                        </div>
                        <h4>Descriptive Question:</h4>
                        <blockquote data-placeholder="AI will generate a descriptive, analytical question here..."><p><br></p></blockquote>
                        <hr>
                        <h3> Key Vocabulary</h3>
                        <div class="nk-textile-deck" contenteditable="false">
                            <div class="nk-text-tile color-7" data-color="7"><div class="nk-text-tile-content" contenteditable="true"><b>Term 1:</b> Definition...</div></div>
                        </div>
                        <hr>
                        <blockquote data-placeholder="AI will add a relevant, inspiring quote here..."></blockquote>
                    `;

                        // --- NEW, FINAL SUPERCHARGED SYSTEM PROMPT ---
                        const systemPrompt = `You are an elite mentor and content strategist named 'KashCraft'. Your mission is to transform a raw user-provided article into a gold-standard, in-depth analysis notes that is perfect to study for competitive exam aspirants (like UPSC) but is also universally useful for any deep learner. Your output must be natural to read and visually impressive (while making sure text is clearly visible and contrasting with background/blocks).

                    **Your Thought Process (Follow these steps meticulously):**

                    1.  **Analyze & Identify:** Read the entire [Article Content]. Identify the core topic and keywords and its broader subject (e.g., Polity, Economy, Science & Tech). For exam aspirants, you must internally map this to a specific syllabus paper, but the output label should be generic (e.g., 'Relevance: Polity & Governance').

                    2.  **Generate Metadata:** Create a new, appropriate \`<h2>\` title. Fill in the metadata textiles: Source, and Relevance.

                    3.  **Create "Context & Key Takeaways":**
                        * This is the most important Task and step which you should treat with utmost care and should consume 75% of all time you will take in Framing craftedArticle, Act as Elite Subject matter expert and Filter all information from Article through the "UPSC lens". Create  a bulleted list (\`<ul>\`) summarizing only what is relevant for exam. You should Summarize in-depth, the most critical, exam-relevant facts, keywords or points (e.g constitutional articles, SC judgments, key data, govt. schemes, names of committes, data points etc.).
                        * **CRITICAL FLOW RULE:** Each \`<li>\` item MUST be a complete, flowing sentence. Do NOT use bolded prefixes or headings like 'Background:' or 'Significance:' within the bullet points. The list should read like a natural paragraph of distinct points with <b> used for important keywords/numbers/dates and <em> for emphasis.

                    4.  **Fill "Deep Dive Analysis":** Populate the two-column table with positives vs. negatives after you have complete analysis of main arguments/facts of artcile. Then, write a brief, solution-oriented "Way Forward" in the blockquote.

                    5.  **Fill "Connections & Context":** Identify 1-3 foundational topics and explain the linkage in form of short table. Use few words possible and make it short.

                    6.  **Generate Practice Questions:** Create most relevant two questions to article of which - one objective question (prelims oriented) (using an \`nk-mcq-block\` ) and one descriptive question (mains oriented) (in a \`<div class="nk-text-tile color-3">\`).

                    7.  **Generate "Key Vocabulary":**
                        * Identify 3-5 of the most important technical terms from the article.
                        * **CRITICAL FORMATTING RULE:** For each term, create a separate \`<div class="nk-text-tile color-7">\`. The content inside MUST be formatted as \`<b>Term:</b> Definition...\`. Do NOT number them as 'Term 1', 'Term 2', etc. Wrap all tiles in a single \`<div class="nk-textile-deck">\`.

                    8.  **Find a Relevant Quote:** Conclude the entire crafted note with an most relevant Quote related to the Article which you writing (with author name too), placed within a \`<blockquote>\`.

                    9.  **Creative Freedom:** The template is a strong starting point, but you are an expert and not restricted to it. It just provides you way forward how to write but you can form your own template according to needs of craftedArticle. If the content requires it, you MUST add new sections or delete a section or use different NoteKash components (\`<div class="nk-timeline-block">\`, etc.) to best structure the information.

                    **CRITICAL OUTPUT FORMAT:**
                    * Your response MUST be the complete, well-structured, and aesthetically pleasing HTML of the final crafted note.
                    * Respond ONLY with the HTML. Do NOT include any other text, markdown, or explanations.`;

                        try {
                            const result = await App.services.ai.queryGenerativeAI(systemPrompt, `[Article Content]:\n${articleContent}\n\n[Base Template Reference]:\n${baseTemplate}`);
                            App.ui.hideToast(toastId);

                            if (!result || !result.trim()) { throw new Error("AI returned an empty response."); }

                            const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                            <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                 KashCraft AI Version 
                            </div>`;

                            const finalHtml = `${result}`

                            contentDiv.insertAdjacentHTML('beforeend', separatorHtml + finalHtml + '<p><br></p>');
                            App.ui.showToast(`KashCraft analysis complete!`, 'success');
                            App.state.isArticleDirty = true;

                            const finalElement = contentDiv.lastElementChild;
                            if (finalElement) {
                                finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }

                        } catch (error) {
                            App.ui.hideToast(toastId);
                            App.ui.showToast(`AI failed: ${error.message}`, "error");
                            console.error("KashCraft Generation Error:", error);
                        }
                    },


                    async executeFixGrammar() {
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();
                        if (!selectedText) {
                            App.ui.showToast("Please select text to fix and restructure.", "warning");
                            return;
                        }

                        const systemPrompt = `You are an expert editor and communication specialist. Your task is to perform two critical actions on the user's selected text:
                        1.  **Correct:** Meticulously fix all spelling mistakes, grammatical errors, vocabulary issue and punctuation issues.
                        2.  **Restructure for Clarity:** Rewrite the corrected text into logical, short, meaningful and easy-to-read paragraph.

                        **CRITICAL RULES:**
                        - You MUST preserve the original meaning and all information from the source text. Do not add or remove facts.
                        - Your response MUST BE ONLY the final, rewritten text formatted into clean HTML paragraph or paragraphs (if its too long).
                        - If selected text has few sentence make a logical paragaph, if it has many sentences you can write in paragraphs too according to what content demands.
                        - Your code will be used as replacement to selected text so, Do NOT include any conversational filler, explanations, or markdown code fences.`;

                        const toastId = App.ui.showToast(' AI is improving your text...', { type: 'info', duration: 0 });
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);
                        App.ui.hideToast(toastId);

                        if (result && result.trim()) {
                            const resultHtml = result.trim().replace(/^```(html)?\n?/, '').replace(/\n?```$/, '');

                            document.execCommand('insertHTML', false, resultHtml);
                            App.ui.showToast("Text fixed and restructured!", "success");
                            App.state.isArticleDirty = true;
                        } else {
                            App.ui.showToast("AI could not process the text. Please try again.", "warning");
                        }
                    },

                },

                spotlight: {
                    currentIndex: -1,
                    navigate(direction) {
                        const container = document.querySelector('.focus-mode-body');
                        if (!container) return;

                        const allItems = Array.from(container.querySelectorAll('.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-accordion'));

                        if (allItems.length === 0) return;

                        const currentFocus = document.querySelector('.spotlight-key-focus');
                        let currentIndex = -1;
                        if (currentFocus) {
                            currentIndex = allItems.indexOf(currentFocus);
                        }
                        let nextIndex;
                        if (currentIndex === -1) {
                            nextIndex = (direction === 1) ? 0 : allItems.length - 1;
                        } else {
                            nextIndex = currentIndex + direction;
                        }

                        nextIndex = Math.max(0, Math.min(allItems.length - 1, nextIndex));
                        const target = allItems[nextIndex];
                        if (target) {
                            container.querySelectorAll('.spotlight-key-focus').forEach(el => el.classList.remove('spotlight-key-focus'));
                            target.focus({ preventScroll: true });
                            target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            target.classList.add('spotlight-key-focus');
                        }
                    },
                },



                handleSpotlight(event) {
                    if (!event.altKey) return;
                    const bodyEl = document.querySelector('.focus-mode-body');
                    if (!bodyEl || !bodyEl.classList.contains('spotlight-active')) return;

                    const targetSnippet = event.target.closest('.snippet, .nk-mcq-block');

                    if (event.type === 'mouseover' && targetSnippet) {
                        targetSnippet.classList.add('spotlight');
                    } else if (event.type === 'mouseout' && targetSnippet) {
                        targetSnippet.classList.remove('spotlight');
                    }
                },


                toggleFocusMode() {
                    App.state.isFullscreen = !App.state.isFullscreen;
                    const isFullscreen = App.state.isFullscreen;
                    document.body.classList.toggle('fullscreen-active', isFullscreen);
                    const floatingBtn = document.getElementById('focus-mode-toggle');
                    const controlsBtn = document.querySelector('.read-mode-controls [data-action="toggleFocusMode"]');
                    const isWrite = App.state.currentMode === 'write';

                    // NEW: Consistent Aesthetic Icons
                    const maximizeIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.8"><path stroke-linecap="round" stroke-linejoin="round" d="M4 8V6a2 2 0 012-2h2M4 16v2a2 2 0 002 2h2M16 4h2a2 2 0 012 2v2M16 20h2a2 2 0 002-2v-2M12 9a3 3 0 100 6 3 3 0 000-6z" /></svg>`;
                    const minimizeIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.8"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>`;

                    const newIcon = isFullscreen ? minimizeIcon : maximizeIcon;

                    if (floatingBtn) {
                        floatingBtn.classList.toggle('exit-active', isFullscreen);
                        floatingBtn.innerHTML = newIcon;
                    }
                    if (controlsBtn) {
                        controlsBtn.innerHTML = newIcon;
                    }

                    if (isFullscreen) {
                        App.ui.showToast('Immersive(f)', 'info');
                    }
                },
                changeFontFamily(e) {
                    const newFont = e.target.value;

                    const freeFonts = [
                        'Arial, Helvetica, sans-serif',
                        "'Courier New', Courier, monospace",
                        'Garamond, serif',
                        'Georgia, serif',
                        'Helvetica, Arial, sans-serif',
                        'Monaco, "Lucida Console", monospace',
                        'Palatino, "Palatino Linotype", serif',
                        'Verdana, Geneva, sans-serif'
                    ];
                    const isPremium = !freeFonts.includes(newFont);

                    if (isPremium && !App.license.isPremium()) {
                        App.ui.showAscensionModal();
                        e.target.value = App.settings.get('fontFamily'); // Revert selection
                        return;
                    }

                    App.settings.set('fontFamily', newFont);
                    App.ui.applyFontSettings();
                },

                changeFontSize(e) {
                    const size = e.target.value;
                    document.documentElement.style.setProperty('--article-font-size', `${size}rem`);
                    document.getElementById('font-size-value').textContent = `${size}rem`;
                    App.settings.set('fontSize', `${size}rem`);
                },
                changeLineHeight(e) {
                    const lineHeight = e.target.value;
                    document.documentElement.style.setProperty('--article-line-height', lineHeight);
                    document.getElementById('line-height-value').textContent = lineHeight;
                    App.settings.set('lineHeight', lineHeight);
                },
                handleThemeChange(newTheme) {
                    const oldTheme = App.settings.get('theme');
                    if (newTheme === 'custom') {
                        if (!App.settings.get('backgroundImage')) this.triggerBgImageUpload(oldTheme);
                        else App.ui.applyTheme('custom');
                    } else App.ui.applyTheme(newTheme);
                    App.ui.updateSettingsUIState();
                },
                triggerBgImageUpload(oldTheme) {
                    const input = document.getElementById('background-image-input');
                    input.onchange = (event) => {
                        const file = event.target.files[0];
                        if (!file) { if (oldTheme) { document.getElementById('theme-select').value = oldTheme; App.events.handleThemeChange(oldTheme); } return; }
                        if (file.size > App.config.image.maxUploadSize) { App.ui.showToast(`Image too large. Max size is ${App.config.image.maxUploadSize / 1024 / 1024}MB.`, { type: 'error' }); return; }
                        const reader = new FileReader();
                        reader.onload = (re) => { App.settings.set('backgroundImage', re.target.result); App.ui.applyTheme('custom'); App.ui.updateSettingsUIState(); };
                        reader.readAsDataURL(file);
                    };
                    input.value = null;
                    input.click();
                },
                handleCustomThemeBaseChange(e) { App.settings.set('customThemeBase', e.target.value); if (App.settings.get('theme') === 'custom') App.ui.applyTheme('custom'); },
                changeUiOpacity(e) {
                    const opacity = e.target.value;
                    document.documentElement.style.setProperty('--ui-opacity', opacity);
                    document.getElementById('opacity-value').textContent = `${Math.round(opacity * 100)}%`;
                    App.settings.set('uiOpacity', opacity);
                    document.documentElement.style.setProperty('--blur-intensity', parseFloat(opacity) === 0 ? '0px' : '8px');
                    document.documentElement.classList.toggle('zero-opacity-active', parseFloat(opacity) === 0);
                },
                changeImageQuality(e) {
                    const quality = e.target.value;
                    document.getElementById('image-quality-value').textContent = `${Math.round(quality * 100)}%`;
                    App.settings.set('jpegQuality', parseFloat(quality));
                },

                changeOcrThreshold(e) {
                    const threshold = e.target.value;
                    const valueDisplay = document.getElementById('ocr-threshold-value');
                    if (valueDisplay) {
                        valueDisplay.textContent = threshold;
                    }
                    App.settings.set('ocrThreshold', parseInt(threshold, 10));
                },

                showTagModal(tag) {
                    const articlesWithTag = App.state.articles.filter(a => a.tags && a.tags.includes(tag)).sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                    const tagDisplayName = App.state.tags[tag]?.displayName || tag;
                    const message = `<div class="tag-modal-body">
                    ${articlesWithTag.map(article => `
                        <div class="tag-modal-article-title" onclick="App.events.navigateToTagInArticle('${article.id}', '${tag}')">
                            <span>${article.title}</span>
                            <button class="btn-icon" title="Remove tag from this article" onclick="event.stopPropagation(); App.events.deleteTag('${tag}', '${article.id}')">${App.util.icons.trash}</button>
                        </div>`).join('') || '<p>No articles found for this tag.</p>'}
                </div>`;
                    App.ui.showConfirmationModal({
                        title: `Notes tagged with "${tagDisplayName}"`,
                        message: message,
                        showCancel: false,
                        confirmText: 'Close'
                    });
                },
                async deleteTag(tag, articleId) {
                    const article = App.storage.getArticle(articleId);
                    const tagDisplayName = App.state.tags[tag]?.displayName || tag;
                    if (!article || !article.tags.includes(tag)) return;

                    App.ui.showConfirmationModal({
                        title: `Remove Tag?`,
                        message: `Are you sure you want to remove the tag "${tagDisplayName}" from the article "${article.title}"? This will only remove the tag, not the text itself.`,
                        confirmText: 'Remove',
                        onConfirm: async () => {
                            const newTags = article.tags.filter(t => t !== tag);
                            let newContent = article.content;

                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = newContent;
                            tempDiv.querySelectorAll(`.rendered-tag[data-tag-text="${tag}"], .rendered-tag[data-tag="${tag}"]`).forEach(el => App.util.unwrapNode(el));
                            newContent = tempDiv.innerHTML;

                            const result = await App.storage.updateArticle(articleId, { tags: newTags, content: newContent });
                            if (result.success) {
                                App.ui.showToast(`Tag "${tagDisplayName}" removed.`);
                                await App.contentTools.updateTagsIndex();
                                App.ui.closeModal();
                                App.events.showTagModal(tag);
                            }
                        }
                    });
                },
                navigateToTagInArticle(articleId, tag, shouldNavigate = true) {
                    if (shouldNavigate) { App.router.navigateTo('article', { id: articleId, mode: 'read', focusTag: tag }); App.ui.closeModal(); }
                    else {
                        const contentDiv = document.getElementById('article-content');
                        if (contentDiv) {
                            const firstTaggedElement = contentDiv.querySelector(`[data-tag-text="${tag}"], [data-tag="${tag}"]`);
                            if (firstTaggedElement) {
                                firstTaggedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                firstTaggedElement.style.transition = 'background-color 0.5s';
                                firstTaggedElement.style.backgroundColor = 'var(--hl-1-bg)';
                                setTimeout(() => { firstTaggedElement.style.backgroundColor = ''; }, 2000);
                            }
                        }
                    }
                },
                changeCategorySort(e, category) { App.settings.set('categorySortBy', e.target.value); App.ui.renderCategoryView(document.getElementById('category-view'), category); },
                changeTagSort(e) { App.settings.set('tagSortBy', e.target.value); App.events.filterAndRenderTags(); },
                filterAndRenderTags() {
                    const sortBy = App.settings.get('tagSortBy');
                    const searchTerm = document.getElementById('tag-search-input')?.value.toLowerCase() || '';
                    const container = document.getElementById('tag-cloud-container');

                    if (!container) return;

                    let allTagsData = Object.values(App.state.tags);

                    if (searchTerm) {
                        allTagsData = allTagsData.filter(t => t.displayName.toLowerCase().includes(searchTerm));
                    }

                    let contentHtml;
                    if (allTagsData.length === 0) {
                        contentHtml = `<div class="empty-state"><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg><h3>No Tags Found</h3><p>Create tags using [[double brackets]] in an article, or adjust your search.</p></div>`;
                    } else {
                        if (sortBy === 'random') allTagsData.sort(() => Math.random() - 0.5);
                        else if (sortBy === 'date-new') allTagsData.sort((a, b) => new Date(b.lastUsed) - new Date(a.lastUsed));
                        else if (sortBy === 'date-old') allTagsData.sort((a, b) => new Date(a.firstUsed) - new Date(b.firstUsed));
                        else allTagsData.sort((a, b) => a.displayName.localeCompare(b.displayName));
                        contentHtml = `<div class="tag-cloud">${allTagsData.map(tagData => `<div class="tag-item" onclick="App.events.showTagModal('${tagData.id}')">${tagData.displayName}</div>`).join('')}</div>`;
                    }
                    container.innerHTML = contentHtml;
                },
                changeFlashcardCategory(category) {
                    App.settings.set('flashcardCategory', category);

                    // Correctly update the active button style using the '.active' class
                    const view = document.getElementById('flashcard-view');
                    if (view) {
                        // First, remove 'active' from all category chips
                        view.querySelectorAll('.category-filters .category-chip').forEach(btn => {
                            btn.classList.remove('active');
                        });

                        // Then, add 'active' to the specific button that was clicked
                        // This is a more robust way to find the exact button
                        const activeBtn = view.querySelector(`.category-filters .category-chip[onclick="App.events.changeFlashcardCategory('${category}')"]`);
                        if (activeBtn) {
                            activeBtn.classList.add('active');
                        }
                    }

                    // **NEW: More Menu Toggle Listener**
                    document.getElementById('whiteboard-more-btn')?.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent closing immediately
                        const container = document.getElementById('wb-more-container');
                        container.classList.toggle('active');
                    });

                    // Close menu when clicking outside
                    document.addEventListener('click', (e) => {
                        const container = document.getElementById('wb-more-container');
                        if (container && container.classList.contains('active') && !container.contains(e.target)) {
                            container.classList.remove('active');
                        }
                    });

                    // Re-render the flashcard grid as before
                    App.ui.filterAndRenderFlashcards();
                },


                changeFlashcardSort(e) { App.settings.set('flashcardSortBy', e.target.value); App.ui.filterAndRenderFlashcards(); },

                updateReadingProgress() {
                    requestAnimationFrame(() => {
                        const articleView = document.getElementById('article-view');
                        if (!articleView || !articleView.classList.contains('active')) return;

                        const mainEl = document.querySelector('main');
                        if (!mainEl) return;

                        const { scrollHeight, clientHeight, scrollTop } = mainEl;

                        if (scrollHeight <= clientHeight) {
                            App.ui.updateTheLine(1);
                            return;
                        }

                        let progress = scrollTop / (scrollHeight - clientHeight);

                        if (scrollTop + clientHeight >= scrollHeight - 2) {
                            progress = 1;
                        }

                        App.ui.updateTheLine(progress);
                    });
                },

                study: {
                    updateLimit(newLimit) {
                        const limit = parseInt(newLimit, 10);
                        if (limit > 0) {
                            App.settings.set('studySessionSize', limit);
                            App.ui.showToast(`Session size set to ${limit}`, { type: 'success' });
                        }
                    },

                    start(options = {}) {
                        const {
                            mode = 'limitedDue',
                            limit = App.settings.get('studySessionSize'),
                            quizCards = null,
                            quizType = 'none' // 'none', 'classic', or 'mcq'
                        } = options;

                        const isQuizMode = !!quizCards;
                        let cardsToStudy;
                        let toastMessage = "No new or due flashcards to study.";

                        if (isQuizMode) {
                            cardsToStudy = quizCards;
                            toastMessage = "You dont have enough cards for a Quiz.";
                        } else {
                            cardsToStudy = App.util.getDueFlashcards();
                            if (mode === 'mcqOnly') {
                                cardsToStudy = cardsToStudy.filter(c => c.type === 'mcq');
                                toastMessage = "No due Multiple-Choice Questions in this deck.";
                            }
                            if (mode === 'limitedDue') {
                                cardsToStudy = cardsToStudy.slice(0, limit);
                            }
                        }

                        if (!cardsToStudy || cardsToStudy.length === 0) {
                            App.ui.showToast(toastMessage);
                            return;
                        }

                        App.state.studySession = { isActive: true, isQuizMode, quizType, cards: cardsToStudy, currentIndex: 0, isRating: false, activeTheme: 'default' };
                        document.body.classList.add('study-mode-active');
                        App.ui.renderStudyView(App.state.studySession);
                        App.ui.updateStudyProgressUI();
                    },

                    toggleFontSize(button) {
                        const fontSizes = ['1.2rem', '1.4rem', '1.6rem', '1.8rem', '2.0rem', '2.2rem', '2.4rem', '2.6rem', '2.8rem', '3rem'];
                        const currentSize = App.settings.get('studyCardFontSize') || '1.6rem';
                        const currentIndex = fontSizes.indexOf(currentSize);
                        const nextIndex = (currentIndex + 1) % fontSizes.length;
                        const newSize = fontSizes[nextIndex];

                        document.documentElement.style.setProperty('--study-card-font-size', newSize);
                        if (button) {
                            button.querySelector('span').textContent = newSize.replace('rem', '');
                        }
                        App.settings.set('studyCardFontSize', newSize);
                    },

                    rate(rating) {
                        const s = App.state.studySession;
                        if (!s.isActive || s.isRating) return;

                        App.util.hapticFeedback(); // <-- ADD THIS LINE

                        s.isRating = true;
                        const card = s.cards[s.currentIndex];
                        card.finalRating = rating;
                        if (!s.isQuizMode) {
                            const updatedCardData = App.util.sm2.rateCard(card, rating);
                            const originalArticle = App.storage.getArticle(card.articleId);
                            if (originalArticle?.flashcards?.[card.id]) {
                                const newFlashcards = { ...originalArticle.flashcards, [card.id]: { ...originalArticle.flashcards[card.id], ...updatedCardData } };
                                App.storage.updateArticle(originalArticle.id, { flashcards: newFlashcards });
                            }
                        }
                        const studyView = document.querySelector('.study-view');
                        if (studyView) {
                            const cardBox = studyView.querySelector('.study-card-content-box');
                            const ratingBtn = studyView.querySelector(`.btn-${rating.toLowerCase()}`);
                            cardBox.classList.add(`rated-${App.config.sm2.colors[rating]}`);
                            if (ratingBtn) ratingBtn.classList.add('btn-popped');
                        }
                        setTimeout(() => this.next(), 1500);
                    },

                    next() {
                        const s = App.state.studySession;
                        if (!s.isActive) return;

                        if (s.currentIndex >= s.cards.length - 1) {
                            this.exit(true);
                            return;
                        }
                        const currentCard = s.cards[s.currentIndex];
                        let nextIndex = s.currentIndex + 1;

                        if (s.cards[nextIndex].articleId === currentCard.articleId) {
                            // Find the first card further in the queue that is from a DIFFERENT article.
                            const alternateIndex = s.cards.findIndex((card, index) => index > nextIndex && card.articleId !== currentCard.articleId);

                            if (alternateIndex !== -1) {
                                // An alternate card was found. Swap it with the next card in line.
                                const relatedCard = s.cards[nextIndex];
                                s.cards[nextIndex] = s.cards[alternateIndex];
                                s.cards[alternateIndex] = relatedCard;
                            }
                        }

                        s.currentIndex++;
                        s.isRating = false;
                        App.ui.renderStudyView(s);
                        App.ui.updateStudyProgressUI();
                    },

                    prev() {
                        const s = App.state.studySession; if (!s.isActive || s.currentIndex === 0 || s.isRating) return;
                        s.currentIndex--; App.ui.renderStudyView(s); App.ui.updateStudyProgressUI();
                    },

                    exit(isCompleted = false) {
                        if (!App.state.studySession.isActive) return;
                        const session = { ...App.state.studySession };

                        // Reset state BEFORE showing results
                        App.state.studySession = { isActive: false, isQuizMode: false, quizType: 'none', cards: [], currentIndex: 0, isRating: false };
                        App.ui.renderStudyView(App.state.studySession); // This will remove the study view and body classes

                        if (session.isQuizMode && isCompleted) {
                            App.quiz.calculateAndShowResults(session.cards);
                        } else if (session.isQuizMode && !isCompleted) {
                            App.ui.showToast("Quiz abandoned!");
                            App.router.navigateTo('flashcard');
                        } else {
                            App.ui.showToast(isCompleted ? "Study session complete!" : "Study session exited.");
                            App.router.navigateTo('flashcard');
                        }
                    },

                    setupCardGestures(cardElement) {
                        let touchStartX = 0;
                        let touchStartY = 0;
                        let touchEndX = 0;
                        let touchEndY = 0;
                        const swipeThreshold = 50; // Minimum pixels to be considered a swipe

                        cardElement.addEventListener('touchstart', (e) => {
                            touchStartX = e.changedTouches[0].screenX;
                            touchStartY = e.changedTouches[0].screenY;
                        }, { passive: true });

                        cardElement.addEventListener('touchend', (e) => {
                            touchEndX = e.changedTouches[0].screenX;
                            touchEndY = e.changedTouches[0].screenY;
                            handleSwipeGesture();
                        }, { passive: true });

                        const handleSwipeGesture = () => {
                            const dx = touchEndX - touchStartX;
                            const dy = touchEndY - touchStartY;
                            const absDx = Math.abs(dx);
                            const absDy = Math.abs(dy);

                            if (App.state.studySession.isRating) return;

                            // Check if it's a horizontal swipe
                            if (absDx > swipeThreshold && absDx > absDy) {
                                if (dx > 0) {
                                    // Swiped Right -> Easy
                                    App.events.study.rate('Easy');
                                } else {
                                    // Swiped Left -> Again
                                    App.events.study.rate('Again');
                                }
                            }
                            // Check if it's a vertical swipe
                            else if (absDy > swipeThreshold && absDy > absDx) {
                                if (dy < 0) {
                                    // Swiped Up -> Good
                                    App.events.study.rate('Good');
                                }
                                // Optional: Swipe Down for "Hard"
                                // else {
                                //     App.events.study.rate('Hard');
                                // }
                            }
                        };
                    },

                    cycleStudyTheme(goBack = false) {
                        const themes = App.events.presentation.themes;
                        const session = App.state.studySession;
                        if (!session.isActive) return;

                        const currentIndex = themes.indexOf(session.activeTheme);
                        const nextIndex = goBack
                            ? (currentIndex - 1 + themes.length) % themes.length
                            : (currentIndex + 1) % themes.length;
                        session.activeTheme = themes[nextIndex];
                        App.ui.applyStudyTheme();

                        const themeName = session.activeTheme.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        App.ui.showToast(`${themeName} Theme`, { type: 'info', duration: 1500 });
                    },

                    resetStudyTheme() {
                        const session = App.state.studySession;
                        if (!session.isActive) return;
                        session.activeTheme = 'default';
                        App.ui.applyStudyTheme();
                        App.ui.showToast('Theme reset to default', { type: 'success', duration: 2000 });
                    },

                    handleKeyboard(e) {
                        if (App.state.studySession.isRating) return;

                        // New logic to handle scrolling with arrow keys
                        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                            e.preventDefault();
                            const studyCard = document.querySelector('.study-card');
                            if (!studyCard) return;

                            const isFlipped = studyCard.classList.contains('is-flipped');
                            const activeFaceSelector = isFlipped ? '.study-card-back' : '.study-card-front';
                            const contentBox = document.querySelector(`${activeFaceSelector} .study-card-content-box`);

                            if (contentBox) {
                                const scrollAmount = 75; // The number of pixels to scroll
                                contentBox.scrollTop += (e.key === 'ArrowDown' ? scrollAmount : -scrollAmount);
                            }
                            return; // Exit after handling scroll
                        }

                        switch (e.key) {
                            case ' ': e.preventDefault(); document.querySelector('.study-card')?.classList.toggle('is-flipped'); break;
                            case 'ArrowLeft': this.prev(); break;
                            case 'ArrowRight': this.next(); break;
                            case 'c':
                                App.events.study.cycleStudyTheme();
                                break;
                            case 'e':
                                document.querySelector('.study-controls .btn-icon-nav[onclick*="toggleFontSize"]')?.click();
                                break;
                            case 'Enter':
                                e.preventDefault();
                                document.querySelector('.study-card')?.classList.toggle('is-flipped');
                                break;
                            case 'a': e.preventDefault(); this.rate('Again'); break;
                            case '5': this.rate('Again'); break;
                            case '4': this.rate('Hard'); break;
                            case '3': this.rate('Hold'); break;
                            case '2': this.rate('Good'); break;
                            case '1': this.rate('Easy'); break;
                        }
                    }
                },

                async handleMcqAnswer(event, isStudyMode = false) {
                    const selectedOption = event.target.closest('.nk-mcq-option');
                    if (!selectedOption) return;

                    const mcqBlock = selectedOption.closest('.nk-mcq-block');
                    if (!mcqBlock || mcqBlock.dataset.answered === 'true') return;

                    event.preventDefault();
                    event.stopPropagation();

                    const isUserCorrect = selectedOption.dataset.isCorrect === 'true';
                    const quizType = mcqBlock.dataset.quizMode;

                    if (quizType === 'mcq') {
                        mcqBlock.dataset.answered = 'true';
                        if (!isUserCorrect) {
                            mcqBlock.dataset.userIncorrect = 'true';
                        }
                        selectedOption.classList.add(isUserCorrect ? 'correct' : 'incorrect');
                        if (!isUserCorrect) {
                            mcqBlock.querySelector('.nk-mcq-option[data-is-correct="true"]')?.classList.add('correct');
                        }

                        const card = App.state.studySession.cards[App.state.studySession.currentIndex];
                        await App.quiz.handleMcqAnswer(isUserCorrect, card);

                        // DEFINITIVE FIX: Auto-advance to the next question after 3 seconds
                        setTimeout(() => {
                            App.events.study.next();
                        }, 3000);

                    } else { // This is the original logic for read mode or classic study mode
                        const blocksToUpdate = isStudyMode ? document.querySelectorAll('.study-card-face .nk-mcq-block') : [mcqBlock];

                        blocksToUpdate.forEach(block => {
                            block.dataset.answered = 'true';
                            // Track incorrect answers for visual feedback
                            if (!isUserCorrect) {
                                block.dataset.userIncorrect = 'true';
                            }
                            const options = Array.from(block.querySelectorAll('.nk-mcq-option'));

                            // IMPROVED MATCHING LOGIC (Fixes Bug #2)
                            let selectedInBlock;
                            if (block === mcqBlock) {
                                // Direct match for Read Mode (Same Block)
                                selectedInBlock = selectedOption;
                            } else {
                                // Fallback for Study Mode (Cloned Block): Match by Index
                                const originalOptions = Array.from(mcqBlock.querySelectorAll('.nk-mcq-option'));
                                const originalIndex = originalOptions.indexOf(selectedOption);
                                if (originalIndex > -1 && options[originalIndex]) {
                                    selectedInBlock = options[originalIndex];
                                } else {
                                    // Last resort: Text match (risky but fallback)
                                    selectedInBlock = options.find(opt => opt.textContent === selectedOption.textContent);
                                }
                            }

                            const correctInBlock = options.find(opt => opt.dataset.isCorrect === 'true');

                            if (isUserCorrect) {
                                if (selectedInBlock) selectedInBlock.classList.add('correct');
                            } else {
                                if (selectedInBlock) selectedInBlock.classList.add('incorrect');
                                if (correctInBlock) correctInBlock.classList.add('correct');
                            }
                        });

                        if (isStudyMode) {
                            setTimeout(() => {
                                const studyCard = document.querySelector('.study-card');
                                if (studyCard && !studyCard.classList.contains('is-flipped')) {
                                    studyCard.classList.add('is-flipped');
                                }
                            }, 3000);
                        }
                    }
                },

                flashcardContextMenu(event, cardId) {
                    event.preventDefault();
                    const menuHtml = `<button onclick="App.events.resetFlashcard('${cardId}')">Reset Card Progress</button>`;
                    App.ui.showContextMenu(event.pageX, event.pageY, menuHtml);
                },
                async resetFlashcard(cardId) {
                    const card = App.util.getAllFlashcards().find(c => c.id === cardId); if (!card) return;
                    const article = App.storage.getArticle(card.articleId);
                    if (article && article.flashcards && article.flashcards[cardId]) {
                        const newFlashcards = { ...article.flashcards };

                        //  FIX: Perform a complete factory reset on the card's learning data.
                        newFlashcards[cardId] = {
                            ...newFlashcards[cardId],
                            rating: null,
                            reviewCount: 0,
                            interval: 0,
                            lastReviewed: null,
                            nextReviewDue: null,
                            reviewHistory: [],
                            easeFactor: 2.5, // Reset Ease Factor to default
                            lapses: 0,       // Reset Leech counter
                        };

                        await App.storage.updateArticle(article.id, { flashcards: newFlashcards });
                        App.ui.filterAndRenderFlashcards();
                        App.ui.showToast("Card progress reset.");
                    }
                },
                resetFilteredFlashcardsConfirmation() {
                    const category = App.settings.get('flashcardCategory') || 'All';
                    App.ui.showConfirmationModal({
                        title: 'Reset Card Progress?',
                        message: `Are you sure you want to reset the progress for all flashcards in the current filter ("${category === 'All' ? 'All' : App.util.getCategoryDisplayName(category)}")? This action cannot be undone.`,
                        confirmText: 'Reset',
                        onConfirm: () => App.events.resetFilteredFlashcards()
                    });
                },
                async resetFilteredFlashcards() {
                    const cardsToReset = App.util.getSortedFlashcardsForDisplay();
                    if (cardsToReset.length === 0) { App.ui.showToast("No cards to reset in this view."); return; }
                    const articlesToUpdate = {};
                    for (const card of cardsToReset) {
                        if (!articlesToUpdate[card.articleId]) articlesToUpdate[card.articleId] = { ...App.storage.getArticle(card.articleId).flashcards };
                        articlesToUpdate[card.articleId][card.id] = { ...articlesToUpdate[card.articleId][card.id], rating: null, reviewCount: 0, interval: 0, lastReviewed: null, nextReviewDue: null, reviewHistory: [] };
                    }
                    App.ui.showToast("Resetting cards...", { type: 'info' });
                    for (const articleId in articlesToUpdate) await App.storage.updateArticle(articleId, { flashcards: articlesToUpdate[articleId] });
                    App.ui.filterAndRenderFlashcards();
                    App.ui.showToast(`${cardsToReset.length} cards have been reset.`, { type: 'success' });
                },
                async nudgeReviewDate(cardId, days) {
                    const card = App.util.getAllFlashcards().find(c => c.id === cardId);
                    if (!card || !card.nextReviewDue) { App.ui.showToast("Cannot nudge a new card."); return; }
                    const article = App.storage.getArticle(card.articleId);
                    if (article && article.flashcards && article.flashcards[cardId]) {
                        const newFlashcards = { ...article.flashcards };
                        const currentDueDate = new Date(card.nextReviewDue);
                        let newDueDate = new Date(currentDueDate.setDate(currentDueDate.getDate() + days));
                        if (newDueDate.getTime() < Date.now()) newDueDate = new Date();
                        newFlashcards[cardId].nextReviewDue = newDueDate.toISOString();
                        await App.storage.updateArticle(article.id, { flashcards: newFlashcards });
                        App.ui.filterAndRenderFlashcards();
                        App.ui.showToast(`Review date moved ${days > 0 ? 'forward' : 'back'} by ${Math.abs(days)} day(s).`);
                    }
                },

                deleteFlashcardConfirmation(cardId) {
                    const card = App.util.getAllFlashcards().find(c => c.id === cardId);
                    if (!card) return;

                    // Sanitize card text for display in the modal
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = card.type === 'collapsible' ? card.frontText : card.fullText;
                    const cardTextSample = (tempDiv.textContent || "").substring(0, 80);

                    App.ui.showConfirmationModal({
                        title: 'Delete Flashcard?',
                        message: `Are you sure you want to permanently delete this flashcard?<br><br><em>"${cardTextSample}..."</em>`,
                        confirmText: 'Delete',
                        onConfirm: () => App.events.deleteFlashcard(cardId)
                    });
                },

                async deleteFlashcard(cardId) {
                    const card = App.util.getAllFlashcards().find(c => c.id === cardId);
                    if (!card) return;

                    const article = App.storage.getArticle(card.articleId);
                    if (article && article.flashcards && article.flashcards[cardId]) {
                        const newFlashcards = { ...article.flashcards };
                        delete newFlashcards[cardId];
                        await App.storage.updateArticle(article.id, { flashcards: newFlashcards });

                        App.ui.filterAndRenderFlashcards();
                        App.ui.showToast("Flashcard deleted.");
                    } else {
                        App.ui.showToast("Could not find flashcard's source article.", { type: 'error' });
                    }
                },

                selectImage(container) {
                    this.deselectImage();
                    container.classList.add('selected');
                    App.state.selectedImageContainer = container;
                    App.ui.showImageToolbar(container);

                    const handle = container.querySelector('.resize-handle');
                    if (!handle) {
                        console.warn('No resize handle found for container:', container);
                        return; // Exit early if no handle exists
                    }

                    const isVisualFlashcard = container.classList.contains('nk-visual-flashcard');

                    // For visual flashcards, we need both images; for regular, just one
                    const images = isVisualFlashcard
                        ? container.querySelectorAll('.nk-vfc-front img, .nk-vfc-back img')
                        : [container.querySelector('img')];
                    const primaryImage = images[0];

                    const startResize = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        document.addEventListener('mousemove', onMove);
                        document.addEventListener('mouseup', onEnd);
                        document.addEventListener('touchmove', onMove, { passive: false });
                        document.addEventListener('touchend', onEnd);
                    };

                    const onMove = (e) => {
                        e.preventDefault();
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const rect = container.getBoundingClientRect();
                        let newWidth = clientX - rect.left;

                        if (isVisualFlashcard) {
                            // For visual flashcards, adjust the container's max-width and both images
                            container.style.maxWidth = `${newWidth}px`;
                            images.forEach(img => {
                                img.style.width = '100%';
                                img.style.height = 'auto';
                            });
                        } else {
                            // For regular images, maintain aspect ratio
                            const originalRatio = parseFloat(primaryImage.dataset.originalWidth) / parseFloat(primaryImage.dataset.originalHeight);
                            primaryImage.style.width = `${newWidth}px`;
                            primaryImage.style.height = `auto`; // Let browser calculate height based on new width
                        }
                    };

                    const onEnd = () => {
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onEnd);
                        document.removeEventListener('touchmove', onMove);
                        document.removeEventListener('touchend', onEnd);
                        App.state.isArticleDirty = true; // Mark for autosave after resizing
                    };

                    handle.addEventListener('mousedown', startResize);
                    handle.addEventListener('touchstart', startResize, { passive: false });
                },


                deselectImage() {
                    if (App.state.selectedImageContainer) {
                        App.state.selectedImageContainer.classList.remove('selected');
                        App.state.selectedImageContainer = null;
                        App.ui.hideImageToolbar();
                    }
                },

                handleImageAlignment(alignClass) {
                    const container = App.state.selectedImageContainer; if (!container) return;
                    if (alignClass === 'reset-size') {
                        const isVisualFlashcard = container.classList.contains('nk-visual-flashcard');
                        if (isVisualFlashcard) {
                            // Reset visual flashcard size
                            container.style.maxWidth = '';
                            const images = container.querySelectorAll('.nk-vfc-front img, .nk-vfc-back img');
                            images.forEach(img => {
                                img.style.width = '100%';
                                img.style.height = 'auto';
                            });
                        } else {
                            // Reset regular image size
                            const img = container.querySelector('img');
                            img.style.width = img.dataset.originalWidth + 'px';
                            img.style.height = 'auto';
                        }
                        return;
                    }
                    container.classList.remove('align-left', 'align-right', 'align-center');
                    if (alignClass) container.classList.add(alignClass);
                },
                async highlightImage() {
                    const container = App.state.selectedImageContainer;
                    if (!container) return;
                    const isHighlighted = container.classList.toggle('highlighted-image');
                    container.dataset.isHighlighted = isHighlighted;
                    await App.events.saveArticle({ isAutosave: true }); // CHANGED: Added silent save option
                    App.ui.showToast(isHighlighted ? 'Image highlighted!' : 'Image highlight removed.', { type: 'success' });
                    // Re-show toolbar to update button color
                    App.ui.showImageToolbar(container);
                },

                addImageCaption() {
                    const container = App.state.selectedImageContainer;
                    if (!container) return;

                    const theme = App.settings.get('captionTheme') || 'default';
                    const align = App.settings.get('captionAlign') || 'bottom';
                    container.setAttribute('data-caption-theme', theme);
                    container.setAttribute('data-caption-align', align);


                    let caption = container.querySelector('.image-caption');

                    if (caption) {
                        caption.setAttribute('contenteditable', 'true');
                        caption.style.pointerEvents = 'auto'; // Make interactive
                        caption.focus();
                    } else {
                        caption = document.createElement('div');
                        caption.className = 'image-caption';
                        caption.setAttribute('contenteditable', 'true');
                        caption.setAttribute('data-placeholder', 'Add a caption...');
                        container.appendChild(caption);
                        caption.focus();
                        App.state.isArticleDirty = true;
                    }
                    caption.onblur = async () => {
                        caption.removeAttribute('contenteditable');
                        caption.style.pointerEvents = 'none'; // Revert to non-interactive
                        if (caption.textContent.trim() === '' && caption.parentNode) {
                            caption.parentNode.removeChild(caption);
                        }
                        await App.events.saveArticle({ isAutosave: true }); // CHANGED: Added silent save option
                        App.ui.hideImageToolbar(); // Hide toolbar after editing
                    };

                    App.ui.showImageToolbar(container);
                },

                toggleShowTags() {
                    const current = App.settings.get('showTagsOnTiles');
                    App.settings.set('showTagsOnTiles', !current);
                    document.getElementById('show-tags-toggle').classList.toggle('active', !current);
                    App.ui.filterAndRenderArticles();
                },
                toggleMobileView() {
                    const current = App.settings.get('mobileViewEnabled');
                    App.settings.set('mobileViewEnabled', !current);
                    App.ui.applyMobileView();
                },

                toggleTextColorPopover(event) {
                    if (event) {
                        event.preventDefault();
                        event.stopPropagation();
                        const btn = event.currentTarget;
                        const group = btn.closest('.color-picker-group');
                        if (group) {
                            const popover = group.querySelector('.color-picker-popover');
                            if (popover) {
                                popover.classList.toggle('show');
                            }
                        }
                    }
                },

                selectTextColor(colorClass) {
                    const selection = window.getSelection();
                    if (!selection || selection.rangeCount === 0 || selection.isCollapsed) {
                        App.ui.showToast("Please select some text first.", { type: 'warning' });
                        return;
                    }

                    // 1. Apply formatting
                    const success = this.applyFormatting('class', colorClass);

                    if (!success) {
                        App.ui.showToast("Could not apply color. Please try again.", { type: 'error' });
                        return;
                    }

                    // 2. Update storage/settings
                    const textColors = ['text-red', 'text-green', 'text-blue', 'text-magenta', 'text-orange', 'text-teal', 'text-slate'];
                    const newIndex = textColors.indexOf(colorClass);
                    if (newIndex >= 0) {
                        App.settings.set('textColorCycleIndex', newIndex);
                    }

                    // 3. Update UI (Direct DOM manipulation to preserve pinned state)
                    const pickerGroup = document.getElementById('text-color-picker-group');
                    if (pickerGroup) {
                        // Update Main Icon Color
                        const mainIconCircle = pickerGroup.querySelector('button svg circle');
                        if (mainIconCircle) {
                            mainIconCircle.setAttribute('fill', `var(--${colorClass})`);
                        }

                        // Update Active State in Popover
                        const popover = document.getElementById('text-color-popover');
                        if (popover) {
                            popover.querySelectorAll('.color-circle-btn').forEach(btn => btn.classList.remove('active'));
                            const newActiveBtn = popover.children[newIndex];
                            if (newActiveBtn) newActiveBtn.classList.add('active');
                        }
                    }
                },



                handleArticleControlsClick(e) {
                    const button = e.target.closest('button, .read-count-badge'); if (!button) return;
                    const { action, value } = button.dataset;

                    switch (action) {
                        case 'cycleReaderTheme': App.events.cycleReaderTheme(); break;
                        case 'goToCategory':
                            const article = App.storage.getArticle(App.state.activeArticleId);
                            if (article) App.router.navigateTo('category', { category: article.category, articleId: article.id });
                            break;
                        case 'switchToWrite': App.events.switchToMode('write'); break;
                        case 'finishArticle': App.events.finishArticle(); break;
                        case 'copyHighlights': App.services.export.copyCurrentArticleHighlights(); break;
                        case 'exportHtml': App.services.export.exportArticleAsHtml(); break;
                        case 'shareArticle': App.services.share.article(); break;
                        case 'exportNoteKash': App.services.export.exportAsNoteKashFile(); break;
                        case 'exportPdf': App.services.export.exportArticleAsPdf(); break;
                        case 'resetReadCount': App.events.resetReadCount(); break;
                        case 'toggleFocusMode': App.events.toggleFocusMode(); break;
                        case 'saveAndRead': App.events.saveArticle({ switchToRead: true }); break;
                        case 'deleteArticle': App.events.deleteArticleWithConfirmation(); break;
                        case 'format': if (value === 'cloze') App.events.applyFormatting('cloze'); else App.events.applyFormatting('class', value); break;
                        case 'manageTable': App.events.showTableModal(); break;
                        case 'insertAccordion': App.events.insertAccordionCard(); break;
                        case 'insertCheckbox':
                            const checkboxHTML = `<div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text"><br></span></div><p><br></p>`;
                            document.execCommand('insertHTML', false, checkboxHTML);
                            setTimeout(() => { const lastCheckbox = document.querySelector('.nk-checkbox-wrapper:last-of-type .nk-checkbox-text'); if (lastCheckbox) App.util.placeCursor(lastCheckbox); }, 10);
                            App.state.isArticleDirty = true;
                            break;
                        case 'applyListStyle':
                            const selection = window.getSelection(); if (!selection.focusNode) break;
                            const focusElement = selection.focusNode.nodeType === Node.TEXT_NODE ? selection.focusNode.parentElement : selection.focusNode;
                            let list = focusElement.closest('ul, ol');
                            if (value === 'ordered-alpha') {
                                if (list && list.tagName === 'UL') {
                                    document.execCommand('insertOrderedList', false);
                                    list = window.getSelection().focusNode.parentElement.closest('ol');
                                } else if (!list) {
                                    document.execCommand('insertOrderedList', false);
                                    list = window.getSelection().focusNode.parentElement.closest('ol');
                                }
                                if (list) list.setAttribute('type', 'a');
                            } else {
                                if (list) list.className = value;
                                else { document.execCommand('insertUnorderedList', false); setTimeout(() => { const newList = window.getSelection().focusNode.parentElement.closest('ul'); if (newList) newList.className = value; }, 0); }
                            }
                            break;
                        case 'execCommand': document.execCommand(value); break;
                    }
                },

                categories: {
                    _refreshActiveView() {
                        const activeViewId = App.router.getActiveView();
                        if (activeViewId && ['library', 'flashcard', 'stats-dashboard', 'article'].includes(activeViewId)) {
                            App.router.navigateTo(activeViewId);
                        }
                    },

                    refreshManager() {
                        const container = document.getElementById('category-list-container');
                        if (!container) return;
                        const categories = App.settings.get('userCategories');

                        container.innerHTML = categories.map(cat => {
                            // UPDATED: Get the display name for rendering
                            const displayName = App.util.getCategoryDisplayName(cat.name);
                            return `
                        <div class="settings-item" data-category-name="${App.util.escapeHtml(cat.name)}">
                            <span class="category-name-display" style="display: inline-flex; align-items: center; gap: 8px;">
                                <span style="width: 16px; height: 16px; border-radius: 50%; background-color: ${App.util.getCategoryColor(cat.colorIndex)}; border: 1px solid var(--border-color);"></span>
                                ${App.util.escapeHtml(displayName)}
                            </span>
                            <div class="category-item-controls">
                                <button class="btn-icon" onclick="App.events.categories.initiateRename(this)" title="Rename"></button>
                                <button class="btn-icon" onclick="App.events.categories.cycleColor('${cat.name}')" title="Change Color"></button>
                                <button class="btn-icon ${cat.isDefault ? 'is-disabled' : ''}" onclick="${cat.isDefault ? "App.ui.showToast('Don\\'t delete Source Category', 'warning')" : `App.events.categories.initiateDelete('${cat.name}')`}" title="${cat.isDefault ? 'This is the default source category and cannot be deleted.' : 'Delete'}">${App.util.icons.trash}</button>
                            </div>
                        </div>
                    `}).join('');

                        const style = document.createElement('style');
                        style.textContent = `
                        .category-name-display { flex-grow: 1; }
                        .category-item-controls { display: flex; gap: 0.5rem; }
                    `;
                        container.appendChild(style);
                    },
                    async executeOperationPlan(plan) {
                        App.ui.showToast('Resuming interrupted category operation...', { type: 'warning' });
                        switch (plan.operation) {
                            case 'migrate':
                                await this.migrateAndDelete(plan.source, plan.destination);
                                break;
                            case 'delete':
                                await this.deleteAll(plan.source);
                                break;
                            default:
                                console.error('Unknown operation in plan file:', plan);
                                await App.fs.write('_category_operation_plan.json', null);
                        }
                    },
                    async add(name) {
                        const trimmedName = name.trim();
                        if (!trimmedName) return;
                        let categories = App.settings.get('userCategories');
                        if (categories.some(c => c.name.toLowerCase() === trimmedName.toLowerCase())) {
                            App.ui.showToast(`Category "${trimmedName}" already exists.`, 'warning');
                            return;
                        }

                        const newCategory = {
                            name: trimmedName,
                            colorIndex: categories.length % App.util.getCategoryColorCount()
                        };
                        categories.push(newCategory);

                        await App.settings.set('userCategories', categories);
                        App.ui.showToast(`Category "${trimmedName}" added.`, 'success');
                        this.refreshManager();
                        this._refreshActiveView();
                    },

                    initiateRename(buttonEl) {
                        const item = buttonEl.closest('.settings-item');
                        const nameDisplay = item.querySelector('.category-name-display');
                        const oldName = item.dataset.categoryName; // This is the stable, internal name
                        const currentDisplayName = App.util.getCategoryDisplayName(oldName);

                        nameDisplay.innerHTML = `<input type="text" class="text-input" value="${App.util.escapeHtml(currentDisplayName)}" style="padding: 4px 8px; font-size: 0.9rem;">`;
                        const input = nameDisplay.querySelector('input');
                        input.focus();
                        input.select();

                        const save = () => App.events.categories.saveRename(input, oldName);
                        input.onblur = save;
                        input.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); input.blur(); } };
                    },

                    async saveRename(inputEl, oldName) {
                        const newDisplayName = inputEl.value.trim();
                        let categories = App.settings.get('userCategories');
                        const categoryToUpdate = categories.find(c => c.name === oldName);

                        // If the new name is empty, or the same as the internal name, we reset it.
                        if (!newDisplayName || newDisplayName === oldName) {
                            if (categoryToUpdate) {
                                delete categoryToUpdate.displayName; // Remove the displayName property
                            }
                        } else {
                            // Check for duplicate display names before saving.
                            if (categories.some(c => c.displayName === newDisplayName && c.name !== oldName)) {
                                App.ui.showToast(`Display name "${newDisplayName}" is already in use.`, 'warning');
                                this.refreshManager(); // Re-render to show the original name
                                return;
                            }
                            // Set the new display name.
                            if (categoryToUpdate) {
                                categoryToUpdate.displayName = newDisplayName;
                            }
                        }

                        // Save the updated categories array to settings.
                        await App.settings.set('userCategories', categories);
                        App.ui.showToast(`Category display name updated.`, 'success');

                        // Refresh the UI to reflect the change.
                        this.refreshManager();
                        this._refreshActiveView();
                    },

                    initiateDelete(catName) {
                        const articleCount = App.state.articles.filter(a => a.category === catName).length;
                        const otherCategories = App.settings.get('userCategories').filter(c => c.name !== catName);
                        const migrationOptions = otherCategories.map(c => `<option value="${c.name}">${App.util.getCategoryDisplayName(c.name)}</option>`).join('');

                        let migrateSection = '';
                        if (articleCount > 0) {
                            migrateSection = `
                            <h4>Option 1: Migrate (Safe)</h4>
                            <p>Move all ${articleCount} articles from "${catName}" to another category.</p>
                            <div style="display:flex; gap: 0.5rem; align-items: center;">
                                <select id="migrate-dest-category" class="text-input" style="flex-grow:1;">${migrationOptions}</select>
                                <button class="btn btn-primary" id="migrate-btn">Migrate</button>
                            </div>`;
                        }

                        App.ui.showCustomModal({
                            title: ` Delete '${catName}'?`,
                            message: `
                            <p>This category contains <strong>${articleCount} articles</strong>.</p>
                            ${migrateSection}
                            <h4 style="color: var(--danger-color); margin-top: 1.5rem;">Option 2: Delete All (Permanent)</h4>
                            <p>This will permanently delete the category AND all articles within it. This cannot be undone.</p>`,
                            buttons: [
                                { text: 'Cancel', className: 'btn-secondary', onClick: () => App.ui.closeModal() },
                                {
                                    text: `Delete All (${articleCount} Articles)`, className: 'btn-danger', onClick: () => {
                                        App.ui.showConfirmationModal({
                                            title: 'Are you absolutely sure?',
                                            message: `This will permanently delete the '${catName}' category and all ${articleCount} articles within it. This action cannot be undone.`,
                                            confirmText: 'Yes, Delete Everything',
                                            onConfirm: () => App.events.categories.deleteAll(catName)
                                        });
                                    }
                                }
                            ]
                        });

                        const migrateBtn = document.getElementById('migrate-btn');
                        if (migrateBtn) {
                            migrateBtn.onclick = () => {
                                const dest = document.getElementById('migrate-dest-category').value;
                                App.events.categories.migrateAndDelete(catName, dest);
                            };
                        }
                    },

                    async cycleColor(categoryName) {
                        let categories = App.settings.get('userCategories');
                        const categoryToUpdate = categories.find(c => c.name === categoryName);

                        if (categoryToUpdate) {
                            categoryToUpdate.colorIndex = (categoryToUpdate.colorIndex + 1) % App.util.getCategoryColorCount();
                            await App.settings.set('userCategories', categories);
                            this.refreshManager(); // Refresh the modal UI
                            this._refreshActiveView(); // Refresh the main app UI
                        }
                    },

                    async migrateAndDelete(sourceCat, destCat) {

                        if (!document.getElementById('migration-overlay')) {
                            App.ui.closeModal();
                            App.ui.migrationScreen.show(`Migrating from '${sourceCat}'`);
                        }

                        // STEP 1: Create the plan file before starting.
                        const plan = { operation: 'migrate', source: sourceCat, destination: destCat, status: 'pending' };
                        await App.fs.write('_category_operation_plan.json', plan);

                        try {
                            const articlesToMove = App.state.articles.filter(a => a.category === sourceCat);

                            for (let i = 0; i < articlesToMove.length; i++) {
                                if (App.ui.migrationScreen.state.isCancelled) {
                                    await App.fs.write('_category_operation_plan.json', null); // Cleanup if cancelled
                                    return;
                                }
                                const article = articlesToMove[i];
                                await App.storage.updateArticle(article.id, { category: destCat });
                                const progress = Math.round(((i + 1) / articlesToMove.length) * 80);
                                App.ui.migrationScreen.update(progress, `Moving article ${i + 1} of ${articlesToMove.length}...`);
                            }

                            if (App.ui.migrationScreen.state.isCancelled) {
                                await App.fs.write('_category_operation_plan.json', null);
                                return;
                            }

                            App.ui.migrationScreen.update(85, "Updating associated tasks...");
                            const tasksToMove = App.hub.state.tasks.filter(t => t.category === sourceCat);
                            if (tasksToMove.length > 0) {
                                tasksToMove.forEach(task => task.category = destCat);
                                await App.hub.data.saveTasks();
                            }

                            App.ui.migrationScreen.update(95, "Finalizing category settings...");
                            let categories = App.settings.get('userCategories');
                            categories = categories.filter(c => c.name !== sourceCat);
                            await App.settings.set('userCategories', categories);

                            if (App.state.storageMode === 'browser') {
                                App.state.articles = await App.browserStore.getAllArticles();
                            }

                            App.ui.migrationScreen.update(100, "Migration Complete!");
                            App.ui.showToast(`Moved ${articlesToMove.length} articles and deleted '${sourceCat}'.`, 'success');

                            // STEP 2: Delete the plan file ONLY after all steps are successful.
                            await App.fs.write('_category_operation_plan.json', null);

                            this.refreshManager();
                            this._refreshActiveView();

                        } catch (error) {
                            console.error("Migration failed:", error);
                            App.ui.showToast("An error occurred during migration. The operation will resume on next launch.", "error");
                        } finally {
                            setTimeout(() => App.ui.migrationScreen.hide(), 1500);
                        }
                    },

                    async deleteAll(catName) {
                        if (!document.getElementById('migration-overlay')) {
                            App.ui.closeModal();
                            App.ui.migrationScreen.show(`Deleting '${catName}'`);
                        }

                        // STEP 1: Create the plan file.
                        const plan = { operation: 'delete', source: catName, status: 'pending' };
                        await App.fs.write('_category_operation_plan.json', plan);

                        try {
                            const articlesToDelete = App.state.articles.filter(a => a.category === catName);

                            for (let i = 0; i < articlesToDelete.length; i++) {
                                if (App.ui.migrationScreen.state.isCancelled) {
                                    await App.fs.write('_category_operation_plan.json', null); // Cleanup if cancelled
                                    return;
                                }
                                const article = articlesToDelete[i];
                                await App.storage.deleteArticle(article.id);
                                const progress = Math.round(((i + 1) / articlesToDelete.length) * 80);
                                App.ui.migrationScreen.update(progress, `Deleting article ${i + 1} of ${articlesToDelete.length}...`);
                            }

                            if (App.ui.migrationScreen.state.isCancelled) {
                                await App.fs.write('_category_operation_plan.json', null);
                                return;
                            }

                            App.ui.migrationScreen.update(85, "Updating associated tasks...");
                            const tasksToMove = App.hub.state.tasks.filter(t => t.category === catName);
                            if (tasksToMove.length > 0) {
                                const defaultCategory = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                                tasksToMove.forEach(task => task.category = defaultCategory);
                                await App.hub.data.saveTasks();
                            }

                            App.ui.migrationScreen.update(95, "Finalizing category settings...");
                            let categories = App.settings.get('userCategories');
                            categories = categories.filter(c => c.name !== catName);
                            await App.settings.set('userCategories', categories);

                            if (App.state.storageMode === 'browser') {
                                App.state.articles = await App.browserStore.getAllArticles();
                            }

                            App.ui.migrationScreen.update(100, "Deletion Complete!");
                            App.ui.showToast(`Deleted '${catName}' and ${articlesToDelete.length} articles.`, 'success');

                            // STEP 2: Delete the plan file on success.
                            await App.fs.write('_category_operation_plan.json', null);

                            this.refreshManager();
                            this._refreshActiveView();

                        } catch (error) {
                            console.error("Deletion failed:", error);
                            App.ui.showToast("An error occurred during deletion. The operation will resume on next launch.", "error");
                        } finally {
                            setTimeout(() => App.ui.migrationScreen.hide(), 1500);
                        }
                    },
                },


                saveDropboxClientId() {
                    const id = document.getElementById('dropbox-client-id-input').value.trim();
                    App.settings.set('dropboxClientId', id);
                    App.ui.showToast('Dropbox Client ID saved!', { type: 'success' });
                    App.ui.showStorageModal();
                },

                removeDropboxClientId() {
                    App.settings.set('dropboxClientId', null);
                    App.ui.showToast('Dropbox Client ID removed.');
                    App.ui.showStorageModal();
                },

                toggleCategoryHighlights() {
                    const container = document.querySelector('.category-view-container');
                    const toggle = document.getElementById('highlight-toggle');
                    if (!container || !toggle) return;

                    const isHiding = container.classList.toggle('hide-snippet-colors');
                    toggle.classList.toggle('active', !isHiding);
                    App.settings.set('categoryHighlightsVisible', !isHiding);
                },

                setCategoryLayout(mode) {
                    App.settings.set('categoryLayout', mode);
                    const container = document.querySelector('.category-view-container');
                    if (container) {
                        const category = App.util.getOriginalCategoryName(container.querySelector('h2').textContent.split(': ')[1] || 'All');
                        App.ui.renderCategoryView(document.getElementById('category-view'), category);
                    }
                },

                // Optimized: Lazy Load Focus Mode
                enterFocusMode(articleId) {
                    const container = document.querySelector('.category-view-container');
                    let sortedArticles = [];
                    let initialIndex = 0;

                    if (container) {
                        // Context: Category View (Snippets Only)
                        const category = container.dataset.category || 'All';
                        sortedArticles = App.services.export.getSortedArticlesForCategory(category);

                        // Filter to match the view (only articles with snippets)
                        sortedArticles = sortedArticles.filter(a => {
                            const c = a.content || '';
                            return c.includes('highlight-') || c.includes('==') || c.includes('nk-mcq') || c.includes('nk-timeline');
                        });
                    } else {
                        const targetArticle = App.storage.getArticle(articleId);
                        if (!targetArticle) return; // Error

                        const category = targetArticle.category || 'All';
                        sortedArticles = App.services.export.getSortedArticlesForCategory(category);
                    }

                    if (sortedArticles.length === 0) {
                        App.ui.showToast("No articles found to focus on.", 'info');
                        return;
                    }

                    // Find safe index
                    initialIndex = sortedArticles.findIndex(a => a.id === articleId);

                    if (initialIndex === -1) {
                        sortedArticles = [App.storage.getArticle(articleId)].filter(Boolean);
                        initialIndex = 0;
                    }

                    App.state.focusSession = {
                        isActive: true,
                        articles: sortedArticles,
                        currentIndex: initialIndex,
                        isStageMode: false,
                        currentSlideIndex: 0,
                        scrollStops: [],
                        activeTheme: 'default',
                        isCinematicActive: false,
                        teleprompterActive: false,
                        annotations: {},
                    };

                    // PREPARE CURRENT ARTICLE IMMEDIATELY
                    this.prepareFocusArticle(initialIndex);

                    App.ui.renderFocusMode();
                    document.addEventListener('keydown', this.handleFocusModeKeyDown);
                    document.body.style.overflow = 'hidden';
                },

                enterFocusModeForCategory(categoryName) {
                    const articlesForCategory = App.services.export.getSortedArticlesForCategory(categoryName);

                    // Fast filter
                    const candidateArticles = articlesForCategory.filter(a => {
                        const c = a.content || '';
                        return c.includes('highlight-') || c.includes('==') || c.includes('nk-mcq') || c.includes('nk-timeline');
                    });

                    if (candidateArticles.length === 0) {
                        App.ui.showToast(`No snippets found in category "${categoryName}" to focus on.`, 'info');
                        return;
                    }

                    App.state.focusSession = {
                        isActive: true,
                        articles: candidateArticles,
                        currentIndex: 0,
                        isStageMode: false,
                        currentSlideIndex: 0,
                        scrollStops: [],
                        activeTheme: 'default',
                        isCinematicActive: false,
                        teleprompterActive: false,
                        annotations: {},
                    };

                    this.prepareFocusArticle(0);

                    App.ui.renderFocusMode();
                    document.addEventListener('keydown', this.handleFocusModeKeyDown);
                    document.body.style.overflow = 'hidden';
                },

                // NEW HELPER: JIT Snippet Parser
                prepareFocusArticle(index) {
                    const session = App.state.focusSession;
                    if (!session || !session.articles[index]) return null;

                    const article = session.articles[index];
                    if (article.snippets) return article; // Already processed

                    // PROCESS SNIPPETS NOW
                    article.snippets = App.util.extractSnippets(article, ['highlight', 'mcq', 'blocks', 'cloze'], true);

                    // Sort logic (copied from original)
                    if (article.snippets.length > 0) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = article.content;
                        const allElements = Array.from(tempDiv.querySelectorAll(
                            '.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-video-embed, ' +
                            '.highlight-1, .highlight-2, .highlight-3, .highlight-4, .highlight-5, .highlight-6, .image-container.highlighted-image'
                        ));
                        article.snippets.sort((a, b) => {
                            const elA = tempDiv.querySelector(`[id="${a.id}"]`);
                            const elB = tempDiv.querySelector(`[id="${b.id}"]`);
                            if (!elA || !elB) return 0;
                            return allElements.indexOf(elA) - allElements.indexOf(elB);
                        });
                    }

                    // Restore annotations if any
                    if (!session.annotations[article.id] && article.stageAnnotations) {
                        session.annotations[article.id] = JSON.parse(JSON.stringify(article.stageAnnotations));
                    }

                    return article;
                },

                exitFocusMode() {
                    if (!App.state.focusSession.isActive) return;

                    const coPilotToggle = document.getElementById('kash-copilot-toggle');
                    if (coPilotToggle) coPilotToggle.style.display = 'none';
                    // NEW: Save annotations before closing
                    const session = App.state.focusSession;
                    const article = session.articles[session.currentIndex];
                    if (article) {
                        const currentAnnotations = JSON.stringify(article.stageAnnotations || {});
                        const newAnnotations = JSON.stringify(session.annotations);

                        if (currentAnnotations !== newAnnotations) {
                            // Find the original article in the main state to update it
                            const mainArticle = App.storage.getArticle(article.id);
                            if (mainArticle) {
                                mainArticle.stageAnnotations = JSON.parse(newAnnotations);
                                App.events.saveArticle({ isAutosave: true });
                            }
                        }
                    }

                    if (App.annotationEngine.state.isActive) {
                        App.annotationEngine.toggle(App.annotationEngine.state.context);
                    }

                    App.state.focusSession.isActive = false;
                    const overlay = document.getElementById('focus-mode-overlay');
                    if (overlay) {
                        overlay.removeEventListener('click', App.events.handleContentClick);
                        const bodyEl = overlay.querySelector('.focus-mode-body');
                        if (bodyEl) {
                            bodyEl.removeEventListener('mouseover', App.events.handleSpotlight);
                            bodyEl.removeEventListener('mouseout', App.events.handleSpotlight);
                        }
                        overlay.remove();
                    }
                    document.removeEventListener('keydown', this.handleFocusModeKeyDown);

                    // MEMORY OP: Aggressively clear session data
                    App.state.focusSession.articles = [];
                    App.util.freeMemory();

                    document.body.style.overflow = '';
                },


                navigateFocusMode(direction) {
                    const { articles, currentIndex } = App.state.focusSession;
                    if (!articles) return;
                    const newIndex = currentIndex + direction;

                    if (newIndex >= 0 && newIndex < articles.length) {
                        App.state.focusSession.currentIndex = newIndex;
                        App.ui.renderFocusMode();
                    }
                },

                toggleStageMode() {
                    const session = App.state.focusSession;

                    // Clean up innovations when exiting Stage Mode
                    if (session.isStageMode) {
                        const bodyEl = document.querySelector('.focus-mode-body');
                        if (bodyEl) {
                            // Innovation 1: Cleanup Bento layouts
                            App.ui._cleanupStageModeBentoLayouts(bodyEl);

                            // Innovation 3: Cleanup 2D camera viewport
                            App.ui._cleanup2DCameraViewport(bodyEl);
                        }
                    }

                    session.isStageMode = !session.isStageMode;
                    session.currentSlideIndex = 0;
                    session.scrollStops = [];
                    App.ui.renderFocusMode();
                },

                navigateStageSlide(direction) {
                    const session = App.state.focusSession;
                    if (!session.isActive || !session.isStageMode) return;

                    // --- NEW: SIGMA ARTICLE NAVIGATION ---
                    if (session.sigmaMode === 'article') {
                        const body = document.querySelector('.focus-mode-body');
                        const overlay = document.querySelector('.focus-mode-overlay');
                        if (body && overlay) {
                            const scrollAmount = window.innerHeight * 0.8; // Scroll 80% of screen height

                            // Add transition class for presentation-like fade effect
                            overlay.classList.add('article-nav-transitioning');

                            // Slight delay before scroll to let fade-out start
                            setTimeout(() => {
                                body.scrollBy({
                                    top: scrollAmount * direction,
                                    behavior: 'smooth'
                                });

                                // Remove transition class after scroll animation completes
                                setTimeout(() => {
                                    overlay.classList.remove('article-nav-transitioning');
                                }, 350);
                            }, 80);
                        }
                        return; // Stop here, do not do slide navigation
                    }

                    const newIndex = session.currentSlideIndex + direction;

                    // INNOVATION 2: List Build Animation
                    // When moving forward, check if there are hidden list items to reveal first
                    if (direction > 0) {
                        const body = document.querySelector('.focus-mode-body');
                        if (body && App.ui._hasHiddenListItems(body)) {
                            // Reveal the next list item instead of advancing slide
                            if (App.ui._revealNextListItem(body)) {
                                return; // Don't advance slide, we revealed a list item
                            }
                        }
                    }

                    if (newIndex >= 0 && newIndex < session.scrollStops.length) {
                        session.currentSlideIndex = newIndex;

                        const body = document.querySelector('.focus-mode-body');
                        if (body) {
                            // INNOVATION 3: 2D Camera navigation
                            if (session.cameraMap && session.cameraMap.positions[newIndex]) {
                                const pos = session.cameraMap.positions[newIndex];
                                App.ui._navigate2DCamera(body, pos.x, pos.y);

                                // Add transitioning class for visual feedback
                                const overlay = document.querySelector('.focus-mode-overlay');
                                if (overlay) {
                                    overlay.classList.add('is-transitioning');
                                    setTimeout(() => overlay.classList.remove('is-transitioning'), 700);
                                }
                            } else {
                                // Fallback to scroll-based navigation
                                body.scrollTo({
                                    top: session.scrollStops[newIndex],
                                    behavior: 'smooth'
                                });
                            }
                        }
                        App.ui.renderFocusModeControls();
                        setTimeout(() => {
                            const container = document.querySelector('.focus-mode-body');
                            if (!container) return;
                            container.querySelectorAll('.spotlight-key-focus').forEach(el => el.classList.remove('spotlight-key-focus'));
                            const newFirstItem = container.querySelector('.is-visible');
                            if (newFirstItem) {
                                // Apply the spotlight to it, ready for the next ArrowDown press.
                                newFirstItem.classList.add('spotlight-key-focus');
                                newFirstItem.focus({ preventScroll: true });
                            }

                            // After navigating to a new slide, reset list build state
                            // so the first item is visible and others are hidden
                            if (session.sigmaMode !== 'article') {
                                const visibleSnippet = container.querySelector('.snippet.is-visible, .stage-bento-split.is-visible, .stage-hero-image.is-visible');
                                if (visibleSnippet) {
                                    const lists = visibleSnippet.querySelectorAll('ul, ol');
                                    lists.forEach(list => {
                                        const items = list.querySelectorAll('li');
                                        items.forEach((item, index) => {
                                            if (index === 0) {
                                                item.classList.add('stage-build-visible');
                                                item.classList.remove('stage-build-hidden');
                                            } else {
                                                item.classList.add('stage-build-hidden');
                                                item.classList.remove('stage-build-visible');
                                            }
                                        });
                                    });
                                }
                            }
                        }, 400);
                    }
                },


                // UNIFIED LASER POINTER (Read & Stage Mode)
                toggleSharedLaser(context = 'stage') {
                    // Context: 'stage' (Focus/Stage Mode) or 'read' (Read/Global Mode)
                    let overlay, canvasId, pointerId;

                    if (context === 'stage') {
                        overlay = document.querySelector('.focus-mode-overlay');
                        canvasId = 'laser-trail-canvas';
                        pointerId = 'laser-pointer';
                    } else {
                        overlay = document.body;
                        canvasId = 'read-mode-laser-canvas';
                        pointerId = 'read-mode-laser-pointer';
                    }

                    if (!overlay) return;

                    let laserCanvas = document.getElementById(canvasId);
                    let pointer = document.getElementById(pointerId);
                    const activeClass = context === 'stage' ? 'laser-active' : 'read-mode-laser-active';

                    // INITIALIZATION
                    if (!pointer) {
                        pointer = document.createElement('div');
                        pointer.id = pointerId;
                        Object.assign(pointer.style, {
                            position: 'fixed',
                            width: '8px',
                            height: '8px',
                            background: '#ff0055',
                            borderRadius: '50%',
                            boxShadow: '0 0 5px #ff0055, 0 0 10px #ff0055, 0 0 20px #ff0055',
                            pointerEvents: 'none',
                            zIndex: '2147483647',
                            display: 'none',
                            transform: 'translate(-50%, -50%)',
                            transition: 'transform 0.04s linear' // Faster follow
                        });
                        overlay.appendChild(pointer);
                    }

                    if (!laserCanvas) {
                        laserCanvas = document.createElement('canvas');
                        laserCanvas.id = canvasId;
                        Object.assign(laserCanvas.style, {
                            position: 'fixed', // Use fixed for both
                            top: '0',
                            left: '0',
                            width: '100%',
                            height: '100%',
                            pointerEvents: 'none',
                            zIndex: '2147483646'
                        });
                        overlay.appendChild(laserCanvas);

                        const resizeCanvas = () => {
                            laserCanvas.width = context === 'stage' ? overlay.clientWidth : window.innerWidth;
                            laserCanvas.height = context === 'stage' ? overlay.clientHeight : window.innerHeight;
                        };
                        window.addEventListener('resize', resizeCanvas);
                        resizeCanvas();
                    }

                    const isActive = !overlay.classList.contains(activeClass);

                    if (isActive) {
                        // Surgical: Theme Awareness & Aesthetic Upgrade
                        const themeSource = context === 'stage' ? overlay : (document.querySelector('.article-view-wrapper') || document.body);
                        const style = getComputedStyle(themeSource);
                        const rawText = style.getPropertyValue('--text-primary').trim();
                        const rawPrimary = style.getPropertyValue('--primary-color').trim();

                        const laserColor = rawText || '#ff0055';
                        const glowColor = rawPrimary || laserColor;

                        overlay.classList.add(activeClass);
                        pointer.style.display = 'block';

                        // Apply Aesthetic Update to Pointer
                        const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                        const isDarkTheme = currentTheme === 'dark'; // 'sepia' counts as light-ish for laser physics

                        if (isDarkTheme) {
                            // Dark Mode: Hot Plasma / Neon
                            pointer.style.background = `radial-gradient(circle at 35% 35%, #fff 0%, ${laserColor} 50%, ${glowColor} 100%)`;
                            pointer.style.boxShadow = `0 0 5px ${glowColor}, 0 0 10px ${laserColor}, 0 0 20px ${glowColor}`;
                            pointer.style.border = 'none';
                        } else {
                            // Light/Sepia Mode: Wet Ink / High-End Marker
                            pointer.style.background = `radial-gradient(circle at 30% 30%, rgba(255,255,255,0.95) 0%, ${laserColor} 55%)`;
                            pointer.style.boxShadow = `0 2px 5px rgba(0,0,0,0.25)`; // Physical shadow for depth
                            pointer.style.border = `1px solid rgba(255,255,255,0.2)`;
                        }

                        laserCanvas.style.display = 'block';

                        // In Read Mode, we need to capture events via canvas. In Stage, overlay might handle it.
                        laserCanvas.style.pointerEvents = 'all';
                        laserCanvas.style.cursor = 'none';

                        if (context === 'stage') document.getElementById('laser-pointer-toggle')?.classList.add('active');

                        const ctx = laserCanvas.getContext('2d');
                        let paths = [];
                        let currentPath = null;
                        let animationFrameId;

                        const draw = () => {
                            if (!overlay.classList.contains(activeClass)) return;

                            ctx.clearRect(0, 0, laserCanvas.width, laserCanvas.height);
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';

                            const activePaths = [...paths, currentPath];
                            const drawPaths = () => {
                                activePaths.forEach(path => {
                                    if (!path || path.length < 2) return;
                                    ctx.beginPath();
                                    ctx.moveTo(path[0].x, path[0].y);
                                    for (let i = 1; i < path.length; i++) {
                                        const p = path[i];
                                        const prev = path[i - 1];
                                        const cx = (prev.x + p.x) / 2;
                                        const cy = (prev.y + p.y) / 2;
                                        ctx.quadraticCurveTo(prev.x, prev.y, cx, cy);
                                    }
                                    ctx.stroke();
                                });
                            };

                            // RENDER LASER TRAIL
                            if (isDarkTheme) {
                                // DARK MODE: NEON / LIGHTSABER PHYSICS
                                // Pass 1: The Glow (Atmosphere) - Additive blending for light physics
                                ctx.globalCompositeOperation = 'lighter';
                                ctx.lineWidth = 6;
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = glowColor;
                                ctx.strokeStyle = glowColor;
                                drawPaths();

                                // Pass 2: The Core (Hot Plasma)
                                ctx.globalCompositeOperation = 'source-over';
                                ctx.lineWidth = 2;
                                ctx.shadowBlur = 1;
                                ctx.shadowColor = '#fff';
                                ctx.strokeStyle = '#fff'; // Always white hot core
                                drawPaths();
                            } else {
                                // LIGHT/SEPIA MODE: FOUNTAIN PEN / MARKER PHYSICS
                                // Pass 1: The Stain/Bleed (Softer, wider, low opacity)
                                ctx.globalCompositeOperation = 'source-over'; // Normal blending (ink on paper)
                                ctx.lineWidth = 7;
                                ctx.lineCap = 'round';
                                ctx.shadowBlur = 6;
                                ctx.shadowColor = glowColor; // Use primary/glow color as the "wash"
                                ctx.strokeStyle = glowColor;
                                ctx.globalAlpha = 0.3; // Transparent bleed
                                drawPaths();

                                // Pass 2: The Ink Flow (Solid, sharper)
                                ctx.globalAlpha = 1.0;
                                ctx.lineWidth = 2.5;
                                ctx.shadowBlur = 1;
                                ctx.shadowColor = 'rgba(0,0,0,0.1)';
                                ctx.strokeStyle = laserColor; // Use the text color (dark) as ink
                                drawPaths();
                            }

                            animationFrameId = requestAnimationFrame(draw);
                        };
                        draw();



                        // Event Handlers
                        const moveHandler = (e) => {
                            pointer.style.left = `${e.clientX}px`;
                            pointer.style.top = `${e.clientY}px`;
                            if (currentPath) currentPath.push({ x: e.clientX, y: e.clientY });
                        };
                        const downHandler = (e) => {
                            if (e.button !== 0) return;
                            e.preventDefault();
                            currentPath = [{ x: e.clientX, y: e.clientY }];
                        };
                        const upHandler = () => {
                            if (currentPath && currentPath.length > 0) paths.push(currentPath);
                            currentPath = null;
                        };
                        const dblClickHandler = () => {
                            paths = [];
                            currentPath = null;
                        };

                        // NEW: Wheel Handler for Scrolling while Laser is active
                        const wheelHandler = (e) => {
                            let scrollTarget;
                            if (context === 'stage') {
                                scrollTarget = document.querySelector('.focus-mode-body');
                            } else {
                                // For Read Mode, the content is usually in <main>
                                scrollTarget = document.querySelector('main') || document.scrollingElement || document.documentElement || document.body;
                            }

                            if (scrollTarget) {
                                scrollTarget.scrollTop += e.deltaY;
                                scrollTarget.scrollLeft += e.deltaX;
                            }
                        };

                        // Unified Key Handler
                        const keyHandler = (e) => {
                            if (e.key === 'Escape' || (e.key.toLowerCase() === 'l' && !e.repeat)) {
                                e.preventDefault();
                                e.stopPropagation();
                                App.events.toggleSharedLaser(context);
                            }
                        };

                        laserCanvas.addEventListener('mousemove', moveHandler);
                        laserCanvas.addEventListener('mousedown', downHandler);
                        laserCanvas.addEventListener('wheel', wheelHandler, { passive: true });
                        window.addEventListener('mouseup', upHandler);
                        laserCanvas.addEventListener('dblclick', dblClickHandler);
                        document.addEventListener('keydown', keyHandler, true); // Capture phase importance

                        laserCanvas._cleanup = () => {
                            laserCanvas.removeEventListener('mousemove', moveHandler);
                            laserCanvas.removeEventListener('mousedown', downHandler);
                            laserCanvas.removeEventListener('wheel', wheelHandler);
                            window.removeEventListener('mouseup', upHandler);
                            laserCanvas.removeEventListener('dblclick', dblClickHandler);
                            document.removeEventListener('keydown', keyHandler, true);
                            cancelAnimationFrame(animationFrameId);
                        };

                    } else {
                        // Deactivate
                        overlay.classList.remove(activeClass);
                        pointer.style.display = 'none';
                        laserCanvas.style.display = 'none';
                        laserCanvas.style.pointerEvents = 'none';
                        if (context === 'stage') document.getElementById('laser-pointer-toggle')?.classList.remove('active');

                        const ctx = laserCanvas.getContext('2d');
                        ctx.clearRect(0, 0, laserCanvas.width, laserCanvas.height);
                        if (laserCanvas._cleanup) laserCanvas._cleanup();

                    }
                },

                // SCREENSHOT CAPTURE - Uses native Screen Capture API for perfect rendering

                async captureVisibleStage() {
                    const overlay = document.getElementById('focus-mode-overlay');
                    if (!overlay) {
                        console.warn('captureVisibleStage: Stage overlay not found');
                        return null;
                    }

                    // Hide UI controls before capture
                    const controlsToHide = overlay.querySelectorAll(
                        '.focus-mode-controls, .stage-mode-controls, #annotation-toolbar, ' +
                        '#laser-pointer, #laser-trail-canvas, #teleprompter-controls'
                    );
                    controlsToHide.forEach(el => el.style.visibility = 'hidden');

                    // Wait for UI to update
                    await new Promise(r => setTimeout(r, 80));

                    let dataUrl = null;

                    try {
                        // Use Screen Capture API - the only method that works with modern CSS
                        if (!navigator.mediaDevices?.getDisplayMedia) {
                            throw new Error('Screen Capture API not supported');
                        }

                        const stream = await navigator.mediaDevices.getDisplayMedia({
                            video: { displaySurface: 'browser', preferCurrentTab: true },
                            preferCurrentTab: true,
                            selfBrowserSurface: 'include'
                        });

                        const track = stream.getVideoTracks()[0];
                        const imageCapture = new ImageCapture(track);
                        const bitmap = await imageCapture.grabFrame();
                        stream.getTracks().forEach(t => t.stop());

                        // Draw to canvas and convert to data URL
                        const canvas = document.createElement('canvas');
                        canvas.width = bitmap.width;
                        canvas.height = bitmap.height;
                        canvas.getContext('2d').drawImage(bitmap, 0, 0);
                        dataUrl = canvas.toDataURL('image/png');

                    } catch (error) {
                        if (error.name === 'NotAllowedError' || error.name === 'AbortError') {
                            console.log('Screenshot: User cancelled');
                        } else {
                            console.error('Screenshot error:', error);
                        }
                    }

                    // Restore UI controls
                    controlsToHide.forEach(el => el.style.visibility = '');

                    return dataUrl;
                },


                async exportCurrentSlide() {
                    App.ui.showToast(' Click "Allow" to capture screenshot', { type: 'info', duration: 3000 });

                    const dataUrl = await this.captureVisibleStage();

                    if (!dataUrl) {
                        App.ui.showToast('Screenshot cancelled', { type: 'info', duration: 1500 });
                        return;
                    }

                    try {
                        const blob = await (await fetch(dataUrl)).blob();
                        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
                        App.ui.showToast(' Screenshot copied to clipboard!', { type: 'success', duration: 2000 });
                    } catch (err) {
                        console.error('Clipboard write failed:', err);
                        App.ui.showToast(' Could not copy to clipboard', { type: 'error', duration: 2500 });
                    }
                },


                handleFocusModeKeyDown(e) {
                    // Skip if user is typing in whiteboard textbox or any input
                    if (App.whiteboard?.state?.isOpen) {
                        const isTyping = e.target.tagName === 'INPUT' ||
                            e.target.tagName === 'TEXTAREA' ||
                            e.target.isContentEditable ||
                            e.target.closest('.wb-text-box');
                        if (isTyping) return; // Let textbox handle the input
                    }

                    if (e.target.closest('#kash-copilot-sidebar')) {
                        return;
                    }
                    const session = App.state.focusSession;
                    if (!session.isActive) return;

                    const bodyEl = document.querySelector('.focus-mode-body');
                    if (bodyEl) {
                        bodyEl.classList.toggle('spotlight-active', e.altKey);
                        if (!e.altKey) { bodyEl.querySelector('.spotlight')?.classList.remove('spotlight'); }
                    }

                    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        if (session.isStageMode && session.sigmaMode === 'article') {
                            e.preventDefault();
                            e.stopPropagation();
                            const bodyEl = document.querySelector('.focus-mode-body');
                            if (bodyEl) {
                                const direction = e.key === 'ArrowDown' ? 1 : -1;
                                bodyEl.scrollBy({ top: direction * 50, behavior: 'auto' });
                            }
                            return;
                        }
                        e.preventDefault();
                        e.stopPropagation();

                        const direction = e.key === 'ArrowDown' ? 1 : -1;

                        if (session.isCinematicActive && session.isStageMode) {
                            // In Cinematic mode, up/down navigates through snippets on the current slide
                            const overlay = document.getElementById('focus-mode-overlay');
                            const allItems = Array.from(overlay.querySelectorAll('.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-accordion'));
                            if (allItems.length === 0) return;

                            const currentIndex = allItems.findIndex(el => el.classList.contains('is-revealing'));
                            let nextIndex = currentIndex + direction;
                            nextIndex = Math.max(0, Math.min(allItems.length - 1, nextIndex));

                            if (currentIndex !== nextIndex || currentIndex === -1) {
                                allItems.forEach(item => item.classList.remove('is-revealing', 'spotlight-key-focus'));
                                const targetItem = allItems[nextIndex];
                                targetItem.classList.add('is-revealing', 'spotlight-key-focus');
                                targetItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                App.events.typewriter.start(targetItem);
                            }
                        } else {
                            // In all other modes, up/down navigates the spotlight
                            App.events.spotlight.navigate(direction);
                        }
                        return; // Arrow key action is handled.
                    }

                    // --- Handle all other keys ---
                    if (session.isStageMode) {
                        const stageKeys = [' ', 'arrowright', 'pagedown', 'arrowleft', 'pageup', 'enter', 'b', 'd', 'c', 'l', 'w', 'p', 'escape', 'g', 'h', 'f'];
                        if (stageKeys.includes(e.key.toLowerCase())) {
                            e.preventDefault();
                            e.stopPropagation();
                        }

                        switch (e.key.toLowerCase()) {
                            case ' ': case 'arrowright': case 'pagedown': App.events.navigateStageSlide(1); break;
                            case 'arrowleft': case 'pageup': App.events.navigateStageSlide(-1); break;
                            case 'enter':
                                const focusedEl = document.querySelector('.spotlight-key-focus');
                                if (focusedEl) {
                                    const accordionTrigger = focusedEl.querySelector('.nk-accordion-trigger');
                                    if (accordionTrigger) {
                                        accordionTrigger.click();
                                    }
                                    else if (focusedEl.classList.contains('nk-mcq-block')) {
                                        App.events.handleMcqAnswer({ target: focusedEl }, false);
                                    }
                                    else if (focusedEl.classList.contains('snippet')) {
                                        focusedEl.click();
                                    }
                                }
                                break;
                            case 's': App.events.toggleStageMode(); break;
                            case 'b': document.querySelector('.focus-mode-overlay')?.classList.toggle('blackout-active'); break;
                            // LOCKED FEATURES
                            case 'd': // Annotation
                                if (!App.license.isPremium()) App.ui.showAscensionModal();
                                else App.annotationEngine.toggle('focus');
                                break;
                            case 'p': // Screenshot
                                if (!App.license.isPremium()) App.ui.showAscensionModal();
                                else App.events.exportCurrentSlide();
                                break;
                            case 'f': App.events.toggleFocusModeControls(); break;
                            case 'g': // Cinematic Reveal
                                if (!App.license.isPremium()) App.ui.showAscensionModal();
                                else App.events.presentation.toggleCinematicMotion(document.querySelector('.stage-mode-controls .btn-icon[onclick*="toggleCinematicMotion"]'));
                                break;
                            case 'r': if (isAnnotationActive) App.annotationEngine.setTool('rect'); break;
                            case 'e': if (isAnnotationActive) App.annotationEngine.setTool('eraser'); break;
                            case 'x': App.events.annotation.clear(); break;
                            case 'c':
                                if (isAnnotationActive) App.annotationEngine.cycleColor();
                                else App.events.presentation.cycleAmbiance();
                                break;
                            case 't': // NEW SHORTCUT
                                if (isAnnotationActive) App.annotationEngine.cycleThickness();
                                break;
                            case 'l': App.events.toggleSharedLaser('stage'); break;
                            case 'w': App.events.annotation.toggleWhiteboard(document.querySelector('#annotation-toolbar .btn-icon[onclick*="toggleWhiteboard"]')); break;

                            case 'h': document.querySelector('.stage-mode-controls .btn-icon[onclick*="toggleStageModeHighlights"]')?.click(); break;
                            case 'i': App.events.presentation.toggleTeleprompter(); break;
                            case '+':
                            case '=':
                                App.events.presentation.adjustTeleprompterFont(0.1);
                                break;
                            case '-':
                                App.events.presentation.adjustTeleprompterFont(-0.1);
                                break;

                            case 'escape':
                                const overlay = document.querySelector('.focus-mode-overlay');
                                if (overlay?.classList.contains('annotation-active')) App.events.annotation.toggle();
                                else if (overlay?.classList.contains('laser-active')) App.events.toggleSharedLaser('stage');
                                else if (overlay?.classList.contains('blackout-active')) overlay.classList.remove('blackout-active');
                                else App.events.toggleStageMode();
                                break;
                        }
                    } else { // Standard Focus Mode
                        const standardKeys = ['enter', 'escape', 'pagedown', 'pageup', 'arrowright', 'arrowleft', 'h', 's'];
                        if (standardKeys.includes(e.key.toLowerCase())) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        switch (e.key.toLowerCase()) {
                            case 'c': App.events.presentation.cycleAmbiance(); break; // Cycle Color
                            case 'e': // Font Size
                                const fontBtn = document.getElementById('focus-font-size-btn');
                                if (fontBtn) App.events.toggleFocusModeFontSize(fontBtn);
                                break;
                            case 'f': App.events.toggleFocusModeControls(); break;
                            case 'enter':
                                const focusedEl = document.querySelector('.spotlight-key-focus');
                                if (focusedEl) {
                                    const accordionTrigger = focusedEl.querySelector('.nk-accordion-trigger');
                                    if (accordionTrigger) {
                                        accordionTrigger.click();
                                    }
                                    else if (focusedEl.classList.contains('nk-mcq-block')) {
                                        App.events.handleMcqAnswer({ target: focusedEl }, false);
                                    }
                                    else if (focusedEl.classList.contains('snippet')) {
                                        focusedEl.click();
                                    }
                                }
                                break;
                            case 'escape': App.events.exitFocusMode(); break;
                            case 'pagedown': case 'arrowright': App.events.navigateFocusMode(1); break;
                            case 'pageup': case 'arrowleft': App.events.navigateFocusMode(-1); break;
                            case 'h': document.querySelector('.focus-mode-controls .btn-icon[onclick*="toggleFocusModeHighlights"]')?.click(); break;
                            case 's': App.events.toggleStageMode(); break;
                        }
                    }
                },



                toggleSnippetVisibility(event) {
                    const snippet = event.currentTarget;
                    snippet.classList.toggle('is-hidden');
                },
                toggleFocusModeFontSize(button) {
                    const fontSizes = ['0.85rem', '1.0rem', '1.1rem', '1.2rem', '1.4rem', '1.6rem', '1.8rem', '2.0rem', '2.2rem', '2.4rem', '2.6rem', '2.8rem', '3rem'];
                    const body = document.querySelector('.focus-mode-body');
                    if (!body || !button) return;

                    // RATIONALE: Reading the current size from settings is more reliable than calculating from the DOM.
                    const currentSize = App.settings.get('focusModeFontSize') || '1.1rem';
                    const currentIndex = fontSizes.indexOf(currentSize);

                    const nextIndex = (currentIndex + 1) % fontSizes.length;
                    const newSize = fontSizes[nextIndex];

                    // RATIONALE: We now update the CSS variable instead of the style directly. This is the correct pattern.
                    body.style.setProperty('--focus-mode-font-size', newSize);
                    button.querySelector('span').textContent = newSize.replace('rem', '');
                    App.settings.set('focusModeFontSize', newSize);
                },
                toggleFocusModeControls() {
                    const overlay = document.querySelector('.focus-mode-overlay');
                    if (!overlay) return;

                    const isHidden = overlay.classList.toggle('controls-hidden');
                    const toggleBtn = document.getElementById('focus-mode-immersive-toggle');



                    if (toggleBtn) {
                        toggleBtn.title = isHidden ? 'Show Controls' : 'Hide Controls';
                        // Update icon if it is the standard focus mode button (which has svg content)
                        if (toggleBtn.querySelector('svg')) {
                            toggleBtn.innerHTML = isHidden ? App.util.icons.compress : App.util.icons.expand;
                        }
                    }

                    // Minified toast
                    if (isHidden) App.ui.showToast('Immersive(f)', 'info');
                },

                toggleFocusModeHighlights(button) {
                    const body = document.querySelector('.focus-mode-body');
                    if (!body || !button) return;
                    const isHiding = body.classList.toggle('hide-snippet-colors');
                    button.classList.toggle('active', !isHiding);
                    App.settings.set('categoryHighlightsVisible', !isHiding);
                },

                toggleStageModeHighlights(button) {
                    const body = document.querySelector('.focus-mode-body');
                    if (!body || !button) return;

                    const isHiding = body.classList.toggle('hide-snippet-colors');
                    button.classList.toggle('active', !isHiding);
                    App.settings.set('categoryHighlightsVisible', !isHiding);
                },

                toggleSigmaMode(button) {
                    const session = App.state.focusSession;

                    // CYCLE STATES: presentation -> article -> presentation
                    const modes = ['presentation', 'article'];
                    const currentMode = session.sigmaMode || 'presentation';
                    const nextIndex = (modes.indexOf(currentMode) + 1) % modes.length;
                    session.sigmaMode = modes[nextIndex];

                    App.ui.renderFocusMode();

                    const titles = {
                        'presentation': "Sigma Mode: Presentation",
                        'article': "Sigma Mode: Full Article"
                    };
                    // NEW: Initialize temporary annotations for Sigma Article Mode if not present
                    if (session.sigmaMode === 'article' && !session.sigmaAnnotations) {
                        session.sigmaAnnotations = {};
                    }
                    if (App.annotationEngine.state.isActive) {
                        setTimeout(() => App.annotationEngine.redrawPageAnnotations(), 50);
                    }

                    const msg = titles[session.sigmaMode] || "Sigma Mode";
                    App.ui.showToast(msg, 'info', 1500);
                },

                triggerZipImport() {
                    App.ui.showConfirmationModal({
                        title: 'Confirm Import',
                        message: 'Select a <b>.zip</b> backup, <b>PDF</b>, or one or more <b>.notekash</b> / <b>.json</b> note files to import. Existing notes will be intelligently merged.',
                        confirmText: 'Proceed',
                        onConfirm: () => {
                            const input = document.getElementById('import-files-input'); // <-- Use new ID
                            input.onchange = (e) => { App.services.backup.handleFileImport(e.target.files); }; // <-- Call new handler
                            input.click();
                        }
                    });
                },
            },


            // ==========================================================================
            // 3.13. SERVICES
            // ==========================================================================
            services: {
                export: {
                    getCategoryContent(category, sortedArticles, asMarkdown = false) {
                        return sortedArticles.map(article => {
                            const snippets = App.util.extractSnippets({ content: article.content, id: article.id }, 'highlight', asMarkdown);
                            if (snippets.length === 0) return '';
                            return (asMarkdown ? `## ${article.title}\n` : `Title: ${article.title}\n`) + snippets.map(s => (asMarkdown ? `- ${s.text}` : ` ${s.text}`)).join('\n');
                        }).filter(Boolean).join('\n\n');
                    },
                    getSortedArticlesForCategory(category) {
                        const sortBy = App.settings.get('categorySortBy') || 'updatedAt';
                        let articles = category === 'All' ? [...App.state.articles] : App.state.articles.filter(a => a.category === category);

                        if (sortBy === 'random') return articles.sort(() => Math.random() - 0.5);

                        articles.sort((a, b) => {
                            switch (sortBy) {
                                case 'createdAt': return new Date(a.createdAt) - new Date(b.createdAt);
                                case 'read': return (b.readCount || 0) - (a.readCount || 0);
                                case 'unread': return (a.readCount || 0) - (b.readCount || 0);
                                default: return new Date(b.updatedAt) - new Date(a.updatedAt);
                            }
                        });

                        if (sortBy === 'unread') articles = articles.filter(a => !a.readCount || a.readCount === 0);
                        if (sortBy === 'read') articles = articles.filter(a => a.readCount > 0);
                        return articles;
                    },
                    copyCategoryContent(category) {
                        const sortedArticles = this.getSortedArticlesForCategory(category);
                        const text = this.getCategoryContent(category, sortedArticles, false);
                        if (!text) return App.ui.showToast('No content to copy.');
                        navigator.clipboard.writeText(text).then(() => App.ui.showToast("Content copied!"));
                    },
                    copyCategoryContentAsMarkdown(category) {
                        const sortedArticles = this.getSortedArticlesForCategory(category);
                        const text = this.getCategoryContent(category, sortedArticles, true);
                        if (!text) return App.ui.showToast('No content to copy.');
                        navigator.clipboard.writeText(text).then(() => App.ui.showToast("Markdown content copied!"));
                    },
                    categoryAsText(category) {
                        const sortedArticles = this.getSortedArticlesForCategory(category);
                        const text = this.getCategoryContent(category, sortedArticles, false);
                        if (!text) return App.ui.showToast('No content to export.');
                        App.util.downloadBlob(new Blob([text], { type: 'text/plain' }), `${category}-highlights.txt`);
                    },
                    async categoryAsPdf(category) {
                        // Check pdfmake availability
                        if (typeof pdfMake === 'undefined') {
                            App.ui.showToast('PDF library is loading. Please try again in a moment.', { type: 'error' });
                            return;
                        }

                        const sortedArticles = this.getSortedArticlesForCategory(category);
                        const articlesWithSnippets = sortedArticles
                            .map(article => ({
                                ...article,
                                snippets: App.util.extractSnippets({ content: article.content, id: article.id }, 'highlight', true)
                            }))
                            .filter(article => article.snippets.length > 0);

                        if (articlesWithSnippets.length === 0) {
                            App.ui.showToast('No highlights in this category to export.', { type: 'info' });
                            return;
                        }

                        const toastId = App.ui.showToast(' Preparing PDF export...', { type: 'info', duration: 0 });

                        try {
                            // 
                            //  DESIGN SYSTEM - Premium category snippets PDF
                            // 
                            const categoryName = App.util.getCategoryDisplayName(category);
                            const categoryColor = App.util.getCategoryColor(category);
                            const totalSnippets = articlesWithSnippets.reduce((sum, a) => sum + a.snippets.length, 0);

                            // Build content for each article with premium styling
                            const articleBlocks = [];
                            articlesWithSnippets.forEach((article, idx) => {
                                // Article separator (except first)
                                if (idx > 0) {
                                    articleBlocks.push({
                                        canvas: [{
                                            type: 'line',
                                            x1: 100, y1: 0,
                                            x2: 395, y2: 0,
                                            lineWidth: 0.5,
                                            lineColor: '#E5E7EB'
                                        }],
                                        margin: [0, 18, 0, 20]
                                    });
                                }

                                // Article title with snippet count - refined elegant design
                                articleBlocks.push({
                                    columns: [
                                        {
                                            text: article.title,
                                            bold: true,
                                            fontSize: 14,
                                            color: '#111827',
                                            width: '*',
                                            lineHeight: 1.2
                                        },
                                        {
                                            stack: [
                                                {
                                                    text: `${article.snippets.length}`,
                                                    fontSize: 11,
                                                    color: '#6366F1',
                                                    bold: true,
                                                    alignment: 'center'
                                                },
                                                {
                                                    text: article.snippets.length === 1 ? 'snip' : 'snips',
                                                    fontSize: 7,
                                                    color: '#9CA3AF',
                                                    alignment: 'center',
                                                    margin: [0, 1, 0, 0]
                                                }
                                            ],
                                            width: 35,
                                            alignment: 'right'
                                        }
                                    ],
                                    margin: [0, 0, 0, 12]
                                });

                                // Snippets for this article - premium left-bordered quotes
                                article.snippets.forEach((snippet, snippetIdx) => {
                                    // Strip HTML tags for clean text
                                    const cleanText = snippet.text || snippet.html?.replace(/<[^>]*>/g, '') || '';
                                    articleBlocks.push({
                                        table: {
                                            widths: [2.5, '*'],
                                            body: [[
                                                { text: '', fillColor: '#6366F1' },
                                                {
                                                    text: cleanText,
                                                    margin: [16, 12, 14, 12],
                                                    fontSize: 10.5,
                                                    color: '#374151',
                                                    lineHeight: 1.65,
                                                    italics: true,
                                                    fillColor: '#FAFBFC'
                                                }
                                            ]]
                                        },
                                        layout: {
                                            hLineWidth: () => 0,
                                            vLineWidth: () => 0,
                                            paddingLeft: () => 0,
                                            paddingRight: () => 0,
                                            paddingTop: () => 0,
                                            paddingBottom: () => 0
                                        },
                                        margin: [0, 0, 0, 8]
                                    });
                                });
                            });

                            // Premium user check (for watermark logic)
                            const isPremiumUser = App.license.isPremium();

                            // Build PDF document with premium design
                            const docDefinition = {
                                pageSize: 'A4',
                                pageMargins: [50, 50, 50, 55],

                                //  WATERMARK (Non-premium users only) 
                                watermark: isPremiumUser ? null : {
                                    text: 'notekash.com',
                                    color: '#6366F1',
                                    opacity: 0.07,
                                    bold: true,
                                    angle: -45
                                },

                                //  FOOTER - Premium branding 
                                footer: function (currentPage, pageCount) {
                                    return {
                                        stack: [
                                            // Refined separator line
                                            {
                                                canvas: [{
                                                    type: 'line',
                                                    x1: 50, y1: 0,
                                                    x2: 545, y2: 0,
                                                    lineWidth: 0.4,
                                                    lineColor: '#E2E8F0'
                                                }]
                                            },
                                            // Elegant footer content
                                            {
                                                columns: [
                                                    // Left: Page indicator
                                                    {
                                                        text: [
                                                            { text: 'Page ', color: '#94A3B8', fontSize: 8 },
                                                            { text: `${currentPage}`, color: '#64748B', fontSize: 8, bold: true },
                                                            { text: ' of ', color: '#94A3B8', fontSize: 8 },
                                                            { text: `${pageCount}`, color: '#64748B', fontSize: 8, bold: true }
                                                        ],
                                                        margin: [50, 10, 0, 0]
                                                    },
                                                    // Right: notekash.com branding
                                                    {
                                                        text: [
                                                            { text: 'note', fontSize: 9, color: '#64748B', bold: true },
                                                            { text: 'kash', fontSize: 9, color: '#6366F1', bold: true },
                                                            { text: '.com', fontSize: 9, color: '#94A3B8' }
                                                        ],
                                                        alignment: 'right',
                                                        margin: [0, 9, 50, 0]
                                                    }
                                                ]
                                            }
                                        ],
                                        margin: [0, 8, 0, 0]
                                    };
                                },

                                content: [
                                    // Category badge - elegant uppercase label
                                    {
                                        text: categoryName.toUpperCase(),
                                        fontSize: 9,
                                        bold: true,
                                        color: categoryColor,
                                        characterSpacing: 1.5,
                                        margin: [0, 0, 0, 8]
                                    },

                                    // Main title - premium typography
                                    {
                                        text: 'Highlights Collection',
                                        fontSize: 32,
                                        bold: true,
                                        color: '#0F172A',
                                        lineHeight: 1.05,
                                        margin: [0, 0, 0, 6]
                                    },

                                    // Elegant subtitle
                                    {
                                        text: 'Curated snippets from your research',
                                        fontSize: 12,
                                        color: '#64748B',
                                        italics: true,
                                        margin: [0, 0, 0, 16]
                                    },

                                    // Meta info row - refined stats
                                    {
                                        columns: [
                                            {
                                                text: [
                                                    { text: `${totalSnippets} `, color: '#6366F1', bold: true, fontSize: 12 },
                                                    { text: `highlight${totalSnippets !== 1 ? 's' : ''}`, color: '#64748B', fontSize: 11 },
                                                    { text: '    ', color: '#CBD5E1', fontSize: 11 },
                                                    { text: `${articlesWithSnippets.length} `, color: '#6366F1', bold: true, fontSize: 12 },
                                                    { text: `source${articlesWithSnippets.length !== 1 ? 's' : ''}`, color: '#64748B', fontSize: 11 }
                                                ]
                                            },
                                            {
                                                text: new Date().toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' }),
                                                fontSize: 10,
                                                color: '#94A3B8',
                                                alignment: 'right'
                                            }
                                        ],
                                        margin: [0, 0, 0, 12]
                                    },

                                    // Premium double-line divider with accent
                                    {
                                        canvas: [
                                            {
                                                type: 'line',
                                                x1: 0, y1: 0,
                                                x2: 495, y2: 0,
                                                lineWidth: 2.5,
                                                lineColor: categoryColor
                                            },
                                            {
                                                type: 'line',
                                                x1: 0, y1: 5,
                                                x2: 495, y2: 5,
                                                lineWidth: 0.5,
                                                lineColor: '#E2E8F0'
                                            }
                                        ],
                                        margin: [0, 6, 0, 28]
                                    },

                                    // Article blocks with snippets
                                    ...articleBlocks
                                ],

                                defaultStyle: {
                                    font: 'Roboto',
                                    fontSize: 11,
                                    color: '#1E293B',
                                    lineHeight: 1.65
                                }
                            };

                            App.ui.updateToast(toastId, ' Generating PDF...');

                            // Generate and download
                            const filename = `${App.util.slugify(categoryName)}-highlights.pdf`;
                            if (App.offline.check('PDF Export') && typeof pdfMake !== 'undefined') pdfMake.createPdf(docDefinition).download(filename);

                            App.ui.updateToast(toastId, ` PDF exported: ${filename}`, { type: 'success', duration: 3000 });

                        } catch (error) {
                            console.error('Category PDF export error:', error);
                            App.ui.updateToast(toastId, ' Failed to generate PDF', { type: 'error', duration: 3000 });
                        }
                    },
                    copyCurrentArticleHighlights() {
                        const article = App.storage.getArticle(App.state.activeArticleId); if (!article) return;
                        const highlights = App.util.extractSnippets({ content: article.content, id: article.id }, 'highlight');
                        if (highlights.length === 0) return App.ui.showToast("No highlights to copy.");
                        const watermark = '\n\n---\nShared from notekash.com';
                        const text = `Title: ${article.title}\n\n` + highlights.map(h => h.text).join('\n\n') + watermark;
                        navigator.clipboard.writeText(text).then(() => App.ui.showToast("Title and highlights copied!"));
                    },
                    copyArticleSnippets(articleId) {
                        const article = App.storage.getArticle(articleId); if (!article) return;
                        const snippets = App.util.extractSnippets({ content: article.content, id: article.id }, 'highlight');
                        if (snippets.length === 0) return App.ui.showToast("No snippets to copy for this article.");
                        const text = `Title: ${article.title}\n` + snippets.map(s => ` ${s.text}`).join('\n');
                        navigator.clipboard.writeText(text).then(() => App.ui.showToast(`Snippets for "${article.title}" copied!`));
                    },
                    exportFlashcardsAsTxt() {
                        const cards = App.util.getSortedFlashcardsForDisplay();
                        if (cards.length === 0) return App.ui.showToast("No flashcards to export.");
                        const text = cards.map(c => c.fullText).join('\n\n---\n\n');
                        App.util.downloadBlob(new Blob([text], { type: 'text/plain;charset=utf-8' }), `${App.util.getCategoryDisplayName(App.settings.get('flashcardCategory') || 'All')}-flashcards.txt`);
                    },
                    exportFlashcardsAsTsv() {
                        const cards = App.util.getSortedFlashcardsForDisplay();
                        if (cards.length === 0) return App.ui.showToast("No flashcards to export.");
                        const tsvHeader = "Front\tBack\tDeck\tTags\n";
                        const tsvRows = cards.map(c => {
                            const article = App.storage.getArticle(c.articleId);
                            const tags = article?.tags?.join(' ') || '';
                            let front, back;
                            if (c.type === 'collapsible') {
                                front = c.frontText;
                                back = c.backText;
                            } else { // Cloze card
                                front = c.fullText;
                                back = ''; // Cloze cards are single-field in Anki
                            }
                            return [front, back, App.util.getCategoryDisplayName(c.category), tags].map(App.util.escapeForTsv).join('\t');
                        });
                        const tsvContent = tsvHeader + tsvRows.join('\n');
                        const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
                        App.util.downloadBlob(new Blob([bom, tsvContent], { type: 'text/tab-separated-values;charset=utf-8' }), `${App.util.getCategoryDisplayName(App.settings.get('flashcardCategory') || 'All')}-flashcards-anki.tsv`);
                    },


                    _getHtmlExportTemplate(title, bodyContent, themeName = 'light') {
                        const styles = getComputedStyle(document.documentElement);
                        const cssVars = [
                            '--bg-primary', '--bg-secondary', '--bg-tertiary', '--text-primary', '--text-secondary',
                            '--border-color', '--primary-color', '--hl-text', '--category-pill-text',
                            '--hl-1-bg', '--hl-1-border', '--hl-2-bg', '--hl-2-border', '--hl-3-bg', '--hl-3-border',
                            '--hl-4-bg', '--hl-4-border', '--hl-5-bg', '--hl-5-border', '--hl-6-bg', '--hl-6-border',
                            '--hl-7-bg', '--hl-7-border', '--text-red', '--text-green', '--text-blue'
                        ].map(v => `${v}: ${styles.getPropertyValue(v)};`).join('\n');

                        const watermarkButtonHTML = `<a id="notekash-watermark" href="https://notekash.com" target="_blank" rel="noopener noreferrer">Source: notekash.com</a>`;

                        // MASTER CSS: Generates the perfect "carved" look for the watermark AND pills based on the exported theme.
                        const getThemeAwareCSS = (theme) => {
                            const baseCSS = `
                            #notekash-watermark, .exported-pill {
                                display: inline-block;
                                padding: 8px 16px;
                                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                                font-size: 12px;
                                font-weight: 600;
                                text-decoration: none;
                                border-radius: 999px;
                                transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                            }
                            #notekash-watermark {
                                position: fixed;
                                bottom: 20px;
                                right: 25px;
                                z-index: 9999;
                            }
                            .exported-pills-container { margin-bottom: 2rem; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
                            .exported-pill.category { font-size: 13px; padding: 9px 18px; }
                        `;

                            switch (theme) {
                                case 'dark':
                                    return baseCSS + `
                                    #notekash-watermark, .exported-pill { /* Honed Slate */
                                        background-color: #21262D;
                                        color: #8B949E;
                                        border: 1px solid #30363D;
                                        box-shadow: 0 4px 15px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.05);
                                        text-shadow: 0 -1px 1px rgba(0, 0, 0, 0.6);
                                    }
                                    #notekash-watermark:hover, .exported-pill:hover {
                                        color: #c9d1d9;
                                        transform: translateY(-2px);
                                        box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.05);
                                    }
                                `;
                                case 'sepia':
                                    return baseCSS + `
                                    #notekash-watermark, .exported-pill { /* Aged Brass */
                                        background: linear-gradient(145deg, #d3c8b6, #fbf0d9);
                                        color: #7a6a57;
                                        border: 1px solid rgba(91, 70, 54, 0.3);
                                        box-shadow: 0 5px 20px rgba(91, 70, 54, 0.2), inset 0 1px 1px rgba(255, 255, 255, 0.7);
                                        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8), 0 -1px 1px rgba(91, 70, 54, 0.2);
                                    }
                                    #notekash-watermark:hover, .exported-pill:hover {
                                        color: #5b4636;
                                        transform: translateY(-2px);
                                        box-shadow: 0 10px 30px rgba(91, 70, 54, 0.3), inset 0 1px 1px rgba(255, 255, 255, 0.7);
                                    }
                                `;
                                default: // Light Theme
                                    return baseCSS + `
                                    #notekash-watermark, .exported-pill { /* Polished Marble */
                                        background: linear-gradient(145deg, #e9ecef, #ffffff);
                                        color: var(--text-secondary);
                                        border: 1px solid var(--border-color);
                                        box-shadow: 0 5px 20px rgba(0,0,0,0.07), inset 0 1px 1px rgba(255,255,255,0.8);
                                        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.9), 0 -1px 1px rgba(0, 0, 0, 0.05);
                                    }
                                    #notekash-watermark:hover, .exported-pill:hover {
                                        color: var(--text-primary);
                                        transform: translateY(-2px);
                                        box-shadow: 0 10px 30px rgba(0,0,0,0.1), inset 0 1px 1px rgba(255,255,255,0.8);
                                    }
                                `;
                            }
                        };

                        const watermarkCSS = getThemeAwareCSS(themeName);

                        return `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>${title}</title><style>:root{${cssVars}}body{padding-bottom: 80px; font-family:Georgia,serif;background-color:var(--bg-primary);color:var(--text-primary);max-width:90ch;margin:2rem auto;line-height:1.7;font-size:1.15rem;padding:2rem;}img{max-width:100%;height:auto;}[class^="highlight-"]{padding:0.1em 0.3em;margin:0 -0.1em;border-radius:4px;color:var(--hl-text);border-bottom:2px solid;}.highlight-1{background-color:var(--hl-1-bg);border-color:var(--hl-1-border);}.highlight-2{background-color:var(--hl-2-bg);border-color:var(--hl-2-border);}.highlight-3{background-color:var(--hl-3-bg);border-color:var(--hl-3-border);}.highlight-4{background-color:var(--hl-4-bg);border-color:var(--hl-4-border);}.highlight-5{background-color:var(--hl-5-bg);border-color:var(--hl-5-border);}.highlight-6{background-color:var(--hl-6-bg);border-color:var(--hl-6-border);}.highlight-7{background-color:var(--hl-7-bg);border-color:var(--hl-7-border);}.text-red{color:var(--text-red);}.text-green{color:var(--text-green);}.text-blue{color:var(--text-blue);}.text-underline{text-decoration:underline;}blockquote{border-left:3px solid var(--primary-color);margin-left:0;padding-left:1.5em;color:var(--text-secondary);font-style:italic;}hr{border:none;border-top:1px solid var(--border-color);margin:2em 0;} ${watermarkCSS}</style></head><body>${bodyContent}${watermarkButtonHTML}</body></html>`;
                    },

                    exportArticleAsHtml() {
                        const article = App.storage.getArticle(App.state.activeArticleId); if (!article) return;
                        const categoryObj = App.settings.get('userCategories').find(c => c.name === article.category) || { name: article.category, colorIndex: 0 };
                        const categoryPill = `<div class="exported-pill category" style="background-color: ${App.util.getCategoryColor(categoryObj.colorIndex)}; color: var(--category-pill-text);">${App.util.getCategoryDisplayName(categoryObj.name)}</div>`;
                        const tagsPills = (article.tags || []).map(tag => `<div class="exported-pill">${App.state.tags[tag]?.displayName || tag}</div>`).join('');
                        const pillsHTML = `<div class="exported-pills-container">${categoryPill}${tagsPills}</div>`;

                        const bodyContent = `${pillsHTML}<h1>${article.title}</h1><hr>${App.util.parseShortcuts(article.content)}`;
                        const fullHtml = this._getHtmlExportTemplate(article.title, bodyContent, App.settings.get('theme'));
                        App.util.downloadBlob(new Blob([fullHtml], { type: 'text/html' }), `${App.util.slugify(article.title)}.html`);
                    },

                    async exportAsNoteKashFile() {
                        const articleId = App.state.activeArticleId;
                        if (!articleId || articleId === 'temp_new_article') {
                            App.ui.showToast('Please save the note once before exporting.', { type: 'error' });
                            return;
                        }

                        const article = App.storage.getArticle(articleId);
                        if (!article) {
                            App.ui.showToast('Article data is missing, cannot export.', { type: 'error' });
                            return;
                        }

                        const filename = `${App.util.slugify(article.title)}.notekash`;
                        const fileContent = JSON.stringify(article, null, 2);
                        const blob = new Blob([fileContent], { type: 'application/json' });
                        const file = new File([blob], filename, { type: 'application/json' });

                        const shareData = {
                            title: `NoteKash Note: ${article.title}`,
                            text: `Here is the NoteKash note "${article.title}"`,
                            files: [file],
                        };

                        let shareSucceeded = false;

                        if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                            try {
                                await navigator.share(shareData);
                                shareSucceeded = true; // Mark as successful
                                App.ui.showToast('Note shared!', { type: 'success' });
                            } catch (err) {
                                if (err.name === 'AbortError') {
                                    shareSucceeded = true; // Mark as "handled"
                                    App.ui.showToast('Share cancelled.', { type: 'info' });
                                } else {
                                    console.warn('Web Share API failed, falling back to download:', err);
                                    shareSucceeded = false;
                                }
                            }
                        }
                        if (!shareSucceeded) {
                            try {
                                App.util.downloadBlob(blob, filename);
                                App.ui.showToast('NoteKash file downloaded!', { type: 'success' });
                            } catch (downloadErr) {
                                console.error('Fallback download also failed:', downloadErr);
                                App.ui.showToast('Could not share or download the file.', { type: 'error' });
                            }
                        }
                    },


                    exportCategoryAsHtml(category) {
                        const sortedArticles = this.getSortedArticlesForCategory(category);
                        const articlesWithHighlights = sortedArticles
                            .map(article => ({ ...article, snippets: App.util.extractSnippets({ content: article.content, id: article.id }, 'highlight', true) }))
                            .filter(article => article.snippets.length > 0);

                        if (articlesWithHighlights.length === 0) { App.ui.showToast("No highlights in this category to export."); return; }

                        const bodyContent = `<h1>Category: ${App.util.getCategoryDisplayName(category)}</h1>` + articlesWithHighlights.map(article =>
                            `<h2><b>${article.title}</b></h2>${article.snippets.map(s => `<p>${s.html}</p>`).join('')}`
                        ).join('<hr>');

                        const fullHtml = this._getHtmlExportTemplate(`${App.util.getCategoryDisplayName(category)} Highlights`, bodyContent, App.settings.get('theme'));
                        App.util.downloadBlob(new Blob([fullHtml], { type: 'text/html' }), `${App.util.slugify(category)}-highlights.html`);
                    },

                    /* Export Article as PDF - Premium PDF with pdfmake (selectable text, images, elegant watermark) */
                    async exportArticleAsPdf() {
                        const article = App.storage.getArticle(App.state.activeArticleId);
                        if (!article) {
                            App.ui.showToast('No article to export.', { type: 'error' });
                            return;
                        }

                        // Check pdfmake availability
                        if (typeof pdfMake === 'undefined') {
                            App.ui.showToast('PDF library is loading. Please try again in a moment.', { type: 'error' });
                            return;
                        }

                        const toastId = App.ui.showToast(' Preparing PDF export...', { type: 'info', duration: 0 });

                        try {
                            //  DESIGN SYSTEM - Print-optimized (always white background)
                            const colors = {
                                bg: '#FFFFFF',
                                paper: '#FFFFFF',
                                text: '#1A1A1A',
                                textMuted: '#6B7280',
                                accent: '#4F46E5',           // Indigo - premium brand color
                                accentLight: '#EEF2FF',
                                categoryBg: '4F46E5',       // Indigo for category badge
                                highlight: {
                                    1: '#FEF9C3',  // Yellow - softer
                                    2: '#DCFCE7',  // Green
                                    3: '#DBEAFE',  // Blue
                                    4: '#FEE2E2',  // Red/Pink
                                    5: '#F3E8FF',  // Purple
                                    6: '#E0F2FE',  // Cyan
                                    7: '#FCE7F3'   // Pink
                                }
                            };

                            // Get category styling
                            const categoryObj = App.settings.get('userCategories').find(c => c.name === article.category) || { name: article.category, colorIndex: 0 };
                            const categoryColor = App.util.getCategoryColor(categoryObj.colorIndex);
                            const categoryName = App.util.getCategoryDisplayName(article.category);

                            // Calculate word count
                            const tempWordCountDiv = document.createElement('div');
                            tempWordCountDiv.innerHTML = article.content;
                            const wordCount = (tempWordCountDiv.textContent || tempWordCountDiv.innerText || '').trim().split(/\s+/).filter(w => w.length > 0).length;


                            //  IMAGE PROCESSING - Only embedded base64 images (no URL fetching)
                            App.ui.updateToast(toastId, ' Processing images...');

                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = App.util.sanitizeHTML(App.util.parseShortcuts(article.content));
                            const allImages = tempDiv.querySelectorAll('img');
                            const imageCache = new Map();

                            let embeddedCount = 0;
                            let skippedCount = 0;

                            Array.from(allImages).forEach(img => {
                                const src = img.getAttribute('src');
                                if (src && src.startsWith('data:')) {
                                    imageCache.set(src, src);
                                    embeddedCount++;
                                } else if (src) {
                                    skippedCount++;
                                }
                            });

                            if (embeddedCount > 0 || skippedCount > 0) {
                                console.log(`PDF Export: ${embeddedCount} embedded images, ${skippedCount} external URLs skipped`);
                            }

                            App.ui.updateToast(toastId, ' Building PDF...');

                            // CONTENT PARSER - Convert HTML to pdfmake format
                            const parseHtmlToPdfContent = (html) => {
                                const div = document.createElement('div');
                                div.innerHTML = App.util.sanitizeHTML(App.util.parseShortcuts(html));

                                const content = [];
                                //  PDF HIGHLIGHT STYLING - Elegant Underlines (No blocky backgrounds) 
                                const highlightUnderlineMap = {
                                    'highlight-1': '#EAB308',  // Yellow-500 (Gold)
                                    'highlight-2': '#16A34A',  // Green-600
                                    'highlight-3': '#2563EB',  // Blue-600
                                    'highlight-4': '#DC2626',  // Red-600
                                    'highlight-5': '#9333EA',  // Purple-600
                                    'highlight-6': '#0891B2',  // Cyan-600
                                    'highlight-7': '#DB2777'   // Pink-600
                                };

                                //  PDF TEXT COLORS - All 7 text colors 
                                const textColorMap = {
                                    'text-red': '#DC2626',     // Red - vibrant
                                    'text-green': '#16A34A',   // Green - forest
                                    'text-blue': '#2563EB',    // Blue - royal
                                    'text-magenta': '#C026D3', // Magenta - Fuchsia 600 (Darker for contrast)
                                    'text-orange': '#EA580C',  // Orange - warm
                                    'text-teal': '#0D9488',    // Teal - Teal 600
                                    'text-slate': '#475569',   // Slate - Slate 600
                                    // Aliases for robustness
                                    'text-purple': '#C026D3',
                                    'text-cyan': '#0891B2',
                                    'text-pink': '#DB2777'
                                };

                                //  EMOJI RENDERING HELPER
                                // Draws emoji to a canvas and returns base64 image to prevent "blank boxes" in PDF
                                const emojiCanvas = document.createElement('canvas');
                                const ctx = emojiCanvas.getContext('2d');
                                const getEmojiDataUrl = (emoji) => {
                                    // High res for crisp PDF
                                    emojiCanvas.width = 64;
                                    emojiCanvas.height = 64;
                                    ctx.clearRect(0, 0, 64, 64);
                                    ctx.font = '54px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif';
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(emoji, 32, 36); // Slight offset for vertical centering
                                    return emojiCanvas.toDataURL('image/png');
                                };

                                const emojiRegex = /([\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F1E6}-\u{1F1FF}]{2}|[\u{1F600}-\u{1F64F}]|[\u{1F680}-\u{1F6FF}]|[\u{1F900}-\u{1F9FF}]|[\u{1FA70}-\u{1FAFF}]|[\u{200D}])/gu;

                                const processTextWithEmojis = (text, inheritedStyles) => {
                                    if (!text) return null;

                                    // If no emojis, return simple text object
                                    if (!text.match(emojiRegex)) {
                                        return { text: text, ...inheritedStyles };
                                    }

                                    // Split by emoji and map to objects
                                    const parts = text.split(emojiRegex);
                                    const resultArray = [];

                                    parts.forEach(part => {
                                        if (!part) return;
                                        if (part.match(emojiRegex)) {
                                            // It's an emoji - render as image
                                            resultArray.push({
                                                image: getEmojiDataUrl(part),
                                                width: 13,  // Slightly larger than text size
                                                height: 13,
                                                margin: [0, 1, 0, -2] // Inline alignment adjustment
                                            });
                                        } else {
                                            // Regular text
                                            resultArray.push({ text: part, ...inheritedStyles });
                                        }
                                    });
                                    return resultArray;
                                };

                                const processNode = (node, inheritedStyles = {}) => {
                                    if (node.nodeType === Node.TEXT_NODE) {
                                        const text = node.textContent;
                                        // Skip empty whitespace-only nodes unless they are significant (e.g. spaces between words)
                                        // But here we usually just trim or check if it's meaningful
                                        if (text.replace(/[\n\r]+/, '').length > 0) {
                                            return processTextWithEmojis(text, inheritedStyles);
                                        }
                                        return null;
                                    }

                                    if (node.nodeType !== Node.ELEMENT_NODE) return null;

                                    const tag = node.tagName.toLowerCase();
                                    const styles = { ...inheritedStyles };

                                    // Apply styles based on classes
                                    const classList = Array.from(node.classList || []);
                                    classList.forEach(cls => {
                                        //  INNOVATION: "Premium Double Underline"
                                        if (highlightUnderlineMap[cls]) {
                                            styles.decoration = 'underline';
                                            styles.decorationStyle = 'double'; // Thicker, "3D-like" premium effect
                                            styles.decorationColor = highlightUnderlineMap[cls];
                                            // Fix for overlap: Increase line height slightly for highlighted text
                                            styles.lineHeight = 1.6;
                                        }
                                        if (textColorMap[cls]) {
                                            styles.color = textColorMap[cls];
                                            styles.bold = true; // colored text often needs emphasis
                                        }
                                    });

                                    // Also check inline styles for colors
                                    const inlineStyle = node.getAttribute('style') || '';
                                    const bgMatch = inlineStyle.match(/background(?:-color)?:\s*([^;]+)/i);
                                    const colorMatch = inlineStyle.match(/(?:^|[^-])color:\s*([^;]+)/i);

                                    if (bgMatch && bgMatch[1]) {
                                        const bgColor = bgMatch[1].trim();
                                        if (bgColor.startsWith('#') || bgColor.startsWith('rgb')) {
                                            styles.background = bgColor;
                                        }
                                    }
                                    if (colorMatch && colorMatch[1]) {
                                        const textColor = colorMatch[1].trim();
                                        if (textColor.startsWith('#') || textColor.startsWith('rgb')) {
                                            styles.color = textColor;
                                        }
                                    }

                                    // Apply styles based on tag
                                    switch (tag) {
                                        case 'b':
                                        case 'strong':
                                            styles.bold = true;
                                            break;
                                        case 'i':
                                        case 'em':
                                            styles.italics = true;
                                            break;
                                        case 'u':
                                            styles.decoration = 'underline';
                                            break;
                                        case 's':
                                        case 'strike':
                                            styles.decoration = 'lineThrough';
                                            break;
                                        case 'sup':
                                            styles.sup = true;
                                            styles.fontSize = 8;
                                            break;
                                        case 'sub':
                                            styles.sub = true;
                                            styles.fontSize = 8;
                                            break;
                                    }

                                    //  Handle image-container divs - Centered, compact layout 
                                    if (node.classList?.contains('image-container')) {
                                        const img = node.querySelector('img');
                                        if (img) {
                                            const src = img.getAttribute('src');
                                            // Only process base64 images (external URLs are skipped)
                                            if (src && src.startsWith('data:')) {
                                                const base64 = imageCache.get(src);
                                                if (base64) {
                                                    // Compact centered image
                                                    return {
                                                        image: base64,
                                                        width: 200,
                                                        margin: [0, 8, 0, 8],
                                                        alignment: 'center'
                                                    };
                                                }
                                            }
                                            // External URL image - show indicator but don't block
                                            if (src && !src.startsWith('data:')) {
                                                return {
                                                    text: '[ External image ]',
                                                    fontSize: 9,
                                                    italics: true,
                                                    color: '#9CA3AF',
                                                    alignment: 'center',
                                                    margin: [0, 6, 0, 6]
                                                };
                                            }
                                        }
                                        return null; // Empty container
                                    }

                                    //  MCQ & ACCORDION - Unified Q&A Card Format (MUST be before generic div handler) 
                                    if (node.classList?.contains('nk-mcq-block') || node.classList?.contains('nk-accordion')) {
                                        let q = '', a = '';
                                        if (node.classList.contains('nk-mcq-block')) {
                                            q = node.querySelector('.nk-mcq-question')?.textContent?.trim() || '';
                                            const correctOpt = node.querySelector('.nk-mcq-option[data-is-correct="true"] .nk-mcq-option-text');
                                            a = correctOpt?.textContent?.trim() || '';
                                        } else {
                                            q = node.querySelector('.nk-accordion-title')?.textContent?.trim() || '';
                                            a = node.querySelector('.nk-accordion-content')?.textContent?.trim() || '';
                                        }
                                        if (!q && !a) return null;
                                        return {
                                            table: {
                                                widths: [3, '*'], body: [[
                                                    { text: '', fillColor: '#6366F1' },
                                                    {
                                                        stack: [
                                                            { text: [{ text: 'Question: ', bold: true, color: '#6366F1' }, { text: q }], fontSize: 10, margin: [0, 0, 0, 4] },
                                                            { text: [{ text: 'Answer: ', bold: true, color: '#16A34A' }, { text: a, color: '#374151' }], fontSize: 10 }
                                                        ], margin: [10, 8, 8, 8]
                                                    }
                                                ]]
                                            },
                                            layout: { hLineWidth: () => 0, vLineWidth: () => 0, paddingLeft: () => 0, paddingRight: () => 0, paddingTop: () => 0, paddingBottom: () => 0 },
                                            margin: [0, 8, 0, 8]
                                        };
                                    }

                                    // Handle block elements
                                    if (['p', 'div'].includes(tag)) {
                                        const children = [];
                                        node.childNodes.forEach(child => {
                                            const processed = processNode(child, styles);
                                            if (processed) {
                                                if (Array.isArray(processed)) children.push(...processed);
                                                else children.push(processed);
                                            }
                                        });
                                        if (children.length === 0) return { text: '\n', margin: [0, 4, 0, 4] };

                                        // Check if any child is an image (non-text content) - return as stack instead
                                        const hasNonTextContent = children.some(c => c.image || c.stack || c.table || (c.text && Array.isArray(c.text)));
                                        if (hasNonTextContent) {
                                            // If we have mixed content (text + emoji images), we need to be careful not to break paragraph flow
                                            const hasBlockElements = children.some(c => c.stack || c.table || (c.image && c.width > 50));

                                            if (hasBlockElements) return { stack: children, margin: [0, 0, 0, 8] };
                                            return { text: children, margin: [0, 0, 0, 8], lineHeight: 1.6 }; // Increased line height
                                        }
                                        return { text: children, margin: [0, 0, 0, 8], lineHeight: 1.6 };
                                    }

                                    if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)) {
                                        const level = parseInt(tag[1]);
                                        const sizes = { 1: 20, 2: 17, 3: 14, 4: 12, 5: 11, 6: 10 };
                                        const margins = { 1: [0, 18, 0, 8], 2: [0, 16, 0, 7], 3: [0, 14, 0, 6], 4: [0, 10, 0, 5], 5: [0, 8, 0, 4], 6: [0, 6, 0, 4] };
                                        const headingColors = { 1: '#111827', 2: '#1F2937', 3: '#374151', 4: '#4B5563', 5: '#6B7280', 6: '#6B7280' };

                                        // Process children (headers might have emojis)
                                        const children = [];
                                        node.childNodes.forEach(child => {
                                            const processed = processNode(child, styles);
                                            if (processed) {
                                                if (Array.isArray(processed)) children.push(...processed);
                                                else children.push(processed);
                                            }
                                        });

                                        return {
                                            text: children.length ? children : node.textContent, // Fallback to content if simple
                                            fontSize: sizes[level],
                                            bold: true,
                                            color: headingColors[level],
                                            margin: margins[level],
                                            lineHeight: 1.3
                                        };
                                    }

                                    if (tag === 'blockquote') {
                                        const children = [];
                                        node.childNodes.forEach(child => {
                                            const processed = processNode(child, { ...styles, italics: true, color: '#6B7280' });
                                            if (processed) {
                                                if (Array.isArray(processed)) children.push(...processed);
                                                else children.push(processed);
                                            }
                                        });
                                        // Elegant left-bordered quote
                                        return {
                                            table: {
                                                widths: [3, '*'],
                                                body: [[
                                                    { text: '', fillColor: '#6366F1' },
                                                    { stack: [{ text: children }], margin: [12, 6, 0, 6] }
                                                ]]
                                            },
                                            layout: {
                                                hLineWidth: () => 0,
                                                vLineWidth: () => 0,
                                                paddingLeft: () => 0,
                                                paddingRight: () => 0,
                                                paddingTop: () => 0,
                                                paddingBottom: () => 0
                                            },
                                            margin: [0, 10, 0, 10]
                                        };
                                    }

                                    if (tag === 'ul' || tag === 'ol') {
                                        const items = [];
                                        node.querySelectorAll(':scope > li').forEach(li => {
                                            // Process LI children to support emojis/styles inside list items
                                            const liChildren = [];
                                            li.childNodes.forEach(child => {
                                                const processed = processNode(child, styles);
                                                if (processed) {
                                                    if (Array.isArray(processed)) liChildren.push(...processed);
                                                    else liChildren.push(processed);
                                                }
                                            });

                                            items.push({
                                                text: liChildren,
                                                margin: [0, 3, 0, 3],
                                                color: '#374151',
                                                lineHeight: 1.5
                                            });
                                        });
                                        return {
                                            [tag]: items,
                                            margin: [8, 4, 0, 12], // Adjusted for better alignment
                                            color: '#6366F1'  // Bullet/number color
                                        };
                                    }

                                    if (tag === 'br') {
                                        return { text: '\n' };
                                    }

                                    if (tag === 'hr') {
                                        // Elegant centered divider
                                        return {
                                            canvas: [{
                                                type: 'line',
                                                x1: 167, y1: 0,
                                                x2: 348, y2: 0,  // Centered, 180px wide
                                                lineWidth: 0.75,
                                                lineColor: '#D1D5DB'
                                            }],
                                            margin: [0, 16, 0, 16]
                                        };
                                    }

                                    //  IMAGES - Centered, base64 only 
                                    if (tag === 'img') {
                                        const src = node.getAttribute('src');
                                        if (src && src.startsWith('data:')) {
                                            const base64 = imageCache.get(src);
                                            if (base64) {
                                                return {
                                                    image: base64,
                                                    width: 200,
                                                    margin: [0, 8, 0, 8],
                                                    alignment: 'center'
                                                };
                                            }
                                        }
                                        // External URL or failed load - show subtle indicator
                                        if (src && !src.startsWith('data:')) {
                                            return {
                                                text: '[ External image ]',
                                                fontSize: 9,
                                                italics: true,
                                                color: '#9CA3AF',
                                                alignment: 'center',
                                                margin: [0, 6, 0, 6]
                                            };
                                        }
                                        return null;
                                    }

                                    // Handle tables
                                    if (tag === 'table') {
                                        const rows = [];
                                        node.querySelectorAll('tr').forEach(tr => {
                                            const cells = [];
                                            tr.querySelectorAll('td, th').forEach(cell => {
                                                cells.push({
                                                    text: cell.textContent,
                                                    bold: cell.tagName === 'TH',
                                                    fillColor: cell.tagName === 'TH' ? colors.paper : null
                                                });
                                            });
                                            if (cells.length > 0) rows.push(cells);
                                        });
                                        if (rows.length > 0) {
                                            const maxCols = Math.max(...rows.map(r => r.length));
                                            return {
                                                table: {
                                                    headerRows: 1,
                                                    widths: Array(maxCols).fill('*'),
                                                    body: rows
                                                },
                                                margin: [0, 10, 0, 10]
                                            };
                                        }
                                        return null;
                                    }

                                    // Default: process children with inherited styles
                                    const children = [];
                                    node.childNodes.forEach(child => {
                                        const processed = processNode(child, styles);
                                        if (processed) {
                                            if (Array.isArray(processed)) children.push(...processed);
                                            else children.push(processed);
                                        }
                                    });

                                    if (children.length === 0) return null;
                                    if (children.length === 1) return children[0];
                                    return children; // Return array for pdfmake to handle as text mix
                                };

                                // Process all top-level nodes
                                div.childNodes.forEach(node => {
                                    const processed = processNode(node);
                                    if (processed) {
                                        if (Array.isArray(processed) && processed.some(p => p.stack || p.table)) {
                                            // logic to keep blocks separated
                                            content.push({ stack: processed });
                                        } else {
                                            content.push(processed);
                                        }
                                    }
                                });

                                return content;
                            };

                            // Parse article content
                            const articleContent = parseHtmlToPdfContent(article.content);

                            // 
                            //  BUILD PREMIUM PDF DOCUMENT
                            // 

                            // Create stylish tag pills
                            const tagPills = (article.tags || []).map(tag => {
                                const tagDisplay = App.state.tags[tag]?.displayName || tag;
                                return {
                                    text: tagDisplay,
                                    fontSize: 9,
                                    color: colors.accent,
                                    background: colors.paper,
                                    margin: [0, 0, 6, 0]
                                };
                            });

                            // Check if user is premium (for watermark logic)
                            const isPremiumUser = App.license.isPremium();

                            const docDefinition = {
                                pageSize: 'A4',
                                pageMargins: [40, 60, 40, 50],

                                //  WATERMARK (Non-premium users only) 
                                watermark: isPremiumUser ? null : {
                                    text: 'notekash.com',
                                    color: '#6366F1',
                                    opacity: 0.07,
                                    bold: true,
                                    angle: -45
                                },

                                //  HEADER - Premium brand header 
                                header: function (currentPage, pageCount) {
                                    if (currentPage === 1) return null;
                                    return {
                                        columns: [
                                            {
                                                text: article.title.substring(0, 50) + (article.title.length > 50 ? '...' : ''),
                                                fontSize: 9,
                                                color: colors.textMuted,
                                                margin: [40, 25, 0, 0]
                                            },
                                            {
                                                text: categoryName,
                                                fontSize: 9,
                                                color: colors.accent,
                                                alignment: 'right',
                                                margin: [0, 25, 40, 0]
                                            }
                                        ]
                                    };
                                },

                                //  FOOTER - Premium branding 
                                footer: function (currentPage, pageCount) {
                                    return {
                                        stack: [
                                            // Refined separator line
                                            {
                                                canvas: [{
                                                    type: 'line',
                                                    x1: 40, y1: 0,
                                                    x2: 555, y2: 0,
                                                    lineWidth: 0.4,
                                                    lineColor: '#E2E8F0'
                                                }]
                                            },
                                            // Elegant footer content
                                            {
                                                columns: [
                                                    // Left: Page indicator
                                                    {
                                                        text: [
                                                            { text: 'Page ', color: '#94A3B8', fontSize: 8 },
                                                            { text: `${currentPage}`, color: '#64748B', fontSize: 8, bold: true },
                                                            { text: ' of ', color: '#94A3B8', fontSize: 8 },
                                                            { text: `${pageCount}`, color: '#64748B', fontSize: 8, bold: true }
                                                        ],
                                                        margin: [40, 10, 0, 0]
                                                    },
                                                    // Right: notekash.com branding
                                                    {
                                                        text: [
                                                            { text: 'note', fontSize: 9, color: '#64748B', bold: true },
                                                            { text: 'kash', fontSize: 9, color: '#6366F1', bold: true },
                                                            { text: '.com', fontSize: 9, color: '#94A3B8' }
                                                        ],
                                                        alignment: 'right',
                                                        margin: [0, 9, 40, 0]
                                                    }
                                                ]
                                            }
                                        ],
                                        margin: [0, 8, 0, 0]
                                    };
                                },


                                //  MAIN CONTENT 
                                content: [
                                    // Premium Header Section
                                    {
                                        stack: [
                                            // Category badge - elegant uppercase with tracking
                                            {
                                                text: categoryName.toUpperCase(),
                                                fontSize: 9,
                                                bold: true,
                                                color: categoryColor,
                                                characterSpacing: 1.5,
                                                margin: [0, 0, 0, 10]
                                            },

                                            // Title - Large, bold, impactful
                                            {
                                                text: article.title,
                                                fontSize: 30,
                                                bold: true,
                                                color: '#0F172A',
                                                lineHeight: 1.08,
                                                margin: [0, 0, 0, 12]
                                            },

                                            // Metadata row - refined with better hierarchy
                                            {
                                                text: [
                                                    {
                                                        text: new Date(article.createdAt).toLocaleDateString('en-US', {
                                                            weekday: 'short',
                                                            year: 'numeric',
                                                            month: 'short',
                                                            day: 'numeric'
                                                        }),
                                                        color: '#64748B',
                                                        fontSize: 10
                                                    },
                                                    {
                                                        text: '    ',
                                                        color: '#CBD5E1',
                                                        fontSize: 10
                                                    },
                                                    {
                                                        text: `${wordCount.toLocaleString()} words`,
                                                        color: '#64748B',
                                                        fontSize: 10
                                                    },
                                                    article.readCount ? {
                                                        text: '    ',
                                                        color: '#CBD5E1',
                                                        fontSize: 10
                                                    } : {},
                                                    article.readCount ? {
                                                        text: `${article.readCount} reads`,
                                                        color: '#64748B',
                                                        fontSize: 10
                                                    } : {}
                                                ],
                                                margin: [0, 0, 0, 8]
                                            }
                                        ],
                                        margin: [0, 0, 0, 2]
                                    },

                                    // Tags (if any) - Elegant hashtag styling
                                    tagPills.length > 0 ? {
                                        text: tagPills.map((tag, i) => ({
                                            text: (i > 0 ? '   ' : '') + '#' + tag.text,
                                            fontSize: 9,
                                            color: '#6366F1',
                                            bold: false
                                        })),
                                        margin: [0, 0, 0, 14]
                                    } : {},

                                    // Premium double-line divider with category color accent
                                    {
                                        canvas: [
                                            {
                                                type: 'line',
                                                x1: 0, y1: 0,
                                                x2: 515, y2: 0,
                                                lineWidth: 2.5,
                                                lineColor: categoryColor
                                            },
                                            {
                                                type: 'line',
                                                x1: 0, y1: 5,
                                                x2: 515, y2: 5,
                                                lineWidth: 0.5,
                                                lineColor: '#E2E8F0'
                                            }
                                        ],
                                        margin: [0, 4, 0, 26]
                                    },

                                    // Main article content
                                    ...articleContent
                                ],

                                //  STYLES 
                                defaultStyle: {
                                    font: 'Roboto',
                                    fontSize: 11,
                                    color: '#1E293B',
                                    lineHeight: 1.7
                                },

                                styles: {
                                    header: {
                                        fontSize: 20,
                                        bold: true,
                                        color: '#0F172A',
                                        margin: [0, 16, 0, 8]
                                    },
                                    subheader: {
                                        fontSize: 15,
                                        bold: true,
                                        color: '#1E293B',
                                        margin: [0, 14, 0, 6]
                                    }
                                }
                            };

                            App.ui.updateToast(toastId, ' Generating PDF...');

                            // Generate and download PDF
                            const filename = `${App.util.slugify(article.title)}.pdf`;

                            if (App.offline.check('PDF Export') && typeof pdfMake !== 'undefined') pdfMake.createPdf(docDefinition).download(filename, () => {
                                App.ui.hideToast(toastId);
                                App.ui.showToast(` PDF exported: ${filename}`, { type: 'success' });
                            });

                        } catch (error) {
                            console.error('PDF Export Error:', error);
                            App.ui.hideToast(toastId);
                            App.ui.showToast('Failed to export PDF. Please try again.', { type: 'error' });
                        }
                    }
                },
                image: {
                    async processAndInsert(file) {
                        if (file.size > App.config.image.maxUploadSize) {
                            App.ui.showToast(`Image exceeds max size of ${App.config.image.maxUploadSize / 1024 / 1024}MB`, { type: 'error' });
                            return;
                        }

                        try {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                const img = new Image();
                                img.onload = () => {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    const { maxWidth } = App.config.image;
                                    const jpegQuality = App.settings.get('jpegQuality');

                                    let { width, height } = img;
                                    if (width > maxWidth) {
                                        height *= maxWidth / width;
                                        width = maxWidth;
                                    }

                                    canvas.width = width;
                                    canvas.height = height;
                                    ctx.drawImage(img, 0, 0, width, height);

                                    // VALIDATION: Ensure canvas rendered correctly
                                    if (canvas.width === 0 || canvas.height === 0) {
                                        App.ui.showToast("Image could not be processed.", { type: 'error' });
                                        return;
                                    }

                                    // FORMAT HANDLING: Respect user's imageFormat setting
                                    const originalType = file.type || 'image/jpeg';
                                    const userPreferredFormat = App.settings.get('imageFormat') || 'jpeg';
                                    let outputFormat = 'image/jpeg';
                                    let outputQuality = jpegQuality;

                                    if (userPreferredFormat === 'png') {
                                        // PNG mode: Preserve original PNG/GIF format for reliability
                                        if (originalType === 'image/png') {
                                            outputFormat = 'image/png';
                                            outputQuality = undefined; // PNG doesn't use quality param
                                        } else if (originalType === 'image/gif') {
                                            outputFormat = 'image/png';
                                            outputQuality = undefined;
                                        }
                                    }

                                    const dataUrl = canvas.toDataURL(outputFormat, outputQuality);

                                    if (!dataUrl || dataUrl === 'data:,') {
                                        App.ui.showToast("Failed to encode image.", { type: 'error' });
                                        return;
                                    }

                                    const html = `<div class="image-container" contenteditable="false"><img src="${dataUrl}" alt="${file.name || 'image'}" data-original-width="${width}" data-original-height="${height}" style="width:${width}px; height:auto;"><div class="resize-handle resize-handle-se"></div></div>`;
                                    document.execCommand('insertHTML', false, `<p>${html}</p><p><br></p>`);

                                    const blob = App.util.dataURLtoBlob(dataUrl);
                                    if (blob) {
                                        const finalSizeKb = (blob.size / 1024).toFixed(0);
                                        const formatLabel = outputFormat === 'image/png' ? 'PNG' : 'JPEG';
                                        App.ui.showToast(`Image added (${formatLabel}) - ${finalSizeKb}kb`, { type: 'success' });
                                    }
                                };
                                img.onerror = () => {
                                    App.ui.showToast("Image is corrupted or unsupported.", { type: 'error' });
                                };
                                img.src = e.target.result;
                            };
                            reader.onerror = () => {
                                App.ui.showToast("Failed to read image data from clipboard.", { type: 'error' });
                            };
                            reader.readAsDataURL(file);

                        } catch (error) {
                            App.ui.showToast("An error occurred while processing the image.", { type: 'error' });
                            console.error('Image Processing Error:', error);
                        }
                    },

                    async runOCR() {
                        const imageContainer = App.state.selectedImageContainer;
                        if (!imageContainer) return;
                        const img = imageContainer.querySelector('img');
                        if (!img || !img.src) {
                            App.ui.showToast('Image source not found.', { type: 'error' });
                            return;
                        }

                        if (typeof Tesseract === 'undefined') {
                            App.ui.showToast('OCR library is not loaded. Please check your internet connection.', 'error');
                            return;
                        }

                        let ocrToastId = App.ui.showToast('Preprocessing image...', { type: 'info', duration: 0 });

                        try {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d', { willReadFrequently: true });

                            const imageToProcess = new Image();
                            imageToProcess.crossOrigin = "Anonymous";

                            await new Promise((resolve, reject) => {
                                imageToProcess.onload = resolve;
                                imageToProcess.onerror = reject;
                                imageToProcess.src = img.src;
                            });

                            canvas.width = imageToProcess.width;
                            canvas.height = imageToProcess.height;
                            ctx.drawImage(imageToProcess, 0, 0);

                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;

                            const threshold = App.settings.get('ocrThreshold') || 128; // A good starting point, can be made adjustable
                            for (let i = 0; i < data.length; i += 4) {
                                // Grayscale conversion using luminance formula
                                const luminance = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                                const color = luminance < threshold ? 0 : 255; // Apply threshold
                                data[i] = data[i + 1] = data[i + 2] = color;
                            }
                            ctx.putImageData(imageData, 0, 0);

                            App.ui.updateToast(ocrToastId, 'Initializing OCR engine...');

                            const worker = await Tesseract.createWorker('eng', 1, {
                                logger: m => {
                                    if (m.status === 'recognizing text') {
                                        const progress = (m.progress * 100).toFixed(0);
                                        App.ui.updateToast(ocrToastId, `Recognizing text... ${progress}%`);
                                    } else if (m.status !== 'initializing tesseract') {
                                        // Avoid showing less useful intermediate statuses
                                        App.ui.updateToast(ocrToastId, `Status: ${m.status}`);
                                    }
                                }
                            });

                            // RATIONALE: We now pass the preprocessed canvas to Tesseract, not the original image.
                            const { data: { text } } = await worker.recognize(canvas);
                            await worker.terminate();
                            App.ui.hideToast(ocrToastId);

                            if (!text.trim()) {
                                App.ui.showToast('No text could be extracted from this image.', 'warning');
                                return;
                            }

                            const ocrHtml = `
                            <blockquote>
                                <p>${App.util.escapeHtml(text)}</p>
                                <footer><small> Text extracted from image</small></footer>
                            </blockquote>
                            <p><br></p>`;

                            const imageParentBlock = imageContainer.closest('p');
                            if (imageParentBlock) {
                                imageParentBlock.insertAdjacentHTML('afterend', ocrHtml);
                                App.state.isArticleDirty = true;
                                App.ui.showToast('Text extracted and added to note!', 'success');
                            } else {
                                document.execCommand('insertHTML', false, ocrHtml);
                                App.state.isArticleDirty = true;
                            }

                        } catch (error) {
                            if (ocrToastId) App.ui.hideToast(ocrToastId);
                            console.error('Tesseract.js OCR Error:', error);
                            App.ui.showToast('Could not perform OCR. Check console for details.', 'error');
                        }
                    },

                    copy(imageContainer) {
                        if (!imageContainer) return;
                        const img = imageContainer.querySelector('img');
                        if (!img || !img.src) {
                            App.ui.showToast('Image source not found.', { type: 'error' });
                            return;
                        }
                        const blob = App.util.dataURLtoBlob(img.src);
                        if (blob) {
                            const objectUrl = URL.createObjectURL(blob);
                            window.open(objectUrl, '_blank');
                            App.ui.showToast('Image opened in a new tab for copying.', { type: 'info' });
                        } else {
                            App.ui.showToast('Could not process image data.', { type: 'error' });
                        }
                    },

                    delete(imageContainer) {
                        if (!imageContainer) return;
                        const p = imageContainer.closest('p');
                        if (p) p.remove();
                        else imageContainer.remove();
                        App.events.deselectImage();
                        App.ui.showToast('Image removed.');
                    }
                },

                migration: {
                    async browserToFolder(handle) {
                        try {
                            const browserArticles = await App.browserStore.getAllArticles();
                            if (browserArticles.length === 0) {
                                return 'no_browser_data';
                            }

                            let folderHasData = false;
                            try {
                                await handle.getFileHandle('_index.json', { create: false });
                                folderHasData = true;
                            } catch (e) {
                                if (e.name !== 'NotFoundError') throw e;
                            }

                            let userResponse;

                            if (folderHasData) {
                                userResponse = await new Promise(resolve => {
                                    App.ui.showCustomModal({
                                        title: 'Merge Data Sources?',
                                        message: `You have notes stored in your browser. This folder also contains notes. How would you like to proceed?<br><br><b>Merge is recommended.</b> It will intelligently combine both sources, keeping the newest version of each note.
                                            <div style="margin-top: 1rem; text-align: left;">
                                                <input type="checkbox" id="migration-backup-checkbox" checked>
                                                <label for="migration-backup-checkbox"> Create a backup of this folder before merging (Recommended)</label>
                                            </div>`,
                                        buttons: [
                                            { text: 'Use Folder Only', className: 'btn-secondary', onClick: () => { App.ui.closeModal(); resolve({ choice: 'use_folder_only' }); } },
                                            {
                                                text: 'Merge Notes', className: 'btn-primary', onClick: () => {
                                                    const shouldBackup = document.getElementById('migration-backup-checkbox').checked;
                                                    App.ui.closeModal();
                                                    resolve({ choice: 'merge', backup: shouldBackup });
                                                }
                                            },
                                            { text: 'Cancel', className: 'btn-secondary', onClick: () => { App.ui.closeModal(); resolve({ choice: 'cancelled' }); } }
                                        ]
                                    });
                                });
                            } else {
                                userResponse = await new Promise(resolve => {
                                    App.ui.showConfirmationModal({
                                        title: 'Copy Notes to New Folder?',
                                        message: `Would you like to copy your ${browserArticles.length} existing notes from the browser to this new, empty folder?`,
                                        confirmText: 'Yes, Copy Notes',
                                        onConfirm: () => resolve({ choice: 'merge', backup: false }),
                                        onCancel: () => resolve({ choice: 'use_folder_only' })
                                    });
                                });
                            }

                            if (userResponse.choice !== 'merge') {
                                return userResponse.choice;
                            }

                            App.ui.migrationScreen.show("Migrating Notes");
                            const { backup: shouldBackup } = userResponse;

                            if (shouldBackup) {
                                App.ui.migrationScreen.update(10, 'Backing up current folder...');
                                const backupDirName = `notekash_backup_${new Date().toISOString().replace(/[:.]/g, '-')}`;
                                const backupHandle = await handle.getDirectoryHandle(backupDirName, { create: true });
                                for await (const entry of handle.values()) {
                                    if (App.ui.migrationScreen.state.isCancelled) return 'cancelled';
                                    if (entry.kind === 'file') {
                                        const file = await entry.getFile();
                                        const newFileHandle = await backupHandle.getFileHandle(entry.name, { create: true });
                                        const writable = await newFileHandle.createWritable();
                                        await writable.write(file);
                                        await writable.close();
                                    }
                                }
                            }

                            // --- NEW: Read all articles in the destination folder to prepare for a smart merge.
                            App.ui.migrationScreen.update(30, 'Analyzing destination folder...');
                            const folderArticlesMap = new Map();
                            for await (const entry of handle.values()) {
                                if (App.ui.migrationScreen.state.isCancelled) return 'cancelled';
                                if (entry.kind === 'file' && entry.name.startsWith('art_')) {
                                    try {
                                        const file = await entry.getFile();
                                        const article = JSON.parse(await file.text());
                                        if (article.id) {
                                            folderArticlesMap.set(article.id, article);
                                        }
                                    } catch (e) { console.warn(`Could not parse ${entry.name} in destination folder.`); }
                                }
                            }

                            // --- NEW: Intelligently decide which articles to write based on existence and timestamp.
                            const articlesToWrite = [];
                            for (const browserArticle of browserArticles) {
                                const folderArticle = folderArticlesMap.get(browserArticle.id);
                                if (!folderArticle) {
                                    articlesToWrite.push(browserArticle); // Article is new to the folder.
                                } else if (new Date(browserArticle.updatedAt) > new Date(folderArticle.updatedAt)) {
                                    articlesToWrite.push(browserArticle); // Browser version is newer.
                                }
                                // If the folder version is the same or newer, it's skipped. No duplication, no data loss.
                            }

                            if (articlesToWrite.length === 0) {
                                App.ui.migrationScreen.hide();
                                App.ui.showToast('All notes are already up-to-date in the folder.', 'info');
                                return 'use_folder_only';
                            }

                            for (let i = 0; i < articlesToWrite.length; i++) {
                                if (App.ui.migrationScreen.state.isCancelled) return 'cancelled';
                                const article = articlesToWrite[i];
                                const progress = 50 + Math.round((i / articlesToWrite.length) * 45);
                                App.ui.migrationScreen.update(progress, `Copying newer note ${i + 1} of ${articlesToWrite.length}...`);

                                const fileHandle = await handle.getFileHandle(`${article.id}.json`, { create: true });
                                const writable = await fileHandle.createWritable();
                                await writable.write(JSON.stringify(article, null, 2));
                                await writable.close();
                            }

                            App.ui.migrationScreen.update(100, 'Migration Complete!');
                            await new Promise(resolve => setTimeout(resolve, 1500));
                            App.ui.migrationScreen.hide();
                            return 'merge_successful';

                        } catch (err) {
                            console.error("Migration failed:", err);
                            App.ui.migrationScreen.hide();
                            App.ui.showToast('Migration process failed. Your data remains untouched.', 'error');
                            return 'error';
                        }
                    }
                },

                backup: {
                    // 1. HELPER: Gathers all app data for export
                    async getAllDataAsFiles() {
                        const files = [];
                        const dataFileNames = ['settings.json', 'todos.json', 'pomodoro.json', 'quiz_stats.json', 'tags.json', 'visual-map-state.json', 'mind-map-state.json', App.storage.DELETED_RECORDS_FILENAME];

                        if (App.state.storageMode === 'fileSystem' && App.state.directoryHandle) {
                            for await (const entry of App.state.directoryHandle.values()) {
                                if (entry.kind === 'file' && entry.name.endsWith('.json')) {
                                    try {
                                        const file = await entry.getFile();
                                        const text = await file.text();
                                        // Robustness: Only export files that actually have content
                                        if (text.trim()) {
                                            files.push({ name: file.name, content: text });
                                        }
                                    } catch (e) { console.warn("Failed to read file for export:", entry.name); }
                                }
                            }
                        } else {
                            const articles = await App.browserStore.getAllArticles();
                            articles.forEach(a => files.push({ name: `${a.id}.json`, content: JSON.stringify(a, null, 2) }));

                            for (const fileName of dataFileNames) {
                                const data = await App.browserStore.getFile(fileName);
                                if (data) files.push({ name: fileName, content: JSON.stringify(data, null, 2) });
                            }
                        }
                        return files;
                    },

                    // 2. EXPORT: Full System Backup (For you, the user)
                    async exportToZip() {
                        if (!window.JSZip) { App.ui.showToast("Export library not loaded.", { type: 'error' }); return; }

                        App.ui.migrationScreen.show("Creating Full Backup");

                        try {
                            App.ui.migrationScreen.update(10, "Gathering files...");
                            const allFiles = await this.getAllDataAsFiles();

                            if (App.ui.migrationScreen.state.isCancelled) return;
                            if (allFiles.length === 0) { App.ui.showToast("No data to export.", "warning"); return; }

                            App.ui.migrationScreen.update(40, `Compressing ${allFiles.length} files...`);
                            const zip = new JSZip();
                            allFiles.forEach(file => zip.file(file.name, file.content));

                            if (App.ui.migrationScreen.state.isCancelled) return;

                            App.ui.migrationScreen.update(80, "Finalizing...");
                            const blob = await zip.generateAsync({ type: 'blob' });
                            const filename = `notekash-backup-${new Date().toISOString().slice(0, 10)}.zip`;

                            App.util.downloadBlob(blob, filename);
                            App.ui.migrationScreen.update(100, "Done!");
                            App.ui.showToast("Full backup created successfully!", "success");
                        } catch (error) {
                            console.error("Export failed:", error);
                            App.ui.showToast("Export failed. Check console.", "error");
                        } finally {
                            setTimeout(() => App.ui.migrationScreen.hide(), 1000);
                        }
                    },

                    // 3. EXPORT: Study Kit (For Selling/Sharing - No System Files)
                    async exportStudyKit(categoryName) {
                        if (!window.JSZip) { App.ui.showToast("Export library not loaded.", { type: 'error' }); return; }

                        // Handle "All" category or specific category
                        const targetArticles = categoryName === 'All'
                            ? App.state.articles
                            : App.state.articles.filter(a => a.category === categoryName);

                        if (targetArticles.length === 0) {
                            App.ui.showToast(`No notes found in category "${categoryName}".`, 'warning');
                            return;
                        }

                        App.ui.migrationScreen.show(`Creating Study Kit: ${categoryName}`);

                        try {
                            const zip = new JSZip();
                            const folderName = `StudyKit-${App.util.slugify(categoryName)}`;

                            // Add only the articles
                            targetArticles.forEach((article, index) => {
                                const progress = Math.round((index / targetArticles.length) * 90);
                                App.ui.migrationScreen.update(progress, `Packing: ${article.title}`);
                                zip.file(`${article.id}.json`, JSON.stringify(article, null, 2));
                            });

                            // Optional: Add a manifest or readme
                            zip.file("README.txt", `NoteKash Study Kit: ${categoryName}\nContains ${targetArticles.length} notes.\nImport this zip directly into NoteKash.`);

                            const blob = await zip.generateAsync({ type: 'blob' });
                            App.util.downloadBlob(blob, `${folderName}.zip`);

                            App.ui.migrationScreen.update(100, "Kit Ready!");
                            App.ui.showToast(`Study Kit downloaded! (${targetArticles.length} notes)`, "success");

                        } catch (e) {
                            console.error("Study Kit Export Failed", e);
                            App.ui.showToast("Failed to create Study Kit.", "error");
                        } finally {
                            setTimeout(() => App.ui.migrationScreen.hide(), 1000);
                        }
                    },

                    // 4. IMPORT ROUTER (The Gatekeeper)
                    async handleFileImport(files) {
                        if (!files || files.length === 0) return;

                        const zipFiles = Array.from(files).filter(f => f.name.endsWith('.zip'));
                        const jsonFiles = Array.from(files).filter(f => f.name.endsWith('.json') || f.name.endsWith('.notekash'));
                        const pdfFiles = Array.from(files).filter(f => f.type === 'application/pdf' || f.name.toLowerCase().endsWith('.pdf'));

                        if (zipFiles.length > 0) {
                            await this.importFromZip(zipFiles[0]);
                        } else {
                            // Process both PDFs and Loose Files in parallel if no Zip
                            if (pdfFiles.length > 0) await this.importPdfFiles(pdfFiles);
                            if (jsonFiles.length > 0) await this.importLooseFiles(jsonFiles);
                        }
                    },

                    // 4.1 PDF IMPORT HANDLER (Creates New Article per PDF)
                    async importPdfFiles(files) {
                        App.ui.migrationScreen.show("Importing PDFs");
                        let importedCount = 0;

                        try {
                            for (const file of files) {
                                try {
                                    // 1. Read file as Base64 Data URL
                                    const dataUrl = await new Promise((resolve, reject) => {
                                        const reader = new FileReader();
                                        reader.onload = (e) => resolve(e.target.result);
                                        reader.onerror = reject;
                                        reader.readAsDataURL(file);
                                    });

                                    // 2. Prepare Attachment Data
                                    // FIX: Use Date.now() + random suffix instead of crypto.randomUUID() for broader compatibility
                                    const safeId = 'pdf_' + Date.now().toString(36) + Math.random().toString(36).substr(2);
                                    const fileData = {
                                        id: safeId,
                                        name: file.name,
                                        type: file.type,
                                        data: dataUrl
                                    };

                                    // 3. Generate HTML Content (Pill)
                                    // Reuse the logic from App.pdf.insertAttachmentPill but generate raw HTML string
                                    const displayName = fileData.name.replace(/\.pdf$/i, '');
                                    const pillHTML = `
                                    <span class="pdf-attachment-pill" data-pdf-id="${fileData.id}" data-original-name="${App.util.escapeHtml(fileData.name)}">
                                        <span class="pdf-attachment-name" contenteditable="true">${App.util.escapeHtml(displayName)}</span>
                                    </span><p><br></p>`;

                                    // 4. Create New Article Object
                                    const newArticle = {
                                        id: 'Note_' + Date.now().toString(36) + Math.random().toString(36).substr(2),
                                        title: displayName, // Title is filename without extension
                                        content: pillHTML,
                                        category: (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name,
                                        tags: [],
                                        attachments: [fileData], // Attach the file to the article model
                                        createdAt: new Date().toISOString(),
                                        updatedAt: new Date().toISOString(),
                                        readCount: 0
                                    };

                                    // 5. Add to State
                                    App.state.articles.push(newArticle);
                                    importedCount++;

                                } catch (err) {
                                    console.error("Failed to import PDF:", file.name, err);
                                }
                            }

                            // 6. Save and Refresh - Using the correct storage pattern
                            if (importedCount > 0) {
                                App.ui.migrationScreen.update(70, "Saving to Storage...");

                                // Get the newly added articles (the last 'importedCount' articles in state)
                                const newArticles = App.state.articles.slice(-importedCount);

                                // Persist each article based on storage mode
                                if (App.state.storageMode === 'fileSystem' && App.state.directoryHandle) {
                                    await Promise.all(newArticles.map(a => App.fs.write(`${a.id}.json`, a)));
                                } else {
                                    await Promise.all(newArticles.map(a => App.browserStore.setArticle(a)));
                                }

                                // Rebuild indexes (wrapped in try/catch as these are optional)
                                App.ui.migrationScreen.update(90, "Rebuilding Index...");
                                try {
                                    await App.storage.generateIndexFromState();
                                } catch (indexErr) {
                                    console.warn("Index regeneration warning:", indexErr);
                                }

                                try {
                                    App.globalSearch.buildIndex();
                                } catch (searchErr) {
                                    console.warn("Search index rebuild warning:", searchErr);
                                }

                                App.ui.migrationScreen.update(100, "Import Complete!");

                                // Use a small delay before UI refresh to ensure state is committed
                                setTimeout(() => {
                                    App.ui.migrationScreen.hide();
                                    App.ui.filterAndRenderArticles();
                                    App.ui.showToast(`Imported ${importedCount} PDF(s) as new notes.`, "success");
                                }, 300);
                                return; // Exit early since we handle hide in the timeout
                            } else {
                                App.ui.showToast("No PDFs were imported.", "warning");
                            }

                        } catch (e) {
                            console.error("PDF Import Error:", e);
                            App.ui.showToast("PDF Import interrupted.", "error");
                        } finally {
                            App.ui.migrationScreen.hide();
                        }
                    },

                    // 5. LOOSE FILE HANDLER (Handles Single JSON, Bulk Arrays, & .notekash)
                    async importLooseFiles(files) {
                        App.ui.migrationScreen.show("Importing Notes");
                        try {
                            const rawArticles = [];
                            for (let i = 0; i < files.length; i++) {
                                const content = await files[i].text();
                                if (!content.trim()) continue;

                                try {
                                    const parsed = JSON.parse(content);

                                    // FIX: Handle "Bulk Array" imports (e.g., [note1, note2, note3])
                                    if (Array.isArray(parsed)) {
                                        parsed.forEach(item => {
                                            if (item.id && item.title) rawArticles.push(item);
                                        });
                                    }
                                    // Handle "Single Object" imports
                                    else if (parsed.id && parsed.title) {
                                        rawArticles.push(parsed);
                                    }
                                } catch (e) { console.warn("Skipping invalid JSON:", files[i].name); }
                            }

                            if (rawArticles.length === 0) {
                                App.ui.showToast("No valid notes found in selection.", "warning");
                                return;
                            }

                            await this.processImportedArticles(rawArticles);
                        } catch (e) {
                            console.error("Import error:", e);
                            App.ui.showToast("Import failed.", "error");
                        } finally {
                            App.ui.migrationScreen.hide();
                        }
                    },

                    // 6. ZIP HANDLER (Handles Backups & Study Kits)
                    async importFromZip(file) {
                        if (!window.JSZip) { App.ui.showToast("Import library not loaded.", { type: 'error' }); return; }

                        App.ui.migrationScreen.show("Reading Archive");

                        try {
                            const zip = await JSZip.loadAsync(file);
                            // FIX: Filter out macOS hidden files (starting with ._) and folders
                            const filesToProcess = Object.keys(zip.files).filter(path =>
                                !zip.files[path].dir &&
                                !path.startsWith('__MACOSX') &&
                                !path.split('/').pop().startsWith('._')
                            );

                            const rawArticles = [];
                            const systemFiles = ['settings.json', 'todos.json', 'pomodoro.json', 'quiz_stats.json', 'tags.json', 'visual-map-state.json', 'mind-map-state.json', App.storage.DELETED_RECORDS_FILENAME];
                            let systemFilesRestored = 0;

                            App.ui.migrationScreen.update(20, "Unpacking & Sorting...");

                            for (const path of filesToProcess) {
                                if (App.ui.migrationScreen.state.isCancelled) break;
                                if (path.includes('_index.json')) continue;

                                const content = await zip.files[path].async('string');

                                // FIX: Check for empty content to prevent crashes
                                if (!content || !content.trim()) continue;

                                // Case A: System Files (Restore immediately)
                                if (systemFiles.includes(path)) {
                                    try {
                                        const data = JSON.parse(content);
                                        await App.fs.write(path, data);

                                        if (path === 'tags.json') App.state.tags = data;
                                        if (path === 'todos.json') App.hub.state.tasks = data;
                                        if (path === 'pomodoro.json') App.hub.state.pomodoroStats = data;

                                        systemFilesRestored++;
                                    } catch (e) { console.warn(`Skipped corrupt system file: ${path}`); }
                                }
                                // Case B: Note Files (Collect for processing)
                                else if (path.endsWith('.json') || path.endsWith('.notekash')) {
                                    try {
                                        const parsed = JSON.parse(content);
                                        // Robustly handle Arrays vs Objects inside Zips too
                                        if (Array.isArray(parsed)) {
                                            parsed.forEach(item => { if (item.id && item.title) rawArticles.push(item); });
                                        } else if (parsed.id && parsed.title) {
                                            rawArticles.push(parsed);
                                        }
                                    } catch (e) { console.warn("Corrupt note file in zip:", path); }
                                }
                            }

                            if (App.ui.migrationScreen.state.isCancelled) return;

                            // Reload settings if restored
                            if (systemFilesRestored > 0) {
                                console.log("System files restored. Reloading settings...");
                                await App.settings.load();
                                App.ui.applyTheme(App.settings.get('theme'));
                            }

                            await this.processImportedArticles(rawArticles);

                        } catch (error) {
                            console.error("Zip Import Error:", error);
                            App.ui.showToast("Failed to process zip file.", "error");
                            App.ui.migrationScreen.hide();
                        }
                    },

                    // 7. THE BRAIN (Handles Merging, Flashcard Generation & Indexing)
                    async processImportedArticles(articles) {
                        let newCount = 0;
                        let updatedCount = 0;

                        App.ui.migrationScreen.update(50, "Merging Knowledge Graph...");

                        // A. Category Reconciliation (Auto-create missing categories)
                        let userCategories = App.settings.get('userCategories');
                        const existingCatNames = new Set(userCategories.map(c => c.name.toLowerCase()));
                        let categoriesUpdated = false;

                        articles.forEach(article => {
                            if (article.category && !existingCatNames.has(article.category.toLowerCase())) {
                                userCategories.push({
                                    name: article.category,
                                    displayName: article.category,
                                    colorIndex: userCategories.length % 20,
                                    isDefault: false
                                });
                                existingCatNames.add(article.category.toLowerCase());
                                categoriesUpdated = true;
                            }
                        });

                        if (categoriesUpdated) {
                            await App.settings.set('userCategories', userCategories);
                        }

                        // B. State Merge & Flashcard Generation
                        const currentArticlesMap = new Map(App.state.articles.map(a => [a.id, a]));
                        const articlesToPersist = [];

                        articles.forEach(incoming => {
                            // FIX: The critical empty object check
                            const hasNoFlashcards = !incoming.flashcards || Object.keys(incoming.flashcards).length === 0;

                            if (hasNoFlashcards && incoming.content) {
                                // Force auto-generation of flashcards for AI/External notes
                                incoming.flashcards = App.util.extractFlashcards(incoming.content, incoming.id, incoming.category || 'General', {});
                            }

                            const existing = currentArticlesMap.get(incoming.id);

                            if (!existing) {
                                App.state.articles.push(incoming);
                                articlesToPersist.push(incoming);
                                newCount++;
                            } else {
                                // Overwrite only if incoming is newer
                                const incomingDate = new Date(incoming.updatedAt || 0);
                                const existingDate = new Date(existing.updatedAt || 0);

                                if (incomingDate > existingDate) {
                                    Object.assign(existing, incoming);
                                    articlesToPersist.push(incoming);
                                    updatedCount++;
                                }
                            }
                        });

                        // C. Batch Persistence
                        App.ui.migrationScreen.update(70, "Saving to Storage...");

                        if (App.state.storageMode === 'fileSystem' && App.state.directoryHandle) {
                            await Promise.all(articlesToPersist.map(a => App.fs.write(`${a.id}.json`, a)));
                        } else {
                            await Promise.all(articlesToPersist.map(a => App.browserStore.setArticle(a)));
                        }

                        // D. Rebuild Indexes
                        App.ui.migrationScreen.update(90, "Rebuilding Master Index...");
                        App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                        await App.storage.generateIndexFromState();

                        // E. Refresh App State
                        App.ui.migrationScreen.update(95, "Refreshing UI...");
                        App.globalSearch.buildIndex();
                        await App.contentTools.updateTagsIndex();
                        App.contentTools.buildDataCache();

                        // F. Finish
                        App.ui.migrationScreen.update(100, "Import Complete!");

                        setTimeout(() => {
                            App.ui.migrationScreen.hide();

                            const currentView = App.router.getActiveView();
                            if (currentView === 'library') App.ui.filterAndRenderArticles();
                            if (currentView === 'flashcard') App.ui.filterAndRenderFlashcards();
                            if (currentView === 'category') App.ui.renderCategoryView(document.getElementById('category-view'), App.router.getActiveViewData());
                            if (currentView === 'visual-map') App.visualMap.init();
                            if (currentView === 'mindmap') App.mindMap.init();
                            if (currentView === 'tags') App.events.filterAndRenderTags();

                            App.ui.showToast(`Imported ${newCount} new, updated ${updatedCount} notes.`, "success");

                            if (App.settings.get('enableDropboxSync') && App.dropbox.isReady()) {
                                App.dropbox.syncChanges(true);
                            }

                        }, 800);
                    }
                },

                share: {
                    async article() {
                        if (!navigator.share) {
                            App.ui.showToast('Share API not supported on this device.', 'warning');
                            return;
                        }

                        const article = App.storage.getArticle(App.state.activeArticleId);
                        if (!article) {
                            App.ui.showToast('Could not find the article to share.', 'error');
                            return;
                        }

                        const categoryObj = App.settings.get('userCategories').find(c => c.name === article.category) || { name: article.category, colorIndex: 0 };
                        const categoryPill = `<div class="exported-pill category" style="background-color: ${App.util.getCategoryColor(categoryObj.colorIndex)}; color: var(--category-pill-text);">${App.util.getCategoryDisplayName(categoryObj.name)}</div>`;
                        const tagsPills = (article.tags || []).map(tag => `<div class="exported-pill">${App.state.tags[tag]?.displayName || tag}</div>`).join('');
                        const pillsHTML = `<div class="exported-pills-container">${categoryPill}${tagsPills}</div>`;

                        const bodyContent = `${pillsHTML}<h1>${article.title}</h1><hr>${App.util.parseShortcuts(article.content)}`;
                        const fullHtml = App.services.export._getHtmlExportTemplate(article.title, bodyContent);

                        const blob = new Blob([fullHtml], { type: 'text/html' });
                        const file = new File([blob], `${App.util.slugify(article.title)}.html`, { type: 'text/html' });

                        if (navigator.canShare && navigator.canShare({ files: [file] })) {
                            try {
                                await navigator.share({
                                    files: [file],
                                    title: article.title,
                                    text: `Note: ${article.title}`,
                                });
                            } catch (err) {
                                if (err.name !== 'AbortError') {
                                    console.error('File share failed:', err);
                                    App.ui.showToast('Something went wrong while sharing.', 'error');
                                }
                            }
                        } else {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = article.content;
                            const textContent = tempDiv.textContent || tempDiv.innerText;
                            const textToCopy = `Title: ${article.title}\n\n${textContent}\n\n---\nSource: notekash.com`;

                            await navigator.clipboard.writeText(textToCopy);
                            App.ui.showToast('File sharing not supported. Full article text has been copied to your clipboard instead!', { type: 'info', duration: 6000 });
                        }
                    },
                },
                ai: {
                    async queryGenerativeAI(systemPrompt, userPrompt) {
                        const provider = App.settings.get('aiProvider') || 'openrouter';
                        const modelName = App.settings.get('openRouterModel');

                        let apiKey, apiUrl, headers, body;
                        const toastId = App.ui.showToast("AI is thinking...", { type: 'info', duration: 0 });

                        const maxRetries = 3;
                        let delay = 2000;

                        for (let attempt = 0; attempt < maxRetries; attempt++) {
                            try {
                                let apiKey, apiUrl, headers, body;

                                // --- PROVIDER LOGIC START ---
                                if (provider === 'gemini') {
                                    apiKey = App.settings.get('geminiKey');
                                    if (!apiKey) throw new Error("Google Gemini API key not set.");

                                    // Gemini Model Selection
                                    // Default to medium if not set
                                    const geminiModel = App.settings.get('geminiModel') || 'gemini-2.5-flash';

                                    // Construct URL (Standard GenerateContent)
                                    apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${apiKey}`;

                                    headers = { "Content-Type": "application/json" };
                                    body = JSON.stringify({ "contents": [{ "parts": [{ "text": `${systemPrompt}\n\n${userPrompt}` }] }] });

                                } else if (provider === 'openai') {
                                    apiKey = App.settings.get('openaiKey');
                                    if (!apiKey) throw new Error("OpenAI API key not set.");
                                    const openaiModel = App.settings.get('openaiModel') || 'gpt-4o-mini';

                                    apiUrl = "https://api.openai.com/v1/chat/completions";
                                    headers = { "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json" };
                                    body = JSON.stringify({
                                        "model": openaiModel,
                                        "messages": [{ "role": "system", "content": systemPrompt }, { "role": "user", "content": userPrompt }]
                                    });

                                } else if (provider === 'huggingface') {
                                    apiKey = App.settings.get('huggingfaceKey');
                                    if (!apiKey) throw new Error("Hugging Face API key not set.");
                                    const hfModel = App.settings.get('huggingfaceModel') || 'mistralai/Mistral-7B-Instruct-v0.2';

                                    apiUrl = `https://api-inference.huggingface.co/models/${hfModel}`;
                                    headers = { "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json" };
                                    // HF Inference API usually takes just inputs string for simple generation, or inputs + parameters
                                    // Some models are chat-completion compatible, but generic inference endpoint is safer for broad compatibility?
                                    // Let's stick to simple generation for now as HF API varies wildly.
                                    // Or try to use the standardized messages format if supported by model.
                                    // For safety, let's treat it as text generation.
                                    const fullPrompt = `System: ${systemPrompt}\nUser: ${userPrompt}\nAssistant:`;
                                    body = JSON.stringify({
                                        "inputs": fullPrompt,
                                        "parameters": { "max_new_tokens": 1024, "return_full_text": false }
                                    });

                                } else {
                                    // Default: OPENROUTER
                                    apiKey = App.settings.get('openRouterKey');
                                    if (!apiKey) throw new Error("OpenRouter API key not set.");
                                    apiUrl = "https://openrouter.ai/api/v1/chat/completions";
                                    headers = { "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json", "HTTP-Referer": `${window.location.protocol}//${window.location.hostname}`, "X-Title": "NoteKash" };
                                    body = JSON.stringify({ "model": modelName, "messages": [{ "role": "system", "content": systemPrompt }, { "role": "user", "content": userPrompt }] });
                                }
                                // --- PROVIDER LOGIC END ---

                                const response = await fetch(apiUrl, { method: "POST", headers, body });

                                if (response.ok) {
                                    const data = await response.json();
                                    let content = null;

                                    if (provider === 'gemini') {
                                        content = data?.candidates?.[0]?.content?.parts?.[0]?.text;
                                    } else if (provider === 'huggingface') {
                                        // HF usually returns array of generated_text
                                        // If array: [{ generated_text: "..." }]
                                        if (Array.isArray(data)) {
                                            content = data[0]?.generated_text;
                                        } else {
                                            content = data?.generated_text;
                                        }
                                    } else {
                                        // OpenAI and OpenRouter share format
                                        content = data?.choices?.[0]?.message?.content;
                                    }

                                    if (!content) throw new Error("AI returned an empty or invalid response structure.");
                                    App.ui.hideToast(toastId);
                                    return content;
                                }

                                const retriableStatusCodes = [429, 500, 503, 504];
                                if (retriableStatusCodes.includes(response.status) && attempt < maxRetries - 1) {
                                    App.ui.updateToast(toastId, `Model is busy. Retrying in ${delay / 1000}s...`);
                                    await new Promise(resolve => setTimeout(resolve, delay));
                                    delay *= 2;
                                    continue;
                                }

                                if (response.status === 401) throw new Error("Invalid API Key. Please check it in Settings.");
                                const errorData = await response.json().catch(() => ({}));
                                const errorMessage = errorData?.error?.message || `API Error: ${response.status} ${response.statusText}`;
                                throw new Error(errorMessage);

                            } catch (error) {
                                // --- THIS IS THE NEW, SMARTER ERROR HANDLING ---
                                App.ui.hideToast(toastId);
                                console.error(`Generative AI Error (attempt ${attempt + 1}):`, error);

                                if (error.message.toLowerCase().includes('quota')) {
                                    const friendlyMessage = 'API Quota Exceeded. Please upgrade your API plan or check your settings.';
                                    App.ui.showToast(friendlyMessage, {
                                        type: 'error',
                                        duration: 10000,
                                        action: {
                                            label: 'Settings',
                                            callback: () => App.ui.showAiSettingsModal()
                                        }
                                    });
                                    // Also update the co-pilot bubble if it's open
                                    if (App.coPilot.state.isOpen) {
                                        App.coPilot.updateLastMessage(`<p style="color:var(--danger-color);">${friendlyMessage}</p>`);
                                    }

                                    return null; // Stop retrying on quota errors.
                                }

                                if (attempt === maxRetries - 1) {
                                    App.ui.showToast(`AI Error: ${error.message}`, "error");
                                    return null;
                                }

                                App.ui.updateToast(toastId, `Connection issue. Retrying in ${delay / 1000}s...`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                                delay *= 2;
                            }
                        }

                        App.ui.hideToast(toastId);
                        App.ui.showToast("AI query failed after multiple retries.", "error");
                        return null;
                    },
                }
            },


            // ==========================================================================
            // 3.13. UTILITIES
            // ==========================================================================
            util: {

                // Optimized: Debounce Function
                debounce(func, wait) {
                    let timeout;
                    return function (...args) {
                        const context = this;
                        clearTimeout(timeout);
                        timeout = setTimeout(() => func.apply(context, args), wait);
                    };
                },

                // NEW: Surgical Memory Cleanup
                // Clears cached snippets and large temporary objects to prevent RAM bloat
                freeMemory() {
                    // 1. Clear cached snippets from all articles
                    if (App.state.articles) {
                        App.state.articles.forEach(article => {
                            if (article.snippets) {
                                delete article.snippets; // Allow GC to reclaim snippet HTML strings
                            }
                            // Clear any other temp props
                            if (article._tempContent) delete article._tempContent;
                        });
                    }

                    // 2. Clear focus session heavy data if not active
                    if (!App.state.focusSession?.isActive) {
                        App.state.focusSession = { isActive: false, articles: [], annotations: {} };
                    }

                    // 3. Clear category render state
                    App.state.categoryRender = {
                        articles: [],
                        currentIndex: 0,
                        observer: null
                    };

                    // 4. Force strict garbage collection hint (nullifying large reachable objects)
                    // (Browsers manage GC automatically, but breaking references helps)
                },

                isMobile: () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),

                escapeRegex(string) {
                    return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                },
                escapeHtml: (u) => u ? u.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;") : '',

                // Enhanced MCQ Parser

                parseMcqText(text) {
                    // Pre-process: Normalize newlines & remove zero-width chars
                    let cleanText = text.replace(/\r\n/g, '\n').replace(/[\u200B-\u200D\uFEFF]/g, '').trim();
                    if (!cleanText) return [];

                    let allBlocks = [];

                    // 1. Explicit Splitting ONLY via MCQ Breaks (>>>, ---, ***, ___)
                    const SEPARATOR_REGEX = /(?:^|\n)\s*(?:>>>|---|___|\*\*\*)\s*(?:\n|$)/;


                    if (SEPARATOR_REGEX.test(cleanText)) {
                        const rawChunks = cleanText.split(SEPARATOR_REGEX).filter(c => c.trim().length > 0);
                        rawChunks.forEach(chunk => {
                            const parsed = this._parseSingleMcq(chunk.trim());
                            if (parsed) allBlocks.push(parsed);
                        });
                    } else {
                        const parsed = this._parseSingleMcq(cleanText);
                        if (parsed) allBlocks.push(parsed);
                    }

                    return allBlocks;
                },

                // Initialize Plyr players
                initPlyr(container) {
                    if (typeof Plyr === 'undefined' || !container) return;

                    // 1. YouTube & Shorts
                    container.querySelectorAll('.js-plyr-video').forEach(el => {
                        if (el.plyr) return; // Prevent double init
                        const options = {
                            controls: ['play-large', 'play', 'progress', 'current-time', 'mute', 'volume', 'captions', 'settings', 'pip', 'airplay', 'fullscreen'],
                            hideControls: true,
                            youtube: { noCookie: true, rel: 0, showinfo: 0, iv_load_policy: 3, modestbranding: 1 }
                        };
                        const ratio = el.dataset.ratio; // Check for custom ratio (e.g., 9:16)
                        if (ratio) options.ratio = ratio;
                        try {
                            el.plyr = new Plyr(el, options);
                        } catch (e) {
                            console.warn('Plyr init failed', e);
                        }
                    });
                },

                // Prepare content for saving by stripping Plyr DOM
                cleanPlyrForSave(container) {
                    if (!container) return;
                    // Iterate over wrappers
                    container.querySelectorAll('.nk-plyr-wrapper').forEach(wrapper => {
                        const provider = wrapper.dataset.provider;
                        const embedId = wrapper.dataset.embedId;
                        const ratio = wrapper.dataset.ratio ? `data-ratio="${wrapper.dataset.ratio}"` : '';
                        if (provider && embedId) {
                            // Hard reset content to seed state
                            wrapper.innerHTML = `<div class="js-plyr-video" data-plyr-provider="${provider}" data-plyr-embed-id="${embedId}" ${ratio}></div>`;
                        }
                    });
                },



                _parseSingleMcq(text) {
                    const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
                    if (lines.length < 2) return null; // Need at least question + 1 option

                    // Option detection patterns - ordered by specificity
                    const LETTER_OPTION = /^\s*(?:[\[\(]\s*[a-zA-Z]\s*[\]\)]|[a-zA-Z]\s*[\.\)\-\:])(?:\s+|$)/; // [A], (a), A., a), A-, A: etc.
                    const ROMAN_OPTION = /^\s*(?:[\[\(]\s*[iIvVxX]+\s*[\]\)]|[iIvVxX]+\s*[\.\)\-])(?:\s+|$)/; // (i), (ii), [I], [II], i., ii) etc.
                    const BULLET_OPTION = /^\s*[\u2022\u25E6\u25AA\u25CF\u25CB\u2023\-\*]\s+/; // , , -, * etc.
                    const NUMBER_BRACKET = /^\s*[\[\(]\s*\d+\s*[\]\)]\.?\s+/; // [1], (1), [2] etc.

                    // Statement patterns (NOT options) - numbered without brackets typically
                    const NUMBERED_STATEMENT = /^\s*\d+[\.\)]\s+(?!\s*only\s|\s*all\s|\s*none\s|\s*both\s)/i; // 1. Statement, 2) Statement (but not "1. Only 1")


                    const isOptionLine = (line, position, totalLines) => {
                        if (LETTER_OPTION.test(line)) return true;
                        if (ROMAN_OPTION.test(line)) return true;
                        if (NUMBER_BRACKET.test(line)) return true; // [1], (1) style

                        // Bullet points are options ONLY if they're at the end
                        if (BULLET_OPTION.test(line)) return true;

                        return false;
                    };

                    const isNumberedStatement = (line) => {
                        return NUMBERED_STATEMENT.test(line) && !LETTER_OPTION.test(line) && !NUMBER_BRACKET.test(line);
                    };

                    // STEP 1: Scan from bottom-up to find the options zone
                    let optionsStartIndex = -1;
                    let consecutiveOptions = 0;
                    let lastOptionType = null;

                    for (let i = lines.length - 1; i >= 0; i--) {
                        const line = lines[i];

                        // Determine what type of marker this line has
                        let currentType = null;
                        if (LETTER_OPTION.test(line)) currentType = 'letter';
                        else if (ROMAN_OPTION.test(line)) currentType = 'roman';
                        else if (NUMBER_BRACKET.test(line)) currentType = 'number_bracket';
                        else if (BULLET_OPTION.test(line)) currentType = 'bullet';

                        if (currentType) {
                            // Line is an option
                            if (lastOptionType === null || lastOptionType === currentType) {
                                consecutiveOptions++;
                                optionsStartIndex = i;
                                lastOptionType = currentType;
                            } else {
                                // Different type - this might be a statement, not an option
                                if (consecutiveOptions >= 2) {
                                    break; // We have our options, stop here
                                } else {
                                    consecutiveOptions = 1;
                                    optionsStartIndex = i;
                                    lastOptionType = currentType;
                                }
                            }
                        } else {
                            // Line is NOT an option marker
                            if (consecutiveOptions >= 2) {
                                break;
                            } else if (consecutiveOptions === 1) {
                                // Only 1 option so far - might be a continuation or different format
                                if (isNumberedStatement(line)) {
                                    break;
                                }
                                // Otherwise, reset - single option line was probably a statement
                                consecutiveOptions = 0;
                                optionsStartIndex = -1;
                                lastOptionType = null;
                            }
                        }
                    }

                    // STEP 2: Split into Question and Options
                    let questionLines = [];
                    let optionLines = [];

                    if (optionsStartIndex > 0 && consecutiveOptions >= 2) {
                        questionLines = lines.slice(0, optionsStartIndex);
                        optionLines = lines.slice(optionsStartIndex);
                    } else {
                        // Fallback: No clear options zone detected via bottom-up scan
                        // Check for letter-based options anywhere (they're most reliable indicators)
                        const letterIndices = [];
                        lines.forEach((line, idx) => {
                            if (LETTER_OPTION.test(line)) letterIndices.push(idx);
                        });

                        if (letterIndices.length >= 2) {
                            // Letter options found - use first letter option as start of options zone
                            const firstLetter = letterIndices[0];
                            questionLines = lines.slice(0, firstLetter);
                            optionLines = lines.slice(firstLetter);
                        } else {
                            // Try bullet point strategy
                            const bulletIndices = [];
                            lines.forEach((line, idx) => {
                                if (BULLET_OPTION.test(line)) bulletIndices.push(idx);
                            });

                            if (bulletIndices.length >= 2) {
                                // Bullet points found - first bullet starts options
                                const firstBullet = bulletIndices[0];
                                questionLines = lines.slice(0, firstBullet);
                                optionLines = lines.slice(firstBullet);
                            } else {
                                // Super fallback: First line is question, rest are options
                                questionLines = [lines[0]];
                                optionLines = lines.slice(1);
                            }
                        }
                    }

                    // Any question data for building result?
                    if (questionLines.length === 0 || optionLines.length === 0) {
                        return null;
                    }

                    // STEP 3: Clean up and build the result
                    return this._finalizeBlock({
                        qLines: questionLines,
                        oLines: optionLines
                    });
                },


                _parseMcqChunk(text) {
                    const result = this._parseSingleMcq(text);
                    return result ? [result] : [];
                },


                _finalizeBlock(block) {
                    const STRIP_OPTION_MARKER = /^\s*(?:[\[\(]\s*[a-zA-Z0-9iIvVxX]+\s*[\]\)]\.?|[a-zA-Z][\.\)\-\:]|[\u2022\u25E6\u25AA\u25CF\u25CB\u2023\-\*]|\d+[\.\)])\s*/;

                    let cleanQ = '';
                    if (block.question && typeof block.question === 'string') {
                        cleanQ = block.question;
                    } else if (block.qLines && Array.isArray(block.qLines)) {
                        cleanQ = block.qLines.join('<br>').trim();
                    } else if (block.q && typeof block.q === 'string') {
                        cleanQ = block.q;
                    }

                    cleanQ = cleanQ.replace(/^(Question\s*)?\d*[\.:)]?\s*/i, '').trim();
                    cleanQ = cleanQ.replace(/^Q[\.:]\s*/i, '').trim();

                    const rawOpts = block.options || block.oLines || block.o || [];

                    const cleanOptions = rawOpts.map(o => {
                        if (typeof o !== 'string') return '';
                        return o.replace(STRIP_OPTION_MARKER, '').trim();
                    }).filter(o => o.length > 0);

                    // Need at least 2 options for a valid MCQ
                    if (cleanOptions.length < 2) {
                        // Try to salvage by splitting if there's only 1 "option" (might be comma-separated)
                        if (cleanOptions.length === 1 && cleanOptions[0].includes(',')) {
                            const split = cleanOptions[0].split(',').map(s => s.trim()).filter(s => s.length > 0);
                            if (split.length >= 2) {
                                return { question: cleanQ, options: split };
                            }
                        }
                        return null;
                    }

                    return { question: cleanQ, options: cleanOptions };
                },

                icons: {
                    eyeOpen: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>`, eyeClosed: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>`,
                    textView: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5M3.75 17.25H12" /></svg>`,

                    chevronUp: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>`,
                    chevronDown: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>`,
                    pen: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>`, edit: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="16 3 21 8 8 21 3 21 3 16 16 3"></polygon></svg>`, done: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`,
                    category: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>`, close: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`,
                    cycle: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M12.433 10.07C14.133 9.585 16 8.007 16 6c0-2.208-1.79-4-4-4s-4 1.792-4 4c0 1.397.646 2.622 1.657 3.313-.42.223-.79.482-1.12.768-.907.643-1.482 1.458-1.752 2.313-.27.856-.333 1.632-.234 2.298C3.666 15.453 5.135 16 6.729 16c1.595 0 3.067-.547 4.143-1.523.27-.855.334-1.631.235-2.298-.27-.855-.846-1.67-1.753-2.312a4.996 4.996 0 0 1-1.12-.768zM6 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm2.5 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm2.5 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm.5 3a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/></svg>`,
                    trash: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>`,
                    list: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm-3 1a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/></svg>`,
                    table: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="12" y1="3" x2="12" y2="21"></line></svg>`,
                    tag: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M2 2v4.586a1 1 0 0 0 .293.707l7 7a1 1 0 0 0 1.414 0l4.586-4.586a1 1 0 0 0 0-1.414l-7-7A1 1 0 0 0 7.586 2H2zm1 5.586 7 7L15.586 9l-7-7H3v4.586z"/><path d="M5 5a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/></svg>`,
                    copy: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`, html: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>`, clearFormatting: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.646 4.646a.5.5 0 0 1 .708 0L14 6.293l1.646-1.647a.5.5 0 0 1 .708.708L14.707 7l1.647 1.646a.5.5 0 0 1-.708.708L14 7.707l-1.646 1.647a.5.5 0 0 1-.708-.708L13.293 7l-1.647-1.646a.5.5 0 0 1 0-.708z"/><path d="M2.5 0A2.5 2.5 0 0 0 0 2.5v11A2.5 2.5 0 0 0 2.5 16h6.086a2.5 2.5 0 0 0 1.768-.732l3.5-3.5a2.5 2.5 0 0 0 0-3.536l-3.5-3.5A2.5 2.5 0 0 0 8.586 2H2.5zm5.553 4.24a.5.5 0 0 1 .707 0l1.25 1.25a.5.5 0 0 1 0 .707L8.707 7.5l1.25 1.25a.5.5 0 0 1-.707.707L8 8.207 6.75 9.457a.5.5 0 0 1-.707-.707L7.293 7.5 6.043 6.25a.5.5 0 0 1 0-.707l1.25-1.25z"/></svg>`, save: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1-1H7.5a1 1 0 0 0-1 1H2zm3 2h4.5v2.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V2zm7 0v2.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V2h4zM3 14v-7h10v7H3z"/></svg>`, saveAndRead: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/></svg>`,
                    expand: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h6v6M9 3H3v6M15 21h6v-6M9 21H3v-6"/></svg>`, compress: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3H5M16 3v3h3M8 21v-3H5M16 21v-3h3"/></svg>`,
                    zoomIn: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6" /></svg>`,
                    zoomOut: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6" /></svg>`,
                    article: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4.5 1h5a.5.5 0 0 1 .5.5v2h.5a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5-.5h-6a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5h.5v-2a.5.5 0 0 1 .5-.5zM5 1.5v2h4v-2H5zm0 3v10.5h4V4.5H5z"/></svg>`, reset: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>`, plus: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>`, minus: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/></svg>`, alignLeft: `<svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M2 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5z"/></svg>`, alignCenter: `<svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-2-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm2-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-2-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/></svg>`, alignRight: `<svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M6 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-4-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm4-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-4-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/></svg>`,
                    star: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/></svg>`,
                    starOutline: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M2.866 14.85c-.078.444.36.791.746.593l4.39-2.256 4.389 2.256c.386.198.824-.149.746-.592l-.83-4.73 3.522-3.356c.329-.313.158-.888-.283-.95l-4.898-.696L8.465.792a.5.5 0 0 0-.927 0L5.354 5.12l-4.898.696c-.441.062-.612.636-.283.95l3.523 3.356-.83 4.73zm4.905-2.767-3.686 1.894.694-3.957a.5.5 0 0 0-.182-.389l-2.832-2.767 3.958-.564a.5.5 0 0 0 .398-.293L8 2.223l1.791 3.582a.5.5 0 0 0 .398.293l3.958.564-2.832 2.767a.5.5 0 0 0-.182.389l.694 3.957-3.686-1.894a.5.5 0 0 0-.461 0z"/></svg>`,
                    caption: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h4.414l.914.914A.5.5 0 0 0 7 13.5v-2.414l.914.914A.5.5 0 0 0 8 12.5h4a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/><path d="M4.5 5.5a.5.5 0 0 0 0 1h7a.5.5 0 0 0 0-1h-7zM4 8a.5.5 0 0 0 0 1h7a.5.5 0 0 0 0-1H4z"/></svg>`,
                    theme: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg>`,
                    pdf: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>`,
                    hint: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 001.5-1.832 5.97 5.97 0 00.832-3.585 5.97 5.97 0 00-3.417-5.585 5.97 5.97 0 00-6.833 2.166" /></svg>`,
                    reversible: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21 3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" /></svg>`,
                    actions: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M5.52.359A.5.5 0 0 1 6 0h4a.5.5 0 0 1 .474.658L8.694 6H12.5a.5.5 0 0 1 .395.807l-7 9a.5.5 0 0 1-.873-.454L6.823 9.5H3.5a.5.5 0 0 1-.48-.641l2.5-8.5z"/></svg>`,
                    pdfExport: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M9 13h2"></path><path d="M9 17h6"></path><path d="M13 13h2"></path></svg>`,

                    image: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>`,
                    accordion: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line></svg>`,
                    present: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="4" width="20" height="16" rx="3" ry="3"></rect><polygon points="10 9 10 15 15 12 10 9" fill="currentColor" stroke="none"></polygon></svg>`,

                },


                hapticFeedback(intensity = 'light') {
                    if ('vibrate' in navigator) {
                        const pattern = intensity === 'heavy' ? [100] : [50];
                        navigator.vibrate(pattern);
                    }
                },

                powerQuotes: [
                    "Every master was once a beginner.", "The secret of getting ahead is getting started.",
                    "Your only limit is your mind.", "Push yourself, because no one else is going to do it for you.",
                    "Great things never come from comfort zones.", "Dream it. Wish it. Do it.",
                    "Success doesnt just find you. You have to go out and get it.", "The harder you work, the luckier you get.",
                    "Turn your can'ts into cans and your dreams into plans.", "Don't stop until you're proud."
                ],
                getPowerQuote() {
                    return this.powerQuotes[Math.floor(Math.random() * this.powerQuotes.length)];
                },
                typewriter(element, text, speed = 75) {
                    if (!element) return;
                    element.innerHTML = '<span class="typewriter-cursor">|</span>'; // Start with just the cursor
                    let i = 0;
                    const typing = () => {
                        if (i < text.length) {
                            element.innerHTML = text.substring(0, i + 1) + '<span class="typewriter-cursor">|</span>';
                            i++;
                            setTimeout(typing, speed);
                        } else {
                        }
                    };
                    setTimeout(typing, speed);
                },

                wittyDeveloperMessages: [
                    "Your support is my superpower!", "Fueling this app requires a lot of coffee.",
                    "Developer is in Debt, He needs Help.", "Help me build the best note app in the universe!",
                    "Developer needs some coffee to survive, could you help?", "I'm the solo dev behind NoteKash!",
                    "Go Premium, and I'll name my next houseplant after you."
                ],

                maybeLaterMessages: [
                    "Maybe Later", "I'm good for now", "Will help you Later",
                    "Continue with Spark", "No Rush, Thanks", "I will Stay Free",
                    "Not Today Dev", "Let me Study", "I am also Poor", "Maybe Soon",
                    "Later, I Promise", "Keep me Free", "Will give you Nothing",
                    "Let me Focus", "Let me Try First", "Will Upgrade Later",
                    "I am on Budget", "Not that Valuable", "Happy as it is", "Will donate later"
                ],

                getRandomMessage(messageArray) {
                    if (!messageArray || messageArray.length === 0) return '';
                    return messageArray[Math.floor(Math.random() * messageArray.length)];
                },

                getTierBadgeHTML(tierName, size = 80) {
                    const tiers = {
                        Spark: {
                            tierClass: 'spark',
                            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><circle cx="12" cy="12" r="5"/></svg>`
                        },
                        Bronze: {
                            tierClass: 'bronze',
                            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><g class="orbiting-dots"><circle cx="5" cy="12" r="2"/><circle cx="19" cy="12" r="2"/></g></svg>`
                        },
                        Silver: {
                            tierClass: 'silver',
                            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>`
                        },
                        Gold: {
                            tierClass: 'gold',
                            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>`
                        },
                        Diamond: {
                            tierClass: 'diamond',
                            icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.49,6.51A2.12,2.12,0,0,0,16.88,6L12,2,7.13,6a2.12,2.12,0,0,0-2.62.51L2,11.84l10,10,10-10Z"/></svg>`
                        }
                    };
                    const tier = tiers[tierName] || tiers.Spark;
                    const sizeStyle = `width: ${size}px; height: ${size}px;`;
                    return `<div class="badge-icon astral ${tier.tierClass}" style="${sizeStyle}"><div class="inner-icon">${tier.icon}</div></div>`;
                },

                getCommandKey() { return navigator.platform.toUpperCase().includes('MAC') ? 'Cmd' : 'Ctrl'; },
                getCategoryDisplayName(originalName) {
                    if (!originalName) return 'General'; // Failsafe
                    const catObj = App.settings.get('userCategories').find(c => c.name === originalName);
                    // Return the display name if it exists and is not empty, otherwise fall back to the original name.
                    return catObj?.displayName || originalName;
                },

                getOriginalCategoryName(displayName) {
                    if (!displayName) return 'General';
                    const catObj = App.settings.get('userCategories').find(c => c.displayName === displayName);
                    // If we find a match by display name, return its true, stable name.
                    if (catObj) {
                        return catObj.name;
                    }
                    // Fallback for cases where the display name is the same as the original name.
                    return displayName;
                },


                getCategoryColor(colorIndex) {
                    return `var(--cat-color-${colorIndex}-bg)`;
                },
                getCategoryColorCount() {
                    return 20;
                },

                colorToRgb(color) {
                    if (!color) return null;
                    const tempDiv = document.createElement('div');
                    tempDiv.style.color = color;
                    document.body.appendChild(tempDiv);
                    const rgbColor = window.getComputedStyle(tempDiv).color;
                    document.body.removeChild(tempDiv);
                    const match = rgbColor.match(/\d+/g);
                    return match ? match.map(Number) : null;
                },
                async requestDurableStorage() {
                    if (navigator.storage && navigator.storage.persist) {
                        try { if (!(await navigator.storage.persisted())) { await navigator.storage.persist(); } }
                        catch (e) { console.warn("Could not request persistent storage:", e); }
                    }
                },
                downloadBlob(blob, filename) {
                    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename;
                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
                },

                insertGuardianBlock(html) {
                    document.execCommand('insertHTML', false, html + '<p><br></p>');
                    App.state.isArticleDirty = true;
                },

                extractSnippets(source = null, types = ['highlight'], returnHtml = false) {
                    const sources = source ? [source] : App.state.articles.map(a => ({ content: a.content, id: a.id }));
                    const results = [];
                    const tempDiv = document.createElement('div');

                    const selectors = {
                        cloze: '.cloze-flashcard',
                        highlight: '.highlight-1, .highlight-2, .highlight-3, .highlight-4, .highlight-5, .highlight-6',
                        image: '.image-container.highlighted-image',
                        textile: '.nk-text-tile',
                        mcq: '.nk-mcq-block',
                        accordion: '.nk-accordion',
                        blocks: '.nk-timeline-block, .chart-container, .nk-video-embed',
                        tag: '.rendered-tag'
                    };

                    sources.forEach(src => {
                        if (!src.content) return;
                        let final = App.util.renderClozeForDisplay(App.util.parseShortcuts(src.content));
                        tempDiv.innerHTML = App.util.sanitizeHTML(final);

                        let selectorsToQuery = [];
                        if (types.includes('highlight')) {
                            selectorsToQuery.push(selectors.highlight, selectors.image, selectors.textile);
                        }
                        if (types.includes('mcq')) {
                            selectorsToQuery.push(selectors.mcq);
                        }
                        if (types.includes('blocks')) {
                            selectorsToQuery.push(selectors.blocks, selectors.accordion);
                        }

                        if (types.includes('tag')) {
                            selectorsToQuery.push(selectors.tag);
                        }
                        if (types.includes('cloze')) {
                            selectorsToQuery.push(selectors.cloze);
                        }

                        const masterSelector = selectorsToQuery.join(', ');
                        if (!masterSelector) return;

                        tempDiv.querySelectorAll(masterSelector).forEach((node, index) => {
                            let snippetObject = null;

                            if (node.matches(selectors.tag)) {
                                const snippetId = node.id || `tag-snip-${src.id}-${index}`;
                                if (!node.id) node.id = snippetId;

                                const parentBlock = node.closest('p, ul, ol, blockquote, h1, h2, h3, h4, h5, h6, li');
                                if (parentBlock) {
                                    snippetObject = {
                                        id: snippetId,
                                        html: parentBlock.innerHTML, // Use the parent's full HTML for display
                                        text: (parentBlock.textContent || "").trim(), // Use the parent's text for searching
                                        articleId: src.id,
                                        type: 'tag-snippet'
                                    };
                                }
                            }

                            else if (node.matches(selectors.textile)) {
                                const snippetId = node.id || `tile-${src.id}-${index}`;
                                if (!node.id) node.id = snippetId;
                                snippetObject = { id: snippetId, html: node.outerHTML, text: (node.querySelector('.nk-text-tile-content')?.textContent || "").trim(), articleId: src.id, type: 'snippet' };
                            }
                            else if (node.matches(selectors.image)) {
                                const img = node.querySelector('img');
                                if (img) {
                                    const snippetId = node.id || `img-${src.id}-${index}`;
                                    const caption = node.querySelector('.image-caption');
                                    snippetObject = { id: snippetId, isImage: true, src: img.src, text: caption ? caption.textContent.trim() : '', html: node.outerHTML, articleId: src.id, type: 'snippet' };
                                }
                            }
                            else if (node.matches(selectors.mcq)) {
                                const questionEl = node.querySelector('.nk-mcq-question');
                                if (questionEl) snippetObject = { id: `mcq-${src.id}-${index}`, html: node.outerHTML, text: (questionEl.textContent || "").trim(), articleId: src.id, type: 'mcq' };
                            }
                            else if (node.matches(selectors.accordion)) {
                                const titleEl = node.querySelector('.nk-accordion-title');
                                if (titleEl) snippetObject = { id: `accordion-${src.id}-${index}`, html: node.outerHTML, text: (titleEl.textContent || "").trim(), articleId: src.id, type: 'accordion' };
                            }
                            else if (node.matches(selectors.blocks)) {
                                if (node.matches('.nk-timeline-block')) {
                                    const firstTitle = node.querySelector('.nk-timeline-title');
                                    snippetObject = { id: `timeline-${src.id}-${index}`, html: node.outerHTML, text: `Timeline: ${firstTitle ? firstTitle.textContent.trim() : 'Event'}`, articleId: src.id, type: 'timeline' };
                                } else if (node.matches('.chart-container')) {
                                    const canvas = node.querySelector('canvas');
                                    if (canvas && canvas.dataset.chartConfig) snippetObject = { id: `chart-${src.id}-${index}`, html: node.outerHTML, text: `Chart Data`, articleId: src.id, type: 'chart' };
                                } else if (node.matches('.nk-video-embed')) {
                                    snippetObject = { id: `video-${src.id}-${index}`, html: node.outerHTML, text: `Video Embed`, articleId: src.id, type: 'video' };
                                }
                            }
                            else if (node.matches(selectors.highlight)) {
                                const snippetId = node.id || `snip-${src.id}-${index}`;
                                snippetObject = { id: snippetId, html: node.outerHTML, text: (node.textContent || "").trim(), articleId: src.id, type: 'snippet' };
                            }

                            if (snippetObject) {
                                results.push(snippetObject);
                            }
                        });
                    });
                    return results.filter(s => (s.text && s.text.trim()) || s.isImage || s.type === 'accordion' || s.type === 'video' || s.type === 'timeline' || s.type === 'chart');

                },


                unwrapNode(node) {
                    const p = node.parentNode; if (!p) return;
                    while (node.firstChild) p.insertBefore(node.firstChild, node);
                    try { p.removeChild(node); } catch (e) { }
                },
                fuzzySearch(query, items, key) {
                    if (!query || !query.trim()) return items;
                    if (!items || items.length === 0) return [];
                    const searchTerms = query.toLowerCase().trim().split(/\s+/).filter(Boolean);
                    return items.filter(item => {
                        if (!item) return false;

                        let searchableText = '';
                        if (key === 'article') {
                            const title = item.title || '';
                            const tags = Array.isArray(item.tags) ? item.tags.join(' ') : '';
                            const content = item.content || '';
                            searchableText = `${title} ${tags} ${content}`;
                        } else if (key === 'flashcard') {
                            if (item.type === 'mcq') {
                                const optionsText = (item.options || []).map(o => o.text).join(' ');
                                searchableText = `${item.question || ''} ${optionsText} ${item.explanation || ''}`;
                            } else { // For Cloze and Collapsible cards
                                searchableText = item.fullText || `${item.frontText || ''} ${item.backText || ''}`;
                            }
                        }
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = searchableText;
                        const cleanText = (tempDiv.textContent || tempDiv.innerText || "").toLowerCase();
                        return searchTerms.every(term => cleanText.includes(term));
                    });
                },
                // --- FIX: Safe Regex with Negative Lookahead to prevent runaway matching ---
                renderClozeForDisplay(text) {
                    // Matches {{c1::...}} but stops if it sees another {{c inside
                    return text ? text.replace(/{{c\d+::((?:(?!{{c\d+::)[\s\S])*?)}}/g, '<span class="cloze-flashcard">$1</span>') : '';
                },

                hashString(str) {
                    let hash = 5381;
                    for (let i = 0; i < str.length; i++) {
                        hash = ((hash << 5) + hash) + str.charCodeAt(i); /* hash * 33 + c */
                    }
                    return hash.toString();
                },

                parseShortcuts(text) {
                    if (!text) return '';

                    // --- FIX: Protect HTML tags (especially data:image URLs) from regex replacements ---
                    const tokens = [];
                    const maskedText = text.replace(/<[^>]+>/g, (match) => {
                        tokens.push(match);
                        return `\uE000${tokens.length - 1}\uE000`;
                    });

                    const createSnippetId = () => `snip-${crypto.randomUUID().slice(0, 12)}`;
                    let processedHtml = maskedText
                        .replace(/^\s*>\s*(.*)/gm, '<blockquote>$1</blockquote>')
                        .replace(/^\s*---\s*$/gm, '<hr>')
                        .replace(/\*\*(.*?)\*\*/g, '<i>$1</i>').replace(/\*([^*]+)\*/g, '<b>$1</b>')

                        .replace(/__(.*?)__/g, '<span class="text-underline">$1</span>').replace(/~~(.*?)~~/g, '<del>$1</del>')
                        .replace(/==(.*?)==g/g, `<span class="highlight-2" id="${createSnippetId()}">$1</span>`).replace(/==(.*?)==b/g, `<span class="highlight-3" id="${createSnippetId()}">$1</span>`)
                        .replace(/==(.*?)==r/g, `<span class="highlight-4" id="${createSnippetId()}">$1</span>`).replace(/==(.*?)==p/g, `<span class="highlight-5" id="${createSnippetId()}">$1</span>`)
                        .replace(/==(.*?)==c/g, `<span class="highlight-6" id="${createSnippetId()}">$1</span>`).replace(/==(.*?)==m/g, `<span class="highlight-7" id="${createSnippetId()}">$1</span>`).replace(/==(.*?)==/g, `<span class="highlight-1" id="${createSnippetId()}">$1</span>`)
                        .replace(/::(.*?)_r::/g, `<span class="text-red" id="${createSnippetId()}">$1</span>`).replace(/::(.*?)_g::/g, `<span class="text-green" id="${createSnippetId()}">$1</span>`)
                        .replace(/::(.*?)_b::/g, `<span class="text-blue" id="${createSnippetId()}">$1</span>`).replace(/::(.*?)_m::/g, `<span class="text-magenta" id="${createSnippetId()}">$1</span>`);

                    // Restore tags
                    processedHtml = processedHtml.replace(/\uE000(\d+)\uE000/g, (match, index) => tokens[parseInt(index)] || match);

                    processedHtml = App.contentTools.convertContentSyntax(processedHtml);
                    return processedHtml;
                },



                cyrb53(str, seed = 0) {
                    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
                    for (let i = 0, ch; i < str.length; i++) {
                        ch = str.charCodeAt(i);
                        h1 = Math.imul(h1 ^ ch, 2654435761);
                        h2 = Math.imul(h2 ^ ch, 1597334677);
                    }
                    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
                    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
                    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
                },

                // --- FIX: Robust parsing with safety checks and unique IDs ---
                extractFlashcards(html, articleId, category, existing) {
                    const isPremium = App.license.isPremium();
                    const totalFlashcards = isPremium ? 0 : this.getAllFlashcards().length;
                    const flashcardLimit = App.config.sparkTierLimit;
                    let canCreateMore = isPremium || totalFlashcards < flashcardLimit;
                    let limitReachedMessageShown = false;

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    const newCards = {};

                    const checkAndShowLimitMessage = () => {
                        if (!canCreateMore && !limitReachedMessageShown) {
                            App.ui.showAscensionModal();
                            App.ui.showToast(`Flashcard limit of ${flashcardLimit} reached.`, 'warning');
                            limitReachedMessageShown = true;
                        }
                    };

                    const addEnhancedProperties = (existingCard) => ({
                        easeFactor: existingCard?.easeFactor || 2.5,
                        lapses: existingCard?.lapses || 0,
                    });

                    const safeClozeRegex = /{{c\d+::((?:(?!{{c\d+::)[\s\S])*?)}}/g;


                    // FIXED: Added 'div' and 'span' to selectors for robustness, with duplicate check
                    tempDiv.querySelectorAll('p, li, h1, h2, h3, h4, h5, h6, blockquote, td, th, pre, div, span').forEach(p => {
                        // Prevent duplicates: If this is a container (div/span) holding other blocks, skip it.
                        if ((p.tagName === 'DIV' || p.tagName === 'SPAN') && p.querySelector('p, li, h1, h2, h3, h4, h5, h6, blockquote, td, th, pre')) return;

                        // Prevent duplicates: If this element is INSIDE a matching block (e.g. span inside p), let the parent handle it? 
                        // Actually, 'innerHTML.includes' is the check. 
                        // If P has innerHTML with {{c1..}}, and SPAN inside has {{c1..}}.
                        // P will generate card. SPAN will generate card.
                        // We must avoid this. 
                        // Logic: If p is a span, check if it has a block parent that we are also scanning.
                        if (p.tagName === 'SPAN' && p.closest('p, li, h1, h2, h3, h4, h5, h6, blockquote, td, th, pre, div')) {
                            // This is risky. If the parent DIV matches, we might skip SPAN.
                            // But we just added DIV and skip DIV if it has children.
                            // Let's rely on the ID generation (cyrb53 of normalizedText). 
                            // If P id == SPAN id, existing check handles it?
                            // P text: "Start {{c1::cloze}} end" -> ID_A
                            // SPAN text: "{{c1::cloze}}" -> ID_B
                            // DIFFERENT IDs. Duplicate cards!
                            // Heuristic: Only process SPAN/DIV if they do NOT have block ancestors?
                            // Or just stick to DIV and skip if children. 
                        }

                        if (p.innerHTML.includes('{{c')) {
                            const fullText = p.innerHTML;


                            const normalizedText = fullText.replace(/\s+/g, ' ').trim();
                            const cardId = `chash_${this.cyrb53(normalizedText)}`;

                            const existingCard = existing[cardId] || Object.values(existing).find(c => c.fullText === fullText);

                            if (fullText.match(safeClozeRegex)) {
                                if (existingCard || canCreateMore) {
                                    newCards[cardId] = {
                                        id: cardId, type: 'cloze', articleId, category, fullText,
                                        rating: existingCard?.rating || null, reviewCount: existingCard?.reviewCount || 0,
                                        interval: existingCard?.interval || 0, lastReviewed: existingCard?.lastReviewed || null,
                                        nextReviewDue: existingCard?.nextReviewDue || null, createdAt: existingCard?.createdAt || new Date().toISOString(),
                                        reviewHistory: existingCard?.reviewHistory || [],
                                        ...addEnhancedProperties(existingCard)
                                    };
                                    if (!existingCard) canCreateMore = isPremium || (totalFlashcards + Object.keys(newCards).length) < flashcardLimit;
                                } else { checkAndShowLimitMessage(); }
                            }
                        }
                    });

                    tempDiv.querySelectorAll('.nk-accordion').forEach(cardEl => {
                        const frontEl = cardEl.querySelector('.nk-accordion-title');
                        const backEl = cardEl.querySelector('.nk-accordion-content');
                        const hintEl = cardEl.querySelector('.nk-accordion-hint-content');
                        if (!frontEl || !backEl) return;

                        const frontText = frontEl.innerHTML.trim();
                        const backText = backEl.innerHTML.trim();
                        const hintText = hintEl ? hintEl.innerHTML.trim() : null;
                        const isReversible = cardEl.dataset.reversible === 'true';
                        const cardId = `coll_${this.cyrb53(frontText + backText)}`;

                        if (cardId && frontEl && backEl) {
                            const isFrontEmpty = frontText === '' || frontText === '<p><br></p>'; const isBackEmpty = backText === '' || backText === '<p><br></p>';
                            if (isFrontEmpty || isBackEmpty) return;

                            const existingCard = existing[cardId];
                            const cardData = {
                                type: 'collapsible', articleId, category, rating: existingCard?.rating || null,
                                reviewCount: existingCard?.reviewCount || 0, interval: existingCard?.interval || 0,
                                lastReviewed: existingCard?.lastReviewed || null, nextReviewDue: existingCard?.nextReviewDue || null,
                                createdAt: existingCard?.createdAt || new Date().toISOString(), reviewHistory: existingCard?.reviewHistory || [],
                                ...addEnhancedProperties(existingCard)
                            };
                            if (hintText) cardData.hint = hintText;

                            if (existingCard || canCreateMore) {
                                newCards[cardId] = { ...cardData, id: cardId, frontText, backText, isReversed: false };
                                if (!existingCard) canCreateMore = isPremium || (totalFlashcards + Object.keys(newCards).length) < flashcardLimit;
                            } else { checkAndShowLimitMessage(); }

                            if (isReversible) {
                                const reversedCardId = `${cardId}_rev`;
                                const existingReversedCard = existing[reversedCardId];
                                if (existingReversedCard || canCreateMore) {
                                    newCards[reversedCardId] = {
                                        ...cardData,
                                        id: reversedCardId, frontText: backText, backText: frontText, isReversed: true,
                                        rating: existingReversedCard?.rating || null, reviewCount: existingReversedCard?.reviewCount || 0,
                                        interval: existingReversedCard?.interval || 0, lastReviewed: existingReversedCard?.lastReviewed || null,
                                        nextReviewDue: existingReversedCard?.nextReviewDue || null, createdAt: existingReversedCard?.createdAt || new Date().toISOString(),
                                        reviewHistory: existingReversedCard?.reviewHistory || [],
                                        ...addEnhancedProperties(existingReversedCard)
                                    };
                                    if (!existingReversedCard) canCreateMore = isPremium || (totalFlashcards + Object.keys(newCards).length) < flashcardLimit;
                                } else { checkAndShowLimitMessage(); }
                            }
                        }
                    });

                    tempDiv.querySelectorAll('.nk-mcq-block').forEach(mcqBlock => {
                        const questionEl = mcqBlock.querySelector('.nk-mcq-question');
                        if (!questionEl || !questionEl.textContent.trim()) return;

                        const questionText = questionEl.innerHTML.trim();
                        const options = Array.from(mcqBlock.querySelectorAll('.nk-mcq-option')).map(opt => ({
                            text: opt.querySelector('.nk-mcq-option-text').innerHTML.trim(),
                            isCorrect: opt.dataset.isCorrect === 'true'
                        })).filter(opt => opt.text);

                        const explanationEl = mcqBlock.querySelector('.nk-mcq-explanation');
                        let explanationText = null;
                        if (explanationEl && explanationEl.textContent.trim()) {
                            explanationText = explanationEl.innerHTML;
                        }
                        if (options.length < 2 || !options.some(opt => opt.isCorrect)) return;

                        const allOptionsText = options.map(o => o.text).join('');
                        const cardId = `mcq_${this.cyrb53(questionText + allOptionsText)}`;

                        const existingCard = existing[cardId];
                        if (existingCard || canCreateMore) {
                            newCards[cardId] = {
                                id: cardId, type: 'mcq', articleId, category,
                                question: questionText, options: options, explanation: explanationText,
                                rating: existingCard?.rating || null, reviewCount: existingCard?.reviewCount || 0,
                                interval: existingCard?.interval || 0, lastReviewed: existingCard?.lastReviewed || null,
                                nextReviewDue: existingCard?.nextReviewDue || null, createdAt: existingCard?.createdAt || new Date().toISOString(),
                                reviewHistory: existingCard?.reviewHistory || [],
                                ...addEnhancedProperties(existingCard)
                            };
                            if (!existingCard) canCreateMore = isPremium || (totalFlashcards + Object.keys(newCards).length) < flashcardLimit;
                        } else { checkAndShowLimitMessage(); }
                    });

                    // Extract Image Occlusion Flashcards (Visual Flashcards from Whiteboard)
                    tempDiv.querySelectorAll('.nk-visual-flashcard.wb-embed').forEach(vfc => {
                        const frontImg = vfc.querySelector('.nk-vfc-front img');
                        const backImg = vfc.querySelector('.nk-vfc-back img');
                        const wbId = vfc.dataset.wbId;
                        if (!frontImg || !backImg || !wbId) return;

                        const cardId = `vfc_${wbId}`;
                        const existingCard = existing[cardId];

                        if (existingCard || canCreateMore) {
                            newCards[cardId] = {
                                id: cardId,
                                type: 'image-occlusion',
                                articleId,
                                category,
                                frontImage: frontImg.src,
                                backImage: backImg.src,
                                wbId: wbId,
                                rating: existingCard?.rating || null,
                                reviewCount: existingCard?.reviewCount || 0,
                                interval: existingCard?.interval || 0,
                                lastReviewed: existingCard?.lastReviewed || null,
                                nextReviewDue: existingCard?.nextReviewDue || null,
                                createdAt: existingCard?.createdAt || new Date().toISOString(),
                                reviewHistory: existingCard?.reviewHistory || [],
                                ...addEnhancedProperties(existingCard)
                            };
                            if (!existingCard) canCreateMore = isPremium || (totalFlashcards + Object.keys(newCards).length) < flashcardLimit;
                        } else { checkAndShowLimitMessage(); }
                    });

                    return newCards;
                },

                getAllFlashcards() { return App.state.articles.flatMap(a => (a.flashcards ? Object.values(a.flashcards) : [])); },

                getAllTagsWithData() {
                    const tagMap = new Map();
                    App.state.articles.forEach(article => {
                        if (article.tags && article.tags.length > 0) {
                            const createdAtDate = new Date(article.createdAt);
                            const updatedAtDate = new Date(article.updatedAt);
                            article.tags.forEach(tag => {
                                if (!tagMap.has(tag)) {
                                    tagMap.set(tag, { tag: tag, firstUsed: createdAtDate, lastUsed: updatedAtDate });
                                } else {
                                    const existing = tagMap.get(tag);
                                    if (createdAtDate < existing.firstUsed) existing.firstUsed = createdAtDate;
                                    if (updatedAtDate > existing.lastUsed) existing.lastUsed = updatedAtDate;
                                }
                            });
                        }
                    });
                    return Array.from(tagMap.values());
                },

                getSortedFlashcardsForDisplay(searchTerm = '') {
                    let cards = this.getAllFlashcards();
                    let currentSearchTerm = searchTerm.trim();

                    // NEW: Check for Rating filter
                    const ratingMap = { '0': null, '1': 'Easy', '2': 'Good', '3': 'Hold', '4': 'Hard', '5': 'Again' };
                    const ratingMatch = currentSearchTerm.match(/^([0-5])\s*(.*)/);

                    if (ratingMatch) {
                        const ratingKey = ratingMatch[1];
                        const ratingFilter = ratingMap[ratingKey];
                        currentSearchTerm = ratingMatch[2].trim();
                        cards = cards.filter(c => c.rating === ratingFilter);
                    }

                    const category = App.settings.get('flashcardCategory') || 'All';
                    const sortBy = App.settings.get('flashcardSortBy');
                    if (category !== 'All') { cards = cards.filter(fc => fc.category === category); }
                    if (currentSearchTerm) { cards = App.util.fuzzySearch(currentSearchTerm, cards, 'flashcard'); }

                    switch (sortBy) {
                        case 'mcq':
                            cards = cards.filter(c => c.type === 'mcq');
                            cards.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)); // Default sort for MCQs is newest first
                            break;
                        case 'sm2':
                            const ratingOrder = { 'Again': 1, 'Hard': 2, 'Hold': 3, 'Good': 4, 'Easy': 5 };
                            cards.sort((a, b) => (ratingOrder[a.rating] || 6) - (ratingOrder[b.rating] || 6) || (a.nextReviewDue ? new Date(a.nextReviewDue) : Infinity) - (b.nextReviewDue ? new Date(b.nextReviewDue) : Infinity));
                            break;
                        case 'random':
                            cards.sort(() => Math.random() - 0.5);
                            break;
                        case 'createdAt-asc':
                            cards.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
                            break;
                        case 'createdAt-desc':
                            cards.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                            break;

                        case 'read':
                            cards = cards.filter(c => c.rating !== null).sort((a, b) => new Date(b.lastReviewed) - new Date(a.lastReviewed));
                            break;
                        case 'unread':
                            cards = cards.filter(c => c.rating === null).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                            break;
                        case 'leeches':
                            cards = cards.filter(c => (c.lapses || 0) >= App.config.sm2.leechThreshold);
                            cards.sort((a, b) => (b.lapses || 0) - (a.lapses || 0));
                            break;
                    }
                    return cards;
                },

                getDueFlashcards(allCategories = false) {
                    let cards = this.getAllFlashcards();
                    const category = App.settings.get('flashcardCategory') || 'All'; const now = new Date();
                    if (category !== 'All' && !allCategories) { cards = cards.filter(fc => fc.category === category); }
                    const dueCards = cards.filter(card => card.rating === null || (card.nextReviewDue && new Date(card.nextReviewDue) <= now));
                    const ratingOrder = { 'Again': 1, 'Hard': 2, 'Hold': 3, 'Good': 4, 'Easy': 5 };
                    dueCards.sort((a, b) => { const aIsNew = a.rating === null, bIsNew = b.rating === null; if (aIsNew && !bIsNew) return -1; if (!aIsNew && bIsNew) return 1; return (ratingOrder[a.rating] || 6) - (ratingOrder[b.rating] || 6); });
                    return dueCards;
                },
                getAppStartDate() {
                    if (App.state.articles.length === 0) { const now = new Date(); return { firstYear: now.getFullYear(), firstMonth: now.getMonth() }; }
                    const firstTimestamp = Math.min(...App.state.articles.map(a => new Date(a.createdAt).getTime()));
                    const firstDate = new Date(firstTimestamp);
                    return { firstYear: firstDate.getFullYear(), firstMonth: firstDate.getMonth() };
                },
                getFlashcardStats() {
                    const allCards = App.util.getAllFlashcards();
                    return { total: allCards.length, due: App.util.getDueFlashcards(true).length, ratings: allCards.reduce((acc, card) => { const rating = card.rating || 'New'; acc[rating] = (acc[rating] || 0) + 1; return acc; }, {}) };
                },
                getReadingStats() {
                    const stats = { total: 0, completed: 0, unread: 0, stages: {} };
                    App.state.articles.forEach(article => {
                        stats.total++;
                        const readCount = article.readCount || 0;
                        if (readCount > 0) { stats.completed++; let stage = readCount >= 5 ? '5' : String(readCount); stats.stages[stage] = (stats.stages[stage] || 0) + 1; }
                        else { stats.unread++; }
                    });
                    return stats;
                },
                getFlashcardStatsForPeriod(period) {
                    const start = new Date(); start.setHours(0, 0, 0, 0); if (period === 'yesterday') start.setDate(start.getDate() - 1);
                    const end = new Date(start); end.setHours(23, 59, 59, 999);
                    let reviewed = 0;
                    this.getAllFlashcards().forEach(card => {
                        if (card.reviewHistory && card.reviewHistory.length > 0) {
                            card.reviewHistory.forEach(ts => { const reviewDate = new Date(ts); if (reviewDate >= start && reviewDate <= end) reviewed++; });
                        }
                    });
                    return { reviewed };
                },
                getReadingStatsForPeriod(period) {
                    const start = new Date(); start.setHours(0, 0, 0, 0); if (period === 'yesterday') start.setDate(start.getDate() - 1);
                    const end = new Date(start); end.setHours(23, 59, 59, 999);
                    let read = 0;
                    App.state.articles.forEach(article => {
                        if (article.readHistory && article.readHistory.length > 0) {
                            article.readHistory.forEach(ts => { const readDate = new Date(ts); if (readDate >= start && readDate <= end) read++; });
                        }
                    });
                    return { read };
                },
                getFlashcardChartData(month, year) {
                    const daysInMonth = new Date(year, month + 1, 0).getDate();
                    const labels = Array.from({ length: daysInMonth }, (_, i) => i + 1); const data = Array(daysInMonth).fill(0);
                    this.getAllFlashcards().forEach(card => {
                        if (card.reviewHistory) {
                            card.reviewHistory.forEach(ts => { const reviewDate = new Date(ts); if (reviewDate.getFullYear() === year && reviewDate.getMonth() === month) data[reviewDate.getDate() - 1]++; });
                        }
                    });
                    return { labels, data };
                },
                getReadingChartData(month, year) {
                    const daysInMonth = new Date(year, month + 1, 0).getDate();
                    const labels = Array.from({ length: daysInMonth }, (_, i) => i + 1); const data = Array(daysInMonth).fill(0);
                    for (const article of App.state.articles) {
                        if (article.readHistory && Array.isArray(article.readHistory)) {
                            for (const timestamp of article.readHistory) { const readDate = new Date(timestamp); if (readDate.getFullYear() === year && readDate.getMonth() === month) data[readDate.getDate() - 1]++; }
                        }
                    }
                    return { labels, data };
                },

                getFlashcardReviewHeatmapData() {
                    const history = App.quiz.stats.quizHistory || [];
                    const reviewCounts = {};
                    history.forEach(ts => {
                        const dateStr = ts.substring(0, 10);
                        reviewCounts[dateStr] = (reviewCounts[dateStr] || 0) + 1;
                    });
                    return reviewCounts;
                },

                getFlashcardForecastData() {
                    const forecast = Array(30).fill(0);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);

                    const allCards = this.getAllFlashcards();
                    allCards.forEach(card => {
                        if (card.nextReviewDue) {
                            const dueDate = new Date(card.nextReviewDue);
                            dueDate.setHours(0, 0, 0, 0);
                            const diffTime = dueDate - today;
                            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                            if (diffDays >= 0 && diffDays < 30) {
                                forecast[diffDays]++;
                            }
                        }
                    });
                    return forecast;
                },

                getCardEaseDistributionData() {
                    const distribution = {
                        Leech: 0,       // EF < 1.8
                        Hard: 0,        // 1.8 <= EF < 2.2
                        Normal: 0,      // 2.2 <= EF < 2.8
                        Easy: 0,        // EF >= 2.8
                        New: 0
                    };
                    const allCards = this.getAllFlashcards();
                    allCards.forEach(card => {
                        if (card.rating === null) {
                            distribution.New++;
                        } else {
                            const ef = card.easeFactor || 2.5;
                            if (ef < 1.8) distribution.Leech++;
                            else if (ef < 2.2) distribution.Hard++;
                            else if (ef < 2.8) distribution.Normal++;
                            else distribution.Easy++;
                        }
                    });
                    return distribution;
                },

                getReadProgressColorVar(readCount) {
                    if (readCount <= 0) return '--rc-0-gray';
                    if (readCount === 1) return '--rc-1-red';
                    if (readCount === 2) return '--rc-2-orange';
                    if (readCount === 3) return '--rc-3-pink';
                    if (readCount === 4) return '--rc-4-purple';
                    if (readCount === 5) return '--rc-5-indigo';
                    if (readCount === 6) return '--rc-6-teal';
                    if (readCount === 7) return '--rc-7-green-light';
                    if (readCount === 8) return '--rc-8-green-med';
                    if (readCount === 9) return '--rc-9-green-bright';
                    return '--rc-10-green-best'; // 10+ reads
                },

                cleanFlashcardTextForDisplay(htmlString) {
                    if (!htmlString) return '';
                    let cleanText = htmlString.replace(/{{c\d+::((?:(?!{{c\d+::)[\s\S])*?)}}/g, '[$1]');
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = cleanText;
                    return tempDiv.textContent || tempDiv.innerText || '';
                },

                escapeForTsv(str) {
                    if (str === null || str === undefined) return '';
                    let result = String(str);
                    if (result.includes('\t') || result.includes('\n') || result.includes('"')) result = '"' + result.replace(/"/g, '""') + '"';
                    return result;
                },

                sanitizeForTeleprompter(htmlString) {
                    const allowedTags = [
                        'P', 'BR', 'B', 'I', 'U', 'STRONG', 'EM', 'SPAN',
                        'UL', 'OL', 'LI', 'BLOCKQUOTE', 'HR',
                        'H1', 'H2', 'H3', 'H4', 'H5', 'H6'
                    ];
                    const allowedAttributes = {
                        'span': ['class'] // Only allow 'class' for highlights/text-colors
                    };

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlString;
                    const allNodes = tempDiv.querySelectorAll('*');

                    allNodes.forEach(node => {
                        const tagName = node.tagName.toUpperCase();
                        if (!allowedTags.includes(tagName)) {
                            // We use unwrapNode to keep the text content (e.g., from a link)
                            App.util.unwrapNode(node);
                            return;
                        }
                        for (const attr of [...node.attributes]) {
                            const attrName = attr.name.toLowerCase();
                            const allowedForTag = allowedAttributes[tagName.toLowerCase()] || [];

                            if (!allowedForTag.includes(attrName)) {
                                node.removeAttribute(attr.name);
                            }
                        }
                    });

                    return tempDiv.innerHTML;
                },

                sanitizeHTML(htmlString) {
                    const { allowedTags, allowedAttributes } = App.config.sanitizer;
                    const tempDiv = document.createElement('div'); tempDiv.innerHTML = htmlString;
                    // FIX: Don't remove iframes so video embeds work in Read Mode
                    tempDiv.querySelectorAll('script, style, link, meta, object, embed').forEach(el => el.remove());
                    const allNodes = tempDiv.querySelectorAll('*');
                    allNodes.forEach(node => {
                        const tagName = node.tagName.toUpperCase();
                        if (!allowedTags.includes(tagName)) { App.util.unwrapNode(node); return; }
                        for (const attr of [...node.attributes]) {
                            const attrName = attr.name.toLowerCase();
                            const allowedForTag = allowedAttributes[tagName.toLowerCase()] || [];
                            const allowedGlobally = allowedAttributes['*'] || [];
                            if (!allowedForTag.includes(attrName) && !allowedGlobally.includes(attrName)) node.removeAttribute(attr.name);
                        }
                    });
                    return tempDiv.innerHTML;
                },
                htmlToMarkdown(node) {
                    let markdown = '';
                    const BOLD_TAGS = ['B', 'STRONG'], ITALIC_TAGS = ['I', 'EM'], UNDERLINE_TAGS = ['U', 'SPAN'];
                    if (BOLD_TAGS.includes(node.tagName)) markdown = `**${node.textContent.trim()}**`;
                    else if (ITALIC_TAGS.includes(node.tagName)) markdown = `*${node.textContent.trim()}*`;
                    else if (UNDERLINE_TAGS.includes(node.tagName) && node.classList.contains('text-underline')) markdown = `<u>${node.textContent.trim()}</u>`;
                    else markdown = node.textContent.trim();
                    return markdown;
                },
                trapFocus(element) {
                    const focusableEls = element.querySelectorAll('a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input[type="text"]:not([disabled]), input[type="number"]:not([disabled]), input[type="range"]:not([disabled]), select:not([disabled])');
                    if (focusableEls.length === 0) return;
                    const firstFocusableEl = focusableEls[0], lastFocusableEl = focusableEls[focusableEls.length - 1];
                    firstFocusableEl?.focus();
                    element.addEventListener('keydown', function (e) {
                        if (e.key !== 'Tab') return;
                        if (e.shiftKey) { if (document.activeElement === firstFocusableEl) { lastFocusableEl.focus(); e.preventDefault(); } }
                        else { if (document.activeElement === lastFocusableEl) { firstFocusableEl.focus(); e.preventDefault(); } }
                    });
                },
                slugify(text) { return text.toString().toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, ''); },
                textToHtml(text) {
                    const paragraphs = text.split(/(\r\n|\n){2,}/g);
                    return paragraphs.filter(p => p && p.trim() !== '' && p !== '\n' && p !== '\r\n').map(p => `<p>${p.trim().replace(/\r\n|\n/g, '<br>')}</p>`).join('');
                },
                placeCursor(element, atStart = false) {
                    const range = document.createRange(); const sel = window.getSelection(); range.selectNodeContents(element); range.collapse(atStart); sel.removeAllRanges(); sel.addRange(range);
                },
                restoreSelection() {
                    if (App.state.savedRange) { const selection = window.getSelection(); selection.removeAllRanges(); selection.addRange(App.state.savedRange); }
                },
                escapeHtml: (u) => u ? u.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;") : '',
                sm2: {
                    rateCard(card, rating) {
                        const now = new Date();

                        // Handle the "Bury" command first, as it's a special case.
                        if (rating === 'Hold') {
                            const nextReviewDate = new Date(now.getTime() + 24 * 60 * 60 * 1000); // 24 hours
                            return {
                                ...card,
                                rating: 'Hold', // Keep original rating
                                nextReviewDue: nextReviewDate.toISOString(),
                                lastReviewed: now.toISOString(),
                            };
                        }

                        let easeFactor = card.easeFactor || 2.5;
                        let reviewCount = card.reviewCount || 0;
                        let interval = card.interval || 0;
                        let lapses = card.lapses || 0;

                        //  NEW: Branch logic. Is this the first time the user is rating this card?
                        if (reviewCount === 0) {
                            switch (rating) {
                                case 'Again':
                                    lapses += 1;
                                    easeFactor = Math.max(1.3, easeFactor - 0.20);
                                    interval = 10 * 60 * 1000; // 10 minutes
                                    reviewCount = 0; // Stays at 0 because it was incorrect
                                    break;
                                case 'Hard':
                                    easeFactor = Math.max(1.3, easeFactor - 0.15);
                                    interval = 6 * 60 * 60 * 1000; // 6 hours
                                    reviewCount = 1; // It was a successful, rated review
                                    break;
                                case 'Good':
                                    // No change to default easeFactor
                                    interval = 12 * 60 * 60 * 1000; // 12 hours
                                    reviewCount = 1;
                                    break;
                                case 'Easy':
                                    easeFactor += 0.15;
                                    interval = 2 * 24 * 60 * 60 * 1000; // 2 days
                                    reviewCount = 1;
                                    break;
                            }
                        } else {
                            const qualityMap = { 'Again': 0, 'Hard': 2, 'Good': 4, 'Easy': 5 };
                            const quality = qualityMap[rating];

                            if (quality < 3) { // User rated 'Again'
                                lapses += 1;
                                easeFactor = Math.max(1.3, easeFactor - 0.20);
                                reviewCount = 0; // Reset consecutive correct reviews
                                interval = 90 * 60 * 1000; // Re-learn in 90 minutes
                            } else { // 'Hard', 'Good', or 'Easy'
                                reviewCount += 1;
                                interval = Math.round(interval * easeFactor);

                                // Update ease factor based on performance
                                easeFactor += (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
                                if (easeFactor < 1.3) easeFactor = 1.3;
                            }
                        }

                        const intervalModifier = App.settings.get('intervalModifier') || 1.0;
                        interval *= intervalModifier;

                        const fuzz = (Math.random() * 0.1) - 0.05; // +/- 5%
                        interval *= (1 + fuzz);

                        const minInterval = 60000; // 1 minute
                        interval = Math.max(minInterval, interval);

                        const nextReviewDue = new Date(now.getTime() + interval);
                        const reviewHistory = [...(card.reviewHistory || []), now.toISOString()];

                        return {
                            rating,
                            reviewCount,
                            interval,
                            lastReviewed: now.toISOString(),
                            nextReviewDue: nextReviewDue.toISOString(),
                            reviewHistory,
                            easeFactor,
                            lapses,
                        };
                    },
                    getRatingColor(rating) {
                        if (!rating) return 'var(--sm2-unrated)';
                        const colorName = App.config.sm2.colors[rating];
                        return `var(--sm2-${colorName})`;
                    }
                },
                formatTimestamp(isoString) {
                    if (!isoString) return 'Never';
                    const date = new Date(isoString); const now = new Date();
                    const isToday = date.toDateString() === now.toDateString();
                    now.setDate(now.getDate() - 1); const isYesterday = date.toDateString() === now.toDateString();
                    const timeFormat = { hour: 'numeric', minute: 'numeric' };
                    if (isToday) return `Today at ${date.toLocaleTimeString([], timeFormat)}`;
                    if (isYesterday) return `Yesterday at ${date.toLocaleTimeString([], timeFormat)}`;
                    return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
                },
                dataURLtoBlob(dataurl) {
                    if (!dataurl || !dataurl.includes(',')) return null;
                    try {
                        const parts = dataurl.split(',');
                        const mimeMatch = parts[0].match(/:(.*?);/);
                        if (!mimeMatch || mimeMatch.length < 2) return null;
                        const mime = mimeMatch[1];
                        const bstr = atob(parts[1]);
                        let n = bstr.length;
                        const u8arr = new Uint8Array(n);
                        while (n--) { u8arr[n] = bstr.charCodeAt(n); }
                        return new Blob([u8arr], { type: mime });
                    } catch (e) {
                        console.error("Failed to convert data URL to blob:", e);
                        return null;
                    }
                },
                getChartColors() {
                    const theme = document.documentElement.getAttribute('data-theme') || 'sepia';
                    const palettes = {
                        light: ['#0d9488', '#f97316', '#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#6366f1'],
                        dark: ['#E0B453', '#22c55e', '#60a5fa', '#a78bfa', '#f87171', '#f59e0b', '#34d399', '#c37aff'],
                        // --- UPGRADED SEPIA PALETTE FOR HIGH CONTRAST ---
                        sepia: ['#8c6d46', '#047857', '#a16207', '#5b4636', '#c2410c', '#4d7c0f', '#1d4ed8', '#be185d']
                    };
                    return palettes[theme] || palettes.light;
                },
                calculateQuizStreak() {
                    const history = App.quiz.stats.quizHistory;
                    if (!history || history.length === 0) {
                        return 0;
                    }

                    const uniqueDates = [...new Set(history.map(ts => ts.substring(0, 10)))].sort();

                    if (uniqueDates.length === 0) {
                        return 0;
                    }

                    let streak = 0;
                    const today = new Date();
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);

                    const todayStr = today.toISOString().substring(0, 10);
                    const yesterdayStr = yesterday.toISOString().substring(0, 10);

                    const lastQuizDateStr = uniqueDates[uniqueDates.length - 1];

                    // If the last quiz wasn't today or yesterday, the streak is broken.
                    if (lastQuizDateStr !== todayStr && lastQuizDateStr !== yesterdayStr) {
                        return 0;
                    }

                    // Start counting from the last quiz day.
                    let currentDate = new Date(lastQuizDateStr + 'T12:00:00Z');

                    for (let i = uniqueDates.length - 1; i >= 0; i--) {
                        const dateInHistory = uniqueDates[i];
                        const expectedDateStr = currentDate.toISOString().substring(0, 10);

                        if (dateInHistory === expectedDateStr) {
                            streak++;
                            currentDate.setDate(currentDate.getDate() - 1); // Move to the previous day
                        } else {
                            // A day was missed, so the streak is broken.
                            break;
                        }
                    }

                    return streak;
                },
                getWeekNumber(d) {
                    // Helper function to get the ISO week number for a given date
                    d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
                    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
                    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
                    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
                    return d.getUTCFullYear() + '-' + weekNo;
                },

                calculateWeeklyQuizStreak() {
                    const history = App.quiz.stats.quizHistory;
                    if (!history || history.length === 0) return 0;

                    // Create a set of unique week identifiers (e.g., "2025-38")
                    const uniqueWeeks = [...new Set(history.map(ts => this.getWeekNumber(new Date(ts))))].sort();
                    if (uniqueWeeks.length === 0) return 0;

                    let streak = 0;
                    const today = new Date();
                    const lastWeek = new Date();
                    lastWeek.setDate(lastWeek.getDate() - 7);

                    const currentWeekStr = this.getWeekNumber(today);
                    const lastWeekStr = this.getWeekNumber(lastWeek);
                    const lastQuizWeekStr = uniqueWeeks[uniqueWeeks.length - 1];

                    // If the last quiz wasn't this week or last week, streak is broken
                    if (lastQuizWeekStr !== currentWeekStr && lastQuizWeekStr !== lastWeekStr) {
                        return 0;
                    }

                    // Start counting backwards from the last quiz week
                    let expectedWeek = new Date(today);
                    for (let i = uniqueWeeks.length - 1; i >= 0; i--) {
                        const weekInHistory = uniqueWeeks[i];
                        const expectedWeekStr = this.getWeekNumber(expectedWeek);

                        if (weekInHistory === expectedWeekStr) {
                            streak++;
                            expectedWeek.setDate(expectedWeek.getDate() - 7); // Go back one week
                        } else {
                            break; // A week was missed
                        }
                    }
                    return streak;
                },

                getWeekCompletionData() {
                    const quizHistory = App.quiz.stats.quizHistory || [];
                    const completedDates = new Set(quizHistory.map(ts => ts.substring(0, 10)));
                    const weekData = [];
                    const today = new Date();

                    // Set to the Monday of the current week
                    const dayOfWeek = today.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
                    const startOfWeek = new Date(today);
                    startOfWeek.setDate(today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1)); // Adjust for Sunday

                    const dayLetters = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];

                    for (let i = 0; i < 7; i++) {
                        const currentDay = new Date(startOfWeek);
                        currentDay.setDate(startOfWeek.getDate() + i);

                        const dateStr = currentDay.toISOString().substring(0, 10);
                        const todayStr = today.toISOString().substring(0, 10);

                        weekData.push({
                            dayLetter: dayLetters[i],
                            dateNumber: currentDay.getDate(),
                            isCompleted: completedDates.has(dateStr),
                            isToday: dateStr === todayStr
                        });
                    }
                    return weekData;
                },

                appreciationMessages: [
                    "{name}, you are in the <strong>{tier} League</strong>",
                    "{name}, you are our precious <strong>{tier} Member</strong>",
                    "{name}, You are a <strong>{tier}</strong> in our Ecosystem",
                    "Welcome Legend our Union will be Exquisitive",
                    "Shine bright, my love {name}.",
                    "Are you feeling the power of {tier} membership?",
                    "{name} your IQ can match Elon Musk.",
                    "{tier} suits {name}.",
                    "{name} I can feel, you have Bright future ahead",
                    "{tier} privileges on.",
                    "{name}, pure {tier} vibes.",
                    "Welcome to the <strong>{tier} League</strong>, {name}!",
                    "Your support as a <strong>{tier} Member</strong> is amazing, {name}."
                ],
                cleanPastedStyles(element) {
                    // Query ALL elements with style attribute
                    element.querySelectorAll('[style]').forEach(el => {
                        if (el.hasAttribute('data-user-font')) {
                            return;
                        }

                        // Method 1: Use DOM CSSStyleDeclaration to reliably strip unwanted styles
                        if (el.style) {
                            // Typography & Colors
                            el.style.removeProperty('font-family');
                            el.style.removeProperty('font-size');
                            el.style.removeProperty('line-height');
                            el.style.removeProperty('background-color');
                            el.style.removeProperty('background');
                            el.style.removeProperty('color');

                            // Layout & Dimensions (Fixes cutoff/spacing issues)
                            el.style.removeProperty('height');
                            el.style.removeProperty('width');
                            el.style.removeProperty('max-height');
                            el.style.removeProperty('max-width');
                            el.style.removeProperty('min-height');
                            el.style.removeProperty('min-width');

                            // Spacing & Positioning
                            el.style.removeProperty('margin');
                            el.style.removeProperty('padding');
                            el.style.removeProperty('position');
                            el.style.removeProperty('top');
                            el.style.removeProperty('left');
                            el.style.removeProperty('right');
                            el.style.removeProperty('bottom');
                            el.style.removeProperty('overflow');
                            el.style.removeProperty('z-index');

                            const remainingStyles = el.getAttribute('style');
                            if (!remainingStyles || remainingStyles.trim() === '') {
                                el.removeAttribute('style');
                            }
                        }
                    });

                    // Method 2: Additional regex-based cleanup as a safety net
                    element.querySelectorAll('[style]').forEach(el => {
                        if (el.hasAttribute('data-user-font')) {
                            return;
                        }

                        let style = el.getAttribute('style');
                        if (style) {
                            // Typography & Colors
                            style = style.replace(/font-family\s*:\s*[^;]+(!important)?;?/gi, '');
                            style = style.replace(/font-size\s*:\s*[^;]+(!important)?;?/gi, '');
                            style = style.replace(/line-height\s*:\s*[^;]+(!important)?;?/gi, '');
                            style = style.replace(/background-color\s*:\s*[^;]+(!important)?;?/gi, '');
                            style = style.replace(/background\s*:\s*[^;]+(!important)?;?/gi, '');
                            style = style.replace(/color\s*:\s*[^;]+(!important)?;?/gi, '');

                            // Layout & Positioning
                            style = style.replace(/(min-|max-)?(width|height)\s*:\s*[^;]+(!important)?;?/gi, '');
                            style = style.replace(/(margin|padding)(-[a-z]+)?\s*:\s*[^;]+(!important)?;?/gi, '');
                            style = style.replace(/position\s*:\s*[^;]+(!important)?;?/gi, '');
                            style = style.replace(/overflow(-[xy])?\s*:\s*[^;]+(!important)?;?/gi, '');
                            style = style.replace(/z-index\s*:\s*[^;]+(!important)?;?/gi, '');
                            style = style.replace(/(top|left|right|bottom)\s*:\s*[^;]+(!important)?;?/gi, '');

                            style = style.replace(/;+/g, ';').replace(/^;|;$/g, '').trim();

                            if (style) {
                                el.setAttribute('style', style);
                            } else {
                                el.removeAttribute('style');
                            }
                        }
                    });
                },

                getAppreciationMessage(name, tier) {
                    const messageTemplate = this.appreciationMessages[Math.floor(Math.random() * this.appreciationMessages.length)];
                    return messageTemplate.replace('{name}', name).replace('{tier}', tier);
                },

                async reconcileCategories() {
                    console.log("Reconciling categories...");
                    const allArticles = App.state.articles;
                    let userCategories = App.settings.get('userCategories');
                    const existingCategoryNames = new Set(userCategories.map(c => c.name.toLowerCase()));
                    let newCategoriesAdded = false;

                    allArticles.forEach(article => {
                        const articleCategory = article.category;
                        if (articleCategory && !existingCategoryNames.has(articleCategory.toLowerCase())) {
                            console.log(`Found new category: ${articleCategory}. Adding to settings.`);
                            const newCategory = {
                                name: articleCategory,
                                colorIndex: userCategories.length % App.util.getCategoryColorCount(),
                                isDefault: false // New categories are never the default
                            };
                            userCategories.push(newCategory);
                            existingCategoryNames.add(articleCategory.toLowerCase());
                            newCategoriesAdded = true;
                        }
                    });

                    if (newCategoriesAdded) {
                        await App.settings.set('userCategories', userCategories);
                        App.ui.showToast('New categories from imported notes have been added!', 'success');
                    }
                    return newCategoriesAdded;
                },

                _transformMcqsForTeleprompter(htmlString) {
                    if (!htmlString || !htmlString.includes('nk-mcq-block')) {
                        return htmlString; // No MCQs, return immediately.
                    }

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlString;

                    const mcqBlocks = tempDiv.querySelectorAll('.nk-mcq-block');
                    if (mcqBlocks.length === 0) {
                        return htmlString; // No MCQs found by selector, return.
                    }

                    mcqBlocks.forEach(block => {
                        const questionEl = block.querySelector('.nk-mcq-question');
                        const options = block.querySelectorAll('.nk-mcq-option');

                        if (!questionEl || options.length === 0) return; // Malformed MCQ, skip it.
                        const questionText = questionEl.innerHTML;
                        const optionsHTML = Array.from(options).map(opt => {
                            const optionTextEl = opt.querySelector('.nk-mcq-option-text');
                            if (!optionTextEl) return '';

                            const optionText = optionTextEl.innerHTML; // Get innerHTML to preserve styles
                            const isCorrect = opt.dataset.isCorrect === 'true';
                            return `<li>${isCorrect ? `<b>${optionText}</b>` : optionText}</li>`;
                        }).join('');
                        const newHtml = `
                        <p style="margin-top: 1em;"><b>Question:</b> ${questionText}</p>
                        <ul>${optionsHTML}</ul>
                    `;
                        block.outerHTML = newHtml;
                    });

                    return tempDiv.innerHTML;
                },
                _transformAccordionsForTeleprompter(htmlString) {
                    if (!htmlString || !htmlString.includes('nk-accordion')) {
                        return htmlString; // No accordions, return immediately.
                    }

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlString;

                    const accordionBlocks = tempDiv.querySelectorAll('.nk-accordion');
                    if (accordionBlocks.length === 0) {
                        return htmlString;
                    }

                    accordionBlocks.forEach(block => {
                        const titleEl = block.querySelector('.nk-accordion-title');
                        const contentEl = block.querySelector('.nk-accordion-content');

                        if (!titleEl || !contentEl) return; // Malformed, skip it.
                        const titleText = titleEl.innerHTML;
                        const contentText = contentEl.innerHTML;
                        const newHtml = `
                        <hr style="border-top: 1px dashed var(--border-color); margin: 1em 0;">
                        <p><b>Question:</b> ${titleText}</p>
                        <p><b>Answer:</b> ${contentText}</p>
                    `;
                        block.outerHTML = newHtml;
                    });

                    return tempDiv.innerHTML;
                },

                hexToRgba(hex, alpha) {
                    if (!hex) return `rgba(0,0,0,${alpha})`;
                    let r = 0, g = 0, b = 0;
                    if (hex.length === 4) {
                        r = "0x" + hex[1] + hex[1];
                        g = "0x" + hex[2] + hex[2];
                        b = "0x" + hex[3] + hex[3];
                    } else if (hex.length === 7) {
                        r = "0x" + hex[1] + hex[2];
                        g = "0x" + hex[3] + hex[4];
                        b = "0x" + hex[5] + hex[6];
                    }
                    return `rgba(${+r},${+g},${+b},${alpha})`;
                },

            },


            // ==========================================================================
            // 3.14. PRODUCTIVITY HUB MODULE (v2)
            // ==========================================================================
            hub: {
                state: { tasks: [], pomodoroStats: {}, elementThatOpenedHub: null, hubViewMode: 'split' },
                async loadData() {
                    this.state.tasks = await App.fs.read('todos.json') || [];
                    this.state.pomodoroStats = await App.fs.read('pomodoro.json') || {};
                    await this.data.migratePomodoroDataIfNeeded();
                    this.pomodoro.init();
                    this.ui.updateTodoBadge();
                },
                data: {
                    async saveTasks(tasksToSave) { await App.fs.write('todos.json', tasksToSave || App.hub.state.tasks); },
                    async savePomodoroStats() { await App.fs.write('pomodoro.json', App.hub.state.pomodoroStats); },
                    async migratePomodoroDataIfNeeded() {
                        let needsMigration = false;
                        const stats = App.hub.state.pomodoroStats;
                        for (const date in stats) { if (typeof stats[date] === 'number') { needsMigration = true; break; } }
                        if (needsMigration) {
                            const newStats = {};
                            for (const date in stats) { if (typeof stats[date] === 'number' && stats[date] > 0) newStats[date] = { 'General': stats[date] }; else newStats[date] = stats[date]; }
                            App.hub.pomodoro.state.pomodoroStats = newStats;
                            await this.savePomodoroStats();
                            App.ui.showToast('Pomodoro data format updated.', 'info');
                        }
                    },
                },
                tasks: {
                    state: { currentFilter: 'today', composer: { title: '', category: 'General', priority: 'low', due: new Date().toISOString().slice(0, 10), pomodoroGoal: 0 } },
                    resetComposer() { const defaultCategoryName = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name; this.state.composer = { title: '', category: defaultCategoryName, priority: 'low', due: App.hub.util.getTodayISO(), pomodoroGoal: 0 }; },

                    async add() {
                        const { title, category, priority, due, pomodoroGoal } = this.state.composer;
                        if (!title.trim()) return;
                        App.hub.state.tasks.push({ id: 'task_' + crypto.randomUUID(), title: title.trim(), category, priority, status: 'pending', due: due || App.hub.util.getTodayISO(), createdAt: new Date().toISOString(), completedAt: null, pomodoroGoal, pomodoros: 0 });
                        await App.hub.data.saveTasks(); this.resetComposer(); App.hub.ui.renderTaskComposer(); App.hub.ui.renderTaskList(); App.hub.ui.updateTodoBadge();
                        document.getElementById('composer-title-input')?.focus();
                    },
                    async deleteTask(id) {
                        const taskIndex = App.hub.state.tasks.findIndex(t => t.id === id); if (taskIndex === -1) return;
                        if (App.hub.pomodoro.state.task && App.hub.pomodoro.state.task.id === id) await App.hub.pomodoro.stopAndReset();
                        const taskEl = document.querySelector(`.task-item[data-id="${id}"]`);
                        if (taskEl) {
                            taskEl.classList.add('exiting');
                            taskEl.addEventListener('animationend', () => { taskEl.remove(); const container = document.getElementById('task-list-container'); if (container && container.childElementCount === 0) container.innerHTML = `<p style="text-align: center; color: var(--text-secondary); padding: 2rem;">No tasks here. Great job!</p>`; }, { once: true });
                        }
                        App.hub.state.tasks.splice(taskIndex, 1);
                        await App.hub.data.saveTasks(); App.hub.ui.updateTodoBadge();
                        App.ui.showToast('Task deleted.', 'info');
                    },
                    async toggleStatus(id, event) {
                        const task = App.hub.state.tasks.find(t => t.id === id); if (!task) return;
                        const isCurrentlyCompleted = task.status === 'completed';
                        task.status = isCurrentlyCompleted ? 'pending' : 'completed';
                        task.completedAt = isCurrentlyCompleted ? null : new Date().toISOString();
                        await App.hub.data.saveTasks(); App.hub.ui.updateTodoBadge();
                        const taskEl = document.querySelector(`.task-item[data-id="${id}"]`); if (!taskEl) return;
                        const shouldRemove = ['today', 'backlog', 'upcoming', 'completed'].includes(this.state.currentFilter);
                        if (!isCurrentlyCompleted) {
                            App.util.hapticFeedback('heavy'); // <-- ADD THIS LINE
                            App.ui.showToast("Great job! ", 'success');
                            const checkbox = event?.target;
                            if (checkbox) App.hub.ui.showConfetti(checkbox.getBoundingClientRect().left, checkbox.getBoundingClientRect().top);
                        }
                        taskEl.classList.toggle('completed', !isCurrentlyCompleted);
                        if (shouldRemove) {
                            taskEl.classList.add('exiting');
                            taskEl.addEventListener('animationend', () => { taskEl.remove(); if (document.getElementById('task-list-container')?.childElementCount === 0) App.hub.ui.renderTaskList(); }, { once: true });
                        }
                    },
                    getFilteredTasks() {
                        const today = App.hub.util.getTodayISO();
                        const allTasks = [...App.hub.state.tasks].sort((a, b) => { const pO = { high: 0, medium: 1, low: 2 }; return pO[a.priority] - pO[b.priority]; });
                        switch (this.state.currentFilter) {
                            case 'today': return allTasks.filter(t => t.status === 'pending' && t.due === today);
                            case 'backlog': return allTasks.filter(t => t.status === 'pending' && t.due < today);
                            case 'upcoming': return allTasks.filter(t => t.status === 'pending' && t.due > today).sort((a, b) => new Date(a.due) - new Date(b.due));
                            case 'completed': return allTasks.filter(t => t.status === 'completed').sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt));
                            default: return allTasks;
                        }
                    },
                },
                pomodoro: {
                    state: {
                        worker: null,
                        timerId: null,
                        mode: 'work',
                        isRunning: false,
                        timeLeft: 0,
                        task: null,
                        totalDuration: 0,
                        currentCategory: 'General',
                        sessionCount: 0,
                        zenTitleVisible: true,
                        saveThrottleCounter: 0
                    },
                    init() {
                        try {
                            const workerBlob = new Blob([document.getElementById('pomodoro-worker-script').textContent]);
                            const workerUrl = URL.createObjectURL(workerBlob);
                            this.state.worker = new Worker(workerUrl);

                            this.state.worker.onmessage = (e) => {
                                const { type, timeLeft } = e.data;
                                if (type === 'tick') {
                                    this.state.timeLeft = timeLeft;
                                    if (timeLeft <= 0) {
                                        this.sessionEnd();
                                    } else {
                                        this.state.saveThrottleCounter++;
                                        if (this.state.saveThrottleCounter >= 150) {
                                            this.saveSessionState();
                                            this.state.saveThrottleCounter = 0;
                                        }
                                    }
                                    App.hub.ui.updatePomodoroDisplay();
                                }
                            };
                        } catch (e) {
                            console.error("Failed to initialize Pomodoro worker. Timer may not work in background.", e);
                            App.ui.showToast("Background timer failed to start.", "error");
                        }
                        try {
                            const savedSession = localStorage.getItem('pomodoroSession');
                            if (savedSession) {
                                const sessionData = JSON.parse(savedSession);
                                if (sessionData.timeLeft > 0) {
                                    if (sessionData.task) {
                                        this.state.timeLeft = sessionData.timeLeft;
                                        this.state.mode = sessionData.mode;
                                        this.state.task = sessionData.task;
                                        this.state.totalDuration = sessionData.totalDuration;
                                        this.state.sessionCount = sessionData.sessionCount;
                                        this.state.currentCategory = sessionData.task.category;
                                        this.state.isRunning = false;
                                    } else {
                                        this.resetState(false);
                                        this.state.timeLeft = sessionData.timeLeft;
                                        this.state.totalDuration = this.state.timeLeft;
                                    }
                                    App.hub.ui.updatePomodoroDisplay();
                                    App.ui.showToast('Pomodoro session restored.', 'info');
                                    return;
                                }
                            }
                        } catch (e) {
                            console.error('Could not restore Pomodoro session:', e);
                            localStorage.removeItem('pomodoroSession');
                        }

                        this.resetState(false);
                    },
                    saveSessionState() {
                        if (!this.state.isRunning && this.state.timeLeft <= 0) return;
                        const sessionToSave = {
                            timeLeft: this.state.timeLeft,
                            mode: this.state.mode,
                            task: this.state.task,
                            totalDuration: this.state.totalDuration,
                            sessionCount: this.state.sessionCount,
                            isRunning: this.state.isRunning
                        };
                        localStorage.setItem('pomodoroSession', JSON.stringify(sessionToSave));
                    },
                    async startCycle(task = null) {
                        if (this.state.isRunning) await this.savePartialProgress();
                        this.state.sessionCount = 1; this.state.task = task;
                        this.resetState(false, 'work', App.settings.get('pomodoroWork'));
                        App.ui.showToast(`Starting Pomodoro Session 1 of 4.`, 'info');
                        this.resume();
                    },
                    togglePlayPause() {
                        if (this.state.isRunning) this.pause();
                        else {
                            if (this.state.timeLeft === App.settings.get('pomodoroWork') * 60 && this.state.sessionCount === 0) this.startCycle(this.state.task);
                            else this.resume();
                        }
                    },
                    resume() {
                        if (this.state.isRunning || this.state.timeLeft <= 0) return;
                        this.state.isRunning = true;
                        this.state.worker?.postMessage({ command: 'start', newTimeLeft: this.state.timeLeft });
                        App.hub.ui.updatePomodoroDisplay();
                    },
                    pause() {
                        if (!this.state.isRunning) return;
                        this.state.isRunning = false;
                        this.state.worker?.postMessage({ command: 'pause' });
                        App.hub.ui.updatePomodoroDisplay();
                    },
                    async stopAndReset() {
                        this.state.isRunning = false;
                        this.state.worker?.postMessage({ command: 'stop' });
                        await this.savePartialProgress();
                        this.state.sessionCount = 0;
                        this.resetState(true);
                        localStorage.removeItem('pomodoroSession');
                    },
                    async savePartialProgress() { await this.saveProgress(this.state.totalDuration - this.state.timeLeft); },
                    async saveProgress(elapsedSeconds) {
                        if (this.state.mode !== 'work' || elapsedSeconds < 5) return;
                        const { task } = this.state; const category = task?.category || 'General';
                        const today = App.hub.util.getTodayISO();
                        if (!App.hub.state.pomodoroStats[today]) App.hub.state.pomodoroStats[today] = {};
                        App.hub.state.pomodoroStats[today][category] = (App.hub.state.pomodoroStats[today][category] || 0) + elapsedSeconds;
                        await App.hub.data.savePomodoroStats();
                        if (task) {
                            task.pomodoros = (task.pomodoros || 0) + 1;
                            if (task.pomodoroGoal > 0 && task.pomodoros >= task.pomodoroGoal && task.status === 'pending') {
                                App.hub.tasks.toggleStatus(task.id); App.ui.showToast(`Task "${task.title}" auto-completed!`, 'success');
                                setTimeout(() => this.stopAndReset(), 1000);
                            }
                            await App.hub.data.saveTasks();
                            if (document.getElementById('productivity-modal')) App.hub.ui.renderTaskList();
                        }
                    },
                    resetState(shouldUpdateUI = true, mode = 'work', durationMins = App.settings.get('pomodoroWork')) {
                        this.state.mode = mode; this.state.timeLeft = durationMins * 60; this.state.totalDuration = this.state.timeLeft;
                        if (mode === 'work' && this.state.sessionCount === 0) this.state.task = null;
                        const defaultCategoryName = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                        this.state.currentCategory = this.state.task?.category || defaultCategoryName;
                        if (shouldUpdateUI) App.hub.ui.updatePomodoroDisplay();
                    },
                    async sessionEnd() {
                        this.pause(); const w = App.settings.get('pomodoroWork'), b = App.settings.get('pomodoroBreak');
                        if (this.state.mode === 'work') {
                            await this.saveProgress(this.state.totalDuration);
                            if (this.state.sessionCount > 0 && this.state.sessionCount < 4) {
                                App.ui.showToast(`Session ${this.state.sessionCount} complete! Time for a break.`, 'success', 8000);
                                this.resetState(false, 'break', b); this.resume();
                            } else {
                                App.ui.showToast(`Pomodoro cycle complete! Great work!`, 'success', 10000);
                                this.state.sessionCount = 0; this.resetState(true, 'work', w);
                                localStorage.removeItem('pomodoroSession');
                            }
                        } else {
                            this.state.sessionCount++; App.ui.showToast(`Break over! Starting session ${this.state.sessionCount} of 4.`, 'info', 5000);
                            this.resetState(false, 'work', w); this.resume();
                        }
                    },
                    toggleZenMode() {
                        const c = document.getElementById('zen-mode-container');
                        if (c.innerHTML) c.innerHTML = ''; else App.hub.ui.renderZenMode();
                    },
                    toggleZenTitleVisibility() { this.state.zenTitleVisible = !this.state.zenTitleVisible; App.hub.ui.renderZenMode(true); },
                    async changeTime(work, brk) {
                        await App.settings.set('pomodoroWork', parseInt(work, 10) || 25);
                        await App.settings.set('pomodoroBreak', parseInt(brk, 10) || 5);
                        this.stopAndReset(); App.ui.closeModal(null, true); App.ui.showToast(`Timer settings saved!`, 'success');
                    },
                    getProgressInfo() {
                        const { timeLeft, totalDuration } = this.state;
                        if (totalDuration === 0) return { percentage: 1, colorValue: 'var(--pomo-color-12)' };
                        const p = (totalDuration - timeLeft) / totalDuration;
                        const c = ['--pomo-color-1', '--pomo-color-2', '--pomo-color-3', '--pomo-color-4', '--pomo-color-5', '--pomo-color-6', '--pomo-color-7', '--pomo-color-8', '--pomo-color-9', '--pomo-color-10', '--pomo-color-11', '--pomo-color-12'];
                        return { percentage: p, colorValue: `var(${c[Math.min(c.length - 1, Math.floor(p * c.length))]})` };
                    }
                },

                util: {
                    getTodayISO: () => new Date().toISOString().slice(0, 10),
                    getYesterdayISO: () => new Date(Date.now() - 864e5).toISOString().slice(0, 10),
                    formatTime: (s) => `${String(Math.floor(s / 60)).padStart(2, '0')}:${String(s % 60).padStart(2, '0')}`,
                    formatSecondsToDecimalHours(seconds) { if (!seconds || seconds < 1) return "0.0 hr"; return `${(seconds / 3600).toFixed(1)} hr`; },
                    escapeHtml: (u) => u ? u.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;") : '',
                    parseSimpleDate(d) {
                        if (!d) return null;
                        const cleanDate = d.replace(/[.\/]/g, '-'); const parts = cleanDate.split('-').map(Number);
                        if (parts.length !== 3 || parts.some(isNaN)) return null;
                        let day = parts[0], month = parts[1], year = parts[2]; if (year < 100) year += 2000;
                        if (month < 1 || month > 12 || day < 1 || day > 31) return null;
                        try {
                            const date = new Date(Date.UTC(year, month - 1, day));
                            if (date.getUTCFullYear() !== year || date.getUTCMonth() !== month - 1 || date.getUTCDate() !== day) return null;
                            return date.toISOString().slice(0, 10);
                        } catch (e) { return null; }
                    },
                    getDashboardStats() {
                        const { tasks, pomodoroStats } = App.hub.state;
                        const todayISO = this.getTodayISO(), yesterdayISO = this.getYesterdayISO();
                        let dailyTotals = {}, categoryTotals = {};
                        for (const date in pomodoroStats) {
                            dailyTotals[date] = Object.values(pomodoroStats[date]).reduce((sum, s) => sum + s, 0);
                            for (const category in pomodoroStats[date]) { categoryTotals[category] = (categoryTotals[category] || 0) + pomodoroStats[date][category]; }
                        }
                        const recordedDays = Object.values(dailyTotals).filter(t => t > 0);
                        const totalTime = recordedDays.reduce((a, b) => a + b, 0);
                        const completedTasks = tasks.filter(t => t.status === 'completed');
                        const pendingTasks = tasks.filter(t => t.status === 'pending');
                        const backlog = pendingTasks.filter(t => t.due < todayISO).length;
                        const upcoming = pendingTasks.filter(t => t.due > todayISO).length;

                        return {
                            pomodoro: { today: dailyTotals[todayISO] || 0, yesterday: dailyTotals[yesterdayISO] || 0, average: recordedDays.length ? totalTime / recordedDays.length : 0, best: Math.max(0, ...Object.values(dailyTotals)), categories: Object.entries(categoryTotals).sort((a, b) => b[1] - a[1]), dailyTotals },
                            tasks: { total: tasks.length, completed: completedTasks.length, backlog, upcoming, completedToday: completedTasks.filter(t => t.completedAt?.startsWith(todayISO)).length, completedYesterday: completedTasks.filter(t => t.completedAt?.startsWith(yesterdayISO)).length }
                        };
                    }
                },
                ui: {
                    showProductivityModal() {
                        App.hub.tasks.resetComposer();
                        const modalContainer = document.getElementById('modal-container');
                        if (document.getElementById('productivity-modal')) { this.closeModal(); return; }

                        App.hub.state.elementThatOpenedHub = document.activeElement;
                        // Default to split if undefined, or keep existing session state
                        if (!App.hub.state.hubViewMode) App.hub.state.hubViewMode = 'split';
                        const currentMode = App.hub.state.hubViewMode;

                        modalContainer.innerHTML = `<div class="modal-backdrop" id="modal-backdrop">
                        <div id="productivity-modal" class="modal-content ui-card productivity-modal mode-${currentMode}">
                            <div class="task-filters"></div>
                            <div class="task-area">
                                <div id="task-composer-container"></div>
                                <div id="task-list-container"></div>
                            </div>
                            
                            <!-- NEW DYNAMIC SEPARATOR -->
                            <div class="hub-separator" id="hub-separator-btn" title="Click to cycle views">
                                <!-- Minimalist: No inner handle -->
                            </div>

                            <div class="pomodoro-section"></div>
                        </div>
                    </div>`;
                        document.addEventListener('keydown', App.events.handleProductivityHubKeyDown, true);
                        document.getElementById('modal-backdrop').addEventListener('click', (e) => this.closeModal(e));
                        document.getElementById('productivity-modal').addEventListener('click', (e) => {
                            const startPomoButton = e.target.closest('[data-action="start-pomodoro"]');
                            const deleteTaskButton = e.target.closest('[data-action="delete-task"]');
                            if (startPomoButton) { const taskId = startPomoButton.dataset.taskId; const task = App.hub.state.tasks.find(t => t.id === taskId); App.hub.pomodoro.startCycle(task); }
                            else if (deleteTaskButton) { const taskId = deleteTaskButton.dataset.taskId; App.hub.tasks.deleteTask(taskId); }
                        });

                        // Separator Interaction
                        document.getElementById('hub-separator-btn').addEventListener('click', () => {
                            this.toggleHubViewMode();
                        });

                        this.renderTaskComposer(); this.renderTaskFilters(); this.renderTaskList(); this.updatePomodoroDisplay();

                        // Focus logic depending on mode
                        if (currentMode !== 'pomo') {
                            document.getElementById('composer-title-input')?.focus();
                        }
                    },

                    toggleHubViewMode() {
                        const states = ['split', 'tasks', 'pomo'];
                        const currentState = App.hub.state.hubViewMode || 'split';
                        const nextState = states[(states.indexOf(currentState) + 1) % states.length];

                        App.hub.state.hubViewMode = nextState;
                        const modal = document.getElementById('productivity-modal');
                        if (modal) {
                            modal.classList.remove('mode-split', 'mode-tasks', 'mode-pomo');
                            modal.classList.add(`mode-${nextState}`);

                            // Re-render components if needed or adjust focus
                            if (nextState === 'pomo') {
                                // Maybe focus something in pomo?
                            } else {
                                setTimeout(() => document.getElementById('composer-title-input')?.focus(), 50);
                            }
                        }
                        // Optional: Save this preference if we wanted to persist across reloads, 
                        // but user request implies just session based or "return to current view"
                    },


                    renderTaskComposer() {
                        const c = document.getElementById('task-composer-container');
                        if (!c) return;

                        const { title, category, priority, due, pomodoroGoal } = App.hub.tasks.state.composer;
                        const formattedDate = new Date(due + 'T00:00:00Z').toLocaleDateString('en-GB', { day: 'numeric', month: '2-digit', year: '2-digit', timeZone: 'UTC' }).replace(/\//g, '-');

                        const categoryObjects = App.settings.get('userCategories');
                        const categoryOptionsHTML = categoryObjects.map(catObj =>
                            `<option value="${catObj.name}" ${catObj.name === category ? 'selected' : ''}>${App.util.getCategoryDisplayName(catObj.name)}</option>`
                        ).join('');


                        c.innerHTML = `
                        <div class="task-composer">
                            <div class="composer-input-row">
                                <input type="text" id="composer-title-input" class="text-input" placeholder="Add a new task..." value="${App.util.escapeHtml(title)}">
                                <button class="btn btn-primary" id="add-task-btn" title="Add Task">+</button>
                            </div>
                            <div class="composer-actions-row">
                                <div class="composer-meta-buttons">
                                    <input type="text" id="composer-date-input" value="${formattedDate}" title="Due Date (dd-mm-yy)">
                                    <button id="priority-btn" class="priority-btn ${priority}" title="Cycle Priority">${priority}</button>
                                    <select id="category-select">${categoryOptionsHTML}</select>
                                    <button id="pomo-goal-btn" title="Set Pomodoro Goal (Left-click to increment, Right-click to reset)">
                                        <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16"><path d="M8 16a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm0-1a5 5 0 1 1 0-10 5 5 0 0 1 0 10Z"/><path d="M8 4.5a.5.5 0 0 0-1 0V7H6.5a.5.5 0 0 0 0 1H7v2.5a.5.5 0 0 0 1 0V8h1.5a.5.5 0 0 0 0-1H8V4.5Z"/></svg>
                                        <span>${pomodoroGoal > 0 ? pomodoroGoal : ''}</span>
                                    </button>
                                </div>
                            </div>
                        </div>`;

                        // Re-attach all event listeners to ensure functionality
                        document.getElementById('composer-title-input').addEventListener('input', e => {
                            App.hub.tasks.state.composer.title = e.target.value;
                        });
                        document.getElementById('add-task-btn').addEventListener('click', () => App.hub.tasks.add());
                        document.getElementById('composer-date-input').addEventListener('change', e => {
                            const newDate = App.hub.util.parseSimpleDate(e.target.value);
                            if (newDate) {
                                App.hub.tasks.state.composer.due = newDate;
                                this.renderTaskComposer(); // Re-render to reflect state
                            } else {
                                App.ui.showToast('Invalid date format. Use dd-mm-yy.', 'error');
                                e.target.value = formattedDate;
                            }
                        });
                        document.getElementById('priority-btn').addEventListener('click', () => {
                            const priorities = ['low', 'medium', 'high'];
                            App.hub.tasks.state.composer.priority = priorities[(priorities.indexOf(App.hub.tasks.state.composer.priority) + 1) % 3];
                            this.renderTaskComposer();
                        });
                        document.getElementById('category-select').addEventListener('change', (e) => {
                            App.hub.tasks.state.composer.category = e.target.value;
                        });
                        const pomoGoalBtn = document.getElementById('pomo-goal-btn');
                        pomoGoalBtn.addEventListener('click', () => {
                            App.hub.tasks.state.composer.pomodoroGoal = (App.hub.tasks.state.composer.pomodoroGoal + 1) % 10;
                            this.renderTaskComposer();
                        });
                        pomoGoalBtn.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            App.hub.tasks.state.composer.pomodoroGoal = 0;
                            this.renderTaskComposer();
                        });
                    },

                    renderTaskList() {
                        const c = document.getElementById('task-list-container'); if (!c) return;
                        const tasks = App.hub.tasks.getFilteredTasks(); const today = App.hub.util.getTodayISO();
                        if (tasks.length === 0) { c.innerHTML = `<p style="text-align: center; color: var(--text-secondary); padding: 2rem;">No tasks here. Great job!</p>`; return; }
                        c.innerHTML = tasks.map(t => {
                            const checkboxHTML = `<label class="custom-checkbox-container"><input type="checkbox" onchange="App.hub.tasks.toggleStatus('${t.id}', event)" ${t.status === 'completed' ? 'checked' : ''}><span class="custom-checkbox"></span></label>`;

                            // UPDATED: Logic to get category color
                            const categoryObj = App.settings.get('userCategories').find(c => c.name === t.category) || { name: t.category, colorIndex: 0 };
                            const categoryPillHTML = `<div class="category-pill" style="background-color: ${App.util.getCategoryColor(categoryObj.colorIndex)};">${App.util.getCategoryDisplayName(categoryObj.name)}</div>`;
                            return `<div class="task-item ${t.status === 'completed' ? 'completed' : ''} ${t.due < today && t.status === 'pending' ? 'is-backlog' : ''}" data-id="${t.id}" data-priority="${t.priority}">${checkboxHTML}<span class="task-title" title="${App.hub.util.escapeHtml(t.title)}">${App.hub.util.escapeHtml(t.title)}</span><div class="task-meta">${t.pomodoroGoal > 0 ? `<div class="pomo-counter-display" title="Pomodoro Progress"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16"><path d="M8 16a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm0-1a5 5 0 1 1 0-10 5 5 0 0 1 0 10Z"/><path d="M8 4.5a.5.5 0 0 0-1 0V7H6.5a.5.5 0 0 0 0 1H7v2.5a.5.5 0 0 0 1 0V8h1.5a.5.5 0 0 0 0-1H8V4.5Z"/></svg> <span>${t.pomodoros || 0}/${t.pomodoroGoal}</span></div>` : (t.pomodoros > 0 ? `<div class="pomo-counter-display" title="Pomodoros Completed"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16"><path d="M8 16a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm0-1a5 5 0 1 1 0-10 5 5 0 0 1 0 10Z"/><path d="M8 4.5a.5.5 0 0 0-1 0V7H6.5a.5.5 0 0 0 0 1H7v2.5a.5.5 0 0 0 1 0V8h1.5a.5.5 0 0 0 0-1H8V4.5Z"/></svg> <span>${t.pomodoros}</span></div>` : '')}${categoryPillHTML}<span class="due-date ${t.due < today && t.status === 'pending' ? 'overdue' : ''}">${new Date(t.due + 'T00:00:00Z').toLocaleDateString(undefined, { month: 'short', day: 'numeric', timeZone: 'UTC' })}</span><button class="btn-icon" data-action="start-pomodoro" data-task-id="${t.id}" title="Start Pomodoro Cycle"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445z"/></svg></button><button class="btn-icon btn-danger" data-action="delete-task" data-task-id="${t.id}" title="Delete Task"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg></button></div></div>`;
                        }).join('');
                    },

                    renderTaskFilters() {
                        const c = document.querySelector('.task-filters'); if (!c) return;
                        const f = { today: 'Due Today', backlog: 'Backlog', upcoming: 'Upcoming', completed: 'Completed', all: 'All Tasks' };
                        c.innerHTML = Object.entries(f).map(([k, l]) => `<button class="btn btn-secondary ${App.hub.tasks.state.currentFilter === k ? 'active' : ''}" onclick="App.hub.tasks.state.currentFilter='${k}'; App.hub.ui.renderTaskFilters(); App.hub.ui.renderTaskList();">${l}</button>`).join('');
                    },
                    updateTodoBadge() {
                        const count = App.hub.state.tasks.filter(t => t.status === 'pending' && t.due === App.hub.util.getTodayISO()).length;
                        const b = document.getElementById('todo-badge'); if (count > 0) { b.textContent = count; b.style.display = 'flex'; } else { b.style.display = 'none'; }
                    },

                    updatePomodoroDisplay() {
                        const c = document.querySelector('.pomodoro-section'); if (!c) return;
                        const { isRunning, timeLeft, task, currentCategory, sessionCount, mode } = App.hub.pomodoro.state;
                        const { percentage, colorValue } = App.hub.pomodoro.getProgressInfo();
                        const p = percentage * 4;

                        let pillIndicator = '';
                        if (mode === 'break') {
                            pillIndicator = `<div class="break-pill">Break</div>`;
                        } else if (sessionCount > 0) {
                            pillIndicator = `<div class="cycle-pill" data-cycle="${sessionCount}">${sessionCount} / 4</div>`;
                        }

                        // NEW: Find the category object to get its color
                        const categoryObj = App.settings.get('userCategories').find(cat => cat.name === currentCategory) || { name: currentCategory, colorIndex: 0 };
                        const backgroundColor = App.util.getCategoryColor(categoryObj.colorIndex);
                        const categoryPillHTML = `<div class="category-pill" style="background-color: ${backgroundColor};">${App.util.getCategoryDisplayName(currentCategory)}</div>`;

                        c.innerHTML = `
                        <div class="pomodoro-display">
                            <div class="pomodoro-progress-frame">
                                <div class="progress-segment progress-top" style="width:${Math.min(1, p) * 100}%;"></div>
                                <div class="progress-segment progress-right" style="height:${p > 1 ? Math.min(1, p - 1) * 100 : 0}%;"></div>
                                <div class="progress-segment progress-bottom" style="width:${p > 2 ? Math.min(1, p - 2) * 100 : 0}%;"></div>
                                <div class="progress-segment progress-left" style="height:${p > 3 ? Math.min(1, p - 3) * 100 : 0}%;"></div>
                            </div>
                            <div class="pomodoro-time-display">${App.hub.util.formatTime(timeLeft)}</div>
                            <div class="pomodoro-task-title" title="${App.hub.util.escapeHtml(task?.title || 'Focus Session')}" style="color: ${colorValue};">${App.hub.util.escapeHtml(task?.title || 'Focus Session')}</div>
                            <div class="pomodoro-meta">${pillIndicator}${categoryPillHTML}</div>
                        </div>
                        <div class="pomodoro-controls">
                            <button class="btn-icon" onclick="App.hub.pomodoro.stopAndReset()" title="Stop & Reset"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/></svg></button>
                            <button class="btn-icon" style="transform: scale(1.4);" onclick="App.hub.pomodoro.togglePlayPause()" title="${isRunning ? 'Pause' : 'Play / Start Cycle'}">${isRunning ? '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>'}</button>
                            <button class="btn-icon" onclick="App.hub.ui.showPomodoroSettings()" title="Settings"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311a1.464 1.464 0 0 1 0 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105 0l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.31-.17a1.464 1.464 0 0 1 2.105-.872l-.1-.34c.413-1.4 2.397-1.4 2.81 0l.1.34a1.464 1.464 0 0 1 2.105.872l.31.17c1.283.698-2.686-.705-1.987-1.987l-.169-.311a1.464 1.464 0 0 1 0-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105 0l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.31.17a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/></svg></button>
                            <button class="btn-icon" onclick="App.hub.pomodoro.toggleZenMode()" title="Zen Mode (Coffee Break)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1 12.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5zM12.5 0a.5.5 0 0 1 .5.5v2h-1V.5a.5.5 0 0 1 .5-.5zm-2 0a.5.5 0 0 1 .5.5v2h-1V.5a.5.5 0 0 1 .5-.5zm-2 0a.5.5 0 0 1 .5.5v2h-1V.5a.5.5 0 0 1 .5-.5zm-2 0a.5.5 0 0 1 .5.5v2h-1V.5a.5.5 0 0 1 .5-.5z"/><path fill-rule="evenodd" d="M.5 4a.5.5 0 0 1 .5-.5h14a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5-.5h-14a.5.5 0 0 1-.5-.5v-8zM1 4.5v7h14v-7H1z"/></svg></button>
                        </div>
                    `;
                        document.querySelectorAll('.progress-segment').forEach(el => { el.style.backgroundColor = colorValue; });
                        if (document.getElementById('zen-timer-display')) this.renderZenMode(true);
                    },
                    showPomodoroSettings() {
                        const modal = document.createElement('div'); modal.id = 'pomodoro-settings-modal'; modal.innerHTML = `<div class="modal-backdrop" id="settings-backdrop"><div id="pomodoro-settings-popup" class="ui-card"><h3>Timer Settings</h3><label>Work Duration (minutes)</label><input type="number" id="pomo-work" class="text-input" value="${App.settings.get('pomodoroWork')}"><label>Break Duration (minutes)</label><input type="number" id="pomo-break" class="text-input" value="${App.settings.get('pomodoroBreak')}"><div style="display:flex; justify-content:flex-end; gap:8px; margin-top:1rem;"><button class="btn btn-secondary" id="settings-cancel">Cancel</button><button class="btn btn-primary" id="settings-save">Save</button></div></div></div>`;
                        document.getElementById('modal-container').appendChild(modal);
                        document.getElementById('settings-backdrop').addEventListener('click', (e) => { if (e.target === e.currentTarget) modal.remove() });
                        document.getElementById('settings-cancel').addEventListener('click', () => modal.remove());
                        document.getElementById('settings-save').addEventListener('click', () => App.hub.pomodoro.changeTime(document.getElementById('pomo-work').value, document.getElementById('pomo-break').value));
                    },

                    renderZenMode(isUpdate = false) {
                        const container = document.getElementById('zen-mode-container');
                        const { isRunning, timeLeft, task, currentCategory, sessionCount, mode, zenTitleVisible } = App.hub.pomodoro.state;
                        const { percentage, colorValue } = App.hub.pomodoro.getProgressInfo();
                        const p = percentage * 4;
                        const currentTaskTitle = task?.title || 'Focus Session';

                        // NEW: Find the category object to get its color
                        const categoryObj = App.settings.get('userCategories').find(cat => cat.name === currentCategory) || { name: currentCategory, colorIndex: 0 };
                        const backgroundColor = App.util.getCategoryColor(categoryObj.colorIndex);
                        const categoryPillHTML = `<div class="category-pill" style="background-color: ${backgroundColor};">${App.util.getCategoryDisplayName(currentCategory)}</div>`;

                        if (isUpdate) {
                            document.getElementById('zen-timer-display').textContent = App.hub.util.formatTime(timeLeft);
                            const titleEl = document.getElementById('zen-task-title'), metaContainer = document.querySelector('.zen-meta-container');
                            titleEl.classList.toggle('hidden', !zenTitleVisible);
                            metaContainer.classList.toggle('hidden', !zenTitleVisible);
                            titleEl.textContent = App.hub.util.escapeHtml(currentTaskTitle);
                            titleEl.style.color = colorValue;
                            document.getElementById('zen-pills-row').innerHTML = `${mode === 'break' ? `<div class="break-pill">Break</div>` : sessionCount > 0 ? `<div class="cycle-pill" data-cycle="${sessionCount}">${sessionCount} / 4</div>` : ''}${categoryPillHTML}`;
                            const frame = document.querySelector('.zen-progress-frame');
                            if (frame) {
                                frame.querySelector('.progress-top').style.width = `${Math.min(1, p) * 100}%`;
                                frame.querySelector('.progress-right').style.height = `${p > 1 ? Math.min(1, p - 1) * 100 : 0}%`;
                                frame.querySelector('.progress-bottom').style.width = `${p > 2 ? Math.min(1, p - 2) * 100 : 0}%`;
                                frame.querySelector('.progress-left').style.height = `${p > 3 ? Math.min(1, p - 3) * 100 : 0}%`;
                                frame.querySelectorAll('.progress-segment').forEach(el => el.style.backgroundColor = colorValue);
                            }
                            const playPauseBtn = document.getElementById('zen-play-pause-btn');
                            if (playPauseBtn) {
                                playPauseBtn.title = isRunning ? 'Pause' : 'Play';
                                playPauseBtn.innerHTML = isRunning ? '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>';
                            }
                            const visibilityBtn = document.getElementById('zen-visibility-btn');
                            if (visibilityBtn) {
                                visibilityBtn.title = zenTitleVisible ? 'Hide Details' : 'Show Details';
                                visibilityBtn.innerHTML = zenTitleVisible ? App.util.icons.chevronUp : App.util.icons.chevronDown;
                            }
                            return;
                        }
                        container.innerHTML = `
                        <div class="zen-mode-overlay">
                            <div class="zen-progress-frame pomodoro-progress-frame">
                                <div class="progress-segment progress-top"></div>
                                <div class="progress-segment progress-right"></div>
                                <div class="progress-segment progress-bottom"></div>
                                <div class="progress-segment progress-left"></div>
                            </div>
                            <div class="zen-meta-container ${!zenTitleVisible ? 'hidden' : ''}">
                                <div id="zen-pills-row" class="zen-pills-row"></div>
                            </div>
                            <div id="zen-timer-display" class="zen-timer"></div>
                            <div id="zen-task-title" class="zen-task-title ${!zenTitleVisible ? 'hidden' : ''}"></div>
                            <div class="zen-bottom-controls">
                                <button class="btn-icon" onclick="App.hub.pomodoro.stopAndReset()" title="Stop & Reset">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/></svg>
                                </button>
                                <button id="zen-play-pause-btn" class="btn-icon" style="transform: scale(1.5);" onclick="App.hub.pomodoro.togglePlayPause()"></button>
                                <button id="zen-visibility-btn" class="btn-icon" onclick="App.hub.pomodoro.toggleZenTitleVisibility()"></button>
                                <button class="btn-icon" onclick="App.hub.pomodoro.toggleZenMode()" title="Exit Zen Mode">${App.util.icons.close}</button>
                            </div>
                        </div>`;
                        this.renderZenMode(true);
                    },
                    showConfetti(x, y) {
                        const c = document.getElementById('confetti-toast-container'); c.style.left = `${x}px`; c.style.top = `${y}px`;
                        for (let i = 0; i < 30; i++) { const el = document.createElement('div'); el.className = 'confetti'; el.style.left = `${Math.random() * 80 - 40}px`; el.style.top = `${Math.random() * 80 - 40}px`; el.style.backgroundColor = `hsl(${Math.random() * 360}, 90%, 65%)`; el.style.animationDelay = `${Math.random() * 0.2}s`; c.appendChild(el); setTimeout(() => el.remove(), 1000); }
                    },
                    closeModal(event, isPopup = false) {
                        if (isPopup) { document.getElementById('pomodoro-settings-modal')?.remove(); return; }
                        if (event && event.target !== event.currentTarget) return;
                        document.body.classList.remove('hub-open'); // Ensures header reappears
                        document.getElementById('modal-container').innerHTML = '';
                        document.removeEventListener('keydown', App.events.handleProductivityHubKeyDown, true);
                    },
                }
            },


            // ==========================================================================
            // 3.15. COMMAND PALETTE MODULE (v2)
            // ==========================================================================
            commandPalette: {
                state: {
                    textileColors: [
                        // 9 Premium Color Styles: Lavender, Mint, Sun, Rose, Sky, Amber, Stone, Crimson, Indigo
                        '1', '2', '3', '4', '5', '6', '7', '8', '9'
                    ],
                    isOpen: false,
                    commands: [],
                    filteredResults: [],
                    selectedIndex: 0,
                    fuse: {
                        commands: null,
                        links: null,
                        categories: null,
                        tags: null,
                        emojis: null,
                        icons: null,
                    },
                    mode: 'commands',
                    emojiData: [],
                    iconData: [],
                    isFetching: false,
                    highlightOptions: [
                        { id: 'yellow', title: 'Yellow Highlight', desc: 'Standard yellow background', icon: '', className: 'highlight-1' },
                        { id: 'green', title: 'Green Highlight', desc: 'Soothing green background', icon: '', className: 'highlight-2' },
                        { id: 'blue', title: 'Blue Highlight', desc: 'Cool blue background', icon: '', className: 'highlight-3' },
                        { id: 'red', title: 'Red Highlight', desc: 'Urgent red background', icon: '', className: 'highlight-4' },
                        { id: 'purple', title: 'Purple Highlight', desc: 'Royal purple background', icon: '', className: 'highlight-5' },
                        { id: 'cyan', title: 'Cyan Highlight', desc: 'Light cyan background', icon: '', className: 'highlight-6' },
                        { id: '1', title: 'Red Text', desc: 'Apply red text color', icon: 'T', className: 'text-red' },
                        { id: '2', title: 'Green Text', desc: 'Apply green text color', icon: 'T', className: 'text-green' },
                        { id: '3', title: 'Blue Text', desc: 'Apply blue text color', icon: 'T', className: 'text-blue' },
                        { id: 'clear', title: 'Clear Highlight', desc: 'Remove all block highlights', icon: '', className: '' },
                    ],
                    // FIX: State for debouncing API calls and storing the highlight target
                    debounceTimeout: null,
                    targetBlockElement: null,
                },
                els: {
                    palette: null,
                    input: null,
                    list: null,
                },

                //  COMPREHENSIVE EMOJI GENERATOR - 2000+ emojis with smart names & keywords!
                _generateEmojiData() {
                    const emojis = [];

                    // Smart emoji naming based on Unicode codepoint ranges
                    const getEmojiName = (code, rangeStart, rangeEnd, baseName) => {
                        const offset = code - rangeStart;
                        const totalInRange = rangeEnd - rangeStart + 1;

                        // Return descriptive name with variation number if range is large
                        if (totalInRange > 20) {
                            return `${baseName} ${offset + 1}`;
                        }
                        return baseName;
                    };

                    // Comprehensive Unicode emoji ranges with names and searchable keywords
                    const ranges = [
                        // === SMILEYS & PEOPLE ===
                        { start: 0x1F600, end: 0x1F64F, name: 'Smiley', keywords: 'face emotion smile happy sad angry laugh cry wink love kiss heart eyes grin beam joy tears blush cool sunglasses smirk worried scared surprised shocked thinking wondering neutral expressionless unamused rolling laughing rofl halo angel devil demon clown cowboy nerd monocle disgusted vomit sneeze sick mask thermometer bandage sleeping zzz dreaming yawn tired sleepy relieved pleased satisfied pensive thoughtful frowning disappointed confused slight anxious nervous stressed sweat drooling money mouth zipper no speak evil hear see monkey' },

                        // === GESTURES & BODY PARTS ===
                        { start: 0x1F44B, end: 0x1F4FF, name: 'Hand Gesture', keywords: 'hand wave hello goodbye bye thumbs up down like dislike ok okay good bad yes no stop palm raised high five pray thank namaste clap applause muscle strong flex bicep punch fist bump point finger left right up down victory peace sign horn love rock metal writing write pen pencil nail polish paint selfie ear nose eye eyes brain tooth bone leg foot footprint lips kiss mouth tongue' },

                        // === ANIMALS & NATURE ===
                        { start: 0x1F400, end: 0x1F43F, name: 'Animal', keywords: 'animal pet wild zoo farm cute rat mouse hamster rabbit bunny bear panda polar koala tiger lion cat kitty kitten dog puppy pup wolf fox raccoon monkey gorilla orangutan chimp whale dolphin fish shark octopus shell snail butterfly bug bee ant beetle ladybug cricket spider web scorpion mosquito fly worm microbe bacteria virus' },
                        { start: 0x1F980, end: 0x1F9AE, name: 'Creature', keywords: 'animal crab lobster shrimp squid oyster bird dove eagle duck swan goose peacock parrot owl flamingo penguin bat dinosaur t-rex dragon unicorn horse zebra deer giraffe elephant rhino hippo kangaroo badger turkey chicken rooster hatching chick baby nest egg shark crocodile lizard snake turtle frog hedgehog llama alpaca camel dromedary sloth otter skunk' },

                        // === FOOD & DRINK ===
                        { start: 0x1F32D, end: 0x1F37F, name: 'Food', keywords: 'food eat meal breakfast lunch dinner snack fast burger pizza hot dog sandwich taco burrito wrap salad pasta spaghetti ramen noodle soup bowl rice curry stew meat chicken poultry turkey bacon egg cooking fried pancake waffle cheese bread croissant baguette pretzel bagel cookie cake birthday cupcake pie chocolate candy lollipop caramel honey apple fruit berry strawberry grape melon watermelon lemon lime orange tangerine banana pineapple kiwi coconut avocado eggplant potato carrot corn pepper cucumber broccoli leafy green peanut chestnut coffee tea cup mug beer wine champagne cocktail drink beverage juice milk baby bottle water sake martini tumbler glass tropical cheers toast' },
                        { start: 0x1F950, end: 0x1F9FF, name: 'Snack', keywords: 'food croissant avocado cucumber broccoli peanuts kiwi pancakes dumpling fortune cookie takeout bento box crab lobster shrimp squid oyster soft ice cream donut birthday cake cupcake pie chocolate candy lollipop custard honey jar milk glass baby bottle tea coffee beverage hot drink mate bagel salt pretzel popcorn butter waffle falafel egg fried cooking bacon cheese wedge moon cake red envelope chopsticks bowl spoon fork knife amphora jar box cup straw bubble mate teacup wine cocktail tropical beer mugs clinking glasses tumbler pouring liquid' },

                        // === ACTIVITIES & SPORTS ===
                        { start: 0x1F3A0, end: 0x1F3FF, name: 'Activity', keywords: 'activity sport game play fun entertainment carnival circus carousel ferris wheel roller coaster fishing pole fish video game controller joystick dice slot machine jigsaw puzzle teddy bear pinata nesting dolls balloon party popper confetti ribbon wrapped gift christmas present birthday bow soccer football basketball baseball softball tennis volleyball rugby golf cricket hockey lacrosse ping pong badminton boxing glove martial arts karate judo wrestling fencing goal net award medal trophy sports champion win first second third podium running runner race track athlete sprint marathon swimming pool swim dive surf skiing skier snowboard ice skate sled curling archery arrow darts yo-yo kite parachute skateboard roller inline artistic gymnast lift weight lifter bicycle bike mountain road shirt play button pause stop record eject shuffle repeat loop arrows musical note music song tune melody rhythm beat drum guitar piano keyboard violin trumpet saxophone clue magnifying glass detective spy investigate search find magnify inspect examine movie film cinema camera video photo picture image snapshot flash lens tripod clapper board director action cut scene theater stage curtain performing arts ballet dance disco ball art palette artist paint brush crayon sketching drawing coloring creative design frame painting sculpture statue museum gallery exhibition masterpiece microphone singer karaoke perform concert headphone speaker audio sound volume loud quiet mute hear listen stereo radio broadcast antenna satellite receiver transmitter signal wave frequency channel ticket admission event show performance magic top hat rabbit trick illusion sleight hand celebration festival fair amusement park ride attraction thrill excitement joy happiness celebration achievement success victory triumph accomplishment goal objective target aim focus determination motivation inspiration aspiration dream hope wish desire want need love passion enthusiasm thrill adventure explore discovery journey travel voyage trip vacation holiday getaway escape relaxation leisure rest break recharge rejuvenate refresh renew revive restore recover heal mend fix repair improve enhance upgrade develop grow evolve progress advance forward onward upward rise ascent climb scale conquer achieve accomplish succeed prevail champion best top excellent outstanding remarkable exceptional extraordinary magnificent superb splendid wonderful marvelous fabulous terrific great good nice pleasant enjoyable delightful charming lovely beautiful pretty attractive gorgeous stunning breathtaking spectacular amazing awesome incredible unbelievable astonishing astounding surprising shocking startling unexpected sudden abrupt instant immediate quick fast rapid swift speedy hasty hurried rushed urgent pressing critical crucial vital essential important significant major key primary main principal chief leading foremost paramount supreme ultimate final conclusive definitive decisive determinative authoritative commanding controlling dominant prevailing ruling governing reigning sovereign' },

                        // === TRAVEL & PLACES ===
                        { start: 0x1F680, end: 0x1F6FF, name: 'Transport', keywords: 'travel place transport vehicle trip journey vacation car auto automobile taxi cab police ambulance fire truck bus trolley tram train railway locomotive metro subway station rail track monorail mountain aerial tramway suspension cable helicopter airplane plane flight fly aviation airport departure arrival takeoff landing pilot airline jet rocket space satellite astronaut alien ufo flying saucer ship boat ferry sailboat speedboat yacht cruise sailing anchor port harbor dock marina water sea ocean wave beach coast shore sand island tropical paradise destination getaway escape adventure explore discover voyage expedition tour sightseeing landmark monument building architecture house home city town village urban rural countryside landscape scenery view panorama horizon skyline cityscape street road highway freeway motorway boulevard avenue lane alley path trail walkway sidewalk pavement bridge tunnel viaduct overpass underpass intersection junction crossroad roundabout traffic light signal sign stop yield caution warning danger hazard construction work zone area region district neighborhood community locality vicinity proximity near close adjacent neighboring surrounding' },

                        // === OBJECTS & TOOLS ===
                        { start: 0x1F4A0, end: 0x1F4FF, name: 'Object', keywords: 'object tool item thing stuff equipment gear apparatus device instrument gadget contraption machine mechanism widget gizmo diamond gem jewel precious stone crystal sparkle shine glitter gleam glisten shimmer twinkle brilliant dazzling radiant luminous bright light illumination glow lamp lantern candle torch flashlight beam ray shaft streak flash flare burst explosion blast boom bang crash smash shatter break fracture crack split rupture tear rip cut slash gash wound injury hurt pain ache throb sting burn scorch char singe sear scald blister peel skin flesh tissue muscle tendon ligament bone skeleton skull cranium brain mind intellect intelligence wisdom knowledge understanding comprehension awareness consciousness perception cognition thought thinking reasoning logic rationality sense sensibility judgment discernment discrimination taste refinement culture cultivation education learning study scholarship erudition literacy proficiency competence skill ability capability capacity faculty talent gift aptitude knack flair genius brilliance excellence mastery expertise professionalism craft craftsmanship artistry workmanship quality standard grade level degree measure extent magnitude size dimension proportion scale ratio rate speed velocity pace tempo rhythm beat pulse throb pulsation vibration oscillation fluctuation variation change modification alteration adjustment adaptation transformation conversion' },

                        // === SYMBOLS & ICONS ===
                        { start: 0x2600, end: 0x26FF, name: 'Symbol', keywords: 'symbol icon sign mark emblem logo badge seal stamp crest insignia flag banner pennant standard colors ensign holy sacred religious spiritual divine celestial heavenly supernatural mystical magical enchanted charmed blessed pure innocent virgin chaste modest humble meek gentle mild soft tender delicate fragile frail weak feeble infirm sickly ill unwell ailing diseased infected contaminated polluted tainted corrupted spoiled rotten decayed decomposed putrid foul nasty disgusting revolting repulsive repugnant offensive objectionable unpleasant disagreeable distasteful unsavory unpalatable inedible uneatable toxic poisonous venomous deadly lethal fatal mortal terminal incurable hopeless desperate dire critical severe serious grave solemn somber sad sorrowful mournful melancholy gloomy dismal dreary bleak dark dim shadowy murky obscure vague unclear ambiguous uncertain doubtful questionable dubious suspicious fishy shady dodgy iffy sketchy unreliable untrustworthy dishonest deceitful deceptive misleading fraudulent fake false counterfeit bogus phony sham pretend mock imitation replica copy duplicate clone facsimile reproduction representation depiction portrayal illustration drawing picture image likeness resemblance similarity correspondence analogy parallel comparison contrast difference distinction variation diversity variety assortment selection range array collection set group cluster bunch batch lot load heap pile stack mound mountain hill summit peak pinnacle apex zenith acme climax culmination height top crest crown cap head brain mind intellect sun moon star cloud rain weather storm thunder lightning bolt electricity power energy force strength might vigor vitality fire flame hot warm cool cold freeze ice snow winter summer spring autumn fall season time period era age epoch cycle circle eternal infinity universe cosmos galaxy planet earth world globe sphere ball round circular oval elliptical curved bent twisted spiral helix coil loop ring band hoop wheel disk disc plate platter tray dish bowl cup mug glass tumbler goblet chalice grail vessel container receptacle holder box chest trunk case crate barrel drum cylinder tube pipe hose conduit duct channel passage corridor hallway hall aisle gangway walkway path trail track route way road street avenue boulevard lane alley court yard garden park plaza square marketplace bazaar souk mall center arcade gallery colonnade portico porch veranda balcony terrace deck patio courtyard atrium foyer lobby entrance entry doorway portal gate gateway arch archway threshold sill lintel jamb frame border edge margin rim brim lip brink verge periphery boundary frontier limit confine bound checkpoint barrier fence wall partition screen divider separator hedge row line queue column file rank tier layer stratum level story floor ceiling roof rafters beams joists studs posts pillars columns supports foundations footings base bottom underneath below under beneath down low lower depth deep abyss chasm gorge canyon ravine gulch gully valley dell hollow basin depression dip indent notch nick scratch scar blemish flaw defect fault imperfection' },
                        { start: 0x2700, end: 0x27BF, name: 'Dingbat', keywords: 'symbol dingbat ornament decoration embellishment adornment trim trimming edging border fringe ribbon bow knot tie band strap belt sash girdle waistband cincture zone area region district sector quarter ward precinct parish township municipality county province state territory dominion realm kingdom empire nation country land homeland fatherland motherland native soil ground earth dirt dust powder grain particle speck mote fleck dot spot point mark sign token indication evidence proof testimony witness attestation certification verification validation confirmation corroboration substantiation authentication legitimation accreditation endorsement approval sanction authorization permission consent assent agreement acceptance acknowledgment recognition admission concession grant allowance dispensation exemption exception exclusion omission oversight neglect disregard ignorance unawareness unconsciousness obliviousness insensibility numbness paralysis immobility immobilization fixation stabilization consolidation solidification crystallization fossilization petrification ossification calcification hardening stiffening rigidity inflexibility stubbornness obstinacy determination resolution resolve commitment dedication devotion loyalty allegiance fidelity faithfulness constancy steadfastness reliability dependability trustworthiness honesty integrity probity rectitude righteousness virtue morality ethics principles values ideals standards benchmarks criteria measures tests trials examinations assessments evaluations appraisals judgments verdicts decisions rulings pronouncements declarations proclamations announcements notifications communications messages dispatches bulletins advisories alerts warnings cautions admonitions reprimands rebukes reproaches criticisms condemnations denunciations censures' },

                        // === HEARTS & EMOTIONS ===
                        { start: 0x2763, end: 0x2764, name: 'Heart', keywords: 'heart love romance passion affection emotion feeling sentiment care compassion empathy sympathy kindness tenderness warmth fondness attachment devotion adoration infatuation crush sweetheart lover beloved darling dear honey sweet valentine wedding marriage engagement relationship couple partnership bond connection tie link union togetherness closeness intimacy courtship dating flirting attraction chemistry spark flame fire burning desire longing yearning craving hunger thirst want need wish hope dream fantasy imagination vision aspiration ambition goal objective target aim purpose mission quest search pursuit hunt chase follow track trail stalk shadow tail dog hound pursue seek look find discover uncover reveal expose disclose divulge betray tell confess admit acknowledge accept recognize realize understand comprehend grasp fathom appreciate value treasure cherish prize esteem respect honor revere worship adore idolize glorify exalt praise laud commend applaud acclaim celebrate tribute homage' },

                        // === FLAGS ===
                        { start: 0x1F1E6, end: 0x1F1FF, name: 'Flag', keywords: 'flag country nation state territory region area place location position spot site locale venue setting scene backdrop background context situation circumstance condition status phase stage step level degree extent measure magnitude size dimension proportion scale ratio rate percentage fraction portion share part piece segment section division subdivision category class group type kind sort variety species genus family order phylum kingdom domain realm sphere field discipline subject topic theme matter issue question problem challenge difficulty obstacle hurdle barrier impediment hindrance obstruction blockage jam congestion traffic gridlock deadlock stalemate impasse standoff Mexican American Canadian British English French German Italian Spanish Russian Chinese Japanese Korean Indian Brazilian Australian European Asian African' },

                        // === CLOCKS & TIME ===
                        { start: 0x1F550, end: 0x1F567, name: 'Clock', keywords: 'clock time hour minute second watch timer alarm schedule timetable calendar date day week month year morning afternoon evening night midnight noon midday dawn dusk twilight sunrise sunset daybreak nightfall early late soon delayed urgent pressing immediate instant quick fast rapid swift speedy hasty prompt punctual timely opportune convenient suitable appropriate fitting proper right correct accurate precise exact specific particular special unique individual personal private confidential secret hidden concealed obscured veiled masked disguised camouflaged' },

                        // === WEATHER ===
                        { start: 0x1F324, end: 0x1F32C, name: 'Weather', keywords: 'weather climate temperature hot cold warm cool heat freeze rain snow sleet hail thunder lightning storm hurricane tornado cyclone typhoon blizzard flood drought sun sunny cloud cloudy overcast gray grey foggy misty hazy clear bright dark wind windy breeze gale gust calm still quiet peaceful serene tranquil placid smooth gentle mild moderate extreme severe harsh brutal intense fierce violent wild turbulent chaotic disorderly messy untidy' },

                        // === ZODIAC ===
                        { start: 0x2648, end: 0x2653, name: 'Zodiac', keywords: 'zodiac astrology horoscope sign star constellation aries ram taurus bull gemini twins cancer crab leo lion virgo maiden libra scales scorpio scorpion sagittarius archer capricorn goat aquarius water bearer pisces fish birth birthday date month celestial heaven sky space universe cosmos galaxy planet star moon sun solar lunar eclipse equinox solstice season spring summer autumn fall winter' },

                        // === ARROWS & DIRECTIONS ===
                        { start: 0x2190, end: 0x21FF, name: 'Arrow', keywords: 'arrow direction point indicate show guide lead navigate orient position locate situate place put set lay rest stand sit down up left right north south east west forward backward ahead behind front rear top bottom side edge corner angle diagonal vertical horizontal perpendicular parallel straight curved bent twisted spiral circular round oval elliptical' },

                        // === MATH & NUMBERS ===
                        { start: 0x2460, end: 0x24FF, name: 'Number', keywords: 'number digit numeral figure count amount quantity sum total aggregate whole entire complete full finished done ready prepared set arranged organized systematic orderly neat tidy clean pure simple plain basic fundamental essential primary main principal chief leading foremost paramount supreme ultimate final conclusive definitive decisive determinative zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty thirty forty fifty sixty seventy eighty ninety hundred thousand million billion trillion math mathematics arithmetic algebra geometry calculus statistics probability logic reasoning calculation computation' },

                        // === OFFICE & WRITING ===
                        { start: 0x270F, end: 0x2712, name: 'Writing Tool', keywords: 'write writing pencil pen ink marker highlighter crayon chalk pastel charcoal brush paint draw sketch doodle scribble jot note record document paper page sheet leaf notebook journal diary log book volume tome manuscript script text copy draft outline plan blueprint diagram chart graph table list inventory catalog index directory register roll roster schedule agenda calendar planner organizer office desk work workspace workplace business corporate professional formal official administrative clerical secretarial' },

                        // === MUSIC ===
                        { start: 0x1F3B5, end: 0x1F3BC, name: 'Music', keywords: 'music musical note song tune melody harmony rhythm beat tempo pulse sound audio acoustic sonic auditory hearing listen ear play perform sing dance disco party celebration festival concert show gig performance recital presentation exhibition display demonstration theater stage curtain spotlight limelight fame celebrity star superstar icon legend hero idol role model inspiration motivation encouragement support help assist aid' },

                        // === ADDITIONAL FACES & EXPRESSIONS ===
                        { start: 0x1F910, end: 0x1F92F, name: 'Face', keywords: 'face expression emotion feeling mood zipper mouth money monocle nerd geek cowboy clown lying pinocchio drool sick thermometer head injury bandage sneeze tissue cold flu virus bacteria germ infection disease illness sickness ailment malady affliction disorder condition syndrome complaint problem issue trouble difficulty complication' },

                        // === SUPPLEMENTAL SYMBOLS ===
                        { start: 0x1F300, end: 0x1F320, name: 'Nature Symbol', keywords: 'nature natural environment ecological green eco sustainable renewable organic earth planet world globe universe cosmos space galaxy star moon sun solar lunar celestial heaven sky cloud rain rainbow weather climate atmosphere air wind breeze storm hurricane tornado cyclone typhoon monsoon flood drought earthquake volcano tsunami' }
                    ];

                    // Generate emojis with unique names and comprehensive keywords
                    ranges.forEach(range => {
                        for (let code = range.start; code <= range.end; code++) {
                            const emoji = String.fromCodePoint(code);
                            const name = getEmojiName(code, range.start, range.end, range.name);
                            emojis.push({
                                e: emoji,
                                name: name,
                                k: range.keywords
                            });
                        }
                    });

                    return emojis;
                },

                _generateIconData() {
                    // 150+ Font Awesome icons in ultra-compact format: [name, keywords]
                    const ic = [
                        // UI & Actions (20)
                        ['heart', 'love like favorite'], ['star', 'favorite rating important'], ['fire', 'hot trending'], ['bolt', 'lightning fast power'],
                        ['check', 'done complete success'], ['xmark', 'close delete cancel'], ['plus', 'add new create'], ['minus', 'remove less'],
                        ['bars', 'menu hamburger'], ['ellipsis', 'more options'], ['gear', 'settings config'], ['sliders', 'adjust controls'],
                        ['bell', 'notification alert'], ['bookmark', 'save mark'], ['flag', 'report mark'], ['tag', 'label'],
                        ['share', 'send export'], ['download', 'save get'], ['upload', 'send put'], ['link', 'chain url'],

                        // Navigation & Arrows (18)
                        ['arrow-up', 'up north top'], ['arrow-down', 'down south bottom'], ['arrow-left', 'left west back'], ['arrow-right', 'right east forward'],
                        ['chevron-up', 'up collapse'], ['chevron-down', 'down expand'], ['chevron-left', 'left previous'], ['chevron-right', 'right next'],
                        ['angle-up', 'up'], ['angle-down', 'down'], ['angle-left', 'left'], ['angle-right', 'right'],
                        ['circle-up', 'up'], ['circle-down', 'down'], ['circle-left', 'left'], ['circle-right', 'right'],

                        // Shapes & Symbols (15)
                        ['circle', 'round dot'], ['square', 'box'], ['diamond', 'gem'], ['heart', 'love'],
                        ['star', 'rating'], ['sun', 'light day'], ['moon', 'night dark'], ['cloud', 'weather'], ['droplet', 'water'],
                        ['hashtag', 'tag number'], ['at', 'email mention'], ['percent', 'discount'], ['dollar-sign', 'money price'], ['infinity', 'unlimited'],

                        // Content & Media (18)
                        ['image', 'picture photo'], ['video', 'film movie'], ['music', 'audio sound'], ['file', 'document'], ['file-lines', 'document text'],
                        ['folder', 'directory'], ['folder-open', 'directory'], ['book', 'read library'], ['newspaper', 'news article'],
                        ['pen', 'write edit'], ['pencil', 'write draw'], ['paintbrush', 'art draw'], ['highlighter', 'mark'],
                        ['scissors', 'cut'], ['copy', 'duplicate'], ['paste', 'insert'], ['rotate', 'refresh reload'], ['crop', 'trim'],

                        // Communication (12)
                        ['envelope', 'email mail'], ['comment', 'message chat'], ['comments', 'discussion'], ['phone', 'call'], ['paper-plane', 'send'],
                        ['inbox', 'mail'], ['microphone', 'voice audio'], ['video', 'camera'], ['user', 'person profile'], ['users', 'people group'],
                        ['address-book', 'contacts'], ['id-card', 'profile identity'],

                        // Time & Calendar (8)
                        ['clock', 'time'], ['calendar', 'date schedule'], ['calendar-days', 'dates events'], ['stopwatch', 'timer'],
                        ['hourglass', 'waiting time'], ['history', 'past recent'], ['sun', 'morning day'], ['moon', 'evening night'],

                        // Places & Travel (15)
                        ['house', 'home'], ['building', 'office work'], ['city', 'urban'], ['mountain', 'nature outdoor'], ['tree', 'nature forest'],
                        ['location-dot', 'place pin'], ['map', 'location navigation'], ['compass', 'direction'], ['globe', 'world earth'],
                        ['plane', 'flight travel'], ['car', 'vehicle drive'], ['train', 'railway'], ['ship', 'boat sea'], ['bicycle', 'bike'], ['rocket', 'space launch'],

                        // Objects & Tools (18)
                        ['magnifying-glass', 'search find'], ['key', 'password access'], ['lock', 'secure private'], ['unlock', 'open access'],
                        ['shield', 'security protect'], ['trash', 'delete remove'], ['box', 'package container'], ['wrench', 'tool fix'],
                        ['hammer', 'tool build'], ['screwdriver', 'tool'], ['briefcase', 'work business'], ['suitcase', 'travel luggage'],
                        ['gift', 'present'], ['trophy', 'award win'], ['medal', 'achievement'], ['crown', 'king premium'], ['wand-magic', 'magic'], ['puzzle-piece', 'plugin addon'],

                        // Status & Alerts (12)
                        ['circle-check', 'success done'], ['circle-xmark', 'error failed'], ['circle-exclamation', 'warning alert'], ['circle-info', 'info help'],
                        ['triangle-exclamation', 'warning caution'], ['question', 'help unknown'], ['lightbulb', 'idea'], ['battery-full', 'power charged'],
                        ['wifi', 'internet connection'], ['signal', 'connection strength'], ['eye', 'view visible'], ['eye-slash', 'hidden invisible'],

                        // Food & Nature (12)
                        ['mug-hot', 'coffee tea drink'], ['utensils', 'food eat'], ['pizza-slice', 'food pizza'], ['burger', 'food'], ['apple', 'fruit'],
                        ['carrot', 'vegetable'], ['leaf', 'nature plant'], ['seedling', 'grow plant'], ['bug', 'insect'], ['paw', 'pet animal'],
                        ['fish', 'sea animal'], ['feather', 'bird light'],

                        // Weather (8)
                        ['cloud-sun', 'partly cloudy'], ['cloud-rain', 'rainy'], ['cloud-bolt', 'storm thunder'], ['snowflake', 'snow cold'],
                        ['temperature-high', 'hot heat'], ['temperature-low', 'cold'], ['wind', 'breeze'], ['umbrella', 'rain protection'],

                        // Social & Brands (10)
                        ['thumbs-up', 'like approve'], ['thumbs-down', 'dislike'], ['hand-peace', 'peace'], ['handshake', 'deal agreement'],
                        ['face-smile', 'happy emoji'], ['face-frown', 'sad emoji'], ['face-laugh', 'laugh emoji'], ['face-angry', 'angry emoji'],
                        ['universal-access', 'accessibility'], ['wheelchair', 'accessible'],

                        // Business & Finance (8)
                        ['chart-line', 'growth analytics'], ['chart-pie', 'statistics'], ['coins', 'money currency'], ['credit-card', 'payment'],
                        ['wallet', 'money finance'], ['receipt', 'bill invoice'], ['scale-balanced', 'law justice'], ['gavel', 'legal court']
                    ];

                    return ic.map(([n, k]) => ({ icon: n, class: `fa-solid fa-${n}`, k }));
                },

                init() {
                    this.els.palette = document.getElementById('command-palette');
                    this.els.input = document.getElementById('command-palette-input');
                    this.els.list = document.getElementById('command-palette-list');
                    this.els.preview = document.getElementById('command-palette-preview');

                    // --- TASK LINK CLICK HANDLER ---
                    document.addEventListener('click', (e) => {
                        const taskLink = e.target.closest('.nk-task-link');
                        if (taskLink) {
                            e.preventDefault();
                            e.stopPropagation();
                            const taskId = taskLink.dataset.taskId;
                            App.ui.showToast(' Launching Task...', { type: 'success', duration: 1000 });

                            // Show Productivity Hub (Modal)
                            if (App.hub && App.hub.ui && App.hub.ui.showProductivityModal) {
                                App.hub.ui.showProductivityModal();
                            } else {
                                App.ui.showToast('Productivity Hub not found.', 'error');
                            }

                            // Try to autostart
                            setTimeout(() => {
                                // Try common methods if available
                                if (App.hub && App.hub.startTask) {
                                    App.hub.startTask(taskId);
                                } else if (App.hub && App.hub.state && App.hub.state.tasks) {
                                    // Manual find and start
                                    const task = App.hub.state.tasks.find(t => t.id === taskId);
                                    if (task && App.hub.pomodoro) App.hub.pomodoro.start(task);
                                }
                            }, 300);
                        }

                        // --- VIDEO DELETE HANDLER ---
                        const deleteVideoBtn = e.target.closest('.nk-video-delete-btn');
                        if (deleteVideoBtn) {
                            e.preventDefault();
                            e.stopPropagation();
                            const embed = deleteVideoBtn.closest('.nk-video-embed');
                            if (embed) {
                                embed.remove();
                                App.state.isArticleDirty = true;
                                App.ui.showToast('Video removed', { type: 'info' });
                            }
                        }

                        // --- VIDEO ALIGN HANDLER ---
                        const alignVideoBtn = e.target.closest('.nk-video-align-btn');
                        if (alignVideoBtn) {
                            e.preventDefault();
                            e.stopPropagation();
                            const embed = alignVideoBtn.closest('.nk-video-embed');
                            if (embed) {
                                embed.classList.toggle('align-left');
                                const icon = alignVideoBtn.querySelector('i');
                                if (embed.classList.contains('align-left')) {
                                    alignVideoBtn.title = "Revert to Center Mode";
                                    if (icon) {
                                        icon.classList.remove('fa-align-left');
                                        icon.classList.add('fa-align-center');
                                    }
                                    App.ui.showToast('Newspaper mode active', { type: 'info' });
                                } else {
                                    alignVideoBtn.title = "Switch to Newspaper Mode";
                                    if (icon) {
                                        icon.classList.remove('fa-align-center');
                                        icon.classList.add('fa-align-left');
                                    }
                                    App.ui.showToast('Center mode active', { type: 'info' });
                                }
                                App.state.isArticleDirty = true;
                            }
                        }

                        // --- MAP DELETE HANDLER ---
                        const deleteMapBtn = e.target.closest('.nk-map-delete-btn');
                        if (deleteMapBtn) {
                            e.preventDefault();
                            e.stopPropagation();
                            const embed = deleteMapBtn.closest('.nk-map-embed');
                            if (embed) {
                                embed.remove();
                                App.state.isArticleDirty = true;
                                App.ui.showToast('Map removed', { type: 'info' });
                            }
                        }
                    });

                    // --- VIDEO FOCUS & DELETE KEYBOARD HANDLER ---
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Backspace' || e.key === 'Delete') {
                            const focused = document.activeElement;
                            if (focused && focused.classList.contains('nk-video-embed')) {
                                e.preventDefault();
                                e.stopPropagation();
                                focused.remove();
                                App.state.isArticleDirty = true;
                                App.ui.showToast('Video removed', { type: 'info' });
                            }
                            if (focused && focused.classList.contains('nk-map-embed')) {
                                e.preventDefault();
                                e.stopPropagation();
                                focused.remove();
                                App.state.isArticleDirty = true;
                                App.ui.showToast('Map removed', { type: 'info' });
                            }
                        }
                    });

                    this.state.isPreviewActive = false;
                    this.state.originalContentState = null;
                    this.state.previewTimeout = null;

                    this.state.fontFamilyOptions = [
                        // --- 11 OFFLINE SYSTEM FONTS (FREE) ---
                        { name: 'Arial', value: 'Arial, Helvetica, sans-serif' },
                        { name: 'Cambria', value: 'Cambria, Cochin, Georgia, Times, "Times New Roman", serif' },
                        { name: 'Courier New', value: "'Courier New', Courier, monospace" },
                        { name: 'Garamond', value: 'Garamond, serif' },
                        { name: 'Georgia', value: 'Georgia, serif' },
                        { name: 'Helvetica', value: 'Helvetica, Arial, sans-serif' },
                        { name: 'Monaco', value: 'Monaco, "Lucida Console", monospace' },
                        { name: 'Palatino', value: 'Palatino, "Palatino Linotype", serif' },
                        { name: 'Sans-Serif', value: 'sans-serif' },
                        { name: 'Times New Roman', value: "'Times New Roman', Times, serif" },
                        { name: 'Verdana', value: 'Verdana, Geneva, sans-serif' },

                        // --- 38 GOOGLE WEB FONTS (PREMIUM) ---
                        { name: 'Allura', value: 'Allura, cursive' },
                        { name: 'Arvo', value: 'Arvo, serif' },
                        { name: 'Bitter', value: 'Bitter, serif' },
                        { name: 'Cabin', value: 'Cabin, sans-serif' },
                        { name: 'Cabin Sketch', value: "'Cabin Sketch', cursive" },
                        { name: 'Changa One', value: "'Changa One', cursive" },
                        { name: 'Cinzel', value: 'Cinzel, serif' },
                        { name: 'Crimson Text', value: "'Crimson Text', serif'" },
                        { name: 'Dancing Script', value: "'Dancing Script', cursive" },
                        { name: 'Exo 2', value: "'Exo 2', sans-serif" },
                        { name: 'Fira Code', value: "'Fira Code', monospace" },
                        { name: 'Great Vibes', value: "'Great Vibes', cursive" },
                        { name: 'Inconsolata', value: 'Inconsolata, monospace' },
                        { name: 'Jersey 20', value: "'Jersey 20', sans-serif" },
                        { name: 'Josefin Sans', value: "'Josefin Sans', sans-serif" },
                        { name: 'Kaushan Script', value: "'Kaushan Script', cursive" },
                        { name: 'Lato', value: 'Lato, sans-serif' },
                        { name: 'Libre Baskerville', value: "'Libre Baskerville', serif" },
                        { name: 'Lobster', value: 'Lobster, cursive' },
                        { name: 'Merriweather', value: 'Merriweather, serif' },
                        { name: 'Metal Mania', value: "'Metal Mania', cursive" },
                        { name: 'Montserrat', value: 'Montserrat, sans-serif' },
                        { name: 'Pacifico', value: 'Pacifico, cursive' },
                        { name: 'Parisienne', value: 'Parisienne, cursive' },
                        { name: 'Patrick Hand', value: "'Patrick Hand', cursive" },
                        { name: 'Playfair Display', value: "'Playfair Display', serif" },
                        { name: 'Protest Revolution', value: "'Protest Revolution', sans-serif" },
                        { name: 'Righteous', value: 'Righteous, cursive' },
                        { name: 'Roboto', value: 'Roboto, sans-serif' },
                        { name: 'Rochester', value: 'Rochester, cursive' },
                        { name: 'Salsa', value: 'Salsa, cursive' },
                        { name: 'Satisfy', value: 'Satisfy, cursive' },
                        { name: 'Sofia', value: 'Sofia, cursive' },
                        { name: 'Source Code Pro', value: "'Source Code Pro', monospace" },
                        { name: 'Special Elite', value: "'Special Elite', cursive" },
                        { name: 'Syne Mono', value: "'Syne Mono', monospace" },
                        { name: 'Ubuntu', value: 'Ubuntu, sans-serif' },
                        { name: 'Vollkorn', value: 'Vollkorn, serif' },
                        { name: 'Zilla Slab', value: "'Zilla Slab', serif" },
                    ];

                    // --- NEW EXPANDED FONT SIZES ---
                    this.state.fontSizeOptions = [
                        '0.8rem', '0.9rem', '1rem', '1.1rem', '1.2rem', '1.3rem', '1.4rem', '1.5rem', '1.6rem', '1.7rem', '1.8rem', '1.9rem', '2rem', '2.1rem', '2.2rem', '2.3rem', '2.4rem', '2.5rem', '3rem'
                    ];


                    this.state.commands = [
                        { id: 'link', title: 'Link to Note/Snippet', desc: 'e.g., link my other note', icon: '', execute: () => { App.commandPalette.els.input.value = 'link '; App.commandPalette.filter(); } },
                        { id: 'whiteboard', title: 'Whiteboard / Ink', desc: 'Draw a sketch and insert it as an image', icon: '', execute: () => App.whiteboard.open('cursor') },

                        { id: 'hig', title: 'Highlight Block', desc: 'e.g., hig yellow, hig 1', icon: '' },
                        { id: 'define', title: 'Define Word', desc: 'e.g., define serendipity', icon: '' },

                        { id: 'category', title: 'Change Category', desc: 'e.g., category History', icon: '' },
                        { id: 'collapse', title: 'Collapsible Heading', desc: 'Make current heading/text collapsible', icon: '', execute: () => App.commandPalette.toggleCollapse() },
                        { id: 'tag', title: 'Insert Existing Tag', desc: 'e.g., tag botany', icon: '' },
                        { id: 'record', title: 'Start/Stop Recording', desc: 'Record audio, or Transcribe it (if downloaded)', icon: '', execute: () => App.audio.toggleRecording() },
                        { id: 'task', title: 'Create Task', desc: 'e.g., task:cat: name #priority', icon: '' },

                        { id: 'clip', title: 'Clip Webpage', desc: 'e.g., clip https://example.com', icon: '', isPremium: true },
                        { id: 'pastefast', title: 'Quick Paste', desc: 'Paste content, preserving styles except background', icon: '', execute: () => App.commandPalette.pasteFast() },
                        { id: 'onenoteimport', title: 'Import from OneNote', desc: 'Clean paste from OneNote', icon: '', execute: () => App.commandPalette.importOneNote() },
                        { id: 'video', title: 'Insert Video', desc: 'YT/X/Insta e.g. video https://...', icon: '', execute: () => { App.commandPalette.els.input.value = 'video '; App.commandPalette.filter(); } },
                        { id: 'map', title: 'Insert Map', desc: 'e.g., map Paris, map earth India', icon: '', execute: () => { App.commandPalette.els.input.value = 'map '; App.commandPalette.filter(); } },
                        { id: 'emoji', title: 'Insert Emoji', desc: 'e.g., emoji smile', icon: '' },
                        { id: 'icon', title: 'Insert Icon', desc: 'e.g., icon heart (Font Awesome)', icon: '' },
                        { id: 'img', title: 'External Image', desc: 'Use on URL, or img https://...', icon: '' },
                        { id: 'table', title: 'Insert Table (dynamic)', desc: 'e.g., table 3x4', icon: '' },

                        { id: 'alignleft', title: 'Align Left', desc: 'Align text to the left', icon: '', execute: () => { document.execCommand('justifyLeft'); App.state.isArticleDirty = true; } },
                        { id: 'aligncenter', title: 'Align Center', desc: 'Center align text', icon: '', execute: () => { document.execCommand('justifyCenter'); App.state.isArticleDirty = true; } },
                        { id: 'alignright', title: 'Align Right', desc: 'Align text to the right', icon: '', execute: () => { document.execCommand('justifyRight'); App.state.isArticleDirty = true; } },
                        { id: 'table2col', title: 'Insert Table (2 Columns)', desc: 'Creates a standard 3x2 table', icon: '', execute: () => App.events.table.create(3, 2) },
                        { id: 'table3col', title: 'Insert Table (3 Columns)', desc: 'Creates a standard 3x3 table', icon: '', execute: () => App.events.table.create(3, 3) },
                        { id: 'chart', title: 'Insert Chart', desc: 'Create a bar, line, or pie chart', icon: '', execute: () => App.ui.showChartModal() },
                        { id: 'timeline', title: 'Insert Timeline', desc: 'Create a historical timeline block', icon: '', execute: () => App.commandPalette.insertTimeline(), isPremium: true },
                        { id: 'mcq', title: 'Insert MCQ Block', desc: 'Create a multiple-choice question', icon: '', execute: () => App.commandPalette.insertMcqBlock(), isPremium: true },
                        { id: 'deck', title: 'Insert Decktile', desc: 'A container for multiple text tiles', icon: '', execute: () => App.commandPalette.insertTextileDeck(), isPremium: true },
                        { id: 'convert', title: 'Convert List to Deck', desc: 'Turns a bulleted list into a Decktile', icon: '', execute: () => App.commandPalette.convertListToDeck(), isPremium: true },
                        { id: 'textile', title: 'Insert Text Tile', desc: 'e.g., textile My important quote', icon: '', execute: () => App.commandPalette.insertTextTile(), isPremium: true },
                        { id: 'convertMcq', title: 'Convert to MCQ', desc: 'Convert selected text to an MCQ block', icon: '', selection: true, execute: () => App.commandPalette.convertSelectionToMcq(), isPremium: true },
                        { id: 'clearFormatting', title: 'Clear Formatting', desc: 'Remove all custom styles from selected text', icon: '', selection: true, execute: () => App.commandPalette.clearFormatting() },
                        { id: 'pdf', title: 'Import PDF', desc: 'Attach a PDF file to this note', icon: '', execute: () => App.pdf.triggerImport() },
                        { id: 'date', title: 'Insert Date', desc: 'Inserts today\'s date', icon: '', execute: () => document.execCommand('insertText', false, new Date().toLocaleDateString()) },
                        { id: 'time', title: 'Insert Time', desc: 'Inserts the current time', icon: '', execute: () => document.execCommand('insertText', false, new Date().toLocaleTimeString()) },
                        { id: 'now', title: 'Insert Timestamp', desc: 'Inserts full date and time', icon: '', execute: () => document.execCommand('insertText', false, new Date().toLocaleString()) },
                        { id: 'h1', title: 'Heading 1', desc: 'Large section heading', icon: 'H1', execute: () => document.execCommand('formatBlock', false, 'H1') },
                        { id: 'h2', title: 'Heading 2', desc: 'Medium section heading', icon: 'H2', execute: () => document.execCommand('formatBlock', false, 'H2') },
                        { id: 'h3', title: 'Heading 3', desc: 'Small section heading', icon: 'H3', execute: () => document.execCommand('formatBlock', false, 'H3') },
                        { id: 'h4', title: 'Heading 4', desc: 'Extra small section heading', icon: 'H4', execute: () => document.execCommand('formatBlock', false, 'H4') },
                        { id: 'h5', title: 'Heading 5', desc: 'Tiny section heading', icon: 'H5', execute: () => document.execCommand('formatBlock', false, 'H5') },
                        { id: 'bulletList', title: 'Bulleted List', desc: 'Create a standard list', icon: '', execute: () => document.execCommand('insertUnorderedList') },
                        { id: 'numberedList', title: 'Numbered List', desc: 'Create an ordered list', icon: '1.', execute: () => document.execCommand('insertOrderedList') },
                        { id: 'checkbox', title: 'Checkbox (To-do)', desc: 'Insert a trackable item', icon: '', execute: () => App.events.handleArticleControlsClick({ target: { closest: () => ({ dataset: { action: 'insertCheckbox' } }) } }), isPremium: true },
                        { id: 'bulletHyphen', title: 'Hyphen List', desc: 'A list with hyphen bullets', icon: '-', execute: () => App.events.handleArticleControlsClick({ target: { closest: () => ({ dataset: { action: 'applyListStyle', value: 'bullet-hyphen' } }) } }) },
                        { id: 'bulletCircle', title: 'Circle List', desc: 'A list with hollow circle bullets', icon: '', execute: () => App.events.handleArticleControlsClick({ target: { closest: () => ({ dataset: { action: 'applyListStyle', value: 'bullet-empty-circle' } }) } }) },
                        { id: 'blockquote', title: 'Blockquote', desc: 'Visually offset text', icon: '', execute: () => document.execCommand('formatBlock', false, 'blockquote') },
                        { id: 'code', title: 'Code Block', desc: 'Insert a pre-formatted block', icon: '&lt;/>', execute: () => document.execCommand('formatBlock', false, 'pre'), isPremium: true },
                        { id: 'accordion', title: 'Accordion Card', desc: 'Collapsible content for Q&A', icon: '', execute: () => App.events.insertAccordionCard(), isPremium: true },
                        { id: 'hr', title: 'Horizontal Rule', desc: 'Insert a dividing line', icon: '', execute: () => document.execCommand('insertHorizontalRule') },
                        // NEW: Stat commands re-introduced
                        { id: 'words', title: 'Word Count', desc: 'Count words in selection or document', icon: '', selection: true, execute: () => App.commandPalette.insertStatBadge('words'), isPremium: true },
                        { id: 'reading-time', title: 'Reading Time', desc: 'Estimate reading time for selection/doc', icon: '', selection: true, execute: () => App.commandPalette.insertStatBadge('time'), isPremium: true },
                        // --- Text Formatting ---
                        { id: 'bold', title: 'Bold', desc: 'Bold the selected text', icon: 'B', execute: () => document.execCommand('bold') },
                        { id: 'italic', title: 'Italic', desc: 'Italicize the selected text', icon: 'I', execute: () => document.execCommand('italic') },
                        { id: 'underline', title: 'Underline', desc: 'Underline the selected text', icon: 'U', execute: () => document.execCommand('underline') },
                        { id: 'normalize', title: 'Normalize Fonts', desc: 'Fix font sizes & remove styling issues', icon: '', execute: () => App.commandPalette.normalizeFonts() },

                        { id: 'cloze', title: 'Create Cloze', desc: 'Make a flashcard from selection', icon: '...', selection: true, execute: () => App.events.applyFormatting('cloze') },
                        { id: 'tag', title: 'Create Tag', desc: 'Make a visual tag from selection', icon: '#', selection: true, execute: () => App.contentTools.tagSelection() },
                        { id: 'save', title: 'Save Article', desc: 'Save changes and continue writing', icon: '', execute: () => App.events.saveArticle() },
                        { id: 'read', title: 'Save & Read', desc: 'Save changes and switch to read mode', icon: '', execute: () => App.events.saveArticle({ switchToRead: true }) },
                        { id: 'done', title: 'Done', desc: 'Save changes and return to library', icon: '', execute: () => { App.events.saveArticle(); App.router.navigateTo('library'); } },
                        { id: 'focus', title: 'Toggle Focus Mode', desc: 'Enter distraction-free writing', icon: '', execute: () => App.events.toggleFocusMode() },
                        // --- Font Size/Family ---
                        { id: 'fontsize', title: 'Set Font Size', desc: 'e.g., fontsize 24, fontsize large', icon: 'Aa' },
                        { id: 'fontfamily', title: 'Set Font Family', desc: 'e.g., fontfamily serif', icon: 'Ab' },
                        //--- AI Tools ---
                        { id: 'aimagic', title: 'Open AI Magic', desc: 'Access the AI Co-Pilot modal for quick commands', icon: '', execute: () => App.ui.aiMagicModal.open() },
                        { id: 'kashsummary', title: 'Kash Summary', desc: 'Generate an AI summary of the current note', icon: '', execute: () => App.events.ai.executeKashSummary(), isPremium: true },
                        { id: 'kashflash', title: 'Kash Flash', desc: 'Generate cloze flashcards from selected text', icon: '', selection: true, execute: () => App.events.ai.executeKashFlash() },
                        { id: 'kashwriting', title: 'Kash Writing', desc: 'Improve the writing of the selected text', icon: '', selection: true, execute: () => App.events.ai.executeImproveWriting(), isPremium: true },
                        { id: 'kashgrammar', title: 'Kash Grammar', desc: 'Fix grammar and spelling for selected text', icon: '', selection: true, execute: () => App.events.ai.executeFixGrammar(), isPremium: true },
                        { id: 'kashhighlight', title: 'Kash Highlight', desc: 'Automatically highlight key parts of the article', icon: '', execute: () => App.events.ai.executeKashHighlight(), isPremium: true },
                        { id: 'kashcurate', title: 'Kash Curate', desc: 'Let AI beautify and structure your note', icon: '', execute: () => App.events.ai.executeKashCurate(), isPremium: true },
                        { id: 'kashpresent', title: 'Kash Present', desc: 'Turn note into a beautiful presentation script', icon: '', execute: () => App.events.ai.executeKashPresent(), isPremium: true },
                        { id: 'kashask', title: 'KashAsk', desc: 'e.g., kashask What is mitochondria?', icon: '', isPremium: true },
                        { id: 'kashkeywords', title: 'KashKeywords', desc: 'Extract key concepts into a Decktile', icon: '', execute: () => App.events.ai.executeKashKeywords(), isPremium: true },
                        { id: 'kashcomedy', title: 'KashComedy', desc: 'Generate a stand-up routine from the article', icon: '', execute: () => App.events.ai.executeKashComedy(), isPremium: true },
                        { id: 'kashstory', title: 'KashStory', desc: 'Generate a memorable story from the article', icon: '', execute: () => App.events.ai.executeKashStory(), isPremium: true },
                        { id: 'kashscript', title: 'KashScript', desc: 'Generate a short video script from the article', icon: '', execute: () => App.events.ai.executeKashScript(), isPremium: true },
                        { id: 'kashmnemonic', title: 'KashMnemonic', desc: 'Create mnemonics from selected text', icon: '', selection: true, execute: () => App.events.ai.executeKashMnemonic(), isPremium: true },
                        { id: 'kashexplain', title: 'KashExplain', desc: 'Generate a clear explanation of selected text', icon: '', selection: true, execute: () => App.events.ai.executeKashExplain(), isPremium: true },
                        { id: 'kashtranslate', title: 'KashTranslate', desc: 'e.g., kashtranslate Spanish', icon: '', selection: true, isPremium: true },
                        { id: 'kashtags', title: 'KashTags', desc: 'Automatically generate and apply tags to the article', icon: '', execute: () => App.events.ai.executeKashTags(), isPremium: true },
                        { id: 'kashaccordion', title: 'KashAccordion', desc: 'Generate Q&A accordions from the article', icon: '', execute: () => App.events.ai.executeKashAccordion(), isPremium: true },
                        { id: 'template', title: 'Insert Template', desc: 'Open the Template Hub to browse and add a Template', icon: '', execute: () => App.ui.showTemplateHubModal() },
                        { id: 'kashcraft', title: 'KashCraft Article Analysis', desc: 'Transform the note into a structured craft for exam', icon: '', execute: () => App.events.ai.executeKashCraft(), isPremium: true },
                        { id: 'kashquestion', title: 'Kash Question', desc: 'Generate 5 key questions from the article', icon: '', execute: () => App.events.ai.executeKashQuestion(), isPremium: true },
                        { id: 'kashdebate', title: 'Kash Debate', desc: 'Create a debate table from the article content', icon: '', execute: () => App.events.ai.executeKashDebate(), isPremium: true },
                        { id: 'kashlong', title: 'Kash Long', desc: 'Generate a detailed summary of the article', icon: '', execute: () => App.events.ai.executeKashLong(), isPremium: true },
                        { id: 'kashtable', title: 'Kash Table', desc: 'Create a revision table from selected text', icon: '', selection: true, execute: () => App.events.ai.executeKashTable(), isPremium: true },
                        { id: 'kashmcq', title: 'KashMCQ Generator', desc: 'Generate MCQs from the article content', icon: '', execute: () => App.events.ai.executeKashMcqGenerator(), isPremium: true },
                        { id: 'kashmcqreviser', title: 'KashMCQ Reviser', desc: 'Revise & Colorize selected MCQs', icon: '', selection: true, execute: () => App.events.ai.executeKashMcqReviser(), isPremium: true },
                        { id: 'kashlist', title: 'Kash List', desc: 'Convert selected text to a Bulleted list', icon: '', selection: true, execute: () => App.events.ai.executeKashListify(), isPremium: true },
                        { id: 'kashtimeline', title: 'Kash Timeline', desc: 'Convert article content into a Timeline', icon: '', execute: () => App.events.ai.executeKashTimeline(), isPremium: true },
                        { id: 'kashoutline', title: 'Kash Outline', desc: 'e.g., kashoutline The Greek Empire', icon: '', execute: () => { /* Handled by filter logic */ }, isPremium: true },
                        { id: 'kashexpand', title: 'Kash Expand', desc: 'Continue writing from your cursor', icon: '', selection: false, execute: () => App.events.ai.executeKashExpand(), isPremium: true },
                        { id: 'kashquote', title: 'Kash Quote', desc: 'Find a contextually relevant quote for your article', icon: '', selection: false, execute: () => App.events.ai.executeKashQuote(), isPremium: true },
                        { id: 'kashextract', title: 'Kash Extract', desc: 'e.g., kashextract key arguments', icon: '', execute: () => { /* Handled by filter logic */ }, isPremium: true },
                        { id: 'kashlink', title: 'Kash Link', desc: 'e.g., kashlink The Indus Valley Civilization', icon: '', execute: () => { /* Handled by filter logic */ }, isPremium: true },
                        { id: 'kashsplit', title: 'KashSplit', desc: 'Intelligently split the current note into two', icon: '', execute: () => App.events.ai.executeKashSplit(), isPremium: true },
                    ];
                    //  SMART DYNAMIC DATA GENERATORS - Replaces 400+ lines of hardcoded data!
                    this.state.emojiData = this._generateEmojiData();
                    this.state.iconData = this._generateIconData();

                    this.state.fuse.commands = App.offline.safeFuse(this.state.commands, { keys: ['title', 'desc', 'id'], threshold: 0.3 });
                    this.state.fuse.categories = null;
                    this.state.fuse.emojis = App.offline.safeFuse(this.state.emojiData, { keys: ['k'], threshold: 0.4 });
                    this.state.fuse.icons = App.offline.safeFuse(this.state.iconData, { keys: ['k', 'icon'], threshold: 0.4 });

                    this.state.fuse.fontFamilies = App.offline.safeFuse(this.state.fontFamilyOptions, { keys: ['name'], threshold: 0.3 });
                    this.state.fuse.fontSizes = App.offline.safeFuse(this.state.fontSizeOptions, { threshold: 0.3 });

                    this.els.input.addEventListener('input', () => this.filter());
                    this.els.input.addEventListener('keydown', (e) => this.handleKeyDown(e));
                },

                async toggleCollapse() {
                    this._restoreEditor();
                    const selection = window.getSelection();
                    if (!selection.rangeCount) return;

                    let range = selection.getRangeAt(0);
                    let node = range.startContainer;
                    if (node.nodeType === 3) node = node.parentNode;

                    // Helper function to create collapsible icon
                    const createCollapsibleIcon = () => {
                        const iconSpan = document.createElement('span');
                        iconSpan.className = 'collapsible-icon';
                        iconSpan.setAttribute('data-collapsible-icon', 'true');
                        iconSpan.contentEditable = 'false'; // Icon should not be editable
                        iconSpan.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>`;
                        return iconSpan;
                    };

                    // Helper function to add icon to heading if not present
                    const ensureIconPresent = (heading) => {
                        if (!heading.querySelector('[data-collapsible-icon]')) {
                            const icon = createCollapsibleIcon();
                            heading.insertBefore(icon, heading.firstChild);
                        }
                    };

                    // Helper function to remove icon from heading
                    const removeIcon = (heading) => {
                        const icon = heading.querySelector('[data-collapsible-icon]');
                        if (icon) icon.remove();
                    };

                    // Find block element
                    let block = node;
                    while (block && !['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'DIV', 'LI', 'BLOCKQUOTE'].includes(block.tagName)) {
                        block = block.parentElement;
                        if (!block || block.id === 'article-content') break;
                    }

                    if (!block || block.id === 'article-content' || block.classList.contains('nk-text-tile') || block.closest('.nk-text-tile')) {
                        // Create new H3 as default collapsible if nothing or tile selected
                        const h3 = document.createElement('h3');
                        h3.className = 'collapsible-heading';
                        const icon = createCollapsibleIcon();
                        h3.appendChild(icon);
                        h3.innerHTML += '<br>'; // Keep empty for immediate typing
                        document.execCommand('insertHTML', false, h3.outerHTML + '<p><br></p>');
                        return;
                    }

                    // Case: It's a header -> Toggle the class
                    if (['H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(block.tagName)) {
                        block.classList.toggle('collapsible-heading');

                        if (block.classList.contains('collapsible-heading')) {
                            // Adding collapsible feature - add icon
                            ensureIconPresent(block);
                        } else {
                            // Removing collapsible feature - remove icon and expand all
                            removeIcon(block);
                            block.removeAttribute('data-collapsed');

                            // Un-hide everything under it (Robustness Fix)
                            let next = block.nextElementSibling;
                            const level = parseInt(block.tagName.substring(1));
                            while (next) {
                                if (['H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(next.tagName)) {
                                    const nextLevel = parseInt(next.tagName.substring(1));
                                    if (nextLevel <= level) break;
                                }
                                next.classList.remove('collapsible-hidden');
                                next = next.nextElementSibling;
                            }
                        }
                    } else {
                        // Case: It's text/p -> Convert to H3 Collapsible
                        const h3 = document.createElement('h3');
                        h3.className = 'collapsible-heading';
                        const icon = createCollapsibleIcon();
                        h3.appendChild(icon);

                        // Preserve the block's content
                        const content = block.innerHTML.trim();
                        if (content && content !== '<br>') {
                            h3.innerHTML += block.innerHTML;
                        } else {
                            h3.innerHTML += '<br>';
                        }

                        block.replaceWith(h3);
                        // Add a generic P after if current block was empty-ish to allow typing
                        if (!h3.textContent.trim()) {
                            h3.insertAdjacentHTML('afterend', '<p><br></p>');
                        }
                    }
                    App.state.isArticleDirty = true;
                },

                async pasteFast() {
                    try {
                        const clipboardItems = await navigator.clipboard.read();
                        const htmlItem = clipboardItems.find(item => item.types.includes('text/html'));

                        let contentToInsert = '';

                        if (htmlItem) {
                            const htmlBlob = await htmlItem.getType('text/html');
                            const pastedHTML = await htmlBlob.text();

                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = pastedHTML;

                            const cleanBackgroundStyles = (element) => {
                                if (element.style && (element.style.backgroundColor || element.style.background)) {
                                    element.style.removeProperty('background-color');
                                    element.style.removeProperty('background'); // Also remove the shorthand property
                                }
                                if (element.hasAttribute('bgcolor')) {
                                    element.removeAttribute('bgcolor');
                                }
                                for (const child of element.children) {
                                    cleanBackgroundStyles(child);
                                }
                            };

                            cleanBackgroundStyles(tempDiv);
                            contentToInsert = tempDiv.innerHTML;

                        } else {
                            const text = await navigator.clipboard.readText();
                            if (text) {
                                contentToInsert = App.util.textToHtml(text);
                            }
                        }

                        if (contentToInsert) {
                            document.execCommand('insertHTML', false, contentToInsert);
                            App.state.isArticleDirty = true;
                            App.ui.showToast('Pasted quickly!', { type: 'success' });
                        } else {
                            App.ui.showToast('Nothing to paste from clipboard.', { type: 'warning' });
                        }

                    } catch (err) {
                        console.error('Quick Paste failed:', err);
                        if (err.name === 'NotAllowedError') {
                            App.ui.showToast('Clipboard access denied. Please allow it in your browser settings.', { type: 'error' });
                        } else {
                            App.ui.showToast('Could not paste content.', { type: 'error' });
                        }
                    }
                },

                async importOneNote() {
                    try {
                        const clipboardItems = await navigator.clipboard.read();
                        const htmlItem = clipboardItems.find(item => item.types.includes('text/html'));

                        if (!htmlItem) {
                            const text = await navigator.clipboard.readText();
                            if (text) {
                                document.execCommand('insertHTML', false, App.util.textToHtml(text));
                                App.ui.showToast('Imported as text (No HTML found).', { type: 'info' });
                            } else {
                                App.ui.showToast('Clipboard is empty.', { type: 'warning' });
                            }
                            return;
                        }

                        // 1. Launch Popup
                        App.ui.migrationScreen.show("Importing OneNote");
                        App.ui.migrationScreen.update(10, "Reading clipboard...");

                        const blob = await htmlItem.getType('text/html');
                        const rawHtml = await blob.text();

                        // Yield to UI thread to let popup render
                        setTimeout(() => {
                            try {
                                if (App.ui.migrationScreen.state.isCancelled) { App.ui.migrationScreen.hide(); return; }

                                App.ui.migrationScreen.update(40, "Cleaning Microsoft formatting...");

                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = rawHtml;

                                // --- THE CLEANING PROTOCOL ---
                                tempDiv.querySelectorAll('style, script, link, meta, xml, o\\:p').forEach(el => el.remove());

                                const allElements = tempDiv.querySelectorAll('*');

                                // Reused helper from previous turn
                                const isDarkColor = (colorString) => {
                                    if (!colorString) return false;
                                    const c = colorString.replace(/\s/g, '').toLowerCase();
                                    return (c === 'black' || c === '#000000' || c === '#000' || c === 'rgb(0,0,0)' || c === '#201f1e' || c === '#333333' || c === 'windowtext');
                                };

                                allElements.forEach(el => {
                                    el.style.removeProperty('width');
                                    el.style.removeProperty('min-width');
                                    el.style.removeProperty('max-width');
                                    el.style.removeProperty('height');
                                    el.style.removeProperty('position');
                                    el.style.removeProperty('left');
                                    el.style.removeProperty('top');
                                    el.style.removeProperty('margin-left');
                                    el.removeAttribute('width');
                                    el.removeAttribute('height');
                                    el.removeAttribute('lang');
                                    el.classList.remove('ExternalClass');

                                    if (el.style.color && isDarkColor(el.style.color)) {
                                        el.style.removeProperty('color');
                                    }
                                    if (el.style.backgroundColor) {
                                        const bg = el.style.backgroundColor.replace(/\s/g, '').toLowerCase();
                                        if (bg === 'white' || bg === '#ffffff' || bg === '#fff' || bg === 'transparent') {
                                            el.style.removeProperty('background-color');
                                        }
                                    }
                                });

                                const tables = tempDiv.querySelectorAll('table');
                                tables.forEach(table => {
                                    table.style.width = '100%';
                                    table.style.borderCollapse = 'collapse';
                                    table.removeAttribute('border');
                                    table.removeAttribute('cellpadding');
                                    table.removeAttribute('cellspacing');
                                    table.style.marginBottom = '1em';
                                });

                                const spans = tempDiv.querySelectorAll('span');
                                spans.forEach(span => {
                                    if (span.style.fontFamily) span.style.removeProperty('font-family');
                                    if (span.style.fontSize) span.style.removeProperty('font-size');
                                    if (!span.hasAttribute('style') && !span.hasAttribute('class') && !span.hasAttribute('id')) {
                                        App.util.unwrapNode(span);
                                    }
                                });

                                const images = tempDiv.querySelectorAll('img');
                                images.forEach(img => {
                                    if (img.src.startsWith('file://')) {
                                        const placeholder = document.createElement('span');
                                        placeholder.innerText = '[Image skipped: Local File]';
                                        placeholder.style.color = 'var(--text-secondary)';
                                        placeholder.style.fontSize = '0.8em';
                                        img.parentNode.replaceChild(placeholder, img);
                                    } else {
                                        img.style.maxWidth = '100%';
                                        img.style.height = 'auto';
                                        img.removeAttribute('width');
                                        img.removeAttribute('height');
                                    }
                                });

                                // 4. Finalize
                                App.ui.migrationScreen.update(90, "Inserting content...");
                                const cleanHtml = tempDiv.innerHTML.trim();

                                if (cleanHtml) {
                                    document.execCommand('insertHTML', false, cleanHtml);
                                    document.execCommand('insertHTML', false, '<p><br></p>');
                                    App.state.isArticleDirty = true;

                                    App.ui.migrationScreen.update(100, "Done!");
                                    setTimeout(() => {
                                        App.ui.migrationScreen.hide();
                                        App.ui.showToast('OneNote content sanitized!', { type: 'success' });
                                    }, 200);
                                } else {
                                    App.ui.migrationScreen.hide();
                                    App.ui.showToast('Could not parse content.', { type: 'error' });
                                }

                            } catch (innerErr) {
                                console.error("OneNote Processing Error:", innerErr);
                                App.ui.migrationScreen.hide();
                                App.ui.showToast('Import failed during processing.', { type: 'error' });
                            }
                        }, 50);

                    } catch (err) {
                        console.error("OneNote Access Error:", err);
                        if (App.ui.migrationScreen) App.ui.migrationScreen.hide();
                        if (err.name === 'NotAllowedError') {
                            App.ui.showToast('Clipboard permission denied.', { type: 'error' });
                        } else {
                            App.ui.showToast('Import failed.', { type: 'error' });
                        }
                    }
                },

                async fetchDefinition(word) {
                    try {
                        const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                        if (!response.ok) { return [{ type: 'definition', error: `No definition found for "${word}".` }]; }
                        const data = await response.json();
                        const results = data.flatMap(entry => entry.meanings.map(meaning => {
                            const definition = meaning.definitions[0];
                            return definition ? {
                                type: 'definition', word: entry.word, partOfSpeech: meaning.partOfSpeech,
                                definition: definition.definition, example: definition.example,
                                synonyms: (meaning.synonyms || []).join(', ')
                            } : null;
                        })).filter(Boolean);
                        return results.length > 0 ? results : [{ type: 'definition', error: `No definition found for "${word}".` }];
                    } catch (error) {
                        console.error("Dictionary API error:", error);
                        return [{ type: 'definition', error: "Could not connect to the dictionary service." }];
                    } finally {
                        this.state.isFetching = false;
                    }
                },
                normalizeFonts() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv) return;

                    this._saveEditorState();

                    const elements = contentDiv.querySelectorAll('[style]');
                    let cleanCount = 0;

                    elements.forEach(el => {
                        if (el.style.fontFamily) { el.style.removeProperty('font-family'); cleanCount++; }
                        if (el.style.fontSize) { el.style.removeProperty('font-size'); cleanCount++; }
                        if (el.style.lineHeight) { el.style.removeProperty('line-height'); cleanCount++; }
                        if (el.style.backgroundColor) { el.style.removeProperty('background-color'); }

                        if (el.getAttribute('style') === '') {
                            el.removeAttribute('style');
                        }
                        if (el.tagName === 'SPAN' && !el.hasAttribute('class') && !el.hasAttribute('style') && !el.hasAttribute('id')) {
                            App.util.unwrapNode(el);
                        }
                    });

                    App.state.isArticleDirty = true;
                    App.ui.showToast(`Normalized fonts on ${cleanCount} elements!`, 'success');
                },

                // FIX: Highlighting logic now uses the stored targetBlockElement
                applyBlockHighlight(className) {
                    const blockElement = this.state.targetBlockElement;
                    if (!blockElement) {
                        App.ui.showToast("Can only highlight full text blocks.", { type: 'warning' });
                        return;
                    }
                    blockElement.classList.remove(...this.state.highlightOptions.map(h => h.className).filter(Boolean));
                    if (className) {
                        blockElement.classList.add(className);
                    }
                    App.state.isArticleDirty = true;
                },

                _saveEditorState() {
                    const contentDiv = document.getElementById('article-content');
                    if (contentDiv && !this.state.isPreviewActive) {
                        if (App.state.autosaveInterval) { clearInterval(App.state.autosaveInterval); App.state.autosaveInterval = null; }
                        this.state.originalContentState = { articleId: App.state.activeArticleId, html: contentDiv.innerHTML, isDirty: App.state.isArticleDirty, scrollTop: document.querySelector('main').scrollTop };
                        this.state.isPreviewActive = true;
                        contentDiv.contentEditable = false;
                    }
                },
                _restoreEditor() {
                    if (this.state.isPreviewActive && this.state.originalContentState) {
                        const originalState = this.state.originalContentState;
                        App.router.navigateTo('article', { id: originalState.articleId, mode: 'write', overrideContent: originalState.html, restoredScrollTop: originalState.scrollTop });
                        App.state.isArticleDirty = originalState.isDirty;
                    }
                    this.state.isPreviewActive = false;
                    this.state.originalContentState = null;
                    clearTimeout(this.state.previewTimeout);
                },
                async _renderPreview(item) {
                    // 1. Clear any existing preview pane locally
                    const existingPane = this.els.palette.querySelector('.nk-command-palette-preview');
                    if (existingPane) existingPane.remove();

                    if (!item) return;

                    const isLinkPreview = item.type === 'article' || item.type === 'snippet' || item.type === 'tag' || item.type === 'task';

                    if (isLinkPreview) {
                        try {
                            const targetId = item.type === 'article' ? item.id : item.articleId;

                            // Check internally
                            const targetArticle = (item.type === 'task') ? { title: item.title } : App.state.articles.find(a => a.id === targetId);
                            if (!targetArticle && item.type !== 'task') return; // Silent fail

                            // Prepare Content Variables
                            let badge = ' Article';
                            let headerText = item.title; // Default: Header is the item title
                            let bodyText = item.desc; // Default: Body is the content
                            let isSnippetView = false;

                            if (item.type === 'snippet') {
                                badge = ' Snippet';
                                isSnippetView = true;

                                // REQ #1-a: Bubble should have Article Title (header) and Complete Snippet (Body)
                                headerText = targetArticle ? targetArticle.title : 'Unknown Article';
                                bodyText = item.title; // Fuse stores the Snippet Text in 'title'

                            } else if (item.type === 'tag') {
                                badge = ' Tag';

                                // REQ #1-c: Title and Tag Extracted Paragraph
                                headerText = `#${item.title}`;
                                bodyText = 'Tag context not found.';

                                if (targetArticle && targetArticle.content) {
                                    // Try to find the tag in the content
                                    const tagRegex = new RegExp(`#${App.util.escapeRegex(item.title)}\\b`, 'i');
                                    const match = targetArticle.content.match(tagRegex);
                                    if (match) {
                                        // Extract surrounding text (approx 150 chars)
                                        const start = Math.max(0, match.index - 50);
                                        const end = Math.min(targetArticle.content.length, match.index + 100);
                                        // Strip HTML for clean preview
                                        const temp = document.createElement('div');
                                        temp.innerHTML = targetArticle.content.substring(start, end);
                                        bodyText = '...' + temp.textContent.trim() + '...';
                                    } else {
                                        // Use first paragraph if tag specific location fail
                                        const temp = document.createElement('div');
                                        temp.innerHTML = targetArticle.content;
                                        bodyText = temp.textContent.substring(0, 150) + '...';
                                    }
                                }

                            } else if (item.type === 'task') {
                                badge = ' Task';
                                // REQ #2: Show task details nicely
                                headerText = item.desc; // "Task: PRIORITY  STATUS"
                                bodyText = item.title; // The Task Name itself is the main content
                                isSnippetView = true; // Use larger font for task name

                            } else {
                                // Standard Article
                                // REQ #1-b: Title and Sample
                                headerText = item.title;
                                if (targetArticle.content) {
                                    const temp = document.createElement('div');
                                    temp.innerHTML = targetArticle.content;
                                    bodyText = temp.textContent || '';
                                } else {
                                    bodyText = item.desc || 'No preview content available.';
                                }
                            }

                            // Truncate Body if MASSIVE
                            if (bodyText.length > 400) bodyText = bodyText.substring(0, 400) + '...';

                            // Render Side Pane
                            const pane = document.createElement('div');
                            pane.className = 'nk-command-palette-preview';
                            pane.innerHTML = `
                                <div class="nk-preview-header">
                                    <span class="nk-preview-badge">${badge}</span>
                                    <span style="font-size:0.9rem; opacity:0.7;">${(item.type === 'article' || item.type === 'snippet') ? '' : (item.type === 'task' ? '' : '')}</span>
                                </div>
                                <h4 class="nk-preview-title" style="font-size: 0.95rem; opacity: 0.9; margin-bottom:4px;">${App.util.escapeHtml(headerText)}</h4>
                                <div class="nk-preview-content ${isSnippetView ? 'is-snippet' : ''}">${App.util.escapeHtml(bodyText)}</div>
                            `;

                            this.els.palette.appendChild(pane);

                            // Slight delay for specific animation
                            requestAnimationFrame(() => {
                                pane.classList.add('visible');
                            });

                        } catch (e) {
                            console.error("In-place preview failed:", e);
                        }
                    }
                },
                _updateSelection() {
                    clearTimeout(this.state.previewTimeout);
                    this._restoreEditor();

                    // Support both list items (.command-item) and grid items (.emoji-grid-item)
                    const items = this.els.list.querySelectorAll('.command-item, .emoji-grid-item');
                    items.forEach((item, index) => {
                        item.classList.toggle('selected', index === this.state.selectedIndex);
                        if (index === this.state.selectedIndex) {
                            item.scrollIntoView({ block: 'nearest' });
                            this.state.previewTimeout = setTimeout(() => { this._renderPreview(this.state.filteredResults[this.state.selectedIndex]); }, 150);
                        }
                    });
                },
                _repositionPaletteIfObscuring(targetElement) {
                    if (!targetElement) return;
                    const targetRect = targetElement.getBoundingClientRect();
                    const paletteRect = this.els.palette.getBoundingClientRect();
                    if (paletteRect.bottom > targetRect.top && paletteRect.top < targetRect.bottom) {
                        this.els.palette.style.top = '15px'; this.els.palette.style.left = '50%'; this.els.palette.style.transform = 'translateX(-50%)';
                    }
                },

                open(range = null) {
                    if (this.state.isOpen) return;

                    if (range && !range.collapsed) {
                        App.state.savedRange = range.cloneRange();
                        this.state.cursorMarkerId = null;
                    } else if (range) {
                        const markerId = `nk-cursor-marker-${Date.now()}`;
                        const markerNode = document.createElement('span');
                        markerNode.id = markerId;
                        range.insertNode(markerNode);
                        this.state.cursorMarkerId = markerId;
                        App.state.savedRange = null;
                    } else {
                        this.state.cursorMarkerId = null;
                        App.state.savedRange = null;
                    }

                    this.state.isOpen = true;
                    document.addEventListener('click', this.handleClickOutside, true);

                    this.state.targetBlockElement = range ? (range.commonAncestorContainer.nodeType === 3 ? range.commonAncestorContainer.parentElement : range.commonAncestorContainer).closest('p, li, h1, h2, h3, h4, h5, h6, blockquote') : null;

                    // --- START: MODIFIED POSITIONING LOGIC ---
                    const isMobileView = document.body.classList.contains('mobile-view');

                    if (isMobileView) {
                        // On mobile, always position at the top.
                        this.els.palette.style.left = '50%';
                        this.els.palette.style.top = '55px'; // Just below the header
                        this.els.palette.style.transform = 'translateX(-50%)';
                    } else if (this.state.cursorMarkerId) {
                        // Original desktop logic for cursor position
                        const markerNode = document.getElementById(this.state.cursorMarkerId);
                        const rect = markerNode.getBoundingClientRect();
                        const paletteWidth = 380, paletteHeight = 400, margin = 10;
                        let top = rect.bottom + window.scrollY + 5;
                        let left = rect.left + window.scrollX;
                        if (rect.bottom + paletteHeight > window.innerHeight) { top = rect.top + window.scrollY - paletteHeight - 5; }
                        if (left + paletteWidth > window.innerWidth) { left = window.innerWidth - paletteWidth - margin; }
                        this.els.palette.style.top = `${Math.max(margin, top)}px`;
                        this.els.palette.style.left = `${Math.max(margin, left)}px`;
                        this.els.palette.style.transform = '';
                    } else {
                        // Original desktop logic for broad selection or header click
                        this.els.palette.style.left = '50%';
                        this.els.palette.style.top = '20vh';
                        this.els.palette.style.transform = 'translateX(-50%)';
                    }
                    // --- END: MODIFIED POSITIONING LOGIC ---

                    this.els.palette.style.display = 'flex';
                    this.els.input.focus();
                    this.filter();
                },

                insertTimeline() {
                    const timelineHTML = `<div class="nk-timeline-block" contenteditable="false"><div class="nk-timeline-entry"><div class="nk-timeline-content"><div class="nk-timeline-date" contenteditable="true">2024-01-01</div><div class="nk-timeline-title" contenteditable="true">First event...</div></div></div><div class="nk-timeline-entry"><div class="nk-timeline-content"><div class="nk-timeline-date" contenteditable="true">2025-03-15</div><div class="nk-timeline-title" contenteditable="true">Second event...</div></div></div><div class="nk-timeline-add" contenteditable="false"><button title="Add Timeline Entry" type="button">+</button></div></div><p><br></p>`;
                    App.util.insertGuardianBlock(timelineHTML);
                },
                // NEW: Function to insert stat badges
                insertStatBadge(type) {
                    const sel = window.getSelection();
                    let text = '';
                    if (sel && !sel.isCollapsed && sel.rangeCount > 0) {
                        text = sel.toString();
                    } else {
                        const contentDiv = document.getElementById('article-content');
                        if (contentDiv) {
                            text = contentDiv.innerText || contentDiv.textContent;
                        }
                    }
                    if (!text.trim()) {
                        App.ui.showToast('No text found to analyze.', { type: 'warning' });
                        return;
                    }
                    const wordCount = text.trim().split(/\s+/).filter(Boolean).length;
                    let badgeHTML = '';

                    // FIX: Replaced complex SVG with simple, reliable Font Awesome icons
                    if (type === 'words') {
                        const icon = `<i class="fa-solid fa-pen-ruler"></i>`;
                        badgeHTML = `<span class="nk-stat-badge" contenteditable="false">${icon} ${wordCount} words</span>`;
                    } else if (type === 'time') {
                        const icon = `<i class="fa-regular fa-clock"></i>`;
                        const minutes = Math.ceil(wordCount / 200);
                        const timeText = minutes < 1 ? '< 1 min read' : `${minutes} min read`;
                        badgeHTML = `<span class="nk-stat-badge" contenteditable="false">${icon} ${timeText}</span>`;
                    }

                    if (badgeHTML) {
                        document.execCommand('insertHTML', false, badgeHTML + '&nbsp;');
                    }
                },

                insertMcqBlock() {
                    const mcqId = `mcq-${crypto.randomUUID()}`; // Unique ID to find the new element
                    const mcqHTML = `
                    <div id="${mcqId}" class="nk-mcq-block" contenteditable="false">
                        <div class="nk-mcq-toolbar">
                            <button class="nk-mcq-copy-block" title="Copy MCQ"><i class="fa-solid fa-copy"></i></button>
                            <button class="nk-mcq-delete-block" title="Delete MCQ"><i class="fa-solid fa-trash"></i></button>
                        </div>
                        <div class="nk-mcq-question" contenteditable="true" data-placeholder="Type your question here..."></div>
                        <div class="nk-mcq-options">
                            <div class="nk-mcq-option" data-is-correct="false">
                                <div class="nk-mcq-option-radio"></div>
                                <div class="nk-mcq-option-text" contenteditable="true" data-placeholder="Option A"></div>
                                <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                            </div>
                            <div class="nk-mcq-option" data-is-correct="false">
                                <div class="nk-mcq-option-radio"></div>
                                <div class="nk-mcq-option-text" contenteditable="true" data-placeholder="Option B"></div>
                                <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                            </div>
                        </div>
                        <button class="btn btn-secondary nk-mcq-add-option">+ Add Option</button>
                        
                        <div class="nk-mcq-explanation" contenteditable="true" data-placeholder="Your Explanation ..."></div>
                    </div>`;
                    App.util.insertGuardianBlock(mcqHTML);

                    // UX ENHANCEMENT: Automatically focus the cursor in the new question area.
                    setTimeout(() => {
                        const newMcq = document.getElementById(mcqId);
                        if (newMcq) {
                            const questionEl = newMcq.querySelector('.nk-mcq-question');
                            if (questionEl) {
                                App.util.placeCursor(questionEl);
                            }
                        }
                    }, 50);

                    App.state.isArticleDirty = true;
                },


                insertTextileDeck() {
                    const deckHTML = `
                <div class="nk-textile-deck" contenteditable="false">
                    <div class="deck-layout-toggle" title="Toggle Layout"><i class="fa-solid fa-table-cells"></i></div>
                    <div class="nk-text-tile color-stone" contenteditable="false" data-color="stone">
                        <span class="nk-text-tile-icon"></span>
                        <div class="nk-text-tile-color-cycler" title="Cycle Color"><i class="fa-solid fa-palette fa-xs"></i></div>
                        <div class="nk-text-tile-content" contenteditable="true" data-placeholder="First tile..."></div>
                    </div>
                    <div class="deck-add-tile-btn" title="Add another tile to this deck">+ Add Tile</div>
                </div>
                <p><br></p>`;
                    App.util.insertGuardianBlock(deckHTML);
                },

                convertListToDeck() {
                    const selection = window.getSelection();
                    if (!selection.rangeCount > 0) return;
                    const range = selection.getRangeAt(0);
                    const listNode = range.startContainer.parentElement.closest('ul, ol');

                    if (!listNode) {
                        App.ui.showToast("Place your cursor in a list to convert it.", { type: 'warning' });
                        return;
                    }

                    // --- FIX: Filter for solid colors only ---
                    const solidColors = this.state.textileColors.filter(c => !isNaN(c));
                    const listItems = listNode.querySelectorAll('li');
                    let tilesHTML = '';
                    listItems.forEach((item, index) => {
                        if (item.textContent.trim() === '') return;
                        // This now correctly cycles through only the 10 solid colors.
                        const color = solidColors[index % solidColors.length];
                        tilesHTML += `
                    <div class="nk-text-tile color-${color}" contenteditable="false" data-color="${color}">
                        <span class="nk-text-tile-icon"></span>
                        <div class="nk-text-tile-color-cycler" title="Cycle Color"><i class="fa-solid fa-palette fa-xs"></i></div>
                        <div class="nk-text-tile-content" contenteditable="true">${item.innerHTML}</div>
                    </div>`;
                    });

                    const deckHTML = `
                <div class="nk-textile-deck" contenteditable="false">
                    <div class="deck-layout-toggle" title="Toggle Layout"><i class="fa-solid fa-table-cells"></i></div>
                    ${tilesHTML}
                    <div class="deck-add-tile-btn" title="Add another tile to this deck">+ Add Tile</div>
                </div>`;

                    listNode.outerHTML = deckHTML;
                    App.state.isArticleDirty = true;
                    App.ui.showToast("List converted to Decktile!", { type: 'success' });
                },

                insertTextTile() {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) return;

                    // Capture selected text if any
                    const selectedText = selection.toString().trim();
                    const selectedHTML = selection.rangeCount > 0 ? (() => {
                        const range = selection.getRangeAt(0);
                        const container = document.createElement('div');
                        container.appendChild(range.cloneContents());
                        return container.innerHTML;
                    })() : '';

                    const solidColors = this.state.textileColors.filter(c => !isNaN(c));
                    const randomColor = solidColors[Math.floor(Math.random() * solidColors.length)];
                    const tileId = `tile-${crypto.randomUUID()}`;

                    // Include selected text/HTML in the textile if present
                    const textTileHTML = `
                    <div id="${tileId}" class="nk-text-tile color-${randomColor}" contenteditable="false" data-color="${randomColor}">
                        <div class="nk-text-tile-color-cycler" title="Cycle Color"><i class="fa-solid fa-palette fa-xs"></i></div>
                        <div class="nk-text-tile-content" contenteditable="true" data-placeholder="Type here...">${selectedHTML || ''}</div>
                    </div>
                    <p><br></p>`;

                    document.execCommand('insertHTML', false, textTileHTML);

                    setTimeout(() => {
                        const newTile = document.getElementById(tileId);
                        if (newTile) {
                            const contentArea = newTile.querySelector('.nk-text-tile-content');
                            if (contentArea) {
                                // If there was selected text, don't place cursor (text is already there)
                                // If empty, place cursor for immediate typing
                                if (!selectedText) {
                                    App.util.placeCursor(contentArea);
                                }
                            }
                        }
                    }, 50);

                    App.state.isArticleDirty = true;
                },

                convertSelectionToMcq() {
                    const selection = window.getSelection();
                    if (!selection || selection.isCollapsed) {
                        App.ui.showToast("Please select the text you want to convert.", { type: 'warning' });
                        return;
                    }

                    const text = selection.toString();
                    const mcqBlocks = App.util.parseMcqText(text);

                    if (!mcqBlocks || mcqBlocks.length === 0) {
                        App.ui.showToast("Could not parse as MCQ. Ensure you have a question line followed by at least 2 options (bullet points, letters, or numbered).", { type: 'error' });
                        return;
                    }

                    let processingToast = null;
                    if (mcqBlocks.length > 5) {
                        processingToast = App.ui.showToast(`Converting ${mcqBlocks.length} MCQs...`, { duration: 0, type: 'info' });
                    }

                    const fullHtml = mcqBlocks.map(block => {
                        const optionsHtml = block.options.map(optText => `
                            <div class="nk-mcq-option" data-is-correct="false">
                                <div class="nk-mcq-option-radio"></div>
                                <div class="nk-mcq-option-text" contenteditable="true">${App.util.escapeHtml(optText)}</div>
                                <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                            </div>
                        `).join('');

                        return `
                        <div class="nk-mcq-block" contenteditable="false">
                            <div class="nk-mcq-toolbar">
                                <button class="nk-mcq-copy-block" title="Copy MCQ"><i class="fa-solid fa-copy"></i></button>
                                <button class="nk-mcq-delete-block" title="Delete MCQ"><i class="fa-solid fa-trash"></i></button>
                            </div>
                            <div class="nk-mcq-question" contenteditable="true">${block.question}</div>
                            <div class="nk-mcq-options">${optionsHtml}</div>
                            <button class="btn btn-secondary nk-mcq-add-option">+ Add Option</button>
                            
                            <div class="nk-mcq-explanation" contenteditable="true" data-placeholder="Add answer explanation (optional)..."></div>
                        </div>
                        <p><br></p>`;
                    }).join('');

                    document.execCommand('insertHTML', false, fullHtml);
                    App.state.isArticleDirty = true;

                    if (processingToast) App.ui.hideToast(processingToast);
                    const msg = mcqBlocks.length > 1 ? `Successfully converted ${mcqBlocks.length} MCQs!` : "Text smartly converted to MCQ!";
                    App.ui.showToast(msg, { type: 'success' });
                },

                clearFormatting() {
                    const selection = window.getSelection();
                    if (!selection || selection.rangeCount === 0) return;

                    if (!selection.isCollapsed) {
                        // --- DEFINITIVE FIX: Hybrid Undoable AND Powerful Cleanup ---

                        // Step 1: Run the native, undoable command. This handles basic tags and creates the undo history.
                        document.execCommand('removeFormat', false, null);

                        // Step 2: Perform a powerful, surgical cleanup for everything the native command missed.
                        const newSelection = window.getSelection();
                        if (newSelection.rangeCount > 0) {
                            const range = newSelection.getRangeAt(0);
                            const commonAncestor = range.commonAncestorContainer;
                            const parentElement = commonAncestor.nodeType === 3 ? commonAncestor.parentElement : commonAncestor;

                            if (parentElement) {
                                // Find the parent block to ensure we only clean within the right scope.
                                const parentBlock = parentElement.closest('p, li, h1, h2, h3, h4, h5, h6, blockquote, div');

                                if (parentBlock) {
                                    // FIX: This selector is now comprehensive. It finds links, all highlight/color
                                    // classes, and any spans with inline styles (from /fontsize).
                                    const selector = 'a, span[class*="highlight-"], span[class*="text-"], span[style]';

                                    parentBlock.querySelectorAll(selector).forEach(elementToClean => {
                                        // We only unwrap the element if it's part of the user's selection.
                                        if (newSelection.containsNode(elementToClean, true)) {
                                            App.util.unwrapNode(elementToClean);
                                        }
                                    });
                                }
                            }
                        }

                        App.ui.showToast("Selection formatting cleared!", { type: 'success' });

                    } else {
                        const range = selection.getRangeAt(0);
                        const blockElement = range.startContainer.closest('p, li, h1, h2, h3, h4, h5, h6, blockquote, div');

                        if (blockElement) {
                            blockElement.removeAttribute('style');
                            const highlightClasses = [...App.config.highlightClasses, ...App.config.textClasses];
                            blockElement.classList.remove(...highlightClasses);
                            blockElement.querySelectorAll('[style], [class*="highlight-"], [class*="text-"], b, i, u, strong, em, del, a, .rendered-tag').forEach(el => {
                                App.util.unwrapNode(el);
                            });
                            App.ui.showToast("Block formatting cleared.", { type: 'success' });
                        } else {
                            App.ui.showToast("Place cursor inside a block to clear its formatting.", { type: 'warning' });
                        }
                    }

                    App.state.isArticleDirty = true;
                },

                async filter() {
                    const query = this.els.input.value;
                    const hasSelection = !!App.state.savedRange;
                    clearTimeout(this.state.debounceTimeout);
                    const kashAskMatch = query.match(/^kashask\s+(.*)/i);
                    const kashTranslateMatch = query.match(/^kashtranslate\s+(.*)/i);
                    const kashOutlineMatch = query.match(/^kashoutline\s+(.*)/i);
                    const kashExtractMatch = query.match(/^kashextract\s*(.*)/i);
                    const kashLinkMatch = query.match(/^kashlink\s+(.*)/i);
                    const tableMatch = query.match(/^table\s+(\d+)x(\d+)/i);

                    if (tableMatch) {
                        this.state.mode = 'commands';
                        const rows = parseInt(tableMatch[1], 10);
                        const cols = parseInt(tableMatch[2], 10);
                        this.state.filteredResults = [{
                            id: 'table-dynamic',
                            title: `Insert Table ${rows}x${cols}`,
                            desc: `Create (or Resize) table to ${rows} rows and ${cols} columns`,
                            icon: '',
                            execute: () => {
                                const selection = window.getSelection();
                                if (selection.rangeCount > 0) {
                                    let anchor = selection.anchorNode;
                                    if (anchor.nodeType === 3) anchor = anchor.parentElement;
                                    const table = anchor.closest('table');
                                    if (table) {
                                        App.events.table.update(table, rows, cols);
                                        App.ui.showToast(`Table resized to ${rows}x${cols}`, { type: 'success' });
                                    } else {
                                        App.events.table.create(rows, cols);
                                        App.ui.showToast(`Inserted ${rows}x${cols} Table`, { type: 'success' });
                                    }
                                } else {
                                    App.events.table.create(rows, cols);
                                }
                            }
                        }];
                        this.state.selectedIndex = 0;
                        this.render();
                        return;
                    }

                    if (kashAskMatch) {
                        this.state.mode = 'kashask';
                        const prompt = kashAskMatch[1].trim();
                        this.state.filteredResults = [{
                            id: 'kashask-action',
                            title: `Ask AI: "${prompt}"`,
                            desc: 'Press Enter to get an answer from the AI',
                            icon: '',
                            prompt: prompt
                        }];
                        this.state.selectedIndex = 0;
                        this.render();
                        return;
                    }

                    if (kashTranslateMatch) {
                        this.state.mode = 'kashtranslate';
                        const language = kashTranslateMatch[1].trim();
                        this.state.filteredResults = [{
                            id: 'kashtranslate-action',
                            title: `Translate selection to ${language}`,
                            desc: 'Press Enter to translate',
                            icon: '',
                            language: language
                        }];
                        this.state.selectedIndex = 0;
                        this.render();
                        return;
                    }
                    if (kashOutlineMatch) {
                        this.state.mode = 'kashoutline';
                        const topic = kashOutlineMatch[1].trim();
                        this.state.filteredResults = [{
                            id: 'kashoutline-action',
                            title: `Generate Outline for: "${topic}"`,
                            desc: 'Press Enter to generate the outline',
                            icon: '',
                            topic: topic
                        }];
                        this.state.selectedIndex = 0;
                        this.render();
                        return;
                    }
                    if (kashExtractMatch) {
                        this.state.mode = 'kashextract';
                        const subCommand = kashExtractMatch[1].trim();
                        this.state.filteredResults = [{
                            id: 'kashextract-action',
                            title: subCommand ? `Extract: "${subCommand}"` : 'Extract: Article Summary',
                            desc: 'Press Enter to query the article content',
                            icon: '',
                            subCommand: subCommand || 'default'
                        }];
                        this.state.selectedIndex = 0;
                        this.render();
                        return;
                    }

                    if (kashLinkMatch) {
                        this.state.mode = 'kashlink';
                        const topic = kashLinkMatch[1].trim();
                        this.state.filteredResults = [{
                            id: 'kashlink-action',
                            title: `Create & Link Note: "${topic}"`,
                            desc: 'Press Enter to generate a new note and link it here',
                            icon: '',
                            topic: topic
                        }];
                        this.state.selectedIndex = 0;
                        this.render();
                        return;
                    }





                    const mapMatch = query.match(/^map\s+(.*)/i);
                    if (mapMatch) {
                        this.state.mode = 'map';
                        let rawQuery = mapMatch[1].trim();

                        // Parse for map type keywords
                        let mapType = 'm'; // Default: m = roadmap
                        let mapTypeName = 'Roadmap';
                        let cleanQuery = rawQuery;

                        if (/\b(?:earth|satellite)\b/i.test(rawQuery)) {
                            mapType = 'k'; // k = satellite
                            mapTypeName = 'Satellite';
                            cleanQuery = rawQuery.replace(/\b(?:earth|satellite)\b/gi, '').trim();
                        } else if (/\b(?:terrain|physical)\b/i.test(rawQuery)) {
                            mapType = 'p'; // p = terrain
                            mapTypeName = 'Terrain';
                            cleanQuery = rawQuery.replace(/\b(?:terrain|physical)\b/gi, '').trim();
                        } else if (/\b(?:hybrid)\b/i.test(rawQuery)) {
                            mapType = 'h'; // h = hybrid
                            mapTypeName = 'Hybrid';
                            cleanQuery = rawQuery.replace(/\b(?:hybrid)\b/gi, '').trim();
                        }

                        this.state.filteredResults = [{
                            id: 'map-action',
                            title: `Insert ${mapTypeName} Map`,
                            desc: cleanQuery ? `Location: ${cleanQuery}` : 'Type a location...',
                            icon: '',
                            execute: () => {
                                if (!cleanQuery) return;
                                const embedUrl = `https://maps.google.com/maps?q=${encodeURIComponent(cleanQuery)}&t=${mapType}&ie=UTF8&iwloc=&output=embed`;

                                // Premium styling with Controls:
                                const mapHtml = `
                                <div class="nk-map-embed" contenteditable="false" tabindex="0" style="width: 100%; max-width: 800px; aspect-ratio: 16/9; margin: 25px auto; border-radius: 16px; overflow: hidden; background: var(--bg-secondary, #222); box-shadow: 0 8px 30px rgba(0,0,0,0.15); border: 1px solid rgba(255,255,255,0.1); position: relative; resize: both; min-width: 300px; min-height: 200px;">
                                    <div class="nk-map-controls">
                                        <div class="nk-map-btn" data-action="fullscreen" onclick="App.handleMapAction(event, 'fullscreen')" title="Toggle Fullscreen"><i class="fa-solid fa-expand"></i></div>
                                        <div class="nk-map-btn" data-action="edit" onclick="App.handleMapAction(event, 'edit')" title="Edit Location"><i class="fa-solid fa-pen"></i></div>
                                        <div class="nk-map-btn is-delete" data-action="delete" onclick="App.handleMapAction(event, 'delete')" title="Remove Map"><i class="fa-solid fa-xmark"></i></div>
                                    </div>
                                    <iframe src="${embedUrl}" style="width: 100%; height: 100%; border: none; display: block;" frameborder="0" scrolling="no" marginheight="0" marginwidth="0"></iframe>
                                    <div style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:-1;"></div>
                                </div>
                                <p><br></p>`;

                                App.util.insertGuardianBlock(mapHtml);
                                App.state.isArticleDirty = true;
                                App.ui.showToast(`Embedded ${mapTypeName} map found!`, { type: 'success' });
                            }


                        }];
                        this.state.selectedIndex = 0;
                        this.render();
                        return;
                    }

                    const videoMatch = query.match(/^video\s+((?:https?:\/\/)?\S+)/i);
                    if (videoMatch) {
                        this.state.mode = 'video';
                        let url = videoMatch[1];
                        if (!/^(https?:\/\/)/i.test(url)) url = 'https://' + url;

                        let platform = 'generic';
                        let videoId = null;
                        let embedUrl = url;
                        let displayTitle = 'Embed Video';
                        let displayIcon = '';
                        let isYoutubeShort = false;

                        // 1. YouTube (including Shorts)
                        const ytMatch = url.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?|shorts)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i);
                        if (ytMatch) {
                            platform = 'youtube';
                            videoId = ytMatch[1];
                            isYoutubeShort = /\/shorts\//i.test(url);
                            embedUrl = `https://www.youtube-nocookie.com/embed/${videoId}?rel=0&modestbranding=1`;
                            displayTitle = isYoutubeShort ? 'Embed YouTube Short' : 'Embed YouTube Video';
                            displayIcon = '';
                        }

                        // 2. Twitter / X
                        if (platform === 'generic') {
                            const twMatch = url.match(/(?:twitter\.com|x\.com)\/(?:#!\/)?(\w+)\/status(?:es)?\/(\d+)/i);
                            if (twMatch) {
                                platform = 'twitter';
                                videoId = twMatch[2]; // Captures the ID
                                // Use the platform.twitter.com embed endpoint for iframes
                                embedUrl = `https://platform.twitter.com/embed/Tweet.html?id=${videoId}&dnt=false&theme=light`;
                                displayTitle = 'Embed Tweet/Video';
                                displayIcon = ''; // Bird
                            }
                        }

                        // 3. Instagram
                        if (platform === 'generic') {
                            const igMatch = url.match(/(?:instagram\.com|instagr\.am)\/(?:p|reel|tv)\/([a-zA-Z0-9_-]+)/i);
                            if (igMatch) {
                                platform = 'instagram';
                                videoId = igMatch[1];
                                embedUrl = `https://www.instagram.com/p/${videoId}/embed`;
                                displayTitle = 'Embed Instagram Post';
                                displayIcon = ''; // Camera
                            }
                        }

                        this.state.filteredResults = [{
                            id: 'video-action',
                            title: displayTitle,
                            desc: videoId ? `ID: ${videoId}  Source: ${platform}` : url,
                            icon: displayIcon,
                            url: url,
                            platform: platform,
                            execute: () => {
                                // Default styling for 16:9 videos
                                let containerStyle = "width: 100%; max-width: 800px; aspect-ratio: 16/9; margin: 10px auto; border-radius: 12px; overflow: hidden; background: #000; box-shadow: 0 4px 12px rgba(0,0,0,0.1); resize: both;";
                                let showAlignBtn = false;
                                if (platform === 'instagram' || isYoutubeShort) {
                                    containerStyle = "width: 320px; max-width: 100%; aspect-ratio: 9/16; margin: 25px auto; border-radius: 12px; overflow: hidden; background: transparent; box-shadow: 0 8px 30px rgba(0,0,0,0.12); border: 1px solid rgba(0,0,0,0.05); resize: both;";
                                    showAlignBtn = true;
                                } else if (platform === 'twitter') {
                                    containerStyle = "width: 400px; max-width: 100%; height: 600px; min-height: 300px; margin: 25px auto; border-radius: 12px; overflow-y: auto; scrollbar-width: none; -ms-overflow-style: none; background: transparent; resize: both;";
                                    showAlignBtn = true;
                                }

                                const alignBtnHtml = showAlignBtn ? `<div class="nk-video-align-btn" title="Toggle Newspaper Mode"><i class="fa-solid fa-align-left"></i></div>` : '';

                                let iframeHtml = '';
                                if (platform === 'youtube') {
                                    const ratioAttr = isYoutubeShort ? 'data-ratio="9:16"' : '';
                                    iframeHtml = `
                                <div class="nk-video-embed" contenteditable="false" tabindex="0" style="${containerStyle}">
                                    <div class="nk-video-delete-btn" title="Remove Video"><i class="fa-solid fa-xmark"></i></div>
                                    ${alignBtnHtml}
                                    <div class="nk-plyr-wrapper" data-provider="youtube" data-embed-id="${videoId}" ${ratioAttr}>
                                        <div class="js-plyr-video" data-plyr-provider="youtube" data-plyr-embed-id="${videoId}" ${ratioAttr}></div>
                                    </div>
                                </div>
                                <p><br></p>`;
                                    // Auto-init Plyr after insertion
                                    setTimeout(() => App.util.initPlyr(document.getElementById('article-content')), 100);
                                } else {
                                    // Standard iframe for others (Twitter/Instagram) - keeping existing logic
                                    iframeHtml = `
                                <div class="nk-video-embed" contenteditable="false" tabindex="0" style="${containerStyle}">
                                    <div class="nk-video-delete-btn" title="Remove Video"><i class="fa-solid fa-xmark"></i></div>
                                    ${alignBtnHtml}
                                    <iframe src="${embedUrl}" style="width: 100%; height: 100%; border: none;" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                                </div>
                                <p><br></p>`;
                                }

                                App.util.insertGuardianBlock(iframeHtml);
                                App.state.isArticleDirty = true;
                                App.ui.showToast(`${displayTitle} embedded!`, { type: 'success' });
                            }
                        }];
                        this.state.selectedIndex = 0;
                        this.render();
                        return;
                    }

                    const clipMatch = query.match(/^clip\s+((?:https?:\/\/)?\S+)/i);
                    if (clipMatch) {
                        this.state.mode = 'clip';
                        let url = clipMatch[1];

                        if (!/^(https?:\/\/)/i.test(url)) {
                            url = 'https://' + url;
                        }
                        this.state.filteredResults = [{
                            id: 'clip-action',
                            title: `Clip Content from URL`,
                            desc: url,
                            icon: '',
                            url: url
                        }];
                        this.state.selectedIndex = 0;
                        this.render();
                        return;
                    }

                    const categoryMatch = query.match(/^category\s*(.*)/i);
                    if (query.toLowerCase().startsWith('define ')) {
                        this.state.mode = 'definitions';
                        const searchTerm = query.substring(7).trim();
                        if (searchTerm.length === 0) {
                            this.state.filteredResults = [{ type: 'definition-prompt', title: 'e.g., define serendipity', desc: 'Type a word to get its definition.' }];
                        } else if (searchTerm.length >= 2) {
                            this.state.isFetching = true; this.render();
                            this.state.debounceTimeout = setTimeout(async () => {
                                this.state.filteredResults = await this.fetchDefinition(searchTerm);
                                this.render();
                            }, 400);
                            return;
                        } else {
                            this.state.filteredResults = [];
                        }
                    } else if (query.toLowerCase().startsWith('hig ')) {
                        this.state.mode = 'block-highlight';
                        const searchTerm = query.substring(4).trim().toLowerCase();
                        this.state.filteredResults = searchTerm ? this.state.highlightOptions.filter(opt => opt.id.toLowerCase().startsWith(searchTerm) || opt.title.toLowerCase().includes(searchTerm)) : this.state.highlightOptions;
                    } else if (query.toLowerCase().startsWith('link ')) {
                        if (!this.state.fuse.links) {
                            App.ui.showToast('Indexing items for linking...', { type: 'info', duration: 1500 });
                            const linkableData = [
                                ...App.state.articles.map(a => ({ type: 'article', id: a.id, title: a.title, desc: `Article: ${a.title}` })),
                                ...App.util.extractSnippets(null, 'highlight').map(s => ({ type: 'snippet', id: s.id, title: s.text, desc: `Snippet in: ${App.storage.getArticle(s.articleId)?.title}`, articleId: s.articleId }))
                            ];

                            // --- TASKS INTEGRATION ---
                            const tasksSource = (App.hub && App.hub.state && App.hub.state.tasks) ? App.hub.state.tasks : [];

                            if (Array.isArray(tasksSource)) {
                                linkableData.push(...tasksSource.map(t => ({
                                    type: 'task',
                                    id: t.id,
                                    title: t.title,
                                    desc: `Task: ${t.priority ? t.priority.toUpperCase() : 'General'}  ${t.status || 'To Do'}`,
                                    raw: t
                                })));
                            }

                            // Re-index tags for "link" command specifically (User request #1-c)
                            Object.values(App.state.tags).forEach(tag => {
                                linkableData.push({
                                    type: 'tag',
                                    id: tag.displayName, // Use name as ID for tags here
                                    title: tag.displayName,
                                    desc: `Tag used in ${tag.articles ? tag.articles.length : 0} notes`,
                                    articleId: tag.articles ? tag.articles[0] : null // Keep a reference to one article for context
                                });
                            });

                            this.state.fuse.links = App.offline.safeFuse(linkableData, { keys: ['title', 'desc'], threshold: 0.3 });
                        }
                        this.state.mode = 'links'; const searchTerm = query.substring(5).trim();
                        if (!searchTerm) { this.state.filteredResults = App.state.articles.slice(0, 500).map(a => ({ type: 'article', id: a.id, title: a.title, desc: `Article: ${a.title}` })); } else { this.state.filteredResults = this.state.fuse.links.search(searchTerm).map(r => r.item); }
                    } else if (query.toLowerCase().startsWith('tag ')) {
                        if (!this.state.fuse.tags) { const tagData = Object.values(App.state.tags).map(tag => ({ ...tag, articleId: tag.articles ? tag.articles[0] : null })); this.state.fuse.tags = App.offline.safeFuse(tagData, { keys: ['displayName'], threshold: 0.3 }); }
                        this.state.mode = 'tags'; const searchTerm = query.substring(4).trim();
                        if (!searchTerm) { this.state.filteredResults = Object.values(App.state.tags).sort((a, b) => a.displayName.localeCompare(b.displayName)); } else { this.state.filteredResults = this.state.fuse.tags.search(searchTerm).map(r => r.item); }
                    } else if (categoryMatch) {
                        this.state.mode = 'categories';
                        const searchTerm = categoryMatch[1].trim(); // Get the search term from the regex
                        const userCategories = App.settings.get('userCategories');
                        const categoryData = userCategories.map(c => ({
                            id: c.name, // The internal name for execution
                            name: App.util.getCategoryDisplayName(c.name) // The display name for UI
                        }));
                        if (!this.state.fuse.categories) {
                            this.state.fuse.categories = App.offline.safeFuse(categoryData, { keys: ['name'], threshold: 0.3 });
                        }

                        if (!searchTerm) {
                            this.state.filteredResults = categoryData.sort((a, b) => a.name.localeCompare(b.name));
                        } else {
                            this.state.filteredResults = this.state.fuse.categories.search(searchTerm).map(r => r.item);
                        }
                    } else if (query.toLowerCase().startsWith('emoji')) {
                        this.state.mode = 'emojis';
                        const arg = query.substring(5).trim(); // Get text after 'emoji'

                        if (arg) {
                            // If there's a search term, filter emojis
                            this.state.filteredResults = this.state.fuse.emojis.search(arg).map(r => r.item);
                        } else {
                            // If just 'emoji' or 'emoji ', show all emojis
                            this.state.filteredResults = this.state.emojiData;
                        }
                    } else if (query.toLowerCase().startsWith('icon')) {
                        this.state.mode = 'icons';
                        const arg = query.substring(4).trim(); // Get text after 'icon'

                        if (arg) {
                            // If there's a search term, filter icons
                            this.state.filteredResults = this.state.fuse.icons.search(arg).map(r => r.item);
                        } else {
                            // If just 'icon' or 'icon ', show all icons
                            this.state.filteredResults = this.state.iconData;
                        }
                    } else if (query.toLowerCase().startsWith('img ') || query.toLowerCase() === 'img') {
                        // Handle /img command - insert external URL-based image
                        this.state.mode = 'img';
                        const url = query.substring(3).trim();

                        if (url) {
                            // User provided a URL
                            this.state.filteredResults = [{
                                id: 'img-action',
                                title: 'Insert External Image',
                                desc: url,
                                icon: '',
                                url: url
                            }];
                        } else {
                            // Just 'img' - show help
                            this.state.filteredResults = [{
                                id: 'img-help',
                                title: 'External Image',
                                desc: 'Type: img https://example.com/image.jpg',
                                icon: ''
                            }];
                        }
                    } else if (query.toLowerCase().startsWith('textile ')) { // NEW: Handle /textile command for initial text
                        this.state.mode = 'commands'; // Still in commands mode, but pre-populating a command
                        const text = query.substring(8).trim();
                        this.state.filteredResults = [{
                            id: 'textile-dynamic',
                            title: 'Insert Text Tile',
                            desc: text || 'Create a visually distinct text block',
                            icon: '',
                            execute: () => App.commandPalette.insertTextTile()
                        }];
                    } else if (query.toLowerCase().startsWith('fontsize')) {
                        this.state.mode = 'font-sizes';
                        const arg = query.substring(8).trim();
                        let results = [];

                        if (arg) {
                            // Smart handling: if user types a number, try to match it to a rem size
                            const numValue = parseFloat(arg);
                            if (!isNaN(numValue) && isFinite(numValue)) {
                                // Convert to rem if it's just a number
                                const remValue = `${numValue}rem`;

                                // Check if this exact size exists in our options
                                if (this.state.fontSizeOptions.includes(remValue)) {
                                    results.push(remValue);
                                }
                            }

                            // Also do fuzzy search to show related options
                            if (!this.state.fuse.fontSizes) {
                                this.state.fuse.fontSizes = App.offline.safeFuse(this.state.fontSizeOptions);
                            }
                            results = results.concat(this.state.fuse.fontSizes.search(arg).map(r => r.item));
                        } else {
                            results = this.state.fontSizeOptions;
                        }

                        this.state.filteredResults = [...new Set(results)];
                    } else if (query.toLowerCase().startsWith('fontfamily') || query.toLowerCase().startsWith('fontfam')) {
                        this.state.mode = 'font-families';
                        const commandLength = query.toLowerCase().startsWith('fontfamily') ? 10 : 7;
                        const arg = query.substring(commandLength).trim();
                        this.state.filteredResults = arg ? this.state.fuse.fontFamilies.search(arg).map(r => r.item) : this.state.fontFamilyOptions;
                    } else {
                        this.state.mode = 'commands';
                        let results = query ? this.state.fuse.commands.search(query).map(r => r.item) : this.state.commands;
                        if (!hasSelection) {
                            results = results.filter(cmd => !cmd.selection);
                        }
                        this.state.filteredResults = results;
                    }

                    this.state.selectedIndex = 0;
                    this.render();
                },

                render() {
                    if (this.state.isFetching) { this.els.list.innerHTML = `<div class="command-item"><div class="command-item-icon spin"></div><div class="command-item-text"><div class="command-item-title">Fetching definition...</div></div></div>`; return; }
                    if (this.state.filteredResults.length === 0) { this.els.list.innerHTML = `<div class="command-item"><div class="command-item-text"><div class="command-item-title">No results found</div></div></div>`; return; }

                    //  SPECIAL GRID LAYOUT FOR EMOJIS - Space-efficient & modern!
                    if (this.state.mode === 'emojis') {
                        const gridHTML = this.state.filteredResults.map((item, index) => {
                            const isSelected = index === this.state.selectedIndex ? 'selected' : '';
                            return `<div class="emoji-grid-item ${isSelected}" data-index="${index}" title="${App.util.escapeHtml(item.name || 'Emoji')}">${item.e}</div>`;
                        }).join('');

                        this.els.list.innerHTML = `<div class="emoji-grid">${gridHTML}</div>`;
                        this.els.list.querySelectorAll('.emoji-grid-item').forEach(item => {
                            item.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                this.state.selectedIndex = parseInt(e.currentTarget.dataset.index, 10);
                                this.execute();
                            });
                        });
                        this._updateSelection();
                        return;
                    }

                    //  SPECIAL GRID LAYOUT FOR ICONS - Similar treatment
                    if (this.state.mode === 'icons') {
                        const gridHTML = this.state.filteredResults.map((item, index) => {
                            const isSelected = index === this.state.selectedIndex ? 'selected' : '';
                            return `<div class="emoji-grid-item ${isSelected}" data-index="${index}" title="${App.util.escapeHtml(item.icon)}"><i class="${item.class}"></i></div>`;
                        }).join('');

                        this.els.list.innerHTML = `<div class="emoji-grid">${gridHTML}</div>`;
                        this.els.list.querySelectorAll('.emoji-grid-item').forEach(item => {
                            item.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                this.state.selectedIndex = parseInt(e.currentTarget.dataset.index, 10);
                                this.execute();
                            });
                        });
                        this._updateSelection();
                        return;
                    }

                    // Regular list rendering for other modes
                    this.els.list.innerHTML = this.state.filteredResults.map((item, index) => {
                        let icon = '?', title = 'Unknown', desc = '';

                        switch (this.state.mode) {
                            case 'kashask':
                            case 'kashtranslate':
                                icon = item.icon;
                                title = item.title;
                                desc = item.desc;
                                break;
                            case 'definitions':
                                if (item.type === 'definition-prompt') {
                                    icon = ''; title = item.title; desc = item.desc;
                                } else if (item.error) {
                                    icon = ''; title = item.error; desc = 'Try another word.';
                                } else { icon = ''; title = `${item.word} (${item.partOfSpeech})`; desc = item.definition; }
                                break;
                            case 'block-highlight': icon = item.icon; title = item.title; desc = item.desc; break;
                            case 'links': icon = item.type === 'article' ? '' : ''; title = item.title; desc = item.desc; break;
                            case 'tags': icon = ''; title = item.displayName; desc = `Insert tag: ${item.displayName}`; break;
                            case 'categories': icon = ''; title = item.name; desc = `Set article category to ${item.name}`; break;
                            case 'font-sizes':
                                icon = 'Aa';
                                const fullText = `${item} is font-size`;
                                return `<div class="command-item ${index === this.state.selectedIndex ? 'selected' : ''}" data-index="${index}">
                                        <div class="command-item-icon">${icon}</div>
                                        <div class="command-item-text">
                                            <div class="command-item-title" style="font-size: ${item}; font-weight: 500;">${fullText}</div>
                                        </div>
                                    </div>`;
                            case 'font-families':
                                icon = 'Ab';
                                title = item.name;
                                desc = `Apply font family: ${item.value.split(',')[0]}`;
                                return `<div class="command-item ${index === this.state.selectedIndex ? 'selected' : ''}" data-index="${index}"><div class="command-item-icon">${icon}</div><div class="command-item-text"><div class="command-item-title" style="font-family: ${item.value};">${App.util.escapeHtml(title)}</div><div class="command-item-desc">${App.util.escapeHtml(desc)}</div></div></div>`;
                            default: icon = item.icon; title = item.title; desc = item.desc; break;
                        }
                        return `<div class="command-item ${index === this.state.selectedIndex ? 'selected' : ''}" data-index="${index}"><div class="command-item-icon">${icon}</div><div class="command-item-text"><div class="command-item-title">${App.util.escapeHtml(title)}</div><div class="command-item-desc">${App.util.escapeHtml(desc)}</div></div></div>`;
                    }).join('');

                    // --- NEW: Logic to add the premium upsell message for Spark Tier users ---
                    if (!App.license.isPremium()) {
                        const wittyMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
                        const upsellHTML = `
                        <div id="command-palette-upsell" class="command-item" style="cursor: pointer; border-top: 1px solid var(--border-color); margin-top: 4px; padding-top: 8px;">
                            <div class="command-item-icon"></div>
                            <div class="command-item-text">
                                <div class="command-item-title" style="color: var(--primary-color);">Unlock Pro Commands</div>
                                <div class="command-item-desc">${wittyMessage}</div>
                            </div>
                        </div>`;
                        this.els.list.insertAdjacentHTML('beforeend', upsellHTML);
                        const upsellEl = document.getElementById('command-palette-upsell');
                        if (upsellEl) {
                            upsellEl.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                App.ui.showAscensionModal();
                                this.close();
                            });
                        }
                    }
                    // --- END of new logic ---

                    this.els.list.querySelectorAll('.command-item:not(#command-palette-upsell)').forEach(item => { item.addEventListener('mousedown', (e) => { e.preventDefault(); this.state.selectedIndex = parseInt(e.currentTarget.dataset.index, 10); this.execute(); }); });
                    this._updateSelection();
                },

                applyStyle(property, value) {
                    const selection = window.getSelection();
                    if (!selection || selection.rangeCount === 0) return;

                    const range = selection.getRangeAt(0);
                    const contentDiv = document.getElementById('article-content');

                    if (!contentDiv.contains(range.commonAncestorContainer)) return;
                    if (!selection.isCollapsed) {
                        const span = document.createElement('span');
                        span.style[property] = value;

                        // Mark user-applied font-family so it's preserved on paste
                        if (property === 'fontFamily') {
                            span.setAttribute('data-user-font', 'true');
                        }

                        try {
                            range.surroundContents(span);
                        } catch (e) {
                            console.warn("Could not use surroundContents, falling back to insertHTML.", e);
                            const userFontAttr = property === 'fontFamily' ? ' data-user-font="true"' : '';
                            document.execCommand('insertHTML', false, `<span style="${property.replace(/([A-Z])/g, '-$1').toLowerCase()}:${value};"${userFontAttr}>${selection.toString()}</span>`);
                        }
                    }
                    else {
                        let blockElement = range.startContainer;
                        if (blockElement.nodeType === Node.TEXT_NODE) {
                            blockElement = blockElement.parentElement;
                        }

                        blockElement = blockElement.closest('p, li, h1, h2, h3, h4, h5, h6, blockquote, div');

                        if (blockElement && contentDiv.contains(blockElement)) {
                            blockElement.style[property] = value;

                            // Mark user-applied font-family so it's preserved on paste
                            if (property === 'fontFamily') {
                                blockElement.setAttribute('data-user-font', 'true');
                            }
                        }
                    }

                    App.state.isArticleDirty = true;
                },

                execute() {
                    const item = this.state.filteredResults[this.state.selectedIndex];
                    if (!item || item.type === 'suggestion') return;

                    if (item.type === 'premium-upsell') {
                        App.ui.showAscensionModal();
                        this.close();
                        return; // Stop execution here.
                    }

                    if (this.state.isPreviewActive) {
                        this._restoreEditor();
                    }

                    if (App.state.savedRange) {
                        const selection = window.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(App.state.savedRange);
                    } else if (this.state.cursorMarkerId) {
                        const markerNode = document.getElementById(this.state.cursorMarkerId);
                        if (markerNode) {
                            const sel = window.getSelection();
                            const range = document.createRange();
                            range.setStartBefore(markerNode);
                            range.collapse(true);
                            sel.removeAllRanges();
                            sel.addRange(range);
                            markerNode.parentNode.removeChild(markerNode);
                        }
                    }
                    App.state.savedRange = null;
                    this.state.cursorMarkerId = null;

                    try {
                        switch (this.state.mode) {
                            case 'kashask':
                                if (item.prompt) App.events.ai.executeKashAsk(item.prompt);
                                break;
                            case 'kashtranslate':
                                if (item.language) App.events.ai.executeKashTranslate(item.language);
                                break;
                            case 'kashextract':
                                if (item.subCommand) App.events.ai.executeKashExtract(item.subCommand);
                                break;
                            case 'kashlink':
                                if (item.topic) App.events.ai.executeKashLink(item.topic);
                                break;
                            case 'kashoutline':
                                if (item.topic) App.events.ai.executeKashOutline(item.topic);
                                break;
                            case 'block-highlight': this.applyBlockHighlight(item.className); break;
                            case 'links':
                                if (item.type === 'task') {
                                    // REQ #2: Nice looking button
                                    const btnHtml = `<span class="nk-task-link" data-taskId="${item.id}" contenteditable="false"> ${App.util.escapeHtml(item.title)}</span>`;
                                    document.execCommand('insertHTML', false, `&nbsp;${btnHtml}&nbsp;`);
                                } else {
                                    document.execCommand('insertHTML', false, item.type === 'snippet' ? `<a href="#" data-link-type="snippet" data-article-id="${item.articleId}" data-link-id="${item.id}">${item.title}</a>` : `<a href="#" data-link-type="article" data-link-id="${item.id}">${item.title}</a>`);
                                }
                                break;
                            case 'tags': document.execCommand('insertHTML', false, `<span class="rendered-tag" data-tag="${item.id}">${item.displayName}</span>`); break;
                            case 'categories': const categorySelector = document.getElementById('category-selector'); if (categorySelector) { categorySelector.value = item.id; App.events.saveArticle({ isAutosave: true }); App.ui.showToast(`Category set to ${item.name}`, { type: 'success' }); } break;
                            case 'font-sizes':
                                // Validate that this is an allowed font size
                                if (this.state.fontSizeOptions.includes(item)) {
                                    this.applyStyle('fontSize', item);
                                } else {
                                    App.ui.showToast(`Font size "${item}" is not available. Please use sizes from 0.8rem to 2.5rem (in 0.1 increments) or 3rem.`, { type: 'error' });
                                }
                                break;
                            case 'font-families':
                                const freeFonts = [
                                    'Arial, Helvetica, sans-serif', 'Cambria, Cochin, Georgia, Times, "Times New Roman", serif',
                                    "'Courier New', Courier, monospace", 'Garamond, serif', 'Georgia, serif',
                                    'Helvetica, Arial, sans-serif', 'Monaco, "Lucida Console", monospace',
                                    'Palatino, "Palatino Linotype", serif', 'sans-serif', "'Times New Roman', Times, serif",
                                    'Verdana, Geneva, sans-serif'
                                ];
                                const isPremiumFont = !freeFonts.includes(item.value);

                                if (isPremiumFont && !App.license.isPremium()) {
                                    App.ui.showAscensionModal();
                                } else {
                                    this.applyStyle('fontFamily', item.value);
                                }
                                break;
                            case 'emojis': document.execCommand('insertText', false, item.e); break;
                            case 'icons':
                                // Insert icon cleanly - inherits font-size, no style pollution
                                document.execCommand('insertHTML', false, `<i class="${item.class}"></i> `);
                                break;
                            case 'definition-prompt': break;
                            case 'definitions':
                                if (item.error) { App.ui.showToast(item.error, 'error'); break; }
                                let definitionHTML = `<b>${item.word}</b> (<i>${item.partOfSpeech}</i>)<blockquote>${item.definition}</blockquote>`;
                                if (item.synonyms) { definitionHTML += `<p><b>Synonyms:</b> ${item.synonyms}</p>`; }
                                definitionHTML += `<p><br></p>`;
                                document.execCommand('insertHTML', false, definitionHTML);
                                break;
                            case 'clip':
                                if (item && item.url) {
                                    App.contentTools.clipArticle(item.url);
                                }
                                break;
                            case 'img':
                                // Get URL from: 1) typed after command, 2) selected text, 3) current line
                                let imageUrl = '';

                                if (item && item.url) {
                                    // URL provided directly via command (e.g., "img https://...")
                                    imageUrl = item.url.trim();
                                } else {
                                    // Try to get URL from selection or current line
                                    const sel = window.getSelection();
                                    const selectedText = sel.toString().trim();

                                    if (selectedText && /^(https?:\/\/|www\.)/i.test(selectedText)) {
                                        // Selected text is a URL
                                        imageUrl = selectedText;
                                    } else if (sel.rangeCount > 0) {
                                        // Check current line for URL
                                        const range = sel.getRangeAt(0);
                                        let lineNode = range.startContainer;
                                        // Get parent element for text nodes
                                        if (lineNode.nodeType === Node.TEXT_NODE) {
                                            lineNode = lineNode.parentElement;
                                        }
                                        // Find block-level parent (p, div, etc.)
                                        while (lineNode && !['P', 'DIV', 'LI', 'BLOCKQUOTE'].includes(lineNode.tagName)) {
                                            lineNode = lineNode.parentElement;
                                        }
                                        if (lineNode) {
                                            const lineText = lineNode.textContent.trim();
                                            // Extract URL from line using regex
                                            const urlMatch = lineText.match(/(https?:\/\/[^\s]+|www\.[^\s]+)/i);
                                            if (urlMatch) {
                                                imageUrl = urlMatch[0];
                                            }
                                        }
                                    }
                                }

                                if (!imageUrl) {
                                    App.ui.showToast('No image URL found. Select a URL or type: img https://...', { type: 'warning' });
                                    break;
                                }

                                // Auto-add https if missing protocol
                                if (!/^(https?:\/\/)/i.test(imageUrl)) {
                                    imageUrl = 'https://' + imageUrl;
                                }
                                // Validate URL format
                                try {
                                    new URL(imageUrl);
                                } catch {
                                    App.ui.showToast('Invalid URL format', { type: 'error' });
                                    break;
                                }

                                // If selected text was used, remove it first
                                const selForRemoval = window.getSelection();
                                if (selForRemoval.toString().trim() && /^(https?:\/\/|www\.)/i.test(selForRemoval.toString().trim())) {
                                    document.execCommand('delete', false, null);
                                } else if (selForRemoval.rangeCount > 0) {
                                    // Remove the entire line if URL was extracted from it
                                    const range = selForRemoval.getRangeAt(0);
                                    let lineNode = range.startContainer;
                                    if (lineNode.nodeType === Node.TEXT_NODE) {
                                        lineNode = lineNode.parentElement;
                                    }
                                    while (lineNode && !['P', 'DIV', 'LI', 'BLOCKQUOTE'].includes(lineNode.tagName)) {
                                        lineNode = lineNode.parentElement;
                                    }
                                    if (lineNode && lineNode.textContent.includes(imageUrl.replace('https://', '').replace('http://', ''))) {
                                        lineNode.remove();
                                    }
                                }

                                // Insert external image with same styling as regular images
                                const imgHtml = `<div class="image-container image-external" contenteditable="false"><img src="${imageUrl}" alt="External image" style="max-width:100%; height:auto; border-radius: var(--border-radius);" onerror="this.parentElement.classList.add('image-load-error')"><div class="resize-handle resize-handle-se"></div></div>`;
                                document.execCommand('insertHTML', false, `<p>${imgHtml}</p><p><br></p>`);
                                App.state.isArticleDirty = true;
                                App.ui.showToast('External image inserted!', { type: 'success' });
                                break;
                            default:
                                if (item.isPremium && !App.license.isPremium()) {
                                    App.ui.showAscensionModal();
                                } else if (item.execute) {
                                    item.execute();
                                }
                                break;
                        }
                    } catch (e) {
                        console.error("Command execution failed:", e);
                        if (item.isPremium && !App.license.isPremium()) {
                            App.ui.showToast("This is a Premium feature. Upgrade to unlock.", "warning");
                        } else {
                            App.ui.showToast('Command failed.', 'error');
                        }
                    }

                    const selection = window.getSelection();
                    const savedCursorRange = selection.rangeCount > 0 ? selection.getRangeAt(0).cloneRange() : null;

                    // Save scroll position
                    const mainContainer = document.querySelector('main');
                    const savedScrollTop = mainContainer ? mainContainer.scrollTop : 0;

                    this.els.palette.style.display = 'none';

                    const contentDiv = document.getElementById('article-content');
                    if (contentDiv) {
                        // Focus WITHOUT scrolling using preventScroll option
                        contentDiv.focus({ preventScroll: true });

                        // Restore scroll position first
                        if (mainContainer) {
                            mainContainer.scrollTop = savedScrollTop;
                        }

                        // Then restore cursor position
                        if (savedCursorRange) {
                            try {
                                selection.removeAllRanges();
                                selection.addRange(savedCursorRange);
                            } catch (e) {
                                // Silently fail if restoration doesn't work
                                console.warn('Could not restore cursor position:', e);
                            }
                        }
                    }

                    this.state.isOpen = false;
                    document.removeEventListener('click', this.handleClickOutside, true);
                },


                close() {
                    if (!this.state.isOpen) return;
                    this._restoreEditor();

                    // 2. Clean up any temporary markers.
                    const markerNode = document.getElementById(this.state.cursorMarkerId);
                    if (markerNode) {
                        markerNode.parentNode.removeChild(markerNode);
                    }

                    // 3. Reset all state and UI elements.
                    this.state.isOpen = false;
                    App.state.savedRange = null;
                    this.state.cursorMarkerId = null;

                    // Remove preview pane if exists
                    const previewPane = this.els.palette.querySelector('.nk-command-palette-preview');
                    if (previewPane) previewPane.remove();

                    if (this.els.palette) this.els.palette.style.display = 'none';
                    if (this.els.input) this.els.input.value = '';

                    document.removeEventListener('click', this.handleClickOutside, true);

                    // 4. Return focus to the editor for a seamless experience.
                    const contentDiv = document.getElementById('article-content');
                    if (contentDiv) contentDiv.focus();
                },

                handleKeyDown(e) {
                    if (!this.state.isOpen) return;
                    // FIX: Correct backspace behavior
                    if (e.key === 'Escape') { e.preventDefault(); this.close(); return; }
                    if (e.key === 'Backspace' && this.els.input.value === '') { e.preventDefault(); this.close(); return; }
                    if (e.key === '/') { e.preventDefault(); this.exitAndInsertSlash(); return; }

                    if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (e.key === 'ArrowDown') { this.state.selectedIndex = (this.state.selectedIndex + 1) % this.state.filteredResults.length; }
                        else { this.state.selectedIndex = (this.state.selectedIndex - 1 + this.state.filteredResults.length) % this.state.filteredResults.length; }
                        this.render();
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        this.execute();
                    }
                },
                exitAndInsertSlash() {
                    if (!this.state.isOpen) return;
                    this._restoreEditor();
                    const markerNode = document.getElementById(this.state.cursorMarkerId);
                    if (markerNode) {
                        const slashNode = document.createTextNode('/'); markerNode.parentNode.insertBefore(slashNode, markerNode);
                        const sel = window.getSelection(); const range = document.createRange();
                        range.setStartAfter(slashNode); range.collapse(true); sel.removeAllRanges(); sel.addRange(range); markerNode.parentNode.removeChild(markerNode);
                    }
                    this.close(true);
                },
                handleClickOutside: (e) => {
                    const self = App.commandPalette;
                    if (self.state.isOpen && !self.els.palette.contains(e.target)) {
                        self.close();
                    }
                },
            },



            // ==========================================================================
            // 3.15. KASH CO-PILOT (AI SIDEBAR)
            // ==========================================================================
            coPilot: {
                state: {
                    isOpen: false,
                    context: {},
                    history: [],
                    commands: [],
                    commandSuggestions: [],
                    selectedCommandIndex: -1,
                    textileColorIndex: 0,
                    isResizing: false,
                    savedWidth: null,
                    savedHeight: null,
                },
                els: {},

                init() {
                    this.els.toggle = document.getElementById('kash-copilot-toggle');
                    this.els.sidebar = document.getElementById('kash-copilot-sidebar');
                    this.els.conversationArea = document.getElementById('copilot-conversation-area');
                    this.els.input = document.getElementById('copilot-input');
                    this.els.sendBtn = document.getElementById('copilot-send-btn');
                    this.els.commandList = document.getElementById('copilot-command-list');

                    this.state.commands = App.commandPalette.state.commands.filter(cmd => cmd.id.startsWith('kash'));

                    this.els.toggle.addEventListener('click', () => this.toggle());
                    this.els.sendBtn.addEventListener('click', () => this.handleUserInput());

                    this.els.input.addEventListener('input', () => {
                        this.els.input.style.height = 'auto';
                        this.els.input.style.height = `${this.els.input.scrollHeight}px`;
                        this.showCommandSuggestions();
                    });

                    this.els.input.addEventListener('keydown', (e) => {
                        if (this.els.commandList.style.display !== 'none') {
                            if (e.key === 'ArrowDown') {
                                e.preventDefault();
                                this.state.selectedCommandIndex = (this.state.selectedCommandIndex + 1) % this.state.commandSuggestions.length;
                                this.renderCommandSuggestions();
                            } else if (e.key === 'ArrowUp') {
                                e.preventDefault();
                                this.state.selectedCommandIndex = (this.state.selectedCommandIndex - 1 + this.state.commandSuggestions.length) % this.state.commandSuggestions.length;
                                this.renderCommandSuggestions();
                            } else if (e.key === 'Enter' && this.state.selectedCommandIndex > -1) {
                                e.preventDefault();
                                this.selectCommand();
                            } else if (e.key === 'Escape') {
                                this.els.commandList.style.display = 'none';
                            }
                        } else if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            this.handleUserInput();
                        }
                    });

                    this.els.toggle.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3L9.5 8.5L4 10l5.5 2.5L12 18l2.5-5.5L20 10l-5.5-2.5z"/></svg>`;

                    // Initialize resize functionality
                    this.els.resizeHandle = document.getElementById('copilot-resize-handle');
                    this.state.savedWidth = localStorage.getItem('copilot-width');
                    this.state.savedHeight = localStorage.getItem('copilot-height');
                    this.initResize();
                },

                initResize() {
                    if (!this.els.resizeHandle) return;

                    const isMobile = () => window.innerWidth <= 768;

                    const onMouseDown = (e) => {
                        e.preventDefault();
                        this.state.isResizing = true;
                        this.els.resizeHandle.classList.add('resizing');
                        document.body.style.cursor = isMobile() ? 'ns-resize' : 'ew-resize';
                        document.body.style.userSelect = 'none';

                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                        document.addEventListener('touchmove', onTouchMove, { passive: false });
                        document.addEventListener('touchend', onMouseUp);
                    };

                    const onMouseMove = (e) => {
                        if (!this.state.isResizing) return;

                        if (isMobile()) {
                            // Resize height from top edge
                            const viewportHeight = window.innerHeight;
                            const newHeight = viewportHeight - e.clientY;
                            const clampedHeight = Math.max(280, Math.min(newHeight, viewportHeight * 0.85));
                            this.els.sidebar.style.height = `${clampedHeight}px`;
                            this.state.savedHeight = clampedHeight;
                        } else {
                            // Resize width from left edge
                            const viewportWidth = window.innerWidth;
                            const sidebarRight = this.els.sidebar.getBoundingClientRect().right;
                            const newWidth = sidebarRight - e.clientX;
                            const clampedWidth = Math.max(340, Math.min(newWidth, viewportWidth * 0.75));
                            this.els.sidebar.style.width = `${clampedWidth}px`;
                            this.state.savedWidth = clampedWidth;
                        }
                    };

                    const onTouchMove = (e) => {
                        if (!this.state.isResizing || !e.touches[0]) return;
                        e.preventDefault();
                        onMouseMove({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
                    };

                    const onMouseUp = () => {
                        if (!this.state.isResizing) return;
                        this.state.isResizing = false;
                        this.els.resizeHandle.classList.remove('resizing');
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';

                        // Save dimensions to localStorage
                        if (isMobile() && this.state.savedHeight) {
                            localStorage.setItem('copilot-height', this.state.savedHeight);
                        } else if (!isMobile() && this.state.savedWidth) {
                            localStorage.setItem('copilot-width', this.state.savedWidth);
                        }

                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                        document.removeEventListener('touchmove', onTouchMove);
                        document.removeEventListener('touchend', onMouseUp);
                    };

                    this.els.resizeHandle.addEventListener('mousedown', onMouseDown);
                    this.els.resizeHandle.addEventListener('touchstart', onMouseDown, { passive: false });
                },
                showCommandSuggestions() {
                    const query = this.els.input.value.toLowerCase();
                    if (query.startsWith('kash')) {
                        const searchTerm = query.substring(4).trim();
                        this.state.commandSuggestions = this.state.commands.filter(cmd => cmd.id.includes(searchTerm) || cmd.title.toLowerCase().includes(searchTerm));
                        this.state.selectedCommandIndex = 0;
                        this.renderCommandSuggestions();
                        this.els.commandList.style.display = 'block';
                    } else {
                        this.els.commandList.style.display = 'none';
                    }
                },

                renderCommandSuggestions() {
                    this.els.commandList.innerHTML = this.state.commandSuggestions.map((cmd, index) =>
                        `<button class="${index === this.state.selectedCommandIndex ? 'selected' : ''}" data-command="${cmd.id}">
                        <span class="command-icon">${cmd.icon}</span>
                        <span><b>${cmd.id}</b>: ${cmd.title}</span>
                    </button>`
                    ).join('');

                    this.els.commandList.querySelectorAll('button').forEach(btn => {
                        btn.addEventListener('click', () => {
                            this.els.input.value = btn.dataset.command + ' ';
                            this.selectCommand();
                        });
                    });
                },

                selectCommand() {
                    const selected = this.state.commandSuggestions[this.state.selectedCommandIndex];
                    if (selected) {
                        this.els.input.value = selected.id + ' ';
                        this.els.input.focus();
                        this.els.commandList.style.display = 'none';
                    }
                },

                async toggle() {
                    this.state.isOpen = !this.state.isOpen;
                    if (this.state.isOpen) {
                        this.renderConversation();
                        this.els.sidebar.style.display = 'flex';

                        // Restore saved dimensions
                        const isMobile = window.innerWidth <= 768;
                        if (isMobile && this.state.savedHeight) {
                            this.els.sidebar.style.height = `${this.state.savedHeight}px`;
                        } else if (!isMobile && this.state.savedWidth) {
                            this.els.sidebar.style.width = `${this.state.savedWidth}px`;
                        }

                        setTimeout(() => { this.els.sidebar.classList.add('visible'); this.els.input.focus(); }, 10);
                    } else {
                        this.els.sidebar.classList.remove('visible');
                        setTimeout(() => {
                            this.els.sidebar.style.display = 'none';
                            // Reset dimensions to allow CSS defaults next time
                            this.els.sidebar.style.width = '';
                            this.els.sidebar.style.height = '';
                        }, 400);
                    }
                },

                async _getPdfContext() {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();

                    if (selectedText) {
                        const container = document.getElementById('pdf-viewer-container');

                        if (container && selection.anchorNode && container.contains(selection.anchorNode)) {
                            console.log("Co-Pilot: Using selected PDF text as context.");
                            return {
                                contextText: selectedText,
                                contextType: 'selection'
                            };
                        }
                    }

                    const currentPageNum = App.pdf.state.pageNum;
                    if (currentPageNum > 0) {
                        console.log(`Co-Pilot: No selection found. Using full text of page ${currentPageNum} as context.`);
                        const pageText = await App.pdf.viewer.getTextContentForPage(currentPageNum);
                        return {
                            contextText: pageText || "No text could be extracted from the current page.",
                            contextType: 'full page'
                        };
                    }
                    return {
                        contextText: "Could not determine the current PDF page or selection.",
                        contextType: 'error'
                    };
                },

                async startWithPrompt(promptText, displayText = null) {
                    // displayText is the friendly button label shown to user; promptText is sent to AI
                    const userVisibleText = displayText || promptText;

                    if (!App.license.isPremium()) {
                        if (!this.state.isOpen) { await this.toggle(); }

                        const wittyMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
                        const persuasiveMessage = `
                        <p><strong>This is a Premium feature! </strong></p>
                        <p>Unlock the full potential of Kash Co-Pilot, let your ideas flow faster and smoother. Consider going Premium to get Unlimited AI Access.</p>
                        <div style="margin: 1rem 0; text-align: center;">
                            <button class="btn btn-primary" onclick="App.ui.showAscensionModal()">Go Premium Go Unlimited</button>
                        </div>
                        <hr style="border-color: var(--border-color); opacity: 0.5;">
                        <p class="witty-gradient-text" style="font-size: 0.9em;"><em>${wittyMessage}</em></p>
                    `;
                        this.state.history.push({ role: 'user', content: userVisibleText });
                        this.state.history.push({ role: 'ai', content: persuasiveMessage });
                        this.renderConversation();
                        return;
                    }

                    if (!this.state.isOpen) { await this.toggle(); }
                    // Store the display text for showing in user bubble, but use full prompt for AI
                    this._pendingDisplayText = userVisibleText;
                    this.els.input.value = promptText;
                    this.els.input.style.height = 'auto';
                    this.els.input.style.height = `${this.els.input.scrollHeight}px`;
                    this.els.input.focus();
                    setTimeout(() => { this.handleUserInput(); }, 100);
                },

                async gatherContext() {
                    this.state.context = { immediate: null, session: null };


                    if (document.body.classList.contains('pdf-viewer-active')) {
                        const { contextText, contextType } = await this._getPdfContext();

                        this.state.context.session = contextText;
                        this.state.context.immediate = `The user is viewing a PDF document. The provided Article Content is from the user's current text ${contextType}.`;

                        return; // Exit early, as we have our context.
                    }

                    if (App.state.focusSession.isActive) {
                        const session = App.state.focusSession;
                        const currentArticle = session.articles[session.currentIndex];

                        if (currentArticle && currentArticle.content) {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = currentArticle.content;
                            this.state.context.session = tempDiv.innerText;
                        } else {
                            this.state.context.session = "No content found for the current presentation.";
                        }

                        const focusBody = document.querySelector('.focus-mode-body');
                        if (focusBody) {
                            const visibleSnippets = Array.from(focusBody.querySelectorAll('.snippet, .nk-mcq-block, .nk-accordion, .nk-timeline-block, .chart-container'));

                            if (visibleSnippets.length > 0) {
                                const onScreenText = visibleSnippets.map(el => el.innerText.trim()).join('\n\n---\n\n');
                                this.state.context.immediate = onScreenText;
                            } else {
                                this.state.context.immediate = 'There are no snippets or blocks currently on screen.';
                            }
                        } else {
                            this.state.context.immediate = 'Could not find the focus mode body.';
                        }
                    }
                },

                async handleUserInput() {
                    await this.gatherContext();

                    const userInput = this.els.input.value.trim();
                    if (!userInput) return;

                    // Use friendly display text if available (from quick prompts), otherwise use actual input
                    const userDisplayText = this._pendingDisplayText || userInput;
                    this._pendingDisplayText = null; // Clear after use

                    if (!App.license.isPremium()) {
                        const wittyMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
                        const persuasiveMessage = `
                        <p><strong>This is a Premium feature! </strong></p>
                        <p>To unlock the full power of Kash Co-Pilot and get instant answers, please consider upgrading your plan.</p>
                        <div style="margin: 1rem 0; text-align: center;">
                            <button class="btn btn-primary" onclick="App.ui.showAscensionModal()">View Premium Tiers</button>
                        </div>
                        <hr style="border-color: var(--border-color); opacity: 0.5;">
                        <p class="witty-gradient-text" style="font-size: 0.9em;"><em>${wittyMessage}</em></p>
                    `;
                        this.state.history.push({ role: 'user', content: userDisplayText });
                        this.state.history.push({ role: 'ai', content: persuasiveMessage });
                        this.renderConversation();
                        this.els.input.value = ''; // Clear the input
                        this.els.input.style.height = 'auto';
                        return; // Stop execution before calling the AI
                    }

                    this.state.history.push({ role: 'user', content: userDisplayText });
                    this.renderConversation();
                    this.els.input.value = '';
                    this.els.input.style.height = 'auto';
                    this.els.input.focus();
                    this.els.commandList.style.display = 'none';
                    this.addMessageToConversation('ai', '...', true);
                    try {
                        const aiResponse = await this.processPrompt(userInput);
                        this.updateLastMessage(aiResponse);
                    } catch (error) {
                        console.error("Co-Pilot Error:", error);
                        this.updateLastMessage(`<p style="color:var(--danger-color);">Sorry, an error occurred: ${error.message}</p>`);
                    }
                },

                renderConversation() {
                    this.els.conversationArea.innerHTML = '';
                    if (this.state.history.length === 0) {
                        const isInFocusMode = App.state.focusSession.isActive;
                        // V-- NEW LOGIC STARTS HERE --V
                        const isPdfView = document.body.classList.contains('pdf-viewer-active');
                        let headerText, promptStarters;
                        let canShuffle = false;

                        if (isPdfView && App.pdf.state.currentAttachment) {
                            const pdfName = App.pdf.state.currentAttachment.name.replace(/\.pdf$/i, '');
                            const shortPdfName = pdfName.split(' ').slice(0, 2).join(' ');
                            headerText = `How can I assist with your "${shortPdfName}" PDF?`;
                            promptStarters = [
                                { icon: 'fa-file-lines', text: 'Summarize this page', prompt: 'Summarize the key points of the current page.' },
                                { icon: 'fa-comments', text: 'Main arguments', prompt: 'What are the main arguments on this page?' },
                                { icon: 'fa-circle-question', text: 'Generate questions', prompt: 'Generate 3 key questions from the text on this page.' }
                            ];
                        } else if (isInFocusMode) {
                            headerText = 'I have read your Presentation. Ask me anything!';
                            promptStarters = [
                                { icon: 'fa-file-lines', text: 'Summarize Session', prompt: 'Summarize the key points of the entire session.' },
                                { icon: 'fa-comments', text: 'Main Arguments', prompt: 'What are the main arguments in this presentation?' },
                                { icon: 'fa-circle-question', text: 'Generate Questions', prompt: 'Generate 3 key questions from this session.' }
                            ];
                        } else {
                            canShuffle = true;
                            headerText = 'How can I help you today?';
                            // NoteKash Co-Pilot Prompt Pool
                            const allPrompts = [
                                { icon: 'fa-wand-magic-sparkles', text: 'What can you do?', prompt: 'What can you do?' },
                                { icon: 'fa-flask', text: 'Random Fun Fact', prompt: 'Give me a random fun fact about science or history that will blow my mind!' },
                                { icon: 'fa-lightbulb', text: 'Suggest a Title', prompt: 'Suggest a creative title for a note about economics.' },
                                { icon: 'fa-face-laugh-squint', text: 'Tell me a Joke', prompt: 'Tell me a clever and funny joke that will make me laugh. Make it original and witty!' },
                                { icon: 'fa-gamepad', text: 'Play a Game', prompt: 'Let\'s play a fun text-based game! You choose a random game (like word association, 20 questions, riddles, or trivia) and start by asking me something.' },
                                { icon: 'fa-fire', text: 'Motivate Me', prompt: 'Share a powerful motivational quote with a brief inspiring explanation of its meaning. Make me feel ready to conquer the world!' },
                                { icon: 'fa-landmark', text: 'Visit History', prompt: 'Tell me about a fascinating and lesser-known historical event that happened on this day or is truly remarkable. Make it engaging and interesting!' },
                                { icon: 'fa-book-open', text: 'Tell me a Story', prompt: 'Tell me a short but captivating story with a meaningful moral. Make it creative and memorable!' },
                                { icon: 'fa-lightbulb', text: 'Give me Ideas', prompt: 'Give me 3 random but interesting and actionable ideas I could do today - they could be creative projects, learning opportunities, or fun activities!' },
                                { icon: 'fa-person-running', text: 'What to do?', prompt: 'Give me a random quick task or challenge to do right now! It could be physical (like 10 pushups), mental (like a brain teaser), or creative. Make it fun!' },
                                { icon: 'fa-feather', text: 'Write a Poem', prompt: 'Share a beautiful short poem - either a famous classic or compose an original one. Include the poet\'s name if it\'s a classic!' },
                                { icon: 'fa-spell-check', text: 'Test my Vocab', prompt: 'Give me 5 interesting English vocabulary words to test my knowledge. I\'ll try to guess their meanings, then you tell me my score and the correct definitions!' },
                                { icon: 'fa-brain', text: 'Go Quiz', prompt: 'Give me a quick 5-question multiple choice quiz to test my general knowledge! I\'ll answer with A, B, C, or D, and you\'ll score me at the end.' },
                                { icon: 'fa-book', text: 'Bookworm Go', prompt: 'Recommend a random great book! Give me a compelling review that hooks me in without spoiling key plot points. Make me want to read it!' },
                                { icon: 'fa-comments', text: 'I will Answer', prompt: 'Ask me a thought-provoking or interesting question! It can be philosophical, creative, or just fun. I\'ll give you my answer and you review it.' },
                                { icon: 'fa-music', text: 'Song of the Day', prompt: 'Recommend a song I should listen to today! Tell me about the artist, why it\'s special, and what mood it\'s perfect for.' },
                                { icon: 'fa-utensils', text: 'Recipe Idea', prompt: 'Give me a quick and delicious recipe idea I can try! Make it interesting and not too complicated.' },
                                { icon: 'fa-globe', text: 'Travel Dreams', prompt: 'Tell me about a random amazing place in the world I should know about! Describe what makes it special and worth visiting.' },
                                { icon: 'fa-heart', text: 'Compliment Me', prompt: 'Give me an uplifting and creative compliment that instantly boosts my mood.' },
                                { icon: 'fa-mask', text: 'Riddle Me', prompt: 'Give me a clever riddle and let me guess the answer. Reveal the answer afterward!' },
                                { icon: 'fa-chart-line', text: 'Trend Insight', prompt: 'Tell me an emerging trend in technology or society that more people should know about. Explain why it matters.' },
                                { icon: 'fa-hammer', text: 'Life Hack', prompt: 'Give me one smart, practical life improvement tip or life hack that I can apply today.' },
                                { icon: 'fa-compass', text: 'Discover Something', prompt: 'Tell me about a fascinating scientific or natural phenomenon that feels almost unbelievable.' },
                                { icon: 'fa-robot', text: 'Teach Me Tech', prompt: 'Explain a cool modern technology which is latest (like AI, quantum computing, blockchain) in a simple and engaging way.' },
                                { icon: 'fa-trophy', text: 'Challenge Me', prompt: 'Give me a small 2-minute challenge that boosts creativity, focus, or energy.' },
                                { icon: 'fa-gem', text: 'Hidden Knowledge', prompt: 'Share a rare, mind-blowing piece of knowledge that most people have never heard of.' }
                            ];
                            // Shuffle and pick 3 random prompts (use spread to avoid mutating original)
                            const shuffled = [...allPrompts].sort(() => Math.random() - 0.5);
                            promptStarters = shuffled.slice(0, 3);
                        }
                        // A-- NEW LOGIC ENDS HERE --A

                        const promptStartersHTML = promptStarters.map((p, idx) => `
                            <div class="copilot-prompt-card" data-prompt-idx="${idx}">
                                <i class="fa-solid ${p.icon}"></i>
                                <span>${p.text}</span>
                            </div>`).join('');

                        // Store prompts for click handling
                        this._quickPrompts = promptStarters;

                        const cycleBtnHTML = canShuffle ?
                            `<button id="copilot-cycle-btn" class="btn-icon" title="Cycle Prompts" style="position:absolute; top:10px; right:15px; opacity:0.6;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                                    <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                                </svg>
                            </button>` : '';

                        this.els.conversationArea.innerHTML = `
                        <div class="copilot-empty-state" style="position:relative;">
                            ${cycleBtnHTML}
                            <div class="copilot-centered-header">
                                <h2 class="witty-gradient-text">Kash Co-Pilot</h2>
                                <p>${headerText}</p>
                            </div>
                            <div class="copilot-prompt-grid">${promptStartersHTML}</div>
                        </div>`;

                        if (canShuffle) {
                            const cycleBtn = this.els.conversationArea.querySelector('#copilot-cycle-btn');
                            if (cycleBtn) {
                                cycleBtn.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    this.renderConversation();
                                });
                            }
                        }

                        // Add click handlers for prompt cards
                        this.els.conversationArea.querySelectorAll('.copilot-prompt-card[data-prompt-idx]').forEach(card => {
                            card.addEventListener('click', () => {
                                const idx = parseInt(card.dataset.promptIdx);
                                const p = this._quickPrompts[idx];
                                const displayLabel = `<i class="fa-solid ${p.icon}"></i> ${p.text}`;
                                this.startWithPrompt(p.prompt, displayLabel);
                            });
                        });
                    } else {
                        this.state.history.forEach(msg => { this.addMessageToConversation(msg.role, msg.content, false); });
                    }
                },

                addMessageToConversation(role, content, isThinking = false) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `copilot-message ${role}`;
                    const bubble = document.createElement('div');
                    bubble.className = 'copilot-message-bubble';

                    if (isThinking) {
                        bubble.innerHTML = '<div class="thinking-dots"><span></span><span></span><span></span></div>';
                        bubble.id = 'thinking-bubble';
                    } else {
                        let finalContent = App.util.sanitizeHTML(content); // Default for user messages
                        if (role === 'ai') {
                            const sanitizedContent = this._sanitizeAiResponse(content); // <-- SANITIZE HERE
                            const actionsHTML = `<div class="copilot-bubble-actions"><button class="btn btn-secondary" onclick="App.coPilot.copyContent(this)">Copy</button><button class="btn btn-primary" onclick="App.coPilot.insertContent(this)">Insert</button></div>`;
                            finalContent = App.util.sanitizeHTML(sanitizedContent) + actionsHTML;
                            bubble.innerHTML = finalContent;
                            bubble.contentEditable = "true";
                        } else {
                            bubble.innerHTML = finalContent;
                        }
                    }

                    messageDiv.appendChild(bubble);
                    this.els.conversationArea.appendChild(messageDiv);
                    this.els.conversationArea.scrollTop = this.els.conversationArea.scrollHeight;
                },

                copyContent(buttonElement) {
                    const bubble = buttonElement.closest('.copilot-message-bubble');
                    if (!bubble) return;
                    const contentToCopy = bubble.cloneNode(true);
                    contentToCopy.querySelector('.copilot-bubble-actions')?.remove();
                    try {
                        const blob = new Blob([contentToCopy.innerHTML], { type: 'text/html' });
                        const textBlob = new Blob([contentToCopy.innerText], { type: 'text/plain' });
                        const clipboardItem = new ClipboardItem({ 'text/html': blob, 'text/plain': textBlob });
                        navigator.clipboard.write([clipboardItem]);
                    } catch (e) {
                        navigator.clipboard.writeText(contentToCopy.innerText || contentToCopy.textContent);
                    }
                    App.ui.showToast('Copied to clipboard!', 'success');
                },

                updateLastMessage(newContent) {
                    const thinkingBubble = document.getElementById('thinking-bubble');
                    if (thinkingBubble) {
                        let finalContent = this._sanitizeAiResponse(newContent); // <-- SANITIZE HERE

                        // Failsafe for empty responses after sanitizing
                        if (!finalContent || finalContent.trim() === '') {
                            finalContent = `<p style="color:var(--danger-color);">Sorry, the AI did not provide a valid response. Please try again.</p>`;
                        }

                        const bubbleContent = App.util.sanitizeHTML(finalContent);
                        const actionsHTML = `<div class="copilot-bubble-actions"><button class="btn btn-secondary" onclick="App.coPilot.copyContent(this)">Copy</button><button class="btn btn-primary" onclick="App.coPilot.insertContent(this)">Insert</button></div>`;

                        thinkingBubble.innerHTML = bubbleContent + actionsHTML;
                        thinkingBubble.id = '';

                        this.state.history[this.state.history.length - 1] = { role: 'ai', content: finalContent };

                        setTimeout(() => { App.ui.renderChartOnCanvas(thinkingBubble.querySelector('canvas')); }, 50);
                    }
                    this.els.conversationArea.scrollTop = this.els.conversationArea.scrollHeight;
                },

                async insertContent(buttonElement) {
                    const bubble = buttonElement.closest('.copilot-message-bubble');
                    if (!bubble) return;

                    const contentToInsert = bubble.cloneNode(true);
                    contentToInsert.querySelector('.copilot-bubble-actions')?.remove();
                    const contentHTML = contentToInsert.innerHTML;

                    const solidColors = App.commandPalette.state.textileColors.filter(c => !isNaN(c));
                    const color = solidColors[this.state.textileColorIndex];
                    this.state.textileColorIndex = (this.state.textileColorIndex + 1) % solidColors.length;
                    const textileHTML = `<div class="nk-text-tile color-${color}" data-color="${color}" contenteditable="false"><div class="nk-text-tile-content" contenteditable="true">${contentHTML}</div></div>`;

                    if (document.body.classList.contains('pdf-viewer-active')) {
                        const article = App.storage.getArticle(App.state.activeArticleId);
                        if (!article) {
                            App.ui.showToast("Could not find the source article to save to.", "error");
                            return;
                        }
                        const updatedContent = article.content + '<p><br></p>' + textileHTML;
                        const result = await App.storage.updateArticle(article.id, { content: updatedContent });

                        if (result.success) {
                            App.ui.showToast('Co-Pilot reply saved!', 'success');
                            this.toggle();
                        } else {
                            App.ui.showToast("Error saving content to the note.", "error");
                        }
                        return;

                    } else if (App.state.focusSession.isActive) {
                        const focusBody = document.querySelector('.focus-mode-body');
                        if (focusBody) {
                            const newSnippet = document.createElement('div');
                            newSnippet.className = 'snippet';
                            newSnippet.tabIndex = 0;
                            newSnippet.innerHTML = textileHTML;
                            focusBody.appendChild(newSnippet);

                            const session = App.state.focusSession;
                            session.scrollStops = App.ui._calculateScrollStops(focusBody);
                            session.currentSlideIndex = session.scrollStops.length - 1;
                            App.ui.renderFocusModeControls();
                            newSnippet.scrollIntoView({ behavior: 'smooth', block: 'end' });
                        }

                        const session = App.state.focusSession;
                        const currentArticleInSession = session.articles[session.currentIndex];
                        const articleToUpdate = App.storage.getArticle(currentArticleInSession.id);

                        if (!articleToUpdate) {
                            App.ui.showToast("Could not find the source article to save to.", "error");
                            return;
                        }

                        const updatedContent = articleToUpdate.content + '<p><br></p>' + textileHTML;
                        const result = await App.storage.updateArticle(articleToUpdate.id, { content: updatedContent });

                        if (result.success) {
                            App.ui.showToast('Co-Pilot reply saved', 'success');
                            this.toggle();
                        } else {
                            App.ui.showToast("Error saving content to the note.", "error");
                        }
                        return;

                    } else {
                        if (App.router.getActiveView() !== 'article') {
                            App.ui.showToast("Please open a note to insert content.", "warning");
                            return;
                        }
                        if (App.state.currentMode !== 'write') {
                            App.events.switchToMode('write');
                            setTimeout(() => this.insertContent(buttonElement), 200);
                            return;
                        }
                        App.util.insertGuardianBlock(textileHTML);
                        App.ui.showToast('Content inserted into note!', 'success');
                        this.toggle();
                    }
                },

                async processPrompt(userInput) {
                    const lowerInput = userInput.toLowerCase();

                    if (lowerInput.startsWith('focus on') || lowerInput.startsWith('find')) {
                        this.executePresentationControl(userInput);
                        return `<p>Okay, I've focused the view for you.</p>`;
                    }


                    const sessionContext = this.state.context.session || '';
                    const immediateContext = this.state.context.immediate || '';

                    const fullContext = `${sessionContext}\n\n${immediateContext}`.trim();
                    const context = fullContext || "No context available.";


                    const combinedUserPrompt = `[User Prompt]: ${userInput}\n\n---\n\n[Article Content]:\n${context}`;

                    const commandMap = {
                        'summary': 'KashSummary', 'summarize': 'KashSummary', 'explain': 'KashExplain',
                        'keywords': 'KashKeywords', 'key terms': 'KashKeywords', 'debate': 'KashDebate',
                        'quote': 'KashQuote', 'accordion': 'KashAccordion', 'q&a': 'KashAccordion',
                        'flashcard': 'KashFlash', 'mcq': 'KashMCQ', 'table': 'KashTable',
                        'mnemonic': 'KashMnemonic', 'question': 'KashQuestion', 'questions': 'KashQuestion',
                        'comedy': 'KashComedy', 'joke': 'KashComedy', 'funny': 'KashComedy',
                        'script': 'KashScript', 'video': 'KashScript',
                        'story': 'KashStory', 'narrative': 'KashStory'
                    };

                    for (const keyword in commandMap) {
                        if (lowerInput.includes(keyword)) {
                            const command = commandMap[keyword];
                            const systemPrompt = this.getSystemPromptForCommand(command);
                            const aiResponse = await App.services.ai.queryGenerativeAI(systemPrompt, combinedUserPrompt);
                            if (!aiResponse) return `<p style="color:var(--danger-color);">The AI was unable to process this command. Please try again.</p>`;
                            return aiResponse;
                        }
                    }

                    const defaultSystemPrompt = `You are Kash Co-Pilot, an intelligent AI assistant and Subject Matter Expert integrated into the 'NoteKash' app.

                **Primary Goal:** Provide the most comprehensive, accurate, and enriched answer possible by intelligently synthesizing the user's note context with your own vast knowledge base. Your answers should be well-structured, factually reliable, and easy to understand.

                **You will receive two inputs:**
                1.  **[User Prompt]:** The user's direct question or command.
                2.  **[Article Content]:** The text from the user's current note, which should be used as supplemental context or a starting point.

                **Core Logic Flow (Synthesis Model - Follow this precisely):**

                1.  **Understand the User's Goal:** First, analyze the [User Prompt] to determine the core Question or Task or Intent of User.

                2.  **Absorb Provided Context:** Second, carefully read the [Article Content]. Treat this as the user's current frame of reference, containing points they already consider very important.

                3.  **Synthesize and Enhance:** This is your primary task. Formulate your response by:
                    a.  Using your own extensive knowledge base from reliable sources as the foundation for a complete and factually accurate answer.
                    b.  Intelligently weaving in relevant facts, terms, or perspectives from the [Article Content] to make the answer more personalized to the user's notes.
                    c.  Enriching the user's context by adding new, relevant information, clarifying complexities, or providing deeper insights.
                    d.  **Accuracy is paramount:** If the [Article Content] seems to conflict with established facts, you MUST prioritize factual accuracy in your response.

                **Formatting Rules (CRITICAL):**
                * Your ENTIRE response MUST be in clean, readable HTML.
                * Use <b> tags for bolding key terms and <i> for emphasis.
                * If structuring data in a table would be clearer (e.g., the user asks for a Table or it's the best format to present material for revision), you MUST generate a simple HTML <table> with <th> headers.
                * Do NOT include \`\`\`html, markdown fences, or any text outside of the required HTML tags.`;

                    return await App.services.ai.queryGenerativeAI(defaultSystemPrompt, combinedUserPrompt);
                },

                executePresentationControl(command) {
                    const lowerCommand = command.toLowerCase();
                    if (lowerCommand.startsWith('focus on') || lowerCommand.startsWith('find')) {
                        const searchTerm = lowerCommand.replace(/^(focus on|find)\s*/, '').trim();
                        const snippets = Array.from(document.querySelectorAll('.focus-mode-body .snippet, .focus-mode-body .nk-mcq-block, .focus-mode-body .nk-accordion'));
                        const targetSnippet = snippets.find(s => s.textContent.toLowerCase().includes(searchTerm));

                        // Surgical Fix: Ensure previous highlights are cleared to prevent "sticky" glows
                        document.querySelectorAll('.spotlight-key-focus').forEach(el => el.classList.remove('spotlight-key-focus'));

                        if (targetSnippet) {
                            targetSnippet.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            targetSnippet.classList.add('spotlight-key-focus');

                            // Robustness: Clear any previous timer to prevent race conditions
                            if (targetSnippet._glowTimer) clearTimeout(targetSnippet._glowTimer);

                            targetSnippet._glowTimer = setTimeout(() => {
                                targetSnippet.classList.remove('spotlight-key-focus');
                                targetSnippet._glowTimer = null;
                            }, 3000);
                        } else {
                            App.ui.showToast(`Couldn't find a snippet about "${searchTerm}".`, 'warning');
                        }
                    }
                },

                getSystemPromptForCommand(commandName) {
                    const prompts = {
                        'KashSummary': `You are a summarizer. You will receive a [User Prompt] and [Article Content]. Your task is fir to analyze [User Prompt] to understand user wants and then to create a concise summary of the [Article Content] according to Users intent (which you got from his prompt).
                        Output a single, one-line descriptive title, followed by 4-12 short, bulleted points using markdown <li> using <ul>.
                        CRITICAL: Respond ONLY with the markdown title and list. Do not use HTML or code fences.`,

                        'KashFlash': `You are an intelligent text editor. You will receive a [User Prompt] and [Article Content]. Your task is to analyze the [Article Content] and convert 2-3 of its most important concepts into cloze deletions using the \`{{c1::concept}}\` syntax. For multiple cloze deletions, use {{c1::...}}, {{c2::...}}, etc.
                        CRITICAL: Respond ONLY with the modified text, preserving the original sentence structure. Do not use code fences.`,

                        'KashQuestion': `You are an Expert of Asking Questions. You only ask Questions and you are best in It. You will receive a [User Prompt] and [Article Content]. Your task is to Generate Questions (atleast 3-8 Questions) based on the [Article Content] and [User prompt]. Generate more relevant 5 insightful, open-ended and most relevant questions based on text to test user's knowlege and also to create insight on main topic. 
                        CRITICAL: Respond ONLY with a numbered list (1., 2., 3., ...) which are separated by new line (i.e new question in new line). Do not use HTML or code fences.`,

                        'KashDebate': `You are an Expert Debater. You will receive a [User Prompt] and [Article Content]. Your task is to create a two-column debate table based on the [Article Content], arguing FOR and AGAINST the main position.
                        CRITICAL: Respond ONLY with the complete HTML for the <table>. Do NOT include code fences.`,

                        'KashTable': `You are 'Kash, the Table-Maker,' an expert AI assistant. Your goal is to create the most accurate and helpful HTML table based on the user's request, intelligently synthesizing your own knowledge with the user's provided notes.

                    **Core Logic Flow (Synthesis Model):**

                    1.  **Analyze the User's Goal:** First, understand the core request in the [User Prompt]. Is it a general knowledge query (e.g., "list the articles of the constitution") or a simple command (e.g., "make a table")?

                    2.  **Synthesize and Enhance:**
                        * **Primary Action:** Use your own extensive knowledge base from reliable sources as the foundation to build the table the user asked for.
                        * **Enhancement:** Read the [Article Content]. If it contains specific details, examples, or nuances relevant to an entry in the table you're building, you **should** integrate that information to make the table more personalized and valuable.
                    
                    3.  **Context-Only Exception:**
                        * You should ONLY create a table *exclusively* from the [Article Content] if the [User Prompt] is a very simple, non-specific command like "make this a table," "convert this," or "summarize this as a table."

                    **CRITICAL FINAL RULE:**
                    Your ENTIRE response MUST be ONLY the complete HTML for the <table>. Do NOT include \`\`\`html, markdown fences, or any other text.`,

                        'KashComedy': `You are a witty stand-up comedian. You will receive a [User Prompt] and [Article Content]. Your task is to turn the [Article Content] into a short, hilarious comedy routine script with touch of subcontinent.
                        **Formatting Rules:**
                        1.  Use simple, conversational English with a South Asian flavor.
                        2.  Use <b> tags for emphasis on punchlines.
                        3.  CRITICAL: Your ENTIRE response MUST be wrapped in a single \`<blockquote>\` tag. Do NOT use code fences.`,

                        'KashKeywords': `You are an expert academic analyst. You will receive a [User Prompt] and [Article Content]. Your task is to extract the 7-16 most important keywords and short phrases from the [Article Content].
                        CRITICAL: You MUST respond ONLY with a valid JSON array of strings. Example: ["Judicial Appointments", "Collegium System"]`,

                        'KashScript': `You are a witty video scriptwriter. You will receive a [User Prompt] and [Article Content]. Your task is to turn the [Article Content] into a short, punchy video script (approx. 250 words).
                        **Formatting Rules:**
                        1.  Start with a strong, funny, one-line hook.
                        2.  Use short, conversational sentences. Make sure your script keeps user's interest (with some witty humour/ punchlines).
                        3.  CRITICAL: Output ONLY the final script text. No titles, no scene markers, no code fences. Just the spoken words.`,

                        'KashStory': `You are 'Kash, the Story-Weaver.' You will receive a [User Prompt] and [Article Content]. Your task is to transform the factual [Article Content] into a short, funny, and memorable fictional story (200-500 words).
                        Embed the article's facts naturally within the narrative.
                        CRITICAL: Respond ONLY with the story text. Do NOT use markdown, code fences, titles, or headings.`,

                        'KashQuote': `You are 'Kash, the Quote Master.' You will receive a [User Prompt] and [Article Content]. Your task is to analyze the [Article Content] and find the single most insightful and contextually relevant quote.
                        CRITICAL: Respond ONLY with a single, valid and most relevant Quote with "quote" and "author name" in end.`,

                        'KashExplain': `You are 'Kash, the Clarifier,' an AI expert. You will receive a [User Prompt] and [Article Content]. Your task is to explain the topic of the [Article Content] with unparalleled clarity for a student. Use the [User Prompt] for any specific instructions (e.g., "explain it like I'm 10").
                        **Strict Output Structure:**
                        1. (Optional) A one-line title.
                        2. A 1-2 sentence plain-language summary.
                        3. 3-6 short bullet points (*) covering what, how, and why.
                        4. 2-4 numbered examples (1., 2., ...).
                        CRITICAL: Respond ONLY with the plain text explanation. DO NOT use headings, HTML, or code fences.`,

                        'KashMnemonic': `You are a focused mnemonic-maker. You will receive a [User Prompt] and [Article Content]. Your task is to create three mnemonic options for the [Article Content].
                        **Strict Output Structure:**
                        1) Simple & Catchy: [Mnemonic]
                        Usage: [Explanation]
                        2) Subcontinent-Flavored: [Mnemonic]
                        Usage: [Explanation]
                        3) Acronym/Rhyme: [Mnemonic]
                        Usage: [Explanation]
                        CRITICAL: Respond ONLY with the text in the exact structure above. Do NOT use headings, HTML, or code fences.`,

                        'KashAccordion': `You are an expert content architect. Who Acts as Expert in subject-matter/topic and generatesmost relevant and important Questions and giving their Short Answers. You will receive a [User Prompt] and [Article Content]. Your task is to analyze the [Article Content] and [User Prompt] and extract distinct questions and their answers. Give priority to [User Prompt] to understand Users intent or any additional information he shared onwhich you can ask QnA's
                        CRITICAL: Respond ONLY with a valid paragprahs  of Question/answer with multiple Questions/Answers. Each object MUST have two keys: "question" and "answer". The "answer" should be a single paragraph. 
                        You can give your reply in clean Html and use <b>, <em> or other styling methods to style content and make sure it looks well arranged. Avoid uses code fences or unnessary text (only Questions and Answers required)
                        How many QnA? - Minimum 3 and maximum 8.
                        Example: ["Question": "What is...?", (in new line)"Answer": "It is..."}, (separate two QnAs) {"Question": "How does...?","Answer": "It works by..."}]`,

                        'KashMCQ': `You are an Expert Educator. You will receive [Article Content] and [User prompt]. Your task is to generate 2-5 multiple-choice questions based on that content and your knowledge (which is reliable) - together synthesized into MCQs. Each question should have a clear correct answer and plausible distractors.
                        
                        **CRITICAL OUTPUT FORMAT:**
                        Your ENTIRE response MUST be complete HTML using this EXACT structure for EACH MCQ:
                        
                        <div class="nk-mcq-block" contenteditable="false">
                            <div class="nk-mcq-toolbar">
                                <button class="nk-mcq-copy-block" title="Copy MCQ"><i class="fa-solid fa-copy"></i></button>
                                <button class="nk-mcq-delete-block" title="Delete MCQ"><i class="fa-solid fa-trash"></i></button>
                            </div>
                            <div class="nk-mcq-question" contenteditable="true">Your question here?</div>
                            <div class="nk-mcq-options">
                                <div class="nk-mcq-option" data-is-correct="false">
                                    <div class="nk-mcq-option-radio"></div>
                                    <div class="nk-mcq-option-text" contenteditable="true">Option A</div>
                                    <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                                </div>
                                <div class="nk-mcq-option" data-is-correct="true">
                                    <div class="nk-mcq-option-radio"></div>
                                    <div class="nk-mcq-option-text" contenteditable="true">Correct Option</div>
                                    <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                                </div>
                            </div>
                            <button class="btn btn-secondary nk-mcq-add-option">+ Add Option</button>
                            <div class="nk-mcq-explanation" contenteditable="true" data-placeholder="Add answer explanation (optional)..."></div>
                        </div>
                        
                        IMPORTANT: Set data-is-correct="true" ONLY for the correct option. Randomly distribute the correct answer position (don't always put it first or last).
                        Do NOT include code fences, markdown, or any text outside the HTML.`
                    };
                    return prompts[commandName];
                },

                clearConversation() {
                    if (this.state.history.length > 0) {
                        this.state.history = [];
                        this.renderConversation(); // Re-render the empty state
                        App.ui.showToast('Conversation cleared.', { type: 'success', duration: 2000 });
                    }
                },

                _sanitizeAiResponse(content) {
                    if (typeof content !== 'string') return content;
                    // This regex robustly removes markdown code fences (e.g., ```html ... ```)
                    const cleaned = content.replace(/^\s*```(?:html|json|javascript)?\s*\n?([\s\S]*?)\n?\s*```\s*$/, '$1');
                    return cleaned.trim();
                },

                async saveConversationAsNote() {
                    if (this.state.history.length === 0) {
                        App.ui.showToast("Nothing to save.", "warning");
                        return;
                    }

                    const title = `Co-Pilot Conversation: ${new Date().toLocaleString()}`;
                    let contentHTML = ``;

                    this.state.history.forEach(msg => {
                        const cleanedContent = msg.content.replace(/<div class="copilot-bubble-actions">.*?<\/div>/s, '');
                        if (msg.role === 'user') {
                            contentHTML += `<blockquote><p><b>You:</b> ${cleanedContent}</p></blockquote>`;
                        } else {
                            contentHTML += `<div>${cleanedContent}</div>`;
                        }
                    });

                    const defaultCategory = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                    const newNote = await App.storage.createArticle({
                        title: title,
                        content: contentHTML,
                        category: defaultCategory
                    });

                    if (newNote) {
                        App.ui.showToast('Conversation saved!', {
                            type: 'success',
                            action: {
                                label: 'Open Note',
                                callback: () => App.router.navigateTo('article', { id: newNote.id, mode: 'read' })
                            }
                        });
                        this.state.history = [];
                        this.renderConversation();
                    } else {
                        App.ui.showToast("Failed to save conversation.", "error");
                    }
                },

            },

            // ==========================================================================
            // 3.16. QUIZ MODULE (v2)
            // ==========================================================================
            quiz: {
                stats: {},
                session: {}, // To hold the state of the active quiz
                defaults: { lastScore: 0, bestScore: 0, totalScore: 0, totalQuizzes: 0, avgScore: 0 },
                async loadStats() { this.stats = await App.fs.read('quiz_stats.json') || { ...this.defaults }; },
                async saveStats() { await App.fs.write('quiz_stats.json', this.stats); },
                getStats() { return this.stats; },

                start(options = {}) {
                    const { mode = 'classic' } = options; // 'classic' for Recall, 'mcq' for Recognition
                    const quizSize = 10;
                    let availableCards = App.util.getSortedFlashcardsForDisplay();
                    let toastMessage = `You need at least ${quizSize} cards in this deck for a Recall Quiz.`;

                    // 1. Filter cards based on the selected quiz mode
                    if (mode === 'mcq') {
                        availableCards = availableCards.filter(c => c.type === 'mcq');
                        toastMessage = `You need at least ${quizSize} MCQs in this deck to start a Recognition Quiz.`;
                    } else { // 'classic' mode for Recall Quiz
                        availableCards = availableCards.filter(c => c.type === 'collapsible' || c.type === 'cloze');
                    }

                    if (availableCards.length < quizSize) {
                        App.ui.showToast(toastMessage, { type: 'warning' });
                        return;
                    }

                    // 2. The Smart Algorithm: 6 (SRS) + 2 (New) + 2 (Random)
                    let quizCards = [];
                    const now = new Date();

                    // Separate cards into buckets
                    const newCards = availableCards.filter(c => c.rating === null);
                    const dueCards = availableCards.filter(c => c.rating !== null && new Date(c.nextReviewDue) <= now);
                    const otherRatedCards = availableCards.filter(c => c.rating !== null && new Date(c.nextReviewDue) > now);

                    // Sort due cards by SRS priority (Again > Hard > ... > Easy)
                    const ratingOrder = { 'Again': 1, 'Hard': 2, 'Hold': 3, 'Good': 4, 'Easy': 5 };
                    dueCards.sort((a, b) => (ratingOrder[a.rating] || 6) - (ratingOrder[b.rating] || 6));

                    // Shuffle new and other cards for random selection
                    newCards.sort(() => 0.5 - Math.random());
                    otherRatedCards.sort(() => 0.5 - Math.random());

                    // 3. Assemble the quiz deck, handling edge cases
                    const takeFrom = (source, count) => {
                        const taken = source.splice(0, count);
                        quizCards.push(...taken);
                        return taken.length;
                    };

                    let needed = 6;
                    let taken = takeFrom(dueCards, needed);
                    needed -= taken;

                    // If not enough due cards, try to fill with new cards first
                    if (needed > 0) {
                        taken = takeFrom(newCards, needed);
                        needed -= taken;
                    }
                    // If still not enough, fill with other rated cards
                    if (needed > 0) {
                        takeFrom(otherRatedCards, needed);
                    }

                    // Now take the dedicated new and random cards
                    needed = 2;
                    taken = takeFrom(newCards, needed);
                    needed -= taken;
                    if (needed > 0) { // Fill from other sources if not enough new cards
                        taken = takeFrom(dueCards, needed);
                        if (taken < needed) takeFrom(otherRatedCards, needed - taken);
                    }

                    needed = 2;
                    taken = takeFrom(otherRatedCards, needed);
                    needed -= taken;
                    if (needed > 0) { // Fill from other sources if not enough random cards
                        taken = takeFrom(dueCards, needed);
                        if (taken < needed) takeFrom(newCards, needed - taken);
                    }

                    // Final shuffle to mix the card types
                    quizCards.sort(() => 0.5 - Math.random());

                    // 4. Start the quiz session
                    this.session = {
                        isActive: true,
                        mode: mode,
                        questions: quizCards,
                        score: 0,
                        answeredCardIds: new Set(),
                    };

                    App.events.study.start({ quizCards: quizCards, quizType: mode });
                },

                async handleMcqAnswer(isCorrect, card) {
                    if (!this.session.isActive || this.session.answeredCardIds.has(card.id)) return;

                    // FIX: No negative marking. 0 for incorrect.
                    this.session.score += isCorrect ? 1 : 0;
                    this.session.answeredCardIds.add(card.id);

                    const rating = isCorrect ? 'Hold' : 'Again';
                    const updatedCardData = App.util.sm2.rateCard(card, rating);
                    const article = App.storage.getArticle(card.articleId);
                    if (article?.flashcards?.[card.id]) {
                        const newFlashcards = { ...article.flashcards, [card.id]: { ...article.flashcards[card.id], ...updatedCardData } };
                        await App.storage.updateArticle(article.id, { flashcards: newFlashcards });
                    }
                },

                async handleMcqSkip(card) {
                    if (!this.session.isActive || this.session.answeredCardIds.has(card.id)) return;
                    this.session.answeredCardIds.add(card.id); // Mark as processed, score remains 0

                    const updatedCardData = App.util.sm2.rateCard(card, 'Again'); // Skipped counts as 'Again' for SRS
                    const article = App.storage.getArticle(card.articleId);
                    if (article?.flashcards?.[card.id]) {
                        const newFlashcards = { ...article.flashcards, [card.id]: { ...article.flashcards[card.id], ...updatedCardData } };
                        await App.storage.updateArticle(article.id, { flashcards: newFlashcards });
                    }
                },

                async calculateAndShowResults(completedCards) {
                    let score = 0;
                    if (this.session.mode === 'mcq') {
                        // FIX: Score is already non-negative
                        score = this.session.score;
                    } else { // Classic Quiz
                        completedCards.forEach(card => {
                            score += App.config.quiz.scores[card.finalRating] || 0;
                        });
                    }
                    if (!this.stats.quizHistory) {
                        this.stats.quizHistory = [];
                    }
                    this.stats.quizHistory.push(new Date().toISOString());
                    this.stats.lastScore = score;
                    this.stats.bestScore = Math.max(this.stats.bestScore, score);
                    this.stats.totalScore += score;
                    this.stats.totalQuizzes += 1;
                    this.stats.avgScore = this.stats.totalScore / this.stats.totalQuizzes;
                    await this.saveStats();
                    App.ui.showQuizResultModal(score, this.session.questions.length);

                    // Clean up the temporary rating property to prevent score leakage
                    completedCards.forEach(card => {
                        delete card.finalRating;
                    });

                    this.session = {}; // Reset session
                },
            },

            // ==========================================================================
            // 3.17. CONTENT TOOLS (v2 SuperTags)
            // ==========================================================================
            contentTools: {
                slugify: (text) => text.toString().toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-'),
                _applyWrapper(className, attributes = {}) {
                    const selection = window.getSelection();
                    if (!selection.rangeCount || selection.isCollapsed) return;
                    const editor = document.getElementById('article-content');
                    if (!editor.contains(selection.anchorNode)) return;
                    const range = selection.getRangeAt(0);
                    const parent = range.commonAncestorContainer.parentElement;
                    if (parent && parent.classList.contains(className)) {
                        parent.replaceWith(...parent.childNodes);
                    } else {
                        const wrapper = document.createElement(className === 'mindmap-snippet' ? 'mark' : 'span');
                        wrapper.className = className;
                        Object.entries(attributes).forEach(([key, value]) => wrapper.setAttribute(key, value));
                        wrapper.textContent = selection.toString();
                        range.deleteContents();
                        range.insertNode(wrapper);
                    }
                    selection.removeAllRanges();
                },

                async clipArticle(url) {
                    const toastId = App.ui.showToast('Clipping article...', { type: 'info', duration: 0 });

                    const insertClippedHTML = (article) => {
                        const clippedHTML = `
                        <blockquote>
                            <p><em>Clipped from: <a href="${App.util.escapeHtml(article.source)}" target="_blank" rel="noopener noreferrer">${App.util.escapeHtml(article.title)}</a></em></p>
                        </blockquote>
                        ${article.content}
                        <p><br></p>`;

                        document.execCommand('insertHTML', false, clippedHTML);
                        App.state.isArticleDirty = true;
                        App.ui.hideToast(toastId);
                        App.ui.showToast('Article clipped successfully!', { type: 'success' });
                    };

                    try {
                        console.log("Clip: Attempting Tier 1 (Netlify Function)...");
                        const response = await fetch('/.netlify/functions/clipper', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ url })
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.error || `Server responded with status ${response.status}`);
                        }

                        const article = await response.json();
                        insertClippedHTML(article);
                        console.log("Clip: Tier 1 succeeded.");

                    } catch (tier1Error) {
                        console.warn("Clip: Tier 1 failed, attempting Tier 2 (Fallback). Reason:", tier1Error.message);
                        App.ui.updateToast(toastId, 'Advanced clipping failed. Trying fallback...');

                        try {
                            if (typeof Readability === 'undefined') {
                                throw new Error("Readability library is not loaded.");
                            }
                            const proxyUrl = 'https://api.allorigins.win/raw?url=';
                            const response = await fetch(proxyUrl + encodeURIComponent(url));

                            if (!response.ok) {
                                throw new Error(`Fallback fetch failed. Status: ${response.statusText}`);
                            }

                            const rawHtml = await response.text();
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(rawHtml, 'text/html');
                            const reader = new Readability(doc);
                            const article = reader.parse();

                            if (!article || !article.content) {
                                throw new Error("Fallback could not parse article content.");
                            }

                            insertClippedHTML({
                                title: article.title,
                                content: article.content,
                                source: url
                            });
                            console.log("Clip: Tier 2 (Fallback) succeeded.");

                        } catch (tier2Error) {
                            console.error('Clip: Tier 2 (Fallback) also failed:', tier2Error);
                            App.ui.hideToast(toastId);
                            App.ui.showToast(`Clipping failed completely: ${tier2Error.message}`, { type: 'error' });
                        }
                    }
                },


                tagSelection(nodeToReplace = null) {
                    if (nodeToReplace) {
                        const slug = this.slugify(nodeToReplace.textContent);
                        const wrapper = document.createElement('span');
                        wrapper.className = 'rendered-tag';
                        wrapper.dataset.tag = slug;
                        wrapper.textContent = nodeToReplace.textContent;
                        nodeToReplace.replaceWith(wrapper);
                    } else {
                        const selectionText = window.getSelection().toString();
                        if (!selectionText.trim()) return;
                        const slug = this.slugify(selectionText);
                        this._applyWrapper('rendered-tag', { 'data-tag': slug });
                    }
                },
                extractTagsFromHTML(html) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    return Array.from(tempDiv.querySelectorAll('.rendered-tag[data-tag]')).map(node => node.dataset.tag);
                },

                convertContentSyntax(htmlString) {
                    if (!htmlString) return '';
                    // DOM-based approach: Only process text nodes, never attributes (protects data: URLs)
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlString;
                    const tagRegex = /\[\[(.*?)\]\]/g;
                    const walker = document.createTreeWalker(tempDiv, NodeFilter.SHOW_TEXT);
                    const nodesToProcess = [];
                    while (walker.nextNode()) {
                        const node = walker.currentNode;
                        // Skip if inside protected elements
                        if (node.parentElement.closest('code, pre, .nk-code-block, .rendered-tag')) continue;
                        if (tagRegex.test(node.nodeValue)) {
                            tagRegex.lastIndex = 0; // Reset regex
                            nodesToProcess.push(node);
                        }
                    }
                    nodesToProcess.forEach(textNode => {
                        const text = textNode.nodeValue;
                        const fragment = document.createDocumentFragment();
                        let lastIndex = 0;
                        let match;
                        tagRegex.lastIndex = 0;
                        while ((match = tagRegex.exec(text)) !== null) {
                            if (match.index > lastIndex) {
                                fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                            }
                            const content = match[1];
                            const slug = this.slugify(content);
                            if (slug) {
                                const span = document.createElement('span');
                                span.className = 'rendered-tag';
                                span.dataset.tag = slug;
                                span.textContent = content;
                                fragment.appendChild(span);
                            } else {
                                fragment.appendChild(document.createTextNode(match[0]));
                            }
                            lastIndex = match.index + match[0].length;
                        }
                        if (lastIndex < text.length) {
                            fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                        }
                        textNode.parentNode.replaceChild(fragment, textNode);
                    });
                    return tempDiv.innerHTML;
                },
                updateDataTagsInContent(html) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    tempDiv.querySelectorAll('.rendered-tag').forEach(tag => {
                        tag.setAttribute('data-tag', this.slugify(tag.textContent));
                    });
                    return tempDiv.innerHTML;
                },
                autoSuggestTags(contentEl) {
                    clearTimeout(App.state.suggestionTimeout);
                    App.state.suggestionTimeout = setTimeout(() => {
                        const tagDisplayNames = Object.values(App.state.tags).map(t => t.displayName);
                        // CRITICAL FIX: Filter out empty/falsy display names to prevent regex matching empty strings at word boundaries
                        const validTagNames = tagDisplayNames.filter(name => name && name.trim());
                        if (validTagNames.length === 0) return;
                        const regex = new RegExp(`\\b(${validTagNames.map(name => name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})\\b`, 'gi');
                        const walker = document.createTreeWalker(contentEl, NodeFilter.SHOW_TEXT);
                        const nodesToProcess = [];
                        while (walker.nextNode()) {
                            if (walker.currentNode.parentElement.closest('.rendered-tag, .tag-suggestion')) continue;
                            nodesToProcess.push(walker.currentNode);
                        }
                        nodesToProcess.forEach(textNode => {
                            const text = textNode.nodeValue;
                            if (!regex.test(text)) return;
                            const fragment = document.createDocumentFragment(); let lastIndex = 0;
                            text.replace(regex, (match, ...args) => {
                                const offset = args[args.length - 2];
                                if (offset > lastIndex) fragment.appendChild(document.createTextNode(text.substring(lastIndex, offset)));
                                // SAFEGUARD: Skip empty or whitespace-only matches
                                if (match && match.trim()) {
                                    const span = document.createElement('span'); span.className = 'tag-suggestion'; span.textContent = match; fragment.appendChild(span);
                                } else {
                                    fragment.appendChild(document.createTextNode(match));
                                }
                                lastIndex = offset + match.length;
                            });
                            if (lastIndex < text.length) fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                            textNode.parentNode.replaceChild(fragment, textNode);
                        });
                    }, 250);
                },
                async updateTagsIndex() {
                    const newTagsIndex = {};
                    App.state.articles.forEach(article => {
                        (article.tags || []).forEach(tag => {
                            const displayName = App.state.tags[tag]?.displayName || tag.replace(/-/g, ' ');
                            if (!newTagsIndex[tag]) newTagsIndex[tag] = { id: tag, displayName, count: 0, articles: [] };
                            newTagsIndex[tag].count++;
                            if (!newTagsIndex[tag].articles.includes(article.id)) newTagsIndex[tag].articles.push(article.id);
                        });
                    });
                    App.state.tags = newTagsIndex;
                    await App.fs.write('tags.json', App.state.tags);
                },
                buildDataCache() {
                    console.time("buildMindMapCache");
                    const mindMapSnippets = {};
                    App.state.articles.forEach(article => {
                        let snippets = App.util.extractSnippets(article, 'highlight');
                        mindMapSnippets[article.id] = snippets.filter(s => s.html && !s.html.includes('class="rendered-tag"'));
                    });
                    App.state.dataCache.mindMapSnippets = mindMapSnippets;
                    App.state.dataCache.isBuilt = true;
                    console.timeEnd("buildMindMapCache");
                },
            },

            // ==========================================================================
            // 3.18. MIND MAP MODULE (v2 - REBUILT FROM PROTOTAGS)
            // ==========================================================================
            mindMap: {
                svg: null, g: null, zoom: null, simulation: null, width: 0, height: 0, resizeObserver: null, isInitialLoad: true,
                mindmapRoots: [], currentMindmapIndex: -1, nodeStates: {}, layoutMode: 'Force',
                currentSnapshotIndex: -1, currentMindmapSearchResults: [], currentMindmapSearchIndex: -1,

                // INTERNALIZED: ColorManager is now part of this module to avoid global conflicts.
                colorManager: {
                    palettes: ['c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'c10', 'c11', 'c12', 'c13', 'c14', 'c15'],
                    assignment: new Map(),
                    seed: 1,
                    _pseudoRandom() { let x = Math.sin(this.seed++) * 10000; return x - Math.floor(x); },
                    getSchemeFor(id, index) {
                        if (!this.assignment.has(id)) this.assignment.set(id, this.palettes[index % this.palettes.length]);
                        return this.assignment.get(id);
                    },
                    rotateSchemes() {
                        const shuffledPalettes = [...this.palettes];
                        for (let i = shuffledPalettes.length - 1; i > 0; i--) {
                            const j = Math.floor(this._pseudoRandom() * (i + 1));
                            [shuffledPalettes[i], shuffledPalettes[j]] = [shuffledPalettes[j], shuffledPalettes[i]];
                        }
                        const currentIds = Array.from(this.assignment.keys());
                        this.assignment.clear();
                        currentIds.forEach((id, index) => this.assignment.set(id, shuffledPalettes[index % shuffledPalettes.length]));
                    },
                    clear() { this.assignment.clear(); }
                },

                calculateEdgePoint(source, target) {
                    const dx = target.x - source.x; const dy = target.y - source.y;
                    if (dx === 0 && dy === 0) return { x: source.x, y: source.y };
                    const w = source.width / 2; const h = source.height / 2;
                    if (w === 0 || h === 0) return { x: source.x, y: source.y };
                    const slope = dy / dx; const absSlope = Math.abs(slope);
                    let x, y;
                    if (absSlope < h / w) { x = dx > 0 ? w : -w; y = slope * x; }
                    else { y = dy > 0 ? h : -h; x = y / slope; }
                    return { x: source.x + x, y: source.y + y };
                },

                init() {

                    this.isInitialLoad = true;

                    if (!App.state.dataCache.isBuilt) {
                        App.ui.showToast('Building mind map cache...', { type: 'info' });
                        App.contentTools.buildDataCache();
                        App.ui.showToast('Cache ready!', { type: 'success' });
                    }

                    if (this.svg) {
                        this.renderAllMindmaps();
                        return;
                    }

                    this.render();
                    this.initControls();

                    const container = document.getElementById('mindmap-container');
                    container.focus();

                    container.onkeydown = (e) => {
                        if (document.activeElement.tagName !== 'INPUT') {
                            if (e.key === ' ' && e.shiftKey) { this.zoomOut(); e.preventDefault(); }
                            else if (e.key === ' ') { this.zoomIn(); e.preventDefault(); }
                            else {
                                switch (e.key.toLowerCase()) {

                                    case 's': document.getElementById('mindmap-search-input').focus(); e.preventDefault(); break; // 'S' is now for Search
                                    case 'p': this.saveSnapshotAndExport(); e.preventDefault(); break; // 'F' is now for snapshot/save frame

                                    case 'k': this.navigateToNextMap(); e.preventDefault(); break;
                                    case 'j': this.navigateToPrevMap(); e.preventDefault(); break;
                                    case 'f': App.events.toggleCanvasFocusMode(); e.preventDefault(); break;
                                    case 'c':
                                        if (App.license.isPremium()) {
                                            this.colorManager.rotateSchemes();
                                            this.renderAllMindmaps();
                                        } else {
                                            App.ui.showAscensionModal();
                                        }
                                        e.preventDefault();
                                        break;
                                    case 'escape':
                                        if (document.body.classList.contains('canvas-focus-mode')) {
                                            App.events.toggleCanvasFocusMode();
                                        } else {
                                            const searchInput = document.getElementById('mindmap-search-input');
                                            searchInput.value = ''; this.searchNodes(''); searchInput.blur();
                                        }
                                        e.preventDefault();
                                        break;
                                }
                            }
                        } else if (e.key === 'Enter' && document.activeElement === document.getElementById('mindmap-search-input')) {
                            e.preventDefault();
                            this.findNextSearchResult();
                        }
                    };

                    const snapshots = App.state.mindMapState.snapshots || [];
                    if (snapshots.length > 0) this.loadSnapshot(snapshots[snapshots.length - 1]);
                    else this.renderAllMindmaps();

                    this.resizeObserver = new ResizeObserver(entries => {
                        if (entries[0].contentRect.width < 1) return;
                        this.width = entries[0].contentRect.width;
                        this.height = entries[0].contentRect.height;
                        this.svg.attr("viewBox", [-this.width / 2, -this.height / 2, this.width, this.height]);
                        if (this.simulation) this.simulation.force("center", d3.forceCenter(0, 0)).alpha(0.3).restart();
                    });
                    this.resizeObserver.observe(container);
                },

                triggerResize() {
                    const container = document.getElementById('mindmap-container');
                    if (!container || !this.resizeObserver) return;
                    // Temporarily disconnect to avoid infinite loops, manually trigger, then reconnect
                    this.resizeObserver.disconnect();
                    const newWidth = container.clientWidth;
                    const newHeight = container.clientHeight;
                    if (newWidth > 0 && newHeight > 0) {
                        this.width = newWidth;
                        this.height = newHeight;
                        this.svg.attr("viewBox", [-this.width / 2, -this.height / 2, this.width, this.height]);
                        if (this.simulation) this.simulation.force("center", d3.forceCenter(0, 0)).alpha(0.3).restart();
                    }
                    this.resizeObserver.observe(container);
                },

                destroy() {
                    if (this.simulation) this.simulation.stop();
                    if (this.resizeObserver) this.resizeObserver.disconnect();
                    d3.select("#mindmap-container > svg").remove();
                    this.svg = this.g = this.zoom = this.simulation = this.resizeObserver = null;
                },

                initControls() {
                    // Free Controls
                    document.getElementById('mindmap-find-next-btn').onclick = () => this.findNextSearchResult();
                    document.getElementById('mindmap-next-btn').onclick = () => this.navigateToNextMap();
                    document.getElementById('mindmap-prev-btn').onclick = () => this.navigateToPrevMap();
                    document.getElementById('mindmap-zoom-in-btn').onclick = () => this.zoomIn();
                    document.getElementById('mindmap-zoom-out-btn').onclick = () => this.zoomOut();
                    document.getElementById('mindmap-reset-view-btn').onclick = () => this.zoomToFit();
                    document.getElementById('mm-focus-line').onclick = () => App.events.toggleCanvasFocusMode();

                    // Search listeners
                    const searchInput = document.getElementById('mindmap-search-input');
                    searchInput.oninput = (e) => this.searchNodes(e.target.value);
                    searchInput.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); this.findNextSearchResult(); } };

                    // Premium Feature Gates
                    document.getElementById('mindmap-expand-all').onclick = () => {
                        if (App.license.isPremium()) { this.nodeStates = {}; this.renderAllMindmaps(); }
                        else App.ui.showAscensionModal();
                    };
                    document.getElementById('mindmap-collapse-all').onclick = () => {
                        if (App.license.isPremium()) {
                            this.mindmapRoots.forEach(root => this.nodeStates[root.id] = { collapsed: true });
                            this.renderAllMindmaps();
                        } else App.ui.showAscensionModal();
                    };
                    document.getElementById('mindmap-gather-nodes-btn').onclick = () => {
                        if (App.license.isPremium()) this.gatherNodes(); else App.ui.showAscensionModal();
                    };
                    const layoutToggle = document.getElementById('mindmap-layout-toggle');
                    layoutToggle.innerHTML = ICON_MINDMAP_FORCE;
                    layoutToggle.onclick = () => {
                        if (App.license.isPremium()) this.toggleLayout(); else App.ui.showAscensionModal();
                    };
                    document.getElementById('mindmap-rotate-colors').onclick = () => {
                        if (App.license.isPremium()) { this.colorManager.rotateSchemes(); this.renderAllMindmaps(); }
                        else App.ui.showAscensionModal();
                    };
                    document.getElementById('mindmap-snapshot-btn').onclick = () => {
                        if (App.license.isPremium()) this.saveSnapshotAndExport(); else App.ui.showAscensionModal();
                    };
                    document.getElementById('mindmap-toggle-snapshots-btn').onclick = () => {
                        if (App.license.isPremium()) this.cycleSnapshots(); else App.ui.showAscensionModal();
                    };
                    document.getElementById('mindmap-delete-snapshots-btn').onclick = () => {
                        if (App.license.isPremium()) this.deleteOldSnapshots(); else App.ui.showAscensionModal();
                    };
                },

                toggleLayout() {
                    this.layoutMode = this.layoutMode === 'Force' ? 'Radial' : 'Force';
                    const btn = document.getElementById('mindmap-layout-toggle');
                    btn.innerHTML = this.layoutMode === 'Force' ? ICON_MINDMAP_FORCE : ICON_MINDMAP_RADIAL;
                    if (this.simulation) this.simulation.alpha(0.3).restart();
                },

                prepareAllMindmapData() {
                    const nodes = [], links = [];
                    this.mindmapRoots = [];

                    Object.entries(App.state.dataCache.mindMapSnippets).forEach(([articleId, snippetsData], index) => {
                        if (snippetsData.length === 0) return;

                        const article = App.storage.getArticle(articleId);
                        if (!article) return;
                        const colorScheme = this.colorManager.getSchemeFor(articleId, index);

                        const rootDims = this.calculateNodeDimensions(article.title || 'Untitled', 'root');
                        const rootNode = { id: articleId, mindmapId: articleId, text: article.title || 'Untitled', type: 'root', colorScheme, ...rootDims };
                        nodes.push(rootNode);
                        this.mindmapRoots.push(rootNode);

                        if (!this.nodeStates[rootNode.id]?.collapsed) {
                            snippetsData.forEach((snippet) => {
                                // Use clean <img> for images, and clean text for snippets
                                const nodeText = snippet.isImage ? `<img src="${snippet.src}">` : snippet.text;
                                const childDims = this.calculateNodeDimensions(nodeText, 'child');

                                nodes.push({
                                    id: snippet.id,
                                    articleId: articleId,
                                    mindmapId: articleId,
                                    text: nodeText,
                                    type: 'child',
                                    colorScheme,
                                    ...childDims
                                });
                                links.push({ source: rootNode.id, target: snippet.id });
                            });
                        }
                    });
                    this.mindmapRoots.sort((a, b) => a.text.localeCompare(b.text));
                    return { nodes, links };
                },

                calculateNodeDimensions(text, type) {

                    if (typeof text === 'string' && text.trim().startsWith('<img')) {
                        return { width: 180, height: 140, needsCustomScroll: false, lineHeight: 0 };
                    }

                    const measurer = document.getElementById('text-measurer');
                    if (!measurer) return { width: 288, height: 112, needsCustomScroll: false, lineHeight: 18 };

                    const isRoot = type === 'root';
                    measurer.style.fontSize = isRoot ? '14px' : '12px';
                    measurer.style.fontWeight = isRoot ? '600' : 'normal';
                    measurer.style.lineHeight = '1.5';
                    measurer.style.width = 'auto';
                    measurer.style.display = 'inline-block';
                    measurer.innerHTML = text;

                    const maxWidth = 250, maxHeight = 150, horizontalPadding = 28, verticalPadding = 20;
                    let contentWidth = measurer.offsetWidth;
                    let finalWidth = Math.min(maxWidth, contentWidth + horizontalPadding);
                    measurer.style.width = `${finalWidth - horizontalPadding}px`;
                    let contentHeight = measurer.scrollHeight;
                    const needsCustomScroll = contentHeight > (maxHeight - verticalPadding);
                    let finalHeight = needsCustomScroll ? maxHeight : Math.max(50, contentHeight + verticalPadding);
                    measurer.style.display = 'block';

                    return { width: finalWidth, height: finalHeight, needsCustomScroll, lineHeight: (isRoot ? 14 : 12) * 1.5 };
                },

                render() {
                    const container = d3.select("#mindmap-container");
                    container.selectAll("*").remove();
                    this.width = container.node().clientWidth;
                    this.height = container.node().clientHeight;
                    this.svg = container.append("svg").attr("viewBox", [-this.width / 2, -this.height / 2, this.width, this.height]);
                    this.g = this.svg.append("g");
                    this.zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", (e) => this.g.attr("transform", e.transform));
                    this.svg.call(this.zoom);
                },

                /* For Loading MindMap Quickly we use renderState & renderBatch */
                _renderState: {
                    allRootNodes: [],
                    fullNodes: [],
                    fullLinks: [],
                    renderedNodeIds: new Set(),
                    renderIndex: 0,
                    isRendering: false,
                    batchSize: 25, // Render 25 complete mind maps per batch
                    renderHandle: null
                },


                _renderNextMindMapBatch() {
                    if (!this._renderState.isRendering) return;
                    const { allRootNodes, fullNodes, fullLinks, batchSize } = this._renderState;
                    const { renderIndex } = this._renderState;
                    const rootsToRender = allRootNodes.slice(renderIndex, renderIndex + batchSize);
                    const rootIdsToRender = new Set(rootsToRender.map(r => r.id));
                    const nodesForThisBatch = fullNodes.filter(n => rootIdsToRender.has(n.mindmapId));
                    const linksForThisBatch = fullLinks.filter(l => rootIdsToRender.has(l.source.mindmapId || l.source));
                    const currentNodes = this.simulation.nodes();
                    const newNodes = [...currentNodes, ...nodesForThisBatch];
                    this.simulation.nodes(newNodes);
                    this.simulation.force("link").links([...this.simulation.force("link").links(), ...linksForThisBatch]);
                    const link = this.g.selectAll(".mindmap-link").data(this.simulation.force("link").links(), d => `${d.source.id}-${d.target.id}`);
                    link.enter().append("path").attr("class", "mindmap-link").style("stroke", d => `var(--mindmap-${d.source.colorScheme}-root)`).attr("opacity", 0).transition().duration(500).attr("opacity", 0.8);
                    const node = this.g.selectAll(".mindmap-node").data(newNodes, d => d.id);

                    const nodeEnter = node.enter().append("g").attr("class", d => `mindmap-node mindmap-${d.type}`).attr("opacity", 0);
                    nodeEnter.append("rect");
                    nodeEnter.append('foreignObject');

                    nodeEnter.append("title").text(d => d.text.includes('<img') ? null : d.text);

                    const allNodes = nodeEnter.merge(node);

                    allNodes.raise();

                    allNodes.call(this.drag(this.simulation))
                        .on("contextmenu", (event, d) => {
                            event.preventDefault();
                            // Simplified: All nodes (root or child) will open the source article.
                            const articleId = d.type === 'root' ? d.id : d.articleId;
                            App.router.navigateTo('article', { id: articleId, mode: 'read' });
                        })
                        .on("click", (event, d) => {
                            if (event.target.closest('.scroll-button-line')) return;
                            event.stopPropagation();
                            if (d.type === 'root') {
                                this.nodeStates[d.id] = { collapsed: !this.nodeStates[d.id]?.collapsed };
                                this.renderAllMindmaps({ shouldZoomToFit: false, isInteraction: true });
                            } else {
                                const nodeEl = d3.select(event.currentTarget);
                                const isFaded = nodeEl.classed('faded');
                                nodeEl.classed('faded', !isFaded);
                                this.g.selectAll('.mindmap-link').filter(l => l.target.id === d.id).classed('faded', !isFaded);
                            }
                        });
                    allNodes.select("rect").attr("width", d => d.width).attr("height", d => d.height).attr("x", d => -d.width / 2).attr("y", d => -d.height / 2).style("fill", d => d.type === 'root' ? `var(--mindmap-${d.colorScheme}-root)` : `var(--mindmap-${d.colorScheme}-child-bg)`).style("stroke", d => d.type === 'root' ? `var(--mindmap-${d.colorScheme}-root)` : 'var(--border-color)');
                    allNodes.select('foreignObject').attr('width', d => d.width).attr('height', d => d.height).attr('x', d => -d.width / 2).attr('y', d => -d.height / 2).html(d => `<div class="node-content-wrapper"><div class="node-html-content ${d.needsCustomScroll ? 'has-custom-scroll' : ''}" style="color: ${d.type === 'child' ? `var(--mindmap-${d.colorScheme}-child-text)` : `var(--text-on-primary)`}">${d.text}</div></div>`);
                    allNodes.transition().duration(500).attr("opacity", 1);
                    this.simulation.alpha(0.4).restart();
                    this._renderState.renderIndex += batchSize;
                    if (this.isInitialLoad) {
                        const progressPercent = Math.round((this._renderState.renderIndex / allRootNodes.length) * 100);
                        App.ui.showToast(`Loading map... ${Math.min(100, progressPercent)}%`, { type: 'info', duration: 2000 });
                    }
                    if (this._renderState.renderIndex < allRootNodes.length) {
                        this._renderState.renderHandle = requestIdleCallback(() => this._renderNextMindMapBatch());
                    } else {
                        this._renderState.isRendering = false;
                        if (this.isInitialLoad) App.ui.showToast('Map ready!', { type: 'success' });
                        this.isInitialLoad = false;
                    }
                },

                renderAllMindmaps(options = {}) {
                    const { shouldZoomToFit = true, isInteraction = false } = typeof options === 'boolean' ? { shouldZoomToFit: options } : options;

                    if (this._renderState.isRendering && this._renderState.renderHandle) {
                        cancelIdleCallback(this._renderState.renderHandle);
                    }

                    const oldNodePositions = new Map();
                    if (this.simulation) {
                        this.simulation.nodes().forEach(node => {
                            oldNodePositions.set(node.id, { x: node.x, y: node.y, fx: node.fx, fy: node.fy });
                        });
                    }

                    const { nodes, links } = this.prepareAllMindmapData();
                    const allRootNodes = this.mindmapRoots;

                    nodes.forEach(node => {
                        if (oldNodePositions.has(node.id)) {
                            const pos = oldNodePositions.get(node.id);
                            node.x = pos.x; node.y = pos.y; node.fx = pos.fx; node.fy = pos.fy;
                        }
                    });

                    // This new logic distinguishes between the initial load and subsequent interactions
                    if (!isInteraction && allRootNodes.length > this._renderState.batchSize) {
                        this._renderState.allRootNodes = allRootNodes; this._renderState.fullNodes = nodes; this._renderState.fullLinks = links; this._renderState.renderIndex = 0; this._renderState.isRendering = true;

                        this.g.selectAll("*").remove(); // Clear only on initial full load

                        this.simulation = d3.forceSimulation().force("link", d3.forceLink().id(d => d.id).distance(d => d.source.width / 2 + d.target.width / 2 + 40).strength(0.5)).force("charge", d3.forceManyBody().strength(-1200)).force("center", d3.forceCenter(0, 0)).force("collide", d3.forceCollide().radius(d => Math.max(d.width, d.height) / 2 + 15));
                        this.simulation.on("tick", () => { const nodeMap = new Map(this.simulation.nodes().map(n => [n.id, n])); this.g.selectAll(".mindmap-link").attr("d", d => { const sourceNode = typeof d.source === 'string' ? nodeMap.get(d.source) : d.source; const targetNode = typeof d.target === 'string' ? nodeMap.get(d.target) : d.target; if (!sourceNode || !targetNode) return null; const sourcePoint = this.calculateEdgePoint(sourceNode, targetNode); const targetPoint = this.calculateEdgePoint(targetNode, sourceNode); return `M${sourcePoint.x},${sourcePoint.y}C${sourcePoint.x},${(sourcePoint.y + targetPoint.y) / 2} ${targetPoint.x},${(sourcePoint.y + targetPoint.y) / 2} ${targetPoint.x},${targetPoint.y}`; }); this.g.selectAll(".mindmap-node").attr("transform", d => `translate(${d.x},${d.y})`); });

                        this._renderNextMindMapBatch();
                    } else {
                        // This is the flicker-free path for small maps and ALL interactions on large maps
                        this._renderState.isRendering = false;
                        if (!this.simulation) {
                            this.simulation = d3.forceSimulation().force("link", d3.forceLink().id(d => d.id).distance(d => d.source.width / 2 + d.target.width / 2 + 40).strength(0.5)).force("charge", d3.forceManyBody().strength(-1200)).force("center", d3.forceCenter(0, 0)).force("collide", d3.forceCollide().radius(d => Math.max(d.width, d.height) / 2 + 15));
                            this.simulation.on("tick", () => { const nodeMap = new Map(this.simulation.nodes().map(n => [n.id, n])); this.g.selectAll(".mindmap-link").attr("d", d => { const sourceNode = typeof d.source === 'string' ? nodeMap.get(d.source) : d.source; const targetNode = typeof d.target === 'string' ? nodeMap.get(d.target) : d.target; if (!sourceNode || !targetNode) return null; const sourcePoint = this.calculateEdgePoint(sourceNode, targetNode); const targetPoint = this.calculateEdgePoint(targetNode, sourceNode); return `M${sourcePoint.x},${sourcePoint.y}C${sourcePoint.x},${(sourcePoint.y + targetPoint.y) / 2} ${targetPoint.x},${(sourcePoint.y + targetPoint.y) / 2} ${targetPoint.x},${targetPoint.y}`; }); this.g.selectAll(".mindmap-node").attr("transform", d => `translate(${d.x},${d.y})`); });
                        }
                        this.simulation.nodes(nodes);
                        this.simulation.force("link").links(links);

                        const link = this.g.selectAll(".mindmap-link").data(links, d => `${d.source.id}-${d.target.id}`);
                        link.join(
                            enter => enter.append("path").attr("class", "mindmap-link").style("stroke", d => `var(--mindmap-${d.source.colorScheme}-root)`).attr("opacity", 0).transition().duration(500).attr("opacity", 0.8),
                            update => update,
                            exit => exit.transition().duration(300).attr("opacity", 0).remove()
                        );

                        const node = this.g.selectAll(".mindmap-node").data(nodes, d => d.id);
                        node.join(
                            enter => {
                                const g = enter.append("g").attr("class", d => `mindmap-node mindmap-${d.type} ${d.text.includes('<img') ? 'image-node' : ''}`).attr("opacity", 0);
                                g.append("rect"); g.append('foreignObject');
                                g.append("title").text(d => d.text.includes('<img') ? null : d.text);
                                g.call(this.drag(this.simulation))
                                    .on("contextmenu", (event, d) => {
                                        event.preventDefault();
                                        if (d.type === 'root') {
                                            App.router.navigateTo('article', { id: d.id, mode: 'read' });
                                        } else { // It's a child node (snippet)
                                            App.router.navigateTo('article', { id: d.articleId, mode: 'read', scrollToSnippetId: d.id });
                                        }
                                    })

                                    .on("click", (event, d) => {
                                        if (event.target.closest('.scroll-button-line')) return;
                                        event.stopPropagation();
                                        if (d.type === 'root') {
                                            if (this.simulation) { this.simulation.nodes().forEach(nodeData => { if (nodeData.type === 'root' && nodeData.id !== d.id) { nodeData.fx = nodeData.x; nodeData.fy = nodeData.y; } }); }
                                            this.nodeStates[d.id] = { collapsed: !this.nodeStates[d.id]?.collapsed };
                                            this.renderAllMindmaps({ shouldZoomToFit: false, isInteraction: true });
                                            setTimeout(() => { if (!this.simulation) return; this.simulation.nodes().forEach(nodeData => { if (nodeData.type === 'root' && nodeData.id !== d.id) { nodeData.fx = null; nodeData.fy = null; } }); }, 2000);
                                        } else {
                                            const nodeEl = d3.select(event.currentTarget);
                                            const isFaded = nodeEl.classed('faded');
                                            nodeEl.classed('faded', !isFaded);
                                            this.g.selectAll('.mindmap-link').filter(l => l.target.id === d.id).classed('faded', !isFaded);
                                        }
                                    });
                                g.transition().duration(500).attr("opacity", 1);
                                return g;
                            },
                            update => update,
                            exit => exit.transition().duration(300).attr("opacity", 0).remove()
                        );

                        this.g.selectAll(".mindmap-node").call(el => {
                            el.select("rect")
                                .attr("width", d => d.width).attr("height", d => d.height)
                                .attr("x", d => -d.width / 2).attr("y", d => -d.height / 2)
                                .style("fill", d => {
                                    // For image nodes, use the app's secondary background for the mat effect
                                    if (d.text.includes('<img')) return 'var(--bg-secondary)';
                                    return d.type === 'root' ? `var(--mindmap-${d.colorScheme}-root)` : `var(--mindmap-${d.colorScheme}-child-bg)`;
                                })
                                .style("stroke", d => {
                                    // For image nodes, use a subtle border for a crisp edge
                                    if (d.text.includes('<img')) return 'var(--border-color)';
                                    return d.type === 'root' ? `var(--mindmap-${d.colorScheme}-root)` : 'var(--border-color)';
                                })
                                // Remove the custom filter and border-radius; let the main stylesheet handle it
                                .style("filter", null)
                                .style("border-radius", null);

                            el.select('foreignObject')
                                .attr('width', d => d.width).attr('height', d => d.height)
                                .attr('x', d => -d.width / 2).attr('y', d => -d.height / 2)
                                .html(d => {
                                    const content = d.text;
                                    return `<div class="node-content-wrapper"><div class="node-html-content ${d.needsCustomScroll ? 'has-custom-scroll' : ''}" style="color: ${d.type === 'child' ? `var(--mindmap-${d.colorScheme}-child-text)` : `var(--text-on-primary)`}">${content}</div></div>`
                                });
                            el.filter(d => d.needsCustomScroll)
                                .select('.node-content-wrapper')
                                .append('xhtml:div')
                                .attr('class', 'scroll-button-line')
                                .style('background-color', d => {
                                    const theme = document.documentElement.getAttribute('data-theme');
                                    if (d.type === 'root') return 'rgba(255, 255, 255, 0.5)';
                                    return theme === 'light' ? 'rgba(0, 0, 0, 0.3)' : `var(--mindmap-${d.colorScheme}-root)`;
                                })
                                .on('click', function (event, d) {
                                    event.stopPropagation();
                                    const container = this.parentNode.querySelector('.node-html-content');
                                    if (!container) return;

                                    const scrollAmount = 100; // A consistent scroll amount in pixels is more reliable
                                    const currentTop = container.scrollTop;
                                    const maxScroll = container.scrollHeight - container.clientHeight;

                                    let targetScrollTop;
                                    if (currentTop >= maxScroll - 5) {
                                        targetScrollTop = 0;
                                    } else {

                                        targetScrollTop = Math.min(maxScroll, currentTop + scrollAmount);
                                    }

                                    container.scrollTo({ top: targetScrollTop, behavior: 'smooth' });
                                })

                            el.select("title").text(d => d.text.includes('<img') ? null : d.text);
                        });

                        this.simulation.alpha(0.3).restart();
                        if (shouldZoomToFit) setTimeout(() => this.zoomToFit(), 100);
                    }
                },



                searchNodes(term) {
                    this.currentMindmapSearchResults = []; this.currentMindmapSearchIndex = -1;
                    const resultsList = document.getElementById('mindmap-search-results');
                    const termLower = term.toLowerCase().trim();
                    this.g.selectAll('.mindmap-node').classed('mindmap-search-highlight', false);
                    resultsList.innerHTML = ''; resultsList.style.display = 'none';
                    if (!termLower) return;
                    const results = this.g.selectAll('.mindmap-node').filter(d => d.text.toLowerCase().includes(termLower));
                    if (!results.empty()) {
                        results.classed('mindmap-search-highlight', true);
                        const resultsData = results.data();

                        // FIX: Sort the results to prioritize master nodes over children nodes.
                        resultsData.sort((a, b) => {
                            // If a is a root and b is a child, a comes first (-1).
                            if (a.type === 'root' && b.type !== 'root') {
                                return -1;
                            }
                            // If b is a root and a is a child, b comes first (1).
                            if (a.type !== 'root' && b.type === 'root') {
                                return 1;
                            }
                            // If both are the same type, sort them alphabetically.
                            return a.text.localeCompare(b.text);
                        });

                        this.currentMindmapSearchResults = resultsData;
                        const ul = document.createElement('ul');
                        resultsData.forEach(d => {
                            const li = document.createElement('li'); const a = document.createElement('a'); a.href = '#'; a.textContent = `${d.type === 'root' ? 'Article:' : 'Snippet:'} ${d.text.slice(0, 30)}...`;
                            a.onclick = (e) => { e.preventDefault(); this.zoomToNode(d); resultsList.style.display = 'none'; };
                            li.appendChild(a); ul.appendChild(li);
                        });
                        resultsList.appendChild(ul); resultsList.style.display = 'block';

                        this.findNextSearchResult();
                    }
                },
                findNextSearchResult() {
                    if (!this.currentMindmapSearchResults || this.currentMindmapSearchResults.length === 0) { const searchTerm = document.getElementById('mindmap-search-input').value; if (searchTerm) { this.searchNodes(searchTerm); if (!this.currentMindmapSearchResults || this.currentMindmapSearchResults.length === 0) { App.ui.showToast("No results found.", { type: 'error' }); return; } } else { App.ui.showToast("Nothing to search for.", { type: 'error' }); return; } }
                    this.currentMindmapSearchIndex = (this.currentMindmapSearchIndex + 1) % this.currentMindmapSearchResults.length;
                    const targetNodeData = this.currentMindmapSearchResults[this.currentMindmapSearchIndex];
                    if (targetNodeData) { this.zoomToNode(targetNodeData); this.g.selectAll('.mindmap-node').filter(d => d.id === targetNodeData.id).select('rect').transition().duration(200).style('stroke', 'var(--danger-color)').style('stroke-width', '4px').transition().duration(1500).style('stroke', 'var(--border-color)').style('stroke-width', '1.5px'); }
                },
                navigateToNextMap() { if (this.mindmapRoots.length === 0) return; this.currentMindmapIndex = (this.currentMindmapIndex + 1) % this.mindmapRoots.length; this.zoomToNode(this.mindmapRoots[this.currentMindmapIndex]); App.ui.showToast(`Mind Map ${this.currentMindmapIndex + 1} of ${this.mindmapRoots.length}`); },
                navigateToPrevMap() { if (this.mindmapRoots.length === 0) return; this.currentMindmapIndex--; if (this.currentMindmapIndex < 0) this.currentMindmapIndex = this.mindmapRoots.length - 1; this.zoomToNode(this.mindmapRoots[this.currentMindmapIndex]); App.ui.showToast(`Mind Map ${this.currentMindmapIndex + 1} of ${this.mindmapRoots.length}`); },
                cycleSnapshots() { const snapshots = App.state.mindMapState.snapshots; if (!snapshots || snapshots.length === 0) { App.ui.showToast('No snapshots saved.'); return; } this.currentSnapshotIndex = (this.currentSnapshotIndex + 1) % snapshots.length; const snapshotToLoad = snapshots[snapshots.length - 1 - this.currentSnapshotIndex]; this.loadSnapshot(snapshotToLoad); App.ui.showToast(`Snapshot ${this.currentSnapshotIndex + 1}/${snapshots.length} ${this.currentSnapshotIndex === 0 ? '(Latest)' : ''}`); },
                deleteOldSnapshots() { const snapshots = App.state.mindMapState.snapshots; if (!snapshots || snapshots.length === 0) { App.ui.showToast('No snapshots to delete.', { type: 'error' }); return; } snapshots.shift(); this.currentSnapshotIndex = -1; App.fs.write('mind-map-state.json', App.state.mindMapState); App.ui.showToast(`Oldest Snapshot Deleted.`); },
                loadSnapshot(snapshot) {
                    if (!snapshot) return; this.nodeStates = snapshot.nodeStates || {}; this.renderAllMindmaps(false);
                    if (snapshot.nodePositions && this.simulation) {
                        const positionMap = new Map(snapshot.nodePositions.map(p => [p.id, p]));
                        this.simulation.nodes().forEach(node => { const savedPos = positionMap.get(node.id); if (savedPos) { node.x = savedPos.x; node.y = savedPos.y; node.fx = savedPos.fx; node.fy = savedPos.fy; } });
                    }
                    if (snapshot.transform) { const { x, y, k } = snapshot.transform; this.svg.transition().duration(750).call(this.zoom.transform, d3.zoomIdentity.translate(x, y).scale(k)); }
                },
                async saveSnapshotAndExport() {
                    const btn = document.getElementById('mindmap-snapshot-btn'); btn.style.color = 'var(--primary-color)';
                    const transform = d3.zoomTransform(this.svg.node());
                    const nodePositions = this.simulation ? this.simulation.nodes().map(n => ({ id: n.id, x: n.x, y: n.y, fx: n.fx, fy: n.fy })) : [];
                    const newSnapshot = { transform: { x: transform.x, y: transform.y, k: transform.k }, nodeStates: JSON.parse(JSON.stringify(this.nodeStates)), nodePositions, timestamp: new Date().toISOString() };
                    App.state.mindMapState.snapshots.push(newSnapshot);
                    if (App.state.mindMapState.snapshots.length > 10) App.state.mindMapState.snapshots.shift();
                    await App.fs.write('mind-map-state.json', App.state.mindMapState);
                    try {
                        const container = document.getElementById('mindmap-container');
                        const blob = await htmlToImage.toBlob(container, { backgroundColor: getComputedStyle(container).backgroundColor });
                        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
                        App.ui.showToast('Snapshot saved & image copied!');
                    } catch (e) { console.error("Mind map copy failed", e); App.ui.showToast('Snapshot saved (image copy failed).', { type: 'error' }); }
                    setTimeout(() => { btn.style.color = ''; }, 1000);
                },
                zoomToNode(nodeData) {
                    if (!nodeData || typeof nodeData.x !== 'number') return;
                    const scale = 1.2; const x = -nodeData.x * scale; const y = -nodeData.y * scale;
                    const transform = d3.zoomIdentity.translate(x, y).scale(scale);
                    const currentTransform = d3.zoomTransform(this.svg.node());
                    if (Math.abs(currentTransform.k - transform.k) < 0.01 && Math.abs(currentTransform.x - transform.x) < 1 && Math.abs(currentTransform.y - transform.y) < 1) return;
                    this.svg.transition().duration(750).call(this.zoom.transform, transform);
                },
                zoomToFit() {
                    if (!this.g.node() || this.g.selectAll('.mindmap-node').empty()) return;
                    const bounds = this.g.node().getBBox(); if (bounds.width === 0 || bounds.height === 0) return;
                    const { x, y, width, height } = bounds;
                    const scale = Math.min(1.5, 0.8 / Math.max(width / this.width, height / this.height));
                    const transform = d3.zoomIdentity.translate(-x * scale - (width * scale / 2), -y * scale - (height * scale / 2)).scale(scale);
                    this.svg.transition().duration(750).call(this.zoom.transform, transform);
                },
                zoomIn() { this.zoom && this.svg.transition().duration(750).call(this.zoom.scaleBy, 1.3); },
                zoomOut() { this.zoom && this.svg.transition().duration(750).call(this.zoom.scaleBy, 1 / 1.3); },
                gatherNodes() {
                    if (!this.simulation) return;
                    this.simulation.nodes().forEach(node => {
                        if (node.type === 'root') {
                            node.fx = null;
                            node.fy = null;
                        }
                    });

                    this.simulation
                        .force("x_gather", d3.forceX(0).strength(d => d.type === 'root' ? 0.15 : 0))
                        .force("y_gather", d3.forceY(0).strength(d => d.type === 'root' ? 0.15 : 0));

                    this.simulation.alpha(1).restart();

                    setTimeout(() => {
                        if (!this.simulation) return;
                        this.simulation.force("x_gather", null)
                            .force("y_gather", null);
                    }, 3000);
                },

                drag(simulation) {
                    function dragstarted(event, d) {
                        if (!event.active) simulation.alphaTarget(0.1).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    }
                    function dragged(event, d) {
                        d.fx = event.x;
                        d.fy = event.y;
                        d3.select(this).classed('dragging', true);
                    }
                    function dragended(event, d) {
                        // Reheat the simulation briefly to settle forces, then cool it down.
                        if (!event.active) {
                            simulation.alphaTarget(0.1).restart();
                            setTimeout(() => simulation.alphaTarget(0), 100);
                        }
                        d3.select(this).classed('dragging', false);

                        if (d.type === 'root') {
                            // Pin the root node to its final location.
                            d.fx = d.x;
                            d.fy = d.y;
                        } else {
                            // Un-pin child nodes to allow them to follow the parent.
                            d.fx = null;
                            d.fy = null;
                        }
                    }
                    return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
                },
            },

            // ==========================================================================
            // 3.18. VISUAL MAP MODULE (v2 - REBUILT FROM PROTOTAGS)
            // ==========================================================================
            visualMap: {
                svg: null, g: null, zoom: null, simulation: null, link: null, node: null, width: 0, height: 0, resizeObserver: null,
                currentFilter: 'all', currentCategoryIndex: -1, nodeStates: {}, layoutMode: 'Force',
                selectedNodes: new Set(), currentZoom: { k: 1, x: 0, y: 0 },
                currentSearchResults: [], currentSearchIndex: -1,
                isLassoActive: false, lassoPoints: [], lassoSelection: null,
                colorPalettes: {
                    category: ["#d90429", "#f77f00", "#ef476f", "#c71f37", "#ff85a1", "#ffafcc"],
                    tag: ["#4361ee", "#3a0ca3", "#7209b7", "#00b4d8", "#5e60ce", "#64dfdf", "#9d4edd", "#0077b6", "#ade8f4", "#480ca8"],
                    article: ["#55a630", "#80b918", "#aacc00", "#f4e409", "#ffbe0b", "#008000", "#70e000", "#b5e48c", "#d4d700", "#eeef20"],
                    orphan: ["#6c757d", "#adb5bd", "#495057", "#ced4da"]
                },

                initEventListeners() {
                    document.getElementById('zoom-in-btn').onclick = () => this.zoomIn();
                    document.getElementById('zoom-out-btn').onclick = () => this.zoomOut();
                    document.getElementById('reset-view-btn').onclick = () => this.zoomToFit();
                    document.getElementById('cycle-category-btn').onclick = () => this.cycleCategoryFocus();
                    document.getElementById('revert-color-btn').onclick = () => this.setDefaultNodeColors();
                    document.getElementById('gather-nodes-btn').onclick = () => this.gatherNodes();
                    document.getElementById('filter-all-btn').onclick = () => this.setNodeStates('expand-all');
                    document.getElementById('filter-tags-btn').onclick = () => this.setNodeStates('collapse-to-tags');
                    document.getElementById('filter-orphans-btn').onclick = () => this.setNodeStates('orphans');
                    document.getElementById('vm-focus-line').onclick = () => App.events.toggleCanvasFocusMode();

                    // Premium Feature Gates
                    document.getElementById('random-color-btn').onclick = () => {
                        if (App.license.isPremium()) this.randomizeNodeColors(); else App.ui.showAscensionModal();
                    };
                    document.getElementById('visual-map-layout-toggle').onclick = () => {
                        if (App.license.isPremium()) this.toggleLayout(); else App.ui.showAscensionModal();
                    };
                    document.getElementById('visual-map-snapshot-btn').onclick = () => {
                        if (App.license.isPremium()) this.exportAndSave(); else App.ui.showAscensionModal();
                    };
                    document.getElementById('toggle-snapshots-btn').onclick = () => {
                        if (App.license.isPremium()) this.cycleSnapshots(); else App.ui.showAscensionModal();
                    };
                    document.getElementById('delete-snapshots-btn').onclick = () => {
                        if (App.license.isPremium()) this.deleteOldSnapshots(); else App.ui.showAscensionModal();
                    };
                    document.getElementById('lasso-btn').onclick = () => {
                        if (App.license.isPremium()) this.toggleLasso(); else App.ui.showAscensionModal();
                    };
                    document.getElementById('expand-selection-btn').onclick = () => {
                        if (App.license.isPremium()) this.modifySelection('expand'); else App.ui.showAscensionModal();
                    };
                    document.getElementById('collapse-selection-btn').onclick = () => {
                        if (App.license.isPremium()) this.modifySelection('collapse'); else App.ui.showAscensionModal();
                    };

                    // Search listeners
                    const searchInput = document.getElementById('graph-search-input');
                    searchInput.oninput = (e) => this.searchNodes(e.target.value);
                    searchInput.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); this.findNextSearchResult(); } };
                    document.getElementById('find-next-btn').onclick = () => this.findNextSearchResult();

                    const layoutBtn = document.getElementById('visual-map-layout-toggle');
                    if (layoutBtn) layoutBtn.innerHTML = ICON_FORCE;
                },

                init() {
                    // If the view is already set up, just update the data
                    if (this.svg) {
                        this.updateGraph();
                        return;
                    }

                    // If it's the first time, render the canvas, then set up all listeners.
                    this.render();
                    this.initEventListeners();

                    const container = document.getElementById('visual-map-container');
                    container.focus();

                    // ... (rest of the original function from this point onwards)
                    container.onkeydown = (e) => {
                        if (document.activeElement.tagName !== 'INPUT') {
                            if (e.key === ' ' && e.shiftKey) { this.zoomOut(); e.preventDefault(); }
                            else if (e.key === ' ') { this.zoomIn(); e.preventDefault(); }
                            else {
                                switch (e.key.toLowerCase()) {
                                    case 'arrowup': this.pan(0, 1); e.preventDefault(); break;
                                    case 'arrowdown': this.pan(0, -1); e.preventDefault(); break;
                                    case 'arrowleft': this.pan(1, 0); e.preventDefault(); break;
                                    case 'arrowright': this.pan(-1, 0); e.preventDefault(); break;
                                    case 't': this.cycleCategoryFocus(); e.preventDefault(); break;
                                    case 'c':
                                        if (App.license.isPremium()) this.randomizeNodeColors();
                                        else App.ui.showAscensionModal();
                                        e.preventDefault();
                                        break;
                                    case 'f': App.events.toggleCanvasFocusMode(); e.preventDefault(); break;
                                    // --- SHORTCUT SWAP ---
                                    case 's': document.getElementById('graph-search-input')?.focus(); e.preventDefault(); break; // 'S' is now for Search
                                    case 'p': this.exportAndSave(); e.preventDefault(); break; // 'F' is now for snapshot/save frame
                                    // --- END SWAP ---
                                    case 'l': this.toggleLasso(); e.preventDefault(); break;
                                    case 'r': this.zoomToFit(); e.preventDefault(); break;
                                    case 'escape':
                                        if (document.body.classList.contains('canvas-focus-mode')) {
                                            App.events.toggleCanvasFocusMode();
                                        } else if (this.isLassoActive) {
                                            this.toggleLasso();
                                        } else {
                                            const searchInput = document.getElementById('graph-search-input');
                                            if (searchInput) { searchInput.value = ''; this.searchNodes(''); searchInput.blur(); }
                                        }
                                        e.preventDefault();
                                        break;
                                    case '+': case '=': this.zoomIn(); e.preventDefault(); break;
                                    case '-': this.zoomOut(); e.preventDefault(); break;
                                }
                            }
                        }
                    };

                    const snapshots = App.state.visualMapState.snapshots || [];
                    if (snapshots.length > 0) {
                        this.loadSnapshot(snapshots[snapshots.length - 1]);
                    } else {
                        this.zoomToFit();
                    }

                    this.resizeObserver = new ResizeObserver(entries => {
                        const { width, height } = entries[0].contentRect;
                        if ((width === this.width && height === this.height) || width < 1) return;
                        this.width = width;
                        this.height = height;
                        this.svg.attr("viewBox", [0, 0, this.width, this.height]);
                        this.simulation.force("center", d3.forceCenter(this.width / 2, this.height / 2)).alpha(0.3).restart();
                    });
                    this.resizeObserver.observe(container);

                    container.addEventListener('wheel', e => e.preventDefault(), { passive: false });
                },

                triggerResize() {
                    const container = document.getElementById('visual-map-container');
                    if (!container || !this.resizeObserver) return;
                    this.resizeObserver.disconnect();
                    const newWidth = container.clientWidth;
                    const newHeight = container.clientHeight;
                    if (newWidth > 0 && newHeight > 0) {
                        this.width = newWidth;
                        this.height = newHeight;
                        this.svg.attr("viewBox", [0, 0, this.width, this.height]);
                        this.simulation.force("center", d3.forceCenter(this.width / 2, this.height / 2)).alpha(0.3).restart();
                    }
                    this.resizeObserver.observe(container);
                },

                destroy() {
                    if (this.simulation) this.simulation.stop();
                    if (this.resizeObserver) this.resizeObserver.disconnect();
                    d3.select("#visual-map-container > svg").remove();
                    d3.select("#visual-map-container > #sticky-note-layer").remove();
                    this.svg = this.g = this.zoom = this.simulation = this.resizeObserver = null;
                },
                // Located in App.visualMap
                render() {
                    const container = d3.select("#visual-map-container");
                    container.selectAll("*").remove();
                    if (this.simulation) this.simulation.stop();
                    const rect = container.node().getBoundingClientRect();
                    this.width = Math.max(10, Math.floor(rect.width));
                    this.height = Math.max(10, Math.floor(rect.height));
                    if (this.width < 10 || this.height < 10) {
                        requestAnimationFrame(() => this.render());
                        return;
                    }

                    const stickyNoteLayer = container.append("div").attr("id", "sticky-note-layer");
                    this.svg = container.append("svg").attr("viewBox", [0, 0, this.width, this.height]);
                    const defs = this.svg.append("defs");
                    defs.append("radialGradient").attr("id", "node-gradient").append("stop").attr("offset", "0%").attr("stop-color", "white").attr("stop-opacity", 0.3).select(function () { return this.parentNode; }).append("stop").attr("offset", "100%").attr("stop-color", "white").attr("stop-opacity", 0);
                    const dropShadow = defs.append("filter").attr("id", "drop-shadow").attr("height", "130%");
                    dropShadow.append("feGaussianBlur").attr("in", "SourceAlpha").attr("stdDeviation", 1);
                    dropShadow.append("feOffset").attr("dx", 1).attr("dy", 1).attr("result", "offsetblur");
                    const feMerge = dropShadow.append("feMerge");
                    feMerge.append("feMergeNode"); feMerge.append("feMergeNode").attr("in", "SourceGraphic");
                    this.g = this.svg.append("g");
                    this.g.append('rect').attr('class', 'background-rect').attr('width', '140%').attr('height', '140%').attr('x', '-20%').attr('y', '-20%').attr('fill', 'var(--bg-secondary)');
                    this.link = this.g.append("g").attr("class", "links").selectAll("line");
                    this.node = this.g.append("g").attr("class", "nodes").selectAll("g.node-group");
                    this.simulation = d3.forceSimulation()
                        .force("charge", d3.forceManyBody().strength(-300))
                        .force("center", d3.forceCenter(this.width / 2, this.height / 2).strength(1))
                        .force("collision", d3.forceCollide().radius(d => d.type === 'category' ? 30 : 20))
                        .force("link", d3.forceLink().id(d => d.id).distance(80).strength(1))
                        .force("x", d3.forceX(this.width / 2).strength(0.05))
                        .force("y", d3.forceY(this.height / 2).strength(0.05))
                        .alphaDecay(0.0228)
                        .velocityDecay(0.4);

                    this.updateGraph();

                    // FIX: The "tick" handler is simplified to remove the node constraints.
                    this.simulation.on("tick", () => {
                        this.node.attr("transform", d => `translate(${d.x},${d.y})`);
                        this.link.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                    });

                    this.zoom = d3.zoom().scaleExtent([0.1, 4])
                        .filter(event => !event.target.closest('.node-group'))
                        .on("zoom", (e) => {
                            this.currentZoom = e.transform;
                            this.g.attr("transform", e.transform);
                            stickyNoteLayer.style("transform", `translate(${e.transform.x}px, ${e.transform.y}px) scale(${e.transform.k})`);
                            this.g.selectAll('.node-text').classed('lod-hidden', e.transform.k < 0.6);
                        });
                    this.svg.call(this.zoom).on("dblclick.zoom", null);
                },


                /* Fix for Large DataSets for Map */
                _renderState: {
                    fullNodes: [],
                    fullLinks: [],
                    renderIndex: 0,
                    isRendering: false,
                    batchSize: 150, // Render 150 nodes per batch
                    renderHandle: null
                },
                // Located in App.visualMap - REPLACE the entire function
                _renderNextBatch() {
                    if (!this._renderState.isRendering) return;

                    const { fullNodes, fullLinks, batchSize } = this._renderState;
                    let { renderIndex } = this._renderState;

                    const nodesBatch = fullNodes.slice(0, renderIndex + batchSize);

                    const renderedNodeIds = new Set(nodesBatch.map(n => n.id));
                    const linksBatch = fullLinks.filter(l => renderedNodeIds.has(l.source.id || l.source) && renderedNodeIds.has(l.target.id || l.target));

                    this.simulation.nodes(nodesBatch);
                    this.simulation.force("link").links(linksBatch);

                    this.link = this.g.select(".links").selectAll("line").data(linksBatch, d => d.id);
                    this.link.enter().append("line").attr('class', 'link').attr("stroke-opacity", 0).merge(this.link)
                        .attr("stroke-width", 1.5).attr("stroke", d => {
                            if (d.source.type === 'category' && d.target.type === 'tag') return 'var(--node-category)';
                            if (d.source.type === 'tag' && d.target.type === 'article') return 'var(--node-tag)';
                            return 'var(--border-color)';
                        }).transition().duration(500).attr("stroke-opacity", 0.6);
                    this.link.exit().remove();

                    this.node = this.g.select(".nodes").selectAll("g.node-group").data(nodesBatch, d => d.id);
                    const nodeEnter = this.node.enter().append("g").attr("class", "node-group").attr("opacity", 0);

                    nodeEnter.append("title").text(d => {
                        if (d.type === 'article' || d.type === 'orphan') { const article = App.storage.getArticle(d.realId); if (!article) return d.label; const tempDiv = document.createElement('div'); tempDiv.innerHTML = article.content; const excerpt = (tempDiv.textContent || "").substring(0, 150); return `${article.title}\n\n${excerpt}...`; } return d.label;
                    });
                    nodeEnter.append("circle").attr("class", "node-main-body").attr("r", d => d.type === 'category' ? 15 : (d.type === 'tag' || d.type === 'orphan') ? 10 : 8).style("fill", d => d.isDuplicate ? `var(--node-article-duplicate)` : `var(--node-${d.type})`).style("filter", "url(#drop-shadow)");
                    nodeEnter.append("circle").attr("class", "node-highlight").attr("r", d => d.type === 'category' ? 15 : (d.type === 'tag' || d.type === 'orphan') ? 10 : 8).attr("fill", "url(#node-gradient)");
                    nodeEnter.append("text").attr("class", d => `node-text ${this.currentZoom.k < 0.6 ? 'lod-hidden' : ''}`).text(d => d.label).attr("fill", "var(--node-text-color)").attr("x", d => d.type === 'category' ? 20 : 15).attr("y", 4).style("pointer-events", "none");
                    nodeEnter.call(this.drag(this.simulation));


                    nodeEnter.on("click", (event, d) => {
                        if (event.defaultPrevented) return;
                        event.stopPropagation();
                        if (event.shiftKey) {
                            this.toggleNodeSelection(d.id);
                        } else {
                            if (d.type === 'article') {
                                this.stickyNotes.create(d);
                            } else if (d.type === 'orphan') {
                                App.router.navigateTo('article', { id: d.realId, mode: 'read' });
                            } else {
                                // This is the logic that handles collapsing for Categories and Tags
                                this.nodeStates[d.id] = { collapsed: !(this.nodeStates[d.id]?.collapsed) };
                                this.updateGraph(); // This re-runs the main render function with the new state
                            }
                        }
                    });


                    this.node = nodeEnter.merge(this.node);
                    this.node.exit().transition().duration(300).attr("opacity", 0).remove();
                    this.node.raise().transition().duration(500).attr("opacity", 1);

                    this.simulation.alpha(0.3).restart();

                    this._renderState.renderIndex += batchSize;

                    const progressPercent = Math.round((this._renderState.renderIndex / fullNodes.length) * 100);
                    App.ui.showToast(`Loading graph... ${Math.min(100, progressPercent)}%`, { type: 'info', duration: 2000 });

                    if (this._renderState.renderIndex < fullNodes.length) {
                        this._renderState.renderHandle = requestIdleCallback(() => this._renderNextBatch());
                    } else {
                        this._renderState.isRendering = false;
                        App.ui.showToast('Graph loaded!', { type: 'success' });
                    }
                },


                updateGraph() {
                    if (this._renderState.isRendering && this._renderState.renderHandle) {
                        cancelIdleCallback(this._renderState.renderHandle);
                    }

                    const { nodes, links } = this.prepareGraphData(this.currentFilter);

                    if (nodes.length <= this._renderState.batchSize) {
                        this._renderState.isRendering = false;
                        this.simulation.nodes(nodes);
                        this.simulation.force("link").links(links);

                        this.link = this.g.select(".links").selectAll("line").data(links, d => d.id).join(enter => enter.append("line").attr('class', 'link').attr("stroke-opacity", 0), u => u, exit => exit.transition().duration(300).attr("stroke-opacity", 0).remove());
                        this.node = this.g.select(".nodes").selectAll("g.node-group").data(nodes, d => d.id).join(enter => { const nodeEnter = enter.append("g").attr("class", "node-group").attr("opacity", 0); nodeEnter.append("title").text(d => { if (d.type === 'article' || d.type === 'orphan') { const article = App.storage.getArticle(d.realId); if (!article) return d.label; const tempDiv = document.createElement('div'); tempDiv.innerHTML = article.content; const excerpt = (tempDiv.textContent || "").substring(0, 150); return `${article.title}\n\n${excerpt}...`; } return d.label; }); nodeEnter.append("circle").attr("class", "node-main-body").attr("r", d => d.type === 'category' ? 15 : (d.type === 'tag' || d.type === 'orphan') ? 10 : 8).style("fill", d => d.isDuplicate ? `var(--node-article-duplicate)` : `var(--node-${d.type})`).style("filter", "url(#drop-shadow)"); nodeEnter.append("circle").attr("class", "node-highlight").attr("r", d => d.type === 'category' ? 15 : (d.type === 'tag' || d.type === 'orphan') ? 10 : 8).attr("fill", "url(#node-gradient)"); nodeEnter.append("text").attr("class", d => `node-text ${this.currentZoom.k < 0.6 ? 'lod-hidden' : ''}`).text(d => d.label).attr("font-size", "10px").attr("fill", "var(--node-text-color)").attr("x", d => d.type === 'category' ? 20 : 15).attr("y", 4).style("pointer-events", "none"); nodeEnter.call(this.drag(this.simulation)); nodeEnter.on("click", (event, d) => { if (event.defaultPrevented) return; event.stopPropagation(); if (event.shiftKey) { this.toggleNodeSelection(d.id); } else { if (d.type === 'article') { this.stickyNotes.create(d); } else if (d.type === 'orphan') { App.router.navigateTo('article', { id: d.realId, mode: 'read' }); } else { this.nodeStates[d.id] = { collapsed: !(this.nodeStates[d.id]?.collapsed) }; this.updateGraph(); } } }); return nodeEnter; }, u => u, exit => exit.transition().duration(300).attr("opacity", 0).remove());
                        this.link.attr("stroke-width", 1.5).attr("stroke", d => { if (d.source.type === 'category' && d.target.type === 'tag') return 'var(--node-category)'; if (d.source.type === 'tag' && d.target.type === 'article') return 'var(--node-tag)'; return 'var(--border-color)'; });
                        this.node.raise();
                        this.node.transition().duration(500).attr("opacity", 1);
                        this.link.transition().duration(500).attr("stroke-opacity", 0.6);
                        const numNodes = this.simulation.nodes().length;
                        this.simulation.force("charge").strength(-250 - numNodes * 5);
                        this.simulation.force("link").distance(d => (d.source.type === 'category' ? 100 : 60) + (numNodes / 4));
                        this.simulation.alpha(0.3).restart();

                    } else {
                        this._renderState.fullNodes = nodes;
                        this._renderState.fullLinks = links;
                        this._renderState.renderIndex = 0;
                        this._renderState.isRendering = true;

                        this.simulation.nodes([]);
                        this.simulation.force("link").links([]);
                        this.g.select(".nodes").selectAll("g.node-group").remove();
                        this.g.select(".links").selectAll("line").remove();

                        this._renderNextBatch();
                    }
                },



                prepareGraphData(filter) {
                    const articles = App.state.articles;
                    if (filter === 'orphans') {
                        const orphanNodes = articles.filter(a => !a.tags || a.tags.length === 0)
                            .map(a => ({ id: a.id, realId: a.id, label: a.title || 'Untitled', type: 'orphan', isDuplicate: false }));
                        return { nodes: orphanNodes, links: [] };
                    }


                    const categoryNodes = new Map();
                    App.settings.get('userCategories').forEach(catObj => {
                        // We now correctly use catObj.name for both the ID and for getting the display name.
                        categoryNodes.set(catObj.name, { id: catObj.name, type: 'category', label: App.util.getCategoryDisplayName(catObj.name) });
                    });


                    const tagNodes = new Map();
                    const articleIdToTags = new Map();
                    const tagToCategories = new Map();
                    const articleIdCounts = new Map();

                    articles.forEach(article => {
                        if (!article.tags || article.tags.length === 0) return;

                        articleIdToTags.set(article.id, article.tags);

                        article.tags.forEach(tagId => {
                            articleIdCounts.set(article.id, (articleIdCounts.get(article.id) || 0) + 1);
                            if (!tagNodes.has(tagId)) {
                                tagNodes.set(tagId, { id: tagId, type: 'tag', label: App.state.tags[tagId]?.displayName || tagId });
                            }
                            if (article.category) {
                                if (!tagToCategories.has(tagId)) tagToCategories.set(tagId, new Set());
                                tagToCategories.get(tagId).add(article.category);
                            }
                        });
                    });

                    const collapsedCategoryIds = new Set(Object.keys(this.nodeStates).filter(id => this.nodeStates[id]?.collapsed));
                    const visibleTagIds = new Set();
                    tagNodes.forEach((tagNode, tagId) => {
                        const parentCategories = tagToCategories.get(tagId) || new Set();
                        const isVisible = Array.from(parentCategories).some(catId => !collapsedCategoryIds.has(catId));
                        if (isVisible) {
                            visibleTagIds.add(tagId);
                        }
                    });

                    const finalNodes = [...categoryNodes.values()];
                    const finalLinks = [];
                    const collapsedTagIds = new Set(Object.keys(this.nodeStates).filter(id => this.nodeStates[id]?.collapsed));

                    visibleTagIds.forEach(tagId => finalNodes.push(tagNodes.get(tagId)));

                    tagToCategories.forEach((categories, tagId) => {
                        if (visibleTagIds.has(tagId)) {
                            categories.forEach(catId => {
                                if (!collapsedCategoryIds.has(catId)) {
                                    finalLinks.push({ id: `${catId}-${tagId}`, source: catId, target: tagId });
                                }
                            });
                        }
                    });

                    articleIdToTags.forEach((tags, articleId) => {
                        const article = App.storage.getArticle(articleId);
                        tags.forEach(tagId => {
                            if (visibleTagIds.has(tagId) && !collapsedTagIds.has(tagId)) {
                                const articleNodeId = `${articleId}-${tagId}`;
                                const isDuplicate = (articleIdCounts.get(articleId) || 0) > 1;
                                finalNodes.push({ id: articleNodeId, realId: articleId, label: article.title || 'Untitled', type: 'article', tagId: tagId, isDuplicate });
                                finalLinks.push({ id: `${tagId}-${articleNodeId}`, source: tagId, target: articleNodeId });
                            }
                        });
                    });

                    return { nodes: finalNodes, links: finalLinks };
                },



                searchNodes(term) {
                    if (!this.simulation) return; this.currentSearchResults = []; this.currentSearchIndex = -1;
                    const termLower = term.toLowerCase().trim();
                    const allNodes = this.g.selectAll('.node-group'); const allLinks = this.g.selectAll('.link'); const allText = this.g.selectAll('.node-text');
                    allNodes.classed('faded', false); allLinks.classed('faded', false);
                    allText.each(function (d) { d3.select(this).text(d.label).selectAll('tspan').remove(); });
                    if (!termLower) return;

                    if (this.currentFilter === 'orphans') {
                        const spotlightIds = new Set();
                        this.simulation.nodes().forEach(d => { if (d.label && d.label.toLowerCase().includes(termLower)) spotlightIds.add(d.id); });
                        this.currentSearchResults = Array.from(spotlightIds);
                        allNodes.classed('faded', d => !spotlightIds.has(d.id));
                        allText.filter(d => spotlightIds.has(d.id)).html(d => { const regex = new RegExp(term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'); return d.label.replace(regex, `<tspan class="search-highlight">$&</tspan>`); });
                        // Auto-focus the first orphan result
                        if (this.currentSearchResults.length > 0) this.findNextSearchResult();
                        return;
                    }

                    const spotlightIds = new Set(); const directMatchIds = new Set();
                    const simulationNodes = this.simulation.nodes();
                    simulationNodes.forEach(d => { if (d.label && d.label.toLowerCase().includes(termLower)) { spotlightIds.add(d.id); directMatchIds.add(d.id); if (d.type === 'article' && d.tagId) spotlightIds.add(d.tagId); if (d.type === 'tag' && d.categoryIds) { d.categoryIds.forEach(catId => spotlightIds.add(catId)); simulationNodes.forEach(node => { if (node.tagId === d.id) spotlightIds.add(node.id); }); } if (d.type === 'category' && d.tagIds) { d.tagIds.forEach(tagId => spotlightIds.add(tagId)); } } });

                    // --- START OF HIERARCHICAL SEARCH FIX ---
                    const allNodesMap = new Map(simulationNodes.map(n => [n.id, n]));
                    const matchingNodeObjects = Array.from(directMatchIds).map(id => allNodesMap.get(id)).filter(Boolean);

                    const priority = { 'category': 1, 'tag': 2, 'article': 3, 'orphan': 3 };

                    matchingNodeObjects.sort((a, b) => {
                        const priorityA = priority[a.type] || 4;
                        const priorityB = priority[b.type] || 4;
                        if (priorityA !== priorityB) {
                            return priorityA - priorityB;
                        }
                        return a.label.localeCompare(b.label);
                    });

                    this.currentSearchResults = matchingNodeObjects.map(n => n.id);
                    // --- END OF HIERARCHICAL SEARCH FIX ---

                    allNodes.classed('faded', d => !spotlightIds.has(d.id));
                    allLinks.classed('faded', l => !spotlightIds.has(l.source.id) || !spotlightIds.has(l.target.id));
                    allText.filter(d => directMatchIds.has(d.id)).html(d => { const regex = new RegExp(term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'); return d.label.replace(regex, `<tspan class="search-highlight">$&</tspan>`); });

                    // Auto-focus the first result
                    if (this.currentSearchResults.length > 0) {
                        this.findNextSearchResult();
                    }
                },


                findNextSearchResult() {
                    if (!this.currentSearchResults || this.currentSearchResults.length === 0) { App.ui.showToast("No search results to cycle through."); return; }
                    this.currentSearchIndex = (this.currentSearchIndex + 1) % this.currentSearchResults.length;
                    const targetNodeId = this.currentSearchResults[this.currentSearchIndex]; const targetNode = this.simulation.nodes().find(n => n.id === targetNodeId);
                    if (targetNode) {
                        const scale = this.currentZoom.k > 1.5 ? this.currentZoom.k : 1.5; const x = this.width / 2 - targetNode.x * scale; const y = this.height / 2 - targetNode.y * scale;
                        this.svg.transition().duration(750).ease(d3.easeCubicInOut).call(this.zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
                        this.node.selectAll('.node-main-body').style('stroke', null).style('stroke-width', null);
                        this.node.filter(d => d.id === targetNodeId).select('.node-main-body').transition().duration(200).style('stroke', 'var(--danger-color)').style('stroke-width', '4px').transition().duration(1500).style('stroke', null).style('stroke-width', null);
                    }
                },
                focusOnStickyNote(noteId) {
                    // CORRECTED: Uses App.state
                    const noteState = App.state.visualMapState.stickyNotes[noteId];
                    if (!noteState || !this.svg) return;
                    const noteCenterX = noteState.x + (noteState.width / 2), noteCenterY = noteState.y + (noteState.height / 2);
                    const viewportCenterX = this.width / 2, viewportCenterY = this.height / 2;
                    const desiredScale = Math.min(2, Math.min(this.width / (noteState.width * 2), this.height / (noteState.height * 2)));
                    const newX = viewportCenterX - (noteCenterX * desiredScale), newY = viewportCenterY - (noteCenterY * desiredScale);
                    this.svg.transition().duration(750).ease(d3.easeCubicInOut).call(this.zoom.transform, d3.zoomIdentity.translate(newX, newY).scale(desiredScale));
                },
                cycleCategoryFocus() { if (!this.simulation) return; const categoryNodes = this.simulation.nodes().filter(n => n.type === 'category'); if (categoryNodes.length === 0) return; this.currentCategoryIndex = (this.currentCategoryIndex + 1) % categoryNodes.length; const targetNode = categoryNodes[this.currentCategoryIndex]; if (typeof targetNode.x !== 'number') return; const scale = 1.5; const x = this.width / 2 - targetNode.x * scale; const y = this.height / 2 - targetNode.y * scale; this.svg.transition().duration(1000).ease(d3.easeCubicInOut).call(this.zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale)); },


                setNodeStates(mode) {
                    document.querySelectorAll('#visual-map-controls .control-btn.active').forEach(b => b.classList.remove('active'));
                    if (mode === 'expand-all') { this.nodeStates = {}; this.currentFilter = 'all'; document.getElementById('filter-all-btn')?.classList.add('active'); }
                    // CORRECTED: Uses App.state
                    else if (mode === 'collapse-to-tags') { this.nodeStates = {}; Object.values(App.state.tags).forEach(t => this.nodeStates[t.id] = { collapsed: true }); this.currentFilter = 'all'; document.getElementById('filter-tags-btn')?.classList.add('active'); }
                    else if (mode === 'orphans') { this.currentFilter = 'orphans'; document.getElementById('filter-orphans-btn')?.classList.add('active'); }
                    this.updateGraph(); this.zoomToFit();
                    const currentSearchTerm = document.getElementById('graph-search-input').value; if (currentSearchTerm) this.searchNodes(currentSearchTerm);
                },
                currentSnapshotIndex: -1,
                cycleSnapshots() {
                    // CORRECTED: Uses App.state
                    const snapshots = App.state.visualMapState.snapshots; if (!snapshots || snapshots.length === 0) { App.ui.showToast('No snapshots saved.'); return; }
                    this.currentSnapshotIndex = (this.currentSnapshotIndex + 1) % snapshots.length;
                    const snapshotToLoad = snapshots[snapshots.length - 1 - this.currentSnapshotIndex]; this.loadSnapshot(snapshotToLoad); App.ui.showToast(`Snapshot ${this.currentSnapshotIndex + 1}/${snapshots.length} ${this.currentSnapshotIndex === 0 ? '(Latest)' : ''}`);
                },
                deleteOldSnapshots() {
                    const snapshots = App.state.visualMapState.snapshots; if (!snapshots || snapshots.length === 0) { App.ui.showToast('No snapshots to delete.', { type: 'error' }); return; }
                    App.state.visualMapState.snapshots.shift(); this.currentSnapshotIndex = -1;
                    // CORRECTED: Uses App.fs
                    App.fs.write('visual-map-state.json', App.state.visualMapState); App.ui.showToast(`Oldest Snapshot Deleted.`);
                },
                loadSnapshot(snapshot) {
                    if (!snapshot) return; d3.select('#sticky-note-layer').selectAll('*').remove();
                    this.nodeStates = (snapshot.collapsedNodes || []).reduce((acc, id) => { acc[id] = { collapsed: true }; return acc; }, {}); this.updateGraph();
                    if (snapshot.transform) { const { x, y, k } = snapshot.transform; this.svg.transition().duration(750).call(this.zoom.transform, d3.zoomIdentity.translate(x, y).scale(k)); }
                    if (snapshot.openStickyNotes) { snapshot.openStickyNotes.forEach(noteStateInSnapshot => { if (App.storage.getArticle(noteStateInSnapshot.articleId)) { App.state.visualMapState.stickyNotes[noteStateInSnapshot.id] = noteStateInSnapshot; this.stickyNotes.render(noteStateInSnapshot.id); } }); }
                },
                async exportAndSave() {
                    const btn = document.getElementById('visual-map-snapshot-btn'); btn.style.color = 'var(--primary-color)'; const container = document.getElementById('visual-map-container');
                    try {
                        const blob = await htmlToImage.toBlob(container, { backgroundColor: getComputedStyle(container).backgroundColor, width: container.clientWidth, height: container.clientHeight });
                        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]); App.ui.showToast('Snapshot saved & image copied!');
                    } catch (e) { console.error("Image copy failed", e); App.ui.showToast('Snapshot saved (image copy failed).'); }
                    const transform = d3.zoomTransform(this.svg.node());
                    const collapsedNodes = Object.keys(this.nodeStates).filter(k => this.nodeStates[k].collapsed);
                    const openStickyNotes = Array.from(document.querySelectorAll('#sticky-note-layer .sticky-note-tile')).map(el => App.state.visualMapState.stickyNotes[el.id]).filter(Boolean);
                    const newSnapshot = { transform: { x: transform.x, y: transform.y, k: transform.k }, collapsedNodes, openStickyNotes, timestamp: new Date().toISOString() };
                    App.state.visualMapState.snapshots.push(newSnapshot);
                    if (App.state.visualMapState.snapshots.length > 10) App.state.visualMapState.snapshots.shift();
                    await App.fs.write('visual-map-state.json', App.state.visualMapState);
                    setTimeout(() => { btn.style.color = ''; }, 1000);
                },
                zoomToFit() {
                    setTimeout(() => {
                        if (!this.g || !this.simulation || this.simulation.nodes().length === 0) return;
                        const bounds = this.g.node().getBBox(); if (bounds.width === 0 || bounds.height === 0) return;
                        const { x, y, width, height } = bounds;
                        const scale = Math.min(1.5, 0.9 / Math.max(width / this.width, height / this.height));
                        const translate = [this.width / 2 - scale * (x + width / 2), this.height / 2 - scale * (y + height / 2)];
                        const transform = d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale);
                        this.svg.transition().duration(750).call(this.zoom.transform, transform);
                    }, 150);
                },
                zoomIn() { this.zoom && this.zoom.scaleBy(this.svg.transition().duration(750), 1.5); },
                zoomOut() { this.zoom && this.zoom.scaleBy(this.svg.transition().duration(750), 1 / 1.5); },
                pan(dx, dy) { if (!this.zoom) return; const panX = dx * (this.width / 4); const panY = dy * (this.height / 4); this.zoom.translateBy(this.svg.transition().duration(600), -panX, -panY); },


                setDefaultNodeColors() {
                    if (!this.node) return;
                    this.node.selectAll(".node-main-body").transition().duration(750)
                        .style("fill", d => d.isDuplicate ? `var(--node-article-duplicate)` : `var(--node-${d.type})`);
                },
                gatherNodes() {
                    if (!this.simulation) return;
                    // Temporarily increase the strength of centering forces
                    this.simulation.force("center").strength(1.5);
                    this.simulation.force("x").strength(0.5);
                    this.simulation.force("y").strength(0.5);
                    // "Reheat" the simulation to make nodes move
                    this.simulation.alpha(1).restart();
                    // Reset strengths back to normal after 2 seconds
                    setTimeout(() => {
                        if (!this.simulation) return;
                        this.simulation.force("center").strength(1);
                        this.simulation.force("x").strength(0.05);
                        this.simulation.force("y").strength(0.05);
                    }, 2000);
                },
                toggleLayout() {
                    if (!this.simulation) return;
                    this.layoutMode = this.layoutMode === 'Force' ? 'Radial' : 'Force';
                    const btn = document.getElementById('visual-map-layout-toggle');
                    btn.innerHTML = this.layoutMode === 'Force' ? ICON_FORCE : ICON_RADIAL;

                    if (this.layoutMode === 'Radial') {
                        // Apply radial forces
                        this.simulation.force("x", null).force("y", null); // Remove X and Y forces
                        this.simulation.force("radial", d3.forceRadial(d => d.type === 'category' ? 0 : (d.type === 'tag' ? 150 : 250), this.width / 2, this.height / 2).strength(0.8));
                    } else {
                        // Apply standard X and Y forces
                        this.simulation.force("radial", null); // Remove radial force
                        this.simulation.force("x", d3.forceX(this.width / 2).strength(0.05));
                        this.simulation.force("y", d3.forceY(this.height / 2).strength(0.05));
                    }
                    this.simulation.alpha(1).restart();
                },


                randomizeNodeColors() {
                    if (!this.node) return; const articleColorMap = {};
                    this.node.selectAll(".node-main-body").each((d, i, nodes) => {
                        let color; const palette = this.colorPalettes[d.type]; if (!palette) return;
                        if (d.type === 'article' || d.type === 'orphan') { if (!articleColorMap[d.realId]) articleColorMap[d.realId] = palette[Math.floor(Math.random() * palette.length)]; color = articleColorMap[d.realId]; }
                        else color = palette[Math.floor(Math.random() * palette.length)];
                        d3.select(nodes[i]).transition().duration(750).style("fill", color);
                    });
                },
                drag(simulation) {
                    function dragstarted(e, d) { if (!e.active) simulation.alphaTarget(0.1).restart(); d.fx = d.x; d.fy = d.y; }
                    function dragged(e, d) { d.fx = e.x; d.fy = e.y; }
                    function dragended(e, d) { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
                    return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
                },
                pointInPolygon(point, polygon) { let x = point[0], y = point[1]; let inside = false; for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) { let xi = polygon[i][0], yi = polygon[i][1]; let xj = polygon[j][0], yj = polygon[j][1]; let intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi); if (intersect) inside = !inside; } return inside; },
                toggleLasso() {
                    this.isLassoActive = !this.isLassoActive; const btn = document.getElementById('lasso-btn'); const container = document.getElementById('visual-map-container');
                    if (this.isLassoActive) { btn.classList.add('active'); container.style.cursor = 'crosshair'; this.clearSelection(); this.svg.on('.zoom', null); this.svg.on('mousedown.lasso', (e) => this.lassoStart(e)).on('mousemove.lasso', (e) => this.lassoDraw(e)).on('mouseup.lasso', (e) => this.lassoEnd(e)); }
                    else { btn.classList.remove('active'); container.style.cursor = 'grab'; if (this.lassoSelection) this.lassoSelection.remove(); this.lassoSelection = null; this.svg.on('.lasso', null); this.svg.call(this.zoom); this.clearSelection(); }
                },
                clearSelection() { this.selectedNodes.clear(); this.node.classed('selected', false); document.getElementById('expand-selection-btn').style.display = 'none'; document.getElementById('collapse-selection-btn').style.display = 'none'; },
                modifySelection(action) {
                    if (this.selectedNodes.size === 0) return;
                    this.selectedNodes.forEach(nodeId => {
                        const nodeData = this.simulation.nodes().find(n => n.id === nodeId);
                        if (nodeData && (nodeData.type === 'category' || nodeData.type === 'tag')) { if (action === 'collapse') this.nodeStates[nodeId] = { collapsed: true }; else if (this.nodeStates[nodeId]) delete this.nodeStates[nodeId]; }
                    });
                    this.updateGraph(); this.toggleLasso();
                },
                lassoStart(event) { if (!this.isLassoActive) return; this.clearSelection(); this.lassoPoints = []; if (this.lassoSelection) this.lassoSelection.remove(); this.lassoSelection = this.g.append("path").style('fill', 'rgba(0, 123, 255, 0.1)').style('stroke', 'var(--primary-color)').style('stroke-width', '1.5px'); },
                lassoDraw(event) { if (!this.isLassoActive || this.lassoPoints === null) return; const [x, y] = d3.pointer(event, this.g.node()); this.lassoPoints.push([x, y]); this.lassoSelection.attr("d", "M" + this.lassoPoints.join("L") + "Z"); },
                lassoEnd(event) {
                    if (!this.isLassoActive || !this.lassoPoints || this.lassoPoints.length < 3) { if (this.lassoSelection) this.lassoSelection.remove(); this.lassoSelection = null; this.lassoPoints = null; return; }
                    this.node.each(d => { if (this.pointInPolygon([d.x, d.y], this.lassoPoints)) this.selectedNodes.add(d.id); });
                    if (this.selectedNodes.size > 0) { this.node.classed('selected', d => this.selectedNodes.has(d.id)); document.getElementById('expand-selection-btn').style.display = 'flex'; document.getElementById('collapse-selection-btn').style.display = 'flex'; }
                    this.lassoPoints = null; setTimeout(() => { if (this.lassoSelection) this.lassoSelection.remove(); this.lassoSelection = null; }, 500);
                },

                stickyNotes: {
                    extractSmartSnippet(articleId, tagId) {
                        const article = App.storage.getArticle(articleId);
                        if (!article || !article.content) return { html: "<p>Content unavailable.</p>", snippetId: null };

                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = article.content;
                        const tagElement = tempDiv.querySelector(`.rendered-tag[data-tag="${tagId}"]`);

                        if (tagElement) {
                            const parentBlock = tagElement.closest('p, ul, ol, blockquote, h1, h2, h3, h4, h5, h6, li');
                            if (parentBlock) {

                                return { html: parentBlock.outerHTML, snippetId: tagElement.id };
                            }
                        }

                        const firstP = tempDiv.querySelector('p');
                        const fallbackHtml = firstP ? firstP.outerHTML : `<p>${article.content.substring(0, 250)}...</p>`;
                        return { html: fallbackHtml, snippetId: null };
                    },
                    create(nodeData) {
                        const noteId = `note-${nodeData.realId}-${nodeData.tagId}`;
                        if (!App.state.visualMapState.stickyNotes[noteId]) {
                            const article = App.storage.getArticle(nodeData.realId);
                            if (!article) return;
                            // This new logic correctly fetches AND stores the snippetId
                            const snippetData = this.extractSmartSnippet(nodeData.realId, nodeData.tagId);
                            const noteState = { id: noteId, articleId: nodeData.realId, tagId: nodeData.tagId, snippetId: snippetData.snippetId, x: nodeData.x + 40, y: nodeData.y - 40, width: 280, height: 240, sizeIndex: 3, color: 'default', title: article.title || 'Untitled' };
                            App.state.visualMapState.stickyNotes[noteId] = noteState;
                        }
                        if (!document.getElementById(noteId)) { this.render(noteId); }
                        else {
                            App.visualMap.focusOnStickyNote(noteId);
                            const el = document.getElementById(noteId); el.classList.remove('spawn'); void el.offsetWidth; el.classList.add('spawn'); d3.select(el).raise();
                        }
                        App.fs.write('visual-map-state.json', App.state.visualMapState);
                    },
                    render(noteId) {
                        const noteState = App.state.visualMapState.stickyNotes[noteId];
                        if (!noteState) return;

                        // UPDATED: Ensure size properties exist, providing new, larger defaults if not.
                        noteState.width = noteState.width || 280;
                        noteState.height = noteState.height || 240;
                        noteState.sizeIndex = noteState.sizeIndex === undefined ? 3 : noteState.sizeIndex;

                        const noteLayer = d3.select('#sticky-note-layer');
                        const snippetData = this.extractSmartSnippet(noteState.articleId, noteState.tagId);
                        const sanitizedSnippet = App.util.sanitizeHTML(snippetData.html);

                        const noteHTML = `
                        <div class="sticky-note-header">
                            <h5 data-article-id="${noteState.articleId}" data-tag-id="${noteState.tagId}">${noteState.title}</h5>
                        </div>
                        <div class="sticky-note-content">${sanitizedSnippet}</div>
                        <div class="sticky-note-controls">
                            <button class="btn-icon color-btn" title="Cycle color">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg>
                            </button>
                            <button class="btn-icon scroll-btn" title="Scroll content">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="m7 15 5 5 5-5M7 9l5-5 5 5"/></svg>
                            </button>
                            <button class="btn-icon resize-btn" title="Cycle size">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M20.25 20.25v-4.5m0 4.5h-4.5m4.5 0L15 15" /></svg>
                            </button>
                            <button class="btn-icon close-btn" title="Close">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </button>
                        </div>
                    `;

                        const note = noteLayer.append('div')
                            .attr('id', noteId)
                            .attr('class', `sticky-note-tile color-${noteState.color} spawn`)
                            .style('left', `${noteState.x}px`)
                            .style('top', `${noteState.y}px`)
                            .style('width', `${noteState.width}px`)
                            .style('height', `${noteState.height}px`)
                            .html(noteHTML);

                        note.select('.close-btn').on('mousedown', (e) => { e.stopPropagation(); this.remove(noteId); });
                        note.select('h5').on('click', (e) => {
                            e.stopPropagation();
                            App.router.navigateTo('article', { id: noteState.articleId, mode: 'read', scrollToSnippetId: noteState.snippetId })
                        });
                        note.select('.color-btn').on('click', (e) => { e.stopPropagation(); this.cycleColor(noteId); });
                        note.select('.resize-btn').on('click', (e) => { e.stopPropagation(); this.cycleSize(noteId); });
                        note.select('.scroll-btn').on('click', (e) => { e.stopPropagation(); this.scrollContent(noteId); });

                        const dragMove = d3.drag()
                            .filter(event => !event.target.closest('.sticky-note-controls'))
                            .on("start", (e) => note.raise().classed('dragging', true))
                            .on("drag", (e) => {
                                noteState.x += e.dx / App.visualMap.currentZoom.k;
                                noteState.y += e.dy / App.visualMap.currentZoom.k;
                                note.style('left', `${noteState.x}px`).style('top', `${noteState.y}px`);
                            }).on("end", () => {
                                note.classed('dragging', false);
                                App.fs.write('visual-map-state.json', App.state.visualMapState);
                            });

                        note.call(dragMove);
                    },

                    cycleSize(noteId) {
                        const noteState = App.state.visualMapState.stickyNotes[noteId];
                        if (!noteState) return;

                        const sizes = [
                            { w: 180, h: 140 }, // 1. X-Small
                            { w: 210, h: 170 }, // 2. Small
                            { w: 240, h: 200 }, // 3. Compact
                            { w: 280, h: 240 }, // 4. Default
                            { w: 340, h: 280 }, // 5. Large
                            { w: 400, h: 320 }, // 6. X-Large
                            { w: 460, h: 360 }  // 7. XX-Large
                        ];

                        noteState.sizeIndex = ((noteState.sizeIndex || 0) + 1) % sizes.length;
                        const newSize = sizes[noteState.sizeIndex];

                        noteState.width = newSize.w;
                        noteState.height = newSize.h;

                        const noteEl = d3.select(`#${noteId}`);
                        noteEl.transition().duration(250)
                            .style('width', `${noteState.width}px`)
                            .style('height', `${noteState.height}px`);

                        App.fs.write('visual-map-state.json', App.state.visualMapState);
                    },

                    scrollContent(noteId) {
                        const noteEl = document.getElementById(noteId);
                        if (!noteEl) return;
                        const contentEl = noteEl.querySelector('.sticky-note-content');
                        if (!contentEl) return;

                        const currentTop = contentEl.scrollTop;
                        const maxScroll = contentEl.scrollHeight - contentEl.clientHeight;
                        const pageHeight = contentEl.clientHeight * 0.8;

                        if (currentTop >= maxScroll - 5) {
                            contentEl.scrollTo({ top: 0, behavior: 'smooth' });
                        } else {
                            contentEl.scrollTo({ top: Math.min(maxScroll, currentTop + pageHeight), behavior: 'smooth' });
                        }
                    },

                    remove(noteId) {
                        d3.select(`#${noteId}`).remove();
                        delete App.state.visualMapState.stickyNotes[noteId];
                        App.fs.write('visual-map-state.json', App.state.visualMapState);
                    },
                    cycleColor(noteId) {
                        const noteState = App.state.visualMapState.stickyNotes[noteId];
                        if (!noteState) return;
                        const noteEl = d3.select(`#${noteId}`);
                        noteEl.classed(`color-${noteState.color}`, false);
                        const currentIndex = App.config.stickyNoteColors.indexOf(noteState.color);
                        noteState.color = App.config.stickyNoteColors[(currentIndex + 1) % App.config.stickyNoteColors.length];
                        noteEl.classed(`color-${noteState.color}`, true);
                        App.fs.write('visual-map-state.json', App.state.visualMapState);
                    },
                },
            },

            // ==========================================================================
            // 3.20. AUDIO MODULE (NEW)
            // ==========================================================================
            audio: {
                isRecording: false,
                isTranscribing: false,
                recorder: null,
                transcriptionWorker: null,
                audioChunks: [],
                activePlayer: null,
                transcriptionToasts: new Map(),
                audioContext: null,
                analyser: null,
                animationFrameId: null,
                recordingToast: null,
                modelDB: null,

                async init() {
                    try {
                        const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1');
                    } catch (e) { console.warn("Could not preload transcription library.") }
                    await this.openModelDB();
                },

                async openModelDB() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open('WhisperModelsDB', 1);
                        request.onerror = (e) => { console.error("IndexedDB error:", e); reject("DB Error"); };
                        request.onsuccess = (e) => { this.modelDB = e.target.result; resolve(); };
                        request.onupgradeneeded = (e) => { e.target.result.createObjectStore('models', { keyPath: 'id' }); };
                    });
                },

                async saveModel(id, data) {
                    if (!this.modelDB) await this.openModelDB();
                    return new Promise((resolve, reject) => {
                        const transaction = this.modelDB.transaction(['models'], 'readwrite');
                        const store = transaction.objectStore('models');
                        const request = store.put({ id, data });
                        request.onsuccess = () => resolve();
                        request.onerror = (e) => { console.error("Failed to save model to DB", e); reject("Save Error"); };
                    });
                },

                async getModel(id) {
                    if (!this.modelDB) await this.openModelDB();
                    return new Promise((resolve) => {
                        const transaction = this.modelDB.transaction(['models'], 'readonly');
                        const store = transaction.objectStore('models');
                        const request = store.get(id);
                        request.onsuccess = (e) => resolve(e.target.result ? e.target.result.data : null);
                        request.onerror = () => resolve(null);
                    });
                },

                async deleteTranscriptionModels() {
                    if (!this.modelDB) await this.openModelDB();
                    return new Promise((resolve) => {
                        const transaction = this.modelDB.transaction(['models'], 'readwrite');
                        const store = transaction.objectStore('models');
                        store.clear().onsuccess = async () => {
                            await App.settings.set('transcriptionModel', null);
                            this.updateModelStatusUI();
                            App.ui.showToast('Offline models deleted.', 'info');
                            resolve();
                        };
                    });
                },

                async downloadTranscriptionModel(modelId) {
                    const btn = document.getElementById(`download-model-${modelId.split('-')[1]}`);
                    if (btn) {
                        btn.textContent = 'Preparing...';
                        btn.disabled = true;
                    }
                    if (!App.offline.check('Voice Typing')) return;
                    try {
                        const { pipeline, env } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1');
                        await pipeline('automatic-speech-recognition', modelId, {
                            progress_callback: (progress) => {
                                if (!btn) return;
                                let progressText = progress.file ? progress.file.split('.')[0] : 'Initializing';
                                if (typeof progress.progress === 'number') {
                                    progressText += `: ${progress.progress.toFixed(0)}%`;
                                }
                                btn.textContent = progressText;
                            }
                        });
                        await App.settings.set('transcriptionModel', modelId);
                        App.ui.showToast(`Model "${modelId.split('/')[1]}" is ready!`, { type: 'success' });
                    } catch (e) {
                        console.error("Model download failed", e);
                        App.ui.showToast('Model download failed. Check console.', 'error');
                    } finally {
                        this.updateModelStatusUI();
                    }
                },

                async updateModelStatusUI() {
                    const statusEl = document.getElementById('transcription-model-status');
                    const deleteBtn = document.getElementById('delete-models-btn');
                    const selectedModel = App.settings.get('transcriptionModel');
                    if (statusEl) {
                        statusEl.textContent = selectedModel ? `Selected: ${selectedModel.split('/')[1]}` : 'No model selected.';
                    }
                    document.querySelectorAll('[id^="download-model-"]').forEach(btn => {
                        const modelId = `Xenova/whisper-${btn.id.split('-')[2]}`;
                        if (modelId === selectedModel) {
                            btn.textContent = 'Selected';
                            btn.disabled = true;
                            btn.classList.remove('btn-secondary');
                            btn.classList.add('btn-primary');
                        } else {
                            btn.textContent = 'Select';
                            btn.disabled = false;
                            btn.classList.remove('btn-primary');
                            btn.classList.add('btn-secondary');
                        }
                    });
                    if (deleteBtn) {
                        deleteBtn.style.display = selectedModel ? 'inline-flex' : 'none';
                    }
                },

                async toggleRecording() {
                    if (this.isRecording) {
                        this.stopRecording();
                    } else {
                        await this.startRecording();
                    }
                },

                async startRecording() {
                    if (this.isRecording) return;
                    const modelName = App.settings.get('transcriptionModel');
                    this.isTranscribing = !!modelName;

                    const stream = await this.requestPermission();
                    if (!stream) return;

                    this.isRecording = true;
                    this.audioChunks = [];
                    this.recorder = new MediaRecorder(stream, { audioBitsPerSecond: App.settings.get('audioBitrate') });

                    this.recorder.addEventListener("stop", async () => {
                        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                        const reader = new FileReader();
                        reader.onloadend = () => {
                            this.insertPlayer(reader.result, crypto.randomUUID());
                        };
                        reader.readAsDataURL(audioBlob);
                    });

                    this.recorder.addEventListener("dataavailable", event => this.audioChunks.push(event.data));
                    this.recorder.start();
                    this._startVisualizer(stream);

                    const articleForControls = App.storage.getArticle(App.state.activeArticleId) || { category: 'General' };
                    App.ui.renderArticleControls(articleForControls);

                    // THE FIX: Create a beautiful, animated toast message instead of static text.
                    const toastMessageHTML = `
                    <div class="toast-wave-container">
                        <div class="toast-wave-visualizer">
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                        </div>
                        <span>Recording...</span>
                    </div>`;
                    this.recordingToast = App.ui.showToast(toastMessageHTML, { type: 'info', duration: 0 });
                },

                stopRecording() {
                    if (!this.isRecording || !this.recorder) return;
                    this.recorder.stop();
                    this.isRecording = false;
                    this._stopVisualizer();

                    const articleForControls = App.state.activeArticleId === 'temp_new_article'
                        ? { category: 'General', readCount: 0, tags: [] }
                        : App.storage.getArticle(App.state.activeArticleId);
                    App.ui.renderArticleControls(articleForControls);

                    if (this.recordingToast) App.ui.hideToast(this.recordingToast);
                    this.recordingToast = null;
                },

                runTranscription(audioData, modelName, transcriptionId) {
                    if (this.transcriptionWorker) {
                        this.transcriptionWorker.terminate();
                    }

                    const workerBlob = new Blob([document.getElementById('transcription-worker-script').textContent], { type: 'application/javascript' });
                    const workerUrl = URL.createObjectURL(workerBlob);

                    // **THIS IS THE FIX**: We create the worker as a 'module' so it can use `import`.
                    this.transcriptionWorker = new Worker(workerUrl, { type: 'module' });

                    const transcribingToast = App.ui.showToast('Transcribing...', { type: 'info', duration: 0 });
                    this.transcriptionToasts.set(transcriptionId, transcribingToast);

                    this.transcriptionWorker.onmessage = (event) => {
                        const { status, text, data, playerId: returnedId } = event.data;
                        const toastToHide = this.transcriptionToasts.get(returnedId);
                        if (toastToHide) {
                            App.ui.hideToast(toastToHide);
                            this.transcriptionToasts.delete(returnedId);
                        }
                        if (status === 'complete') {
                            this.insertTranscriptionAsTile(text, returnedId);
                        } else if (status === 'error') {
                            App.ui.showToast(`Transcription failed: ${data}`, { type: 'error' });
                        }
                        this.transcriptionWorker.terminate();
                        this.transcriptionWorker = null;
                    };

                    this.transcriptionWorker.onerror = (e) => {
                        console.error('Worker error:', e);
                        const toastToHide = this.transcriptionToasts.get(transcriptionId);
                        if (toastToHide) App.ui.hideToast(toastToHide);
                        App.ui.showToast('A critical worker error occurred.', 'error');
                    };

                    this.transcriptionWorker.postMessage({ audioData, modelName, playerId: transcriptionId });
                },

                insertTranscriptionAsTile(text, transcriptionId) {
                    if (!text || !text.trim() || !transcriptionId) return;
                    navigator.clipboard.writeText(text.trim()).then(() => {
                        App.ui.showToast('Transcription complete & copied!', { type: 'success' });
                    });
                    const tileHTML = `<div class="nk-text-tile color-default" contenteditable="false" data-color="default">
                    <span class="nk-text-tile-icon"></span>
                    <div class="nk-text-tile-color-cycler" title="Cycle Color"><i class="fa-solid fa-palette fa-xs"></i></div>
                    <div class="nk-text-tile-content" contenteditable="true">${App.util.escapeHtml(text.trim())}</div>
                </div>`;

                    const placeholderContainer = document.getElementById(transcriptionId);
                    if (placeholderContainer) {
                        placeholderContainer.outerHTML = tileHTML;
                    } else {
                        console.warn("Could not find transcription placeholder container for ID:", transcriptionId);
                        // Fallback just in case, inserts at the end of the article.
                        document.getElementById('article-content').insertAdjacentHTML('beforeend', tileHTML + '<p><br></p>');
                    }
                    App.state.isArticleDirty = true;
                },

                insertPlayer(base64Url, transcriptionId) {
                    const playerId = `audio-player-${transcriptionId}`;

                    const transcribeButtonHTML = `
                    <div class="nk-transcribe-container" id="transcribe-container-${transcriptionId}">
                    <button class="btn btn-secondary btn-gradient-text">Transcribe Audio</button>
                    </div>`;

                    const playerHTML = `
                    <div class="nk-audio-block">
                        <div class="nk-audio-player" id="${playerId}" contenteditable="false">
                            <button class="audio-play-pause-btn" aria-label="Play"></button>
                            <div class="audio-progress-bar-container">
                                <input type="range" class="audio-progress-bar" value="0" min="0" max="100" step="0.1">
                            </div>
                            <div class="audio-time-display">0:00 / 0:00</div>
                            <button class="btn btn-secondary audio-speed-btn" data-speed="1" title="Playback Speed">1x</button>
                            <audio src="${base64Url}" preload="metadata" data-speed="1"></audio>
                        </div>
                        ${transcribeButtonHTML}
                    </div>`;

                    App.util.insertGuardianBlock(playerHTML);

                    setTimeout(() => {
                        const newPlayer = document.getElementById(playerId);
                        if (newPlayer) this._initializeSinglePlayer(newPlayer);
                    }, 100);
                    App.state.isArticleDirty = true;
                },

                initializePlayersIn(container) {
                    container.querySelectorAll('.nk-audio-player').forEach(player => { if (player.dataset.initialized) return; this._initializeSinglePlayer(player); });
                },

                _initializeSinglePlayer(player) {
                    const audio = player.querySelector('audio'); const playPauseBtn = player.querySelector('.audio-play-pause-btn'); const progressBar = player.querySelector('.audio-progress-bar'); const timeDisplay = player.querySelector('.audio-time-display');
                    if (!audio || !playPauseBtn || !progressBar || !timeDisplay) return;
                    const formatTime = (seconds) => `${Math.floor(seconds / 60)}:${Math.floor(seconds % 60).toString().padStart(2, '0')}`;
                    const updateDisplay = () => { if (!audio.duration) return; progressBar.value = audio.currentTime; timeDisplay.textContent = `${formatTime(audio.currentTime)} / ${formatTime(audio.duration || 0)}`; };
                    playPauseBtn.classList.remove('playing');
                    audio.addEventListener('loadedmetadata', () => { progressBar.max = audio.duration; updateDisplay(); });
                    audio.addEventListener('timeupdate', updateDisplay);
                    audio.addEventListener('play', () => { playPauseBtn.classList.add('playing'); this.activePlayer = audio; });
                    audio.addEventListener('pause', () => { playPauseBtn.classList.remove('playing'); if (this.activePlayer === audio) this.activePlayer = null; });
                    audio.addEventListener('ended', () => { playPauseBtn.classList.remove('playing'); audio.currentTime = 0; updateDisplay(); if (this.activePlayer === audio) this.activePlayer = null; });
                    progressBar.addEventListener('input', () => { audio.currentTime = progressBar.value; updateDisplay(); });
                    player.dataset.initialized = 'true';
                },

                async transcribeAudioBlock(buttonEl) {
                    const container = buttonEl.parentElement;
                    const audioPlayer = container.previousElementSibling;
                    if (!audioPlayer || !audioPlayer.classList.contains('nk-audio-player')) {
                        App.ui.showToast("Could not find the associated audio player.", 'error');
                        return;
                    }

                    const audioEl = audioPlayer.querySelector('audio');
                    const modelName = App.settings.get('transcriptionModel');
                    if (!audioEl || !audioEl.src || !modelName) {
                        App.ui.showToast("Audio source or transcription model not found.", 'error');
                        return;
                    }

                    // Show feedback to the user immediately
                    container.innerHTML = `<p id="${container.id}" class="transcript-placeholder" style="color:var(--text-secondary); font-style:italic;">Transcribing, wait for a moment ...</p>`;

                    try {
                        // Convert the base64 data URL back into an ArrayBuffer the AI can use
                        const audioBlob = App.util.dataURLtoBlob(audioEl.src);
                        if (!audioBlob) throw new Error("Could not convert audio data.");

                        const arrayBuffer = await audioBlob.arrayBuffer();
                        // Use a temporary AudioContext for this one-off task
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        const audioDataForTranscription = audioBuffer.getChannelData(0);

                        // The container's ID is our unique key for this transcription job
                        const transcriptionId = container.id;
                        this.runTranscription(audioDataForTranscription, modelName, transcriptionId);

                    } catch (error) {
                        console.error("Error preparing audio for transcription:", error);
                        App.ui.showToast("Failed to process audio for transcription.", 'error');
                        // Restore the button if processing fails
                        container.innerHTML = `<button class="btn btn-secondary" onclick="App.audio.transcribeAudioBlock(this)">Transcribe Audio</button>`;
                    }
                },

                handlePlayPause(button) {
                    const player = button.closest('.nk-audio-player'); if (!player) return; const audio = player.querySelector('audio');
                    if (this.activePlayer && this.activePlayer !== audio) this.activePlayer.pause();
                    if (audio.paused) audio.play(); else audio.pause();
                },

                // NEW FUNCTION
                handleSpeedChange(button) {
                    const player = button.closest('.nk-audio-player');
                    if (!player) return;
                    const audio = player.querySelector('audio');
                    if (!audio) return;

                    const speeds = [1, 1.25, 1.5, 1.75, 2];
                    const currentSpeed = parseFloat(button.dataset.speed || "1");
                    const currentIndex = speeds.indexOf(currentSpeed);
                    const nextIndex = (currentIndex + 1) % speeds.length;
                    const newSpeed = speeds[nextIndex];

                    audio.playbackRate = newSpeed;
                    button.dataset.speed = newSpeed;
                    button.textContent = `${newSpeed}x`;
                    button.title = `Playback Speed: ${newSpeed}x`;
                },

                async requestPermission() {
                    try { if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Error('InsecureContext'); return await navigator.mediaDevices.getUserMedia({ audio: true }); }
                    catch (err) { let msg = 'An unknown error occurred.'; if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') msg = 'Microphone permission was denied.'; else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') msg = 'No microphone was found on this device.'; else if (err.message === 'InsecureContext') msg = 'Microphone access requires a secure (https:// or localhost) connection.'; App.ui.showToast(msg, 'error'); console.error("Mic error:", err.name, err.message); return null; }
                },

                _startVisualizer(stream) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); this.analyser = this.audioContext.createAnalyser(); const source = this.audioContext.createMediaStreamSource(stream); source.connect(this.analyser); this.analyser.fftSize = 256; const bufferLength = this.analyser.frequencyBinCount; const dataArray = new Uint8Array(bufferLength); const canvas = document.getElementById('recording-visualizer-canvas'); if (!canvas) return; const canvasCtx = canvas.getContext('2d');
                    const draw = () => { this.animationFrameId = requestAnimationFrame(draw); this.analyser.getByteTimeDomainData(dataArray); canvasCtx.clearRect(0, 0, canvas.width, canvas.height); canvasCtx.lineWidth = 2; canvasCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--danger-color'); canvasCtx.beginPath(); const sliceWidth = canvas.width * 1.0 / bufferLength; let x = 0; for (let i = 0; i < bufferLength; i++) { const v = dataArray[i] / 128.0; const y = v * canvas.height / 2; if (i === 0) canvasCtx.moveTo(x, y); else canvasCtx.lineTo(x, y); x += sliceWidth; } canvasCtx.lineTo(canvas.width, canvas.height / 2); canvasCtx.stroke(); }; draw();
                },

                _stopVisualizer() {
                    if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId); if (this.audioContext) this.audioContext.close(); this.animationFrameId = null; this.audioContext = null; const canvas = document.getElementById('recording-visualizer-canvas'); if (canvas) canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
                }
            },


            // ==========================================================================
            // 3.20. WHITEBOARD ANNOTATION MODULE v2 - PREMIUM WITH TEXT BOXES & ZOOM
            // ==========================================================================
            whiteboard: {
                state: {
                    isOpen: false,
                    tool: 'pen',
                    color: '--text-primary',
                    thickness: 3,
                    thicknesses: [1, 2, 3, 5, 8, 12],
                    thicknessIndex: 2,
                    isDrawing: false,
                    lastPos: { x: 0, y: 0 },
                    startPos: { x: 0, y: 0 },
                    history: [],
                    historyIndex: -1,
                    insertMode: 'end', // 'end' or 'cursor'
                    previewImageData: null,
                    zoom: 1,
                    pan: { x: 0, y: 0 },
                    isPanning: false,
                    panStart: { x: 0, y: 0 },
                    textBoxes: [],
                    textBoxIdCounter: 0,
                    activeTextBox: null,
                    imageBoxes: [],
                    connectors: [], // {from: id, to: id}
                    isConnecting: false,
                    connectFromId: null,
                    editingBlockId: null, // Track when editing from existing block
                    backgroundStyle: 0, // 0=transparent, 1=white, 2=dark, 3=grid
                    // Image annotation mode
                    isImageAnnotation: false,
                    sourceImageContainer: null,
                    backgroundImage: null,
                    bgImageData: null,
                    // Image manipulation state
                    imageSelected: false,
                    isDraggingImage: false,
                    isResizingImage: false,
                    resizeHandle: null, // 'nw', 'ne', 'sw', 'se'
                    dragStartPos: null,
                    dragStartImagePos: null,
                    animationFrameId: null, // For animation cleanup
                    // Occlusion Tape state (Visual Flashcard)
                    tapeBoxes: [],          // Array of tape objects: {id, x, y, w, h, element, revealed}
                    tapeIdCounter: 0,       // Counter for unique tape IDs
                    isDrawingTape: false,   // Currently drawing a tape?
                    tapeStartPos: null,     // Start position for tape drawing
                    tapePreview: null,      // Preview element during drawing
                    // Stage mode screenshot state
                    stageModeSrcArticleId: null, // Article ID when opened from stage mode
                },

                // NEW: Initialize whiteboard with an existing image as full-viewport background
                async initImageAnnotation(imageContainer) {
                    if (!imageContainer) return;

                    const img = imageContainer.querySelector('img');
                    if (!img) return;

                    // 1. Get original image dimensions
                    const src = img.src;
                    const imgNaturalW = img.naturalWidth || img.width || 800;
                    const imgNaturalH = img.naturalHeight || img.height || 600;

                    // 2. Pre-load image object and wait for it
                    const imageObj = new Image();
                    imageObj.crossOrigin = "Anonymous";

                    const imageLoaded = new Promise((resolve, reject) => {
                        imageObj.onload = () => resolve(imageObj);
                        imageObj.onerror = () => reject(new Error('Failed to load image'));
                        if (imageObj.complete && imageObj.naturalWidth > 0) {
                            resolve(imageObj);
                        }
                    });
                    imageObj.src = src;

                    try {
                        await imageLoaded;
                    } catch (err) {
                        App.ui.showToast('Failed to load image for annotation', { type: 'error' });
                        return;
                    }

                    // 3. Open whiteboard and reset state
                    this.state.insertMode = 'cursor';
                    this.state.isOpen = true;
                    this.state.pan = { x: 0, y: 0 };
                    this.state.textBoxes = [];
                    this.state.imageBoxes = [];
                    this.state.tapeBoxes = [];
                    this.state.tapeIdCounter = 0;
                    this.state.activeTextBox = null;
                    this.state.connectors = [];
                    this.state.isConnecting = false;
                    this.state.connectFromId = null;
                    this.state.connectFromColor = null;
                    this.state.backgroundStyle = 0;

                    // Reset container visual
                    if (this.els.container) {
                        this.els.container.style.background = 'transparent';
                        this.els.container.style.backgroundImage = 'none';
                    }
                    this.els.overlay.classList.add('active');
                    this.els.overlay.classList.add('has-bg-image'); // Enable image tool visibility
                    this.els.overlay.focus();
                    document.body.style.overflow = 'hidden';

                    // 4. Set image annotation state
                    this.state.isImageAnnotation = true;
                    this.state.sourceImageContainer = imageContainer;
                    this.state.backgroundImage = imageObj;

                    // 5. Get viewport dimensions and set canvas to fill it
                    const viewportW = this.els.container.clientWidth || window.innerWidth - 100;
                    const viewportH = this.els.container.clientHeight || window.innerHeight - 150;
                    const dpr = window.devicePixelRatio || 1;
                    const padding = 40; // Padding around image

                    // Available space for image
                    const availW = viewportW - (padding * 2);
                    const availH = viewportH - (padding * 2);

                    // Scale image to fit (contain) within viewport
                    const imgAspect = imgNaturalW / imgNaturalH;
                    const viewAspect = availW / availH;

                    let drawW, drawH;
                    if (imgAspect > viewAspect) {
                        // Image is wider - fit to width
                        drawW = availW;
                        drawH = availW / imgAspect;
                    } else {
                        // Image is taller - fit to height
                        drawH = availH;
                        drawW = availH * imgAspect;
                    }

                    // Center the image in viewport
                    const drawX = padding + (availW - drawW) / 2;
                    const drawY = padding + (availH - drawH) / 2;

                    // Size canvas to fill viewport (not image size!)
                    this.els.canvas.width = viewportW * dpr;
                    this.els.canvas.height = viewportH * dpr;
                    this.els.canvas.style.width = viewportW + 'px';
                    this.els.canvas.style.height = viewportH + 'px';

                    // Reset and scale context for DPR
                    this.els.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.els.ctx.scale(dpr, dpr);

                    // 6. Store image data and draw it as background
                    this.state.bgImageData = {
                        x: drawX,
                        y: drawY,
                        w: drawW,
                        h: drawH,
                        originalW: imgNaturalW,
                        originalH: imgNaturalH
                    };

                    // Draw the background image with rounded corners
                    this.redrawWithImage();

                    // Clear history (fresh start for undo)
                    this.state.history = [];
                    this.state.historyIndex = -1;

                    // Set zoom to 100% - canvas already fits viewport
                    this.setZoom(1);

                    // Reset scroll position
                    this.els.container.scrollLeft = 0;
                    this.els.container.scrollTop = 0;

                    // Auto-select image tool for easy manipulation
                    this.setTool('image');
                },

                els: {
                    overlay: null,
                    card: null,
                    canvas: null,
                    ctx: null,
                    container: null,
                    zoomSlider: null,
                    zoomDisplay: null,
                    connectorsSvg: null,
                },

                init() {
                    this.els.overlay = document.getElementById('whiteboard-overlay');
                    this.els.card = document.getElementById('whiteboard-card');
                    this.els.canvas = document.getElementById('whiteboard-canvas');
                    this.els.container = document.getElementById('whiteboard-canvas-container');
                    this.els.bgImage = document.getElementById('whiteboard-bg-image'); // Background image layer
                    this.els.zoomSlider = document.getElementById('whiteboard-zoom-slider');
                    this.els.zoomDisplay = document.getElementById('whiteboard-zoom-display');
                    this.els.connectorsSvg = document.getElementById('whiteboard-connectors');

                    if (!this.els.overlay || !this.els.canvas) return;
                    this.els.ctx = this.els.canvas.getContext('2d');

                    // Tool buttons
                    this.els.overlay.querySelectorAll('[data-tool]').forEach(btn => {
                        btn.addEventListener('click', () => this.setTool(btn.dataset.tool));
                    });

                    // Color swatches
                    this.els.overlay.querySelectorAll('.wb-color-swatch').forEach(swatch => {
                        swatch.addEventListener('click', () => this.setColor(swatch.dataset.color));
                    });

                    // Global Paste Listener
                    document.addEventListener('paste', (e) => this.onPaste(e));

                    // Drag and Drop Listeners for Image Import
                    this.els.overlay.addEventListener('dragover', (e) => this.handleDragOver(e));
                    this.els.overlay.addEventListener('drop', (e) => this.handleDrop(e));

                    // Action buttons
                    document.getElementById('whiteboard-undo-btn')?.addEventListener('click', () => this.undo());
                    document.getElementById('whiteboard-paste-btn')?.addEventListener('click', () => this.pasteContent());
                    document.getElementById('whiteboard-clear-btn')?.addEventListener('click', () => this.clear());
                    document.getElementById('whiteboard-cancel-btn')?.addEventListener('click', () => this.close());

                    document.getElementById('whiteboard-add-btn')?.addEventListener('click', () => {
                        this.addToArticle();
                    });

                    document.getElementById('whiteboard-thickness-btn')?.addEventListener('click', () => this.cycleThickness());

                    document.getElementById('whiteboard-bg-btn')?.addEventListener('click', () => this.cycleBackground());

                    this.els.zoomSlider?.addEventListener('input', (e) => {
                        this.setZoom(parseInt(e.target.value) / 100);
                    });

                    document.getElementById('wb-auto-layout-btn')?.addEventListener('click', () => {
                        this.autoLayout();
                    });

                    // Canvas drawing events - MOVED TO CONTAINER to capture events even if canvas is pointer-events: none
                    this.els.container.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                    this.els.container.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                    this.els.container.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                    this.els.container.addEventListener('mouseleave', () => {
                        if (this.state.isDrawing && this.state.tool === 'pen') this.stopDrawing();
                    });

                    // Touch events for mobile
                    this.els.container.addEventListener('touchstart', (e) => {
                        if (e.target === this.els.canvas || this.state.tool !== 'select') {
                            e.preventDefault();
                        }
                        if (e.touches && e.touches[0]) this.handleMouseDown(e.touches[0]);
                    }, { passive: false });

                    this.els.container.addEventListener('touchmove', (e) => {
                        if (e.target === this.els.canvas || this.state.tool !== 'select') {
                            e.preventDefault();
                        }
                        if (e.touches && e.touches[0]) this.handleMouseMove(e.touches[0]);
                    }, { passive: false });

                    this.els.container.addEventListener('touchend', (e) => {
                        this.handleMouseUp(e.changedTouches ? e.changedTouches[0] : e);
                    });

                    // Block ALL keyboard events when whiteboard is open (prevent background leakage)
                    this.els.overlay.addEventListener('keydown', (e) => {
                        if (e.target.classList?.contains('wb-text-content') || e.target.contentEditable === 'true') {

                            // RAPID FIRE: TAB to Spawn Child / Shift+Tab to Parent
                            if (e.key === 'Tab') {
                                e.preventDefault();
                                e.stopPropagation();

                                // Find active box
                                let activeBox = this.state.activeTextBox;
                                if (!activeBox) {
                                    const boxEl = e.target.closest('.wb-text-box');
                                    if (boxEl) {
                                        const id = parseInt(boxEl.getAttribute('data-id'));
                                        activeBox = this.state.textBoxes.find(tb => tb.id === id);
                                    }
                                }

                                if (activeBox) {
                                    if (e.shiftKey) {
                                        this.navigateToParent(activeBox);
                                    } else {
                                        this.spawnChildTextBox(activeBox);
                                    }
                                }
                                return;
                            }

                            // Still block Escape
                            if (e.key === 'Escape') {
                                e.preventDefault();
                                e.target.blur();
                                this.deselectAllTextBoxes();
                            }
                            return;
                        }
                        e.stopPropagation();
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            this.close();
                        }
                    }, true); // Use capture phase

                    this.els.overlay.addEventListener('click', (e) => {
                        if (e.target === this.els.overlay) this.close();
                    });

                    this.els.card?.addEventListener('click', (e) => e.stopPropagation());

                    window.addEventListener('resize', () => {
                        if (this.state.isOpen) this.resizeCanvas();
                    });

                    this.els.container?.addEventListener('click', (e) => {
                        if ((e.target === this.els.canvas || e.target === this.els.container) && this.state.tool === 'select') {
                            this.deselectAllTextBoxes();
                        }
                    });


                },

                open(insertMode = 'end', articleId = null) {
                    if (this.els.overlay) {
                        this.els.overlay.classList.remove('is-fullscreen');
                        const bgImg = this.els.overlay.querySelector('#whiteboard-bg-image');
                        if (bgImg) bgImg.style.display = 'none';
                    }
                    this.state.insertMode = insertMode;
                    this.state.isOpen = true;
                    this.state.editingBlockId = null; // Fresh whiteboard, not editing existing
                    this.state.pan = { x: 0, y: 0 };
                    this.state.textBoxes = [];
                    this.state.imageBoxes = [];
                    this.state.tapeBoxes = [];
                    this.state.tapeIdCounter = 0;
                    this.state.activeTextBox = null;
                    this.state.connectors = [];
                    this.state.isConnecting = false;
                    this.state.connectFromId = null;
                    this.state.connectFromColor = null;
                    this.state.backgroundStyle = 0;
                    this.state.isImageAnnotation = false;
                    this.state.sourceImageContainer = null;
                    this.state.backgroundImage = null;
                    this.state.bgImageData = null;

                    // Store article ID if provided (for stage mode saves)
                    this.state.stageModeSrcArticleId = articleId;

                    if (this.els.container) {
                        this.els.container.style.background = 'transparent';
                        this.els.container.style.backgroundImage = 'none';
                    }
                    this.els.overlay.classList.add('active');

                    this.resizeCanvas();
                    this.clear();

                    this.setTool('pen');

                    this.els.overlay.focus();
                    document.body.style.overflow = 'hidden';
                },

                // NEW: Open whiteboard with a screenshot image as full-viewport background
                async openWithScreenshot(imageDataUrl, imgNaturalW, imgNaturalH, articleId = null, isFullScreen = false) {
                    // 1. Pre-load image object and wait for it
                    const imageObj = new Image();
                    imageObj.crossOrigin = "Anonymous";

                    const imageLoaded = new Promise((resolve, reject) => {
                        imageObj.onload = () => resolve(imageObj);
                        imageObj.onerror = () => reject(new Error('Failed to load screenshot'));
                        if (imageObj.complete && imageObj.naturalWidth > 0) {
                            resolve(imageObj);
                        }
                    });
                    imageObj.src = imageDataUrl;

                    try {
                        await imageLoaded;
                    } catch (err) {
                        App.ui.showToast('Failed to load screenshot for annotation', { type: 'error' });
                        return;
                    }

                    // 2. Open whiteboard and reset state
                    this.state.insertMode = 'end';
                    this.state.isOpen = true;
                    this.state.editingBlockId = null;
                    this.state.pan = { x: 0, y: 0 };
                    this.state.textBoxes = [];
                    this.state.imageBoxes = [];
                    this.state.tapeBoxes = [];
                    this.state.tapeIdCounter = 0;
                    this.state.activeTextBox = null;
                    this.state.connectors = [];
                    this.state.isConnecting = false;
                    this.state.connectFromId = null;
                    this.state.connectFromColor = null;
                    this.state.backgroundStyle = 0;

                    // Store the article ID for stage mode saving
                    this.state.stageModeSrcArticleId = articleId;

                    // Reset container visual
                    if (this.els.container) {
                        this.els.container.style.background = 'transparent';
                        this.els.container.style.backgroundImage = 'none';
                    }
                    this.els.overlay.classList.add('active');
                    if (isFullScreen) {
                        this.els.overlay.classList.add('is-fullscreen');
                    } else {
                        this.els.overlay.classList.remove('is-fullscreen');
                    }
                    this.els.overlay.classList.add('has-bg-image'); // Enable image tool visibility
                    this.els.overlay.focus();
                    document.body.style.overflow = 'hidden';

                    // 3. Set image annotation state
                    this.state.isImageAnnotation = true;
                    this.state.sourceImageContainer = null; // No source container for screenshot mode
                    this.state.backgroundImage = imageObj;

                    // 4. Get viewport dimensions and set canvas to fill it
                    const viewportW = this.els.container.clientWidth || window.innerWidth - 100;
                    const viewportH = this.els.container.clientHeight || window.innerHeight - 150;
                    const dpr = window.devicePixelRatio || 1;
                    const padding = isFullScreen ? 0 : 20;

                    const availW = viewportW - (padding * 2);
                    const availH = viewportH - (padding * 2);

                    const imgAspect = imgNaturalW / imgNaturalH;
                    const viewAspect = availW / availH;

                    let drawW, drawH;
                    if (imgAspect > viewAspect) {
                        // Image is wider - fit to width
                        drawW = availW;
                        drawH = availW / imgAspect;
                    } else {
                        // Image is taller - fit to height
                        drawH = availH;
                        drawW = availH * imgAspect;
                    }

                    const drawX = padding + (availW - drawW) / 2;
                    const drawY = padding + (availH - drawH) / 2;

                    this.els.canvas.width = viewportW * dpr;
                    this.els.canvas.height = viewportH * dpr;
                    this.els.canvas.style.width = viewportW + 'px';
                    this.els.canvas.style.height = viewportH + 'px';

                    this.els.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.els.ctx.scale(dpr, dpr);

                    // 5. Store image data for export
                    this.state.bgImageData = {
                        x: drawX,
                        y: drawY,
                        w: drawW,
                        h: drawH,
                        originalW: imgNaturalW,
                        originalH: imgNaturalH
                    };

                    // 6. Use SEPARATE background image element (not on canvas) for proper z-index layering
                    if (this.els.bgImage) {
                        this.els.bgImage.src = imageDataUrl;
                        this.els.bgImage.style.display = 'block';
                        this.els.bgImage.style.left = drawX + 'px';
                        this.els.bgImage.style.top = drawY + 'px';
                        this.els.bgImage.style.width = drawW + 'px';
                        this.els.bgImage.style.height = drawH + 'px';
                    }

                    this.state.useSeparateBgImage = true;

                    this.state.history = [];
                    this.state.historyIndex = -1;

                    this.setZoom(1);

                    this.els.container.scrollLeft = 0;
                    this.els.container.scrollTop = 0;

                    this.setTool('pen');
                },

                close() {
                    if (this.state.animationFrameId) {
                        cancelAnimationFrame(this.state.animationFrameId);
                        this.state.animationFrameId = null;
                    }
                    this.state.isOpen = false;
                    this.state.editingBlockId = null; // Reset editing mode
                    this.els.overlay.classList.remove('active');
                    this.els.overlay.classList.remove('has-bg-image'); // Clean up image mode class
                    document.body.style.overflow = '';
                    // Hide background image element
                    if (this.els.bgImage) {
                        this.els.bgImage.style.display = 'none';
                        this.els.bgImage.src = '';
                    }
                    this.state.useSeparateBgImage = false;
                    this.state.textBoxes.forEach(tb => tb.element?.remove());
                    this.state.textBoxes = [];
                    (this.state.imageBoxes || []).forEach(ib => ib.element?.remove());
                    this.state.imageBoxes = [];
                    (this.state.tapeBoxes || []).forEach(tb => tb.element?.remove());
                    this.state.tapeBoxes = [];
                    this.state.connectors = [];
                    if (this.els.connectorsSvg) this.els.connectorsSvg.innerHTML = '';
                },

                resizeCanvas() {
                    if (!this.els.container || !this.els.canvas) return;

                    const rect = this.els.container.getBoundingClientRect();
                    const dpr = window.devicePixelRatio || 1;

                    // Store current drawing if any
                    let imageData = null;
                    if (this.els.canvas.width > 0 && this.els.canvas.height > 0) {
                        try {
                            imageData = this.els.ctx.getImageData(0, 0, this.els.canvas.width, this.els.canvas.height);
                        } catch (e) { /* empty canvas */ }
                    }

                    this.els.canvas.width = rect.width * dpr;
                    this.els.canvas.height = rect.height * dpr;
                    this.els.canvas.style.width = rect.width + 'px';
                    this.els.canvas.style.height = rect.height + 'px';

                    this.els.ctx.scale(dpr, dpr);

                    // Restore drawing if we had one
                    if (imageData) {
                        this.els.ctx.putImageData(imageData, 0, 0);
                    }
                },

                setZoom(zoom) {
                    this.state.zoom = Math.max(0.5, Math.min(2, zoom));
                    this.els.canvas.style.transform = `scale(${this.state.zoom})`;
                    this.els.canvas.style.transformOrigin = 'center center';
                    if (this.els.zoomDisplay) {
                        this.els.zoomDisplay.textContent = Math.round(this.state.zoom * 100) + '%';
                    }
                },

                setTool(tool) {
                    const prevTool = this.state.tool;
                    this.state.tool = tool;
                    this.els.overlay.querySelectorAll('[data-tool]').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.tool === tool);
                    });

                    // Update cursor based on tool
                    const cursors = {
                        'select': 'default',
                        'pen': 'crosshair',
                        'line': 'crosshair',
                        'rect': 'crosshair',
                        'circle': 'crosshair',
                        'text': 'text',
                        'eraser': 'crosshair',
                        'image': 'default',
                        'tape': 'crosshair'
                    };
                    this.els.canvas.style.cursor = cursors[tool] || 'crosshair';
                    this.els.container.style.cursor = cursors[tool] || 'crosshair'; // Apply to container too

                    // Toggle Tool Classes on Container
                    this.els.container.classList.remove('wb-tool-select', 'wb-tool-pen', 'wb-tool-image', 'wb-tool-text', 'wb-tool-tape');
                    this.els.container.classList.add(`wb-tool-${tool}`);

                    // Handle image tool selection
                    if (tool === 'image' && this.state.isImageAnnotation) {
                        this.redrawWithImage(); // Show handles
                        App.ui.showToast(' Drag to move, corners to resize', { duration: 2000 });
                    } else if (prevTool === 'image' && tool !== 'image' && this.state.isImageAnnotation) {
                        // Cancel animation when switching away from image tool
                        if (this.state.animationFrameId) {
                            cancelAnimationFrame(this.state.animationFrameId);
                            this.state.animationFrameId = null;
                        }
                        this.redrawWithImage(); // Hide handles
                    }
                },

                setColor(colorVar) {
                    this.state.color = '--' + colorVar;
                    this.els.overlay.querySelectorAll('.wb-color-swatch').forEach(swatch => {
                        swatch.classList.toggle('active', swatch.dataset.color === colorVar);
                    });

                    // Update active text box color if any
                    if (this.state.activeTextBox) {
                        const tb = this.state.activeTextBox;
                        const color = this.getActiveColor();

                        // Change border and text color
                        tb.color = color;
                        this.updateTextBoxVisuals(tb);
                    }
                },

                getActiveColor() {
                    return getComputedStyle(document.documentElement).getPropertyValue(this.state.color).trim() || '#212529';
                },

                updateTextBoxVisuals(tb) {
                    const style = ['default', 'filled', 'glass', 'minimal'][tb.boxStyleIndex || 0];
                    const content = tb.element.querySelector('.wb-text-content');
                    const color = tb.color || this.getActiveColor();

                    // Reset inline styles
                    tb.element.style.backgroundColor = '';

                    if (style === 'filled') {
                        tb.element.style.backgroundColor = color;
                        tb.element.style.borderColor = color;
                        content.style.color = '#ffffff';
                    } else if (style === 'minimal') {
                        tb.element.style.borderColor = 'transparent';
                        content.style.color = color;
                    } else {
                        // Default, Glass
                        tb.element.style.borderColor = color;
                        content.style.color = color;
                    }
                },

                cycleThickness() {
                    this.state.thicknessIndex = (this.state.thicknessIndex + 1) % this.state.thicknesses.length;
                    this.state.thickness = this.state.thicknesses[this.state.thicknessIndex];

                    const btn = document.getElementById('whiteboard-thickness-btn');
                    const circle = btn?.querySelector('circle');
                    if (circle) circle.setAttribute('r', 2 + this.state.thickness * 0.5);

                    App.ui.showToast(`Thickness: ${this.state.thickness}px`, { duration: 1200 });
                },

                cycleBackground() {
                    const styles = ['transparent', 'white', 'sepia', 'dark', 'paper', 'grid'];
                    const labels = ['Transparent', 'White', 'Sepia', 'Dark', 'Paper', 'Grid'];
                    this.state.backgroundStyle = (this.state.backgroundStyle + 1) % styles.length;
                    const style = styles[this.state.backgroundStyle];

                    // Apply visual background to container
                    const container = this.els.container;

                    // Reset Logic
                    container.style.background = '';
                    container.style.backgroundImage = '';
                    container.classList.remove('wb-theme-dark', 'wb-bg-sepia', 'wb-bg-paper');

                    // Specific Handling
                    if (style === 'transparent') {
                        container.style.background = 'transparent';
                    } else if (style === 'white') {
                        container.style.background = '#ffffff';
                    } else if (style === 'sepia') {
                        container.classList.add('wb-bg-sepia');
                    } else if (style === 'paper') {
                        container.classList.add('wb-bg-paper');
                    } else if (style === 'dark') {
                        container.style.background = '#1a1a2e';
                        container.classList.add('wb-theme-dark');
                    } else if (style === 'grid') {
                        container.style.background = '#fafafa';
                        container.style.backgroundImage =
                            'linear-gradient(rgba(0,0,0,0.06) 1px, transparent 1px), ' +
                            'linear-gradient(90deg, rgba(0,0,0,0.06) 1px, transparent 1px)';
                        container.style.backgroundSize = '20px 20px';
                    }

                    // Update button visual indicator
                    const btn = document.getElementById('whiteboard-bg-btn');
                    if (btn) {
                        // const icons = ['', '', '', ''];
                        btn.title = `Background: ${labels[this.state.backgroundStyle]}`;
                    }

                    App.ui.showToast(`Background: ${labels[this.state.backgroundStyle]}`, { duration: 1200 });
                },


                // MOUSE/TOUCH HANDLERS
                handleMouseDown(e) {
                    if (this.state.tool === 'select') {
                        this.startPanning(e);
                        return;
                    }
                    if (this.state.tool === 'image' && this.state.isImageAnnotation) {
                        this.handleImageMouseDown(e);
                        return;
                    }
                    if (this.state.tool === 'text') {
                        this.createTextBox(e);
                        return;
                    }
                    // Tape tool - start drawing preview
                    if (this.state.tool === 'tape') {
                        this.startTapeDrawing(e);
                        return;
                    }
                    this.startDrawing(e);
                },

                handleMouseMove(e) {
                    if (this.state.isPanning) {
                        this.doPanning(e);
                        return;
                    }
                    if (this.state.isDraggingImage || this.state.isResizingImage) {
                        this.handleImageMouseMove(e);
                        return;
                    }
                    // Update cursor for image tool hover
                    if (this.state.tool === 'image' && this.state.isImageAnnotation) {
                        this.updateImageCursor(e);
                    }
                    // Tape drawing preview
                    if (this.state.isDrawingTape) {
                        this.updateTapePreview(e);
                        return;
                    }
                    this.draw(e);
                },

                handleMouseUp(e) {
                    if (this.state.isPanning) {
                        this.stopPanning();
                        return;
                    }
                    if (this.state.isDraggingImage || this.state.isResizingImage) {
                        this.handleImageMouseUp(e);
                        return;
                    }
                    // Finalize tape drawing
                    if (this.state.isDrawingTape) {
                        this.finishTapeDrawing(e);
                        return;
                    }
                    this.stopDrawing(e);
                },

                // TAPE DRAWING FUNCTIONS
                startTapeDrawing(e) {
                    const rect = this.els.container.getBoundingClientRect();
                    const x = e.clientX - rect.left + this.els.container.scrollLeft;
                    const y = e.clientY - rect.top + this.els.container.scrollTop;

                    this.state.isDrawingTape = true;
                    this.state.tapeStartPos = { x, y };

                    // Create preview element
                    const preview = document.createElement('div');
                    preview.className = 'wb-tape-preview';
                    preview.style.left = x + 'px';
                    preview.style.top = y + 'px';
                    preview.style.width = '0px';
                    preview.style.height = '0px';
                    this.els.container.appendChild(preview);
                    this.state.tapePreview = preview;
                },

                updateTapePreview(e) {
                    if (!this.state.tapePreview || !this.state.tapeStartPos) return;

                    const rect = this.els.container.getBoundingClientRect();
                    const currentX = e.clientX - rect.left + this.els.container.scrollLeft;
                    const currentY = e.clientY - rect.top + this.els.container.scrollTop;

                    const startX = this.state.tapeStartPos.x;
                    const startY = this.state.tapeStartPos.y;

                    // Calculate dimensions (allow drawing in any direction)
                    const x = Math.min(startX, currentX);
                    const y = Math.min(startY, currentY);
                    const w = Math.abs(currentX - startX);
                    const h = Math.abs(currentY - startY);

                    this.state.tapePreview.style.left = x + 'px';
                    this.state.tapePreview.style.top = y + 'px';
                    this.state.tapePreview.style.width = w + 'px';
                    this.state.tapePreview.style.height = h + 'px';
                },

                finishTapeDrawing(e) {
                    if (!this.state.tapePreview || !this.state.tapeStartPos) {
                        this.state.isDrawingTape = false;
                        return;
                    }

                    const rect = this.els.container.getBoundingClientRect();
                    const currentX = e.clientX - rect.left + this.els.container.scrollLeft;
                    const currentY = e.clientY - rect.top + this.els.container.scrollTop;

                    const startX = this.state.tapeStartPos.x;
                    const startY = this.state.tapeStartPos.y;

                    const x = Math.min(startX, currentX);
                    const y = Math.min(startY, currentY);
                    const w = Math.abs(currentX - startX);
                    const h = Math.abs(currentY - startY);

                    // Remove preview
                    this.state.tapePreview.remove();
                    this.state.tapePreview = null;
                    this.state.tapeStartPos = null;
                    this.state.isDrawingTape = false;

                    // Only create tape if it has minimum size
                    if (w >= 20 && h >= 10) {
                        this.addTapeBox(x, y, w, h);
                        App.ui.showToast(' Occluded', { duration: 2000 });
                    }
                },

                // PAN FUNCTIONALITY
                startPanning(e) {
                    this.state.isPanning = true;
                    this.state.panStart = { x: e.clientX, y: e.clientY };
                    this.els.canvas.style.cursor = 'grabbing';
                },

                doPanning(e) {
                    if (!this.state.isPanning) return;
                    const dx = e.clientX - this.state.panStart.x;
                    const dy = e.clientY - this.state.panStart.y;
                    this.els.container.scrollLeft -= dx;
                    this.els.container.scrollTop -= dy;
                    this.state.panStart = { x: e.clientX, y: e.clientY };
                },

                stopPanning() {
                    this.state.isPanning = false;
                    this.els.canvas.style.cursor = 'grab';
                },


                // IMAGE MANIPULATION
                getCanvasCoords(e) {
                    const rect = this.els.canvas.getBoundingClientRect();
                    const zoom = this.state.zoom || 1;
                    return {
                        x: (e.clientX - rect.left) / zoom,
                        y: (e.clientY - rect.top) / zoom
                    };
                },

                // Check if point is on a resize handle (returns handle name or null)
                getResizeHandle(pos) {
                    if (!this.state.bgImageData) return null;
                    const { x, y, w, h } = this.state.bgImageData;
                    const handleSize = 12;

                    // Corner handles
                    const handles = {
                        'nw': { x: x, y: y },
                        'ne': { x: x + w, y: y },
                        'sw': { x: x, y: y + h },
                        'se': { x: x + w, y: y + h }
                    };

                    for (const [name, corner] of Object.entries(handles)) {
                        if (Math.abs(pos.x - corner.x) < handleSize &&
                            Math.abs(pos.y - corner.y) < handleSize) {
                            return name;
                        }
                    }
                    return null;
                },

                // Check if point is inside image bounds
                isInsideImage(pos) {
                    if (!this.state.bgImageData) return false;
                    const { x, y, w, h } = this.state.bgImageData;
                    return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
                },

                handleImageMouseDown(e) {
                    const pos = this.getCanvasCoords(e);

                    // Check for resize handle first
                    const handle = this.getResizeHandle(pos);
                    if (handle) {
                        this.state.isResizingImage = true;
                        this.state.resizeHandle = handle;
                        this.state.dragStartPos = { ...pos };
                        this.state.dragStartImagePos = { ...this.state.bgImageData };
                        e.preventDefault();
                        return;
                    }

                    // Check if clicking on image (for dragging)
                    if (this.isInsideImage(pos)) {
                        this.state.isDraggingImage = true;
                        this.state.dragStartPos = { ...pos };
                        this.state.dragStartImagePos = { ...this.state.bgImageData };
                        this.els.canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                },

                handleImageMouseMove(e) {
                    const pos = this.getCanvasCoords(e);

                    if (this.state.isDraggingImage) {
                        // Move image
                        const dx = pos.x - this.state.dragStartPos.x;
                        const dy = pos.y - this.state.dragStartPos.y;
                        this.state.bgImageData.x = this.state.dragStartImagePos.x + dx;
                        this.state.bgImageData.y = this.state.dragStartImagePos.y + dy;
                        this.redrawWithImage();
                    } else if (this.state.isResizingImage) {
                        // Resize image (maintain aspect ratio)
                        const startImg = this.state.dragStartImagePos;
                        const aspectRatio = startImg.w / startImg.h;
                        const handle = this.state.resizeHandle;

                        let newX = startImg.x;
                        let newY = startImg.y;
                        let newW = startImg.w;
                        let newH = startImg.h;

                        const dx = pos.x - this.state.dragStartPos.x;
                        const dy = pos.y - this.state.dragStartPos.y;

                        if (handle === 'se') {
                            newW = Math.max(100, startImg.w + dx);
                            newH = newW / aspectRatio;
                        } else if (handle === 'sw') {
                            newW = Math.max(100, startImg.w - dx);
                            newH = newW / aspectRatio;
                            newX = startImg.x + startImg.w - newW;
                        } else if (handle === 'ne') {
                            newW = Math.max(100, startImg.w + dx);
                            newH = newW / aspectRatio;
                            newY = startImg.y + startImg.h - newH;
                        } else if (handle === 'nw') {
                            newW = Math.max(100, startImg.w - dx);
                            newH = newW / aspectRatio;
                            newX = startImg.x + startImg.w - newW;
                            newY = startImg.y + startImg.h - newH;
                        }

                        this.state.bgImageData = {
                            ...this.state.bgImageData,
                            x: newX, y: newY, w: newW, h: newH
                        };
                        this.redrawWithImage();
                    }
                },

                handleImageMouseUp(e) {
                    if (this.state.isDraggingImage || this.state.isResizingImage) {
                        this.state.isDraggingImage = false;
                        this.state.isResizingImage = false;
                        this.state.resizeHandle = null;
                        this.els.canvas.style.cursor = 'default';
                        // Save history for undo
                        this.saveState();
                    }
                },

                updateImageCursor(e) {
                    const pos = this.getCanvasCoords(e);
                    const handle = this.getResizeHandle(pos);

                    if (handle) {
                        const cursors = {
                            'nw': 'nwse-resize',
                            'ne': 'nesw-resize',
                            'sw': 'nesw-resize',
                            'se': 'nwse-resize'
                        };
                        this.els.canvas.style.cursor = cursors[handle];
                    } else if (this.isInsideImage(pos)) {
                        this.els.canvas.style.cursor = 'move';
                    } else {
                        this.els.canvas.style.cursor = 'default';
                    }
                },

                // Redraw canvas with image and handles
                redrawWithImage() {
                    if (!this.state.backgroundImage || !this.state.bgImageData) return;

                    if (this.state.useSeparateBgImage) {
                        const { x, y, w, h } = this.state.bgImageData;

                        if (this.els.bgImage) {
                            this.els.bgImage.style.left = x + 'px';
                            this.els.bgImage.style.top = y + 'px';
                            this.els.bgImage.style.width = w + 'px';
                            this.els.bgImage.style.height = h + 'px';
                        }

                        if (this.state.tool === 'image') {
                            const ctx = this.els.ctx;
                            const dpr = window.devicePixelRatio || 1;
                            const cornerRadius = 16;

                            // Clear canvas and draw handles only
                            ctx.setTransform(1, 0, 0, 1, 0, 0);
                            ctx.clearRect(0, 0, this.els.canvas.width, this.els.canvas.height);
                            ctx.scale(dpr, dpr);
                            this.drawImageHandles(ctx, x, y, w, h, cornerRadius);
                        }
                        return;
                    }

                    const ctx = this.els.ctx;
                    const dpr = window.devicePixelRatio || 1;
                    const { x, y, w, h } = this.state.bgImageData;
                    const cornerRadius = 16; // Modern rounded corners

                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, this.els.canvas.width, this.els.canvas.height);
                    ctx.scale(dpr, dpr);

                    ctx.save();
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                    ctx.shadowBlur = 20;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 8;
                    ctx.beginPath();
                    this.roundRect(ctx, x, y, w, h, cornerRadius);
                    ctx.fillStyle = 'rgba(0,0,0,0.01)'; // Nearly invisible but triggers shadow
                    ctx.fill();
                    ctx.restore();

                    // Draw background image with rounded corners using clip path
                    ctx.save();
                    ctx.beginPath();
                    this.roundRect(ctx, x, y, w, h, cornerRadius);
                    ctx.clip();
                    ctx.drawImage(this.state.backgroundImage, x, y, w, h);
                    ctx.restore();

                    // Draw selection handles if image tool is active
                    if (this.state.tool === 'image') {
                        this.drawImageHandles(ctx, x, y, w, h, cornerRadius);
                    }

                },

                // Helper function to draw rounded rectangles
                roundRect(ctx, x, y, w, h, r) {
                    if (w < 2 * r) r = w / 2;
                    if (h < 2 * r) r = h / 2;
                    ctx.moveTo(x + r, y);
                    ctx.arcTo(x + w, y, x + w, y + h, r);
                    ctx.arcTo(x + w, y + h, x, y + h, r);
                    ctx.arcTo(x, y + h, x, y, r);
                    ctx.arcTo(x, y, x + w, y, r);
                    ctx.closePath();
                },

                // Draw premium selection handles around image
                drawImageHandles(ctx, x, y, w, h, cornerRadius = 16) {
                    const handleSize = 14;
                    const primaryColor = getComputedStyle(document.documentElement)
                        .getPropertyValue('--primary-color').trim() || '#6366f1';

                    // Draw animated gradient border (premium look)
                    ctx.save();
                    ctx.strokeStyle = primaryColor;
                    ctx.setLineDash([8, 4]);
                    ctx.lineDashOffset = -Date.now() / 100 % 24; // Animated dash
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    this.roundRect(ctx, x - 1, y - 1, w + 2, h + 2, cornerRadius);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();

                    // Draw corner handles with shadow
                    const corners = [
                        { x: x, y: y },                 // NW
                        { x: x + w, y: y },             // NE
                        { x: x, y: y + h },             // SW
                        { x: x + w, y: y + h }          // SE
                    ];

                    corners.forEach(corner => {
                        // Handle shadow
                        ctx.save();
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
                        ctx.shadowBlur = 6;
                        ctx.shadowOffsetY = 2;

                        // White fill with primary border - circular handles
                        ctx.beginPath();
                        ctx.arc(corner.x, corner.y, handleSize / 2, 0, Math.PI * 2);
                        ctx.fillStyle = 'white';
                        ctx.fill();
                        ctx.restore();

                        // Border
                        ctx.beginPath();
                        ctx.arc(corner.x, corner.y, handleSize / 2, 0, Math.PI * 2);
                        ctx.strokeStyle = primaryColor;
                        ctx.lineWidth = 2.5;
                        ctx.stroke();
                    });

                    // Request animation frame for continuous border animation
                    if (this.state.tool === 'image' && this.state.isImageAnnotation) {
                        // Cancel previous frame to prevent stacking
                        if (this.state.animationFrameId) {
                            cancelAnimationFrame(this.state.animationFrameId);
                        }
                        this.state.animationFrameId = requestAnimationFrame(() => this.redrawWithImage());
                    }
                },


                // TEXT BOX FUNCTIONALITY
                // Available font families for text boxes - 18 diverse options with cursive variety
                fontFamilies: [
                    { name: 'Serif', value: 'var(--font-serif)' },
                    { name: 'Display', value: 'var(--font-display)' },
                    { name: 'Monospace', value: "'SF Mono', 'Fira Code', Consolas, monospace" },
                    { name: 'Montserrat', value: "'Montserrat', sans-serif" },
                    { name: 'Playfair', value: "'Playfair Display', Georgia, serif" },
                    { name: 'Courier', value: "'Courier New', Courier, monospace" },
                    { name: 'Trebuchet', value: "'Trebuchet MS', Helvetica, sans-serif" },
                    { name: 'Impact', value: "Impact, 'Arial Black', sans-serif" },
                    { name: 'Futura', value: "Futura, 'Century Gothic', sans-serif" },
                    // Cursive & Script Fonts
                    { name: 'Patrick Hand', value: "'Patrick Hand', cursive" },
                    { name: 'Satisfy', value: "'Satisfy', cursive" },
                    { name: 'Pacifico', value: "'Pacifico', cursive" },
                    { name: 'Lobster', value: "'Lobster', cursive" },
                    { name: 'Dancing Script', value: "'Dancing Script', cursive" },
                    { name: 'Shadows Into Light', value: "'Shadows Into Light', cursive" },
                    { name: 'Great Vibes', value: "'Great Vibes', cursive" },
                    { name: 'Caveat', value: "'Caveat', cursive" },
                    { name: 'Handwriting', value: "'Comic Sans MS', 'Segoe Print', cursive" }
                ],

                createTextBox(e) {
                    // If connecting via dot drag, don't create new box
                    if (this.state.isConnecting) return;

                    const rect = this.els.container.getBoundingClientRect();
                    const x = e.clientX - rect.left + this.els.container.scrollLeft;
                    const y = e.clientY - rect.top + this.els.container.scrollTop;
                    const color = this.getActiveColor();

                    this.addTextBox(x, y, color);
                    this.setTool('select'); // Switch to select mode to allow interaction
                },

                addTextBox(x, y, color) {
                    const id = ++this.state.textBoxIdCounter;

                    const box = document.createElement('div');
                    box.className = 'wb-text-box wb-spawn';
                    box.setAttribute('data-id', id);
                    box.setAttribute('data-box-style', 'default');
                    box.style.left = x + 'px';
                    box.style.top = y + 'px';
                    box.style.borderColor = color;

                    box.innerHTML = `
                        <div class="wb-text-controls">
                            <button data-action="style" title="Change Style"></button>
                            <button data-action="font-family" title="Change Font">Aa</button>
                            <button data-action="font-down" title="Smaller">A-</button>
                            <button data-action="font-up" title="Larger">A+</button>
                            <div class="wb-ctrl-divider"></div>
                            <button data-action="ai-spark" title="AI Sparks"></button>
                            <button data-action="delete" class="danger" title="Delete"></button>
                        </div>
                        <div class="wb-text-content" contenteditable="true" style="color: ${color}; font-size: 16px; font-family: var(--font-body);" placeholder="Type here..."></div>
                        <div class="wb-text-resize"></div>
                        <div class="wb-connector-dot" title="Click to add child node"></div>
                    `;

                    this.els.container.appendChild(box);

                    // Remove spawn class after animation
                    setTimeout(() => box.classList.remove('wb-spawn'), 300);

                    const textBoxData = {
                        id,
                        element: box,
                        x, y,
                        color,
                        fontSize: 16,
                        fontFamilyIndex: 0, // Track current font family
                        boxStyleIndex: 0,  // Track current box style (0=default, 1=filled, 2=glass, 3=minimal)
                    };
                    this.state.textBoxes.push(textBoxData);

                    // Setup interactions
                    this.setupTextBoxInteractions(textBoxData);

                    // Focus and select text - auto-editable immediately
                    const content = box.querySelector('.wb-text-content');
                    content.innerHTML = '';  // Clear placeholder
                    setTimeout(() => {
                        content.focus();
                        this.selectTextBox(textBoxData);
                    }, 50);

                    return textBoxData;
                },

                spawnChildTextBox(parentTb) {
                    const gapY = 150;
                    // Random small x offset for organic look
                    const x = parentTb.x + (Math.random() * 60 - 30);
                    const y = parentTb.y + gapY;

                    // Create new box with parent's color
                    const childTb = this.addTextBox(x, y, parentTb.color);

                    // Copy box style (gradient/filled/glass/outline)
                    if (parentTb.boxStyleIndex !== undefined) {
                        childTb.boxStyleIndex = parentTb.boxStyleIndex;
                        const styles = ['default', 'filled', 'glass', 'minimal'];
                        childTb.element.setAttribute('data-box-style', styles[parentTb.boxStyleIndex]);
                    }

                    // Copy font family
                    if (parentTb.fontFamilyIndex !== undefined) {
                        childTb.fontFamilyIndex = parentTb.fontFamilyIndex;
                        const font = this.fontFamilies[parentTb.fontFamilyIndex];
                        const childContent = childTb.element.querySelector('.wb-text-content');
                        if (childContent && font) {
                            childContent.style.fontFamily = font.value;
                        }
                    }

                    // Copy font size
                    if (parentTb.fontSize) {
                        childTb.fontSize = parentTb.fontSize;
                        const childContent = childTb.element.querySelector('.wb-text-content');
                        if (childContent) {
                            childContent.style.fontSize = parentTb.fontSize + 'px';
                        }
                    }

                    this.updateTextBoxVisuals(childTb);

                    this.state.connectors.push({
                        from: parentTb.id,
                        to: childTb.id,
                        color: parentTb.color
                    });
                    this.drawConnectors();
                },

                navigateToParent(childTb) {
                    // Find connection where to == childTb.id
                    const connection = this.state.connectors.find(c => c.to === childTb.id);
                    if (connection) {
                        const parentTb = this.state.textBoxes.find(tb => tb.id === connection.from);
                        if (parentTb) {
                            this.selectTextBox(parentTb);
                            // Also focus the text content
                            const content = parentTb.element.querySelector('.wb-text-content');
                            if (content) {
                                content.focus();
                                // Move cursor to end
                                const range = document.createRange();
                                const sel = window.getSelection();
                                range.selectNodeContents(content);
                                range.collapse(false);
                                sel.removeAllRanges();
                                sel.addRange(range);
                            }
                        }
                    } else {
                        App.ui.showToast("No parent node found", "info");
                    }
                },

                // --- AI EXPANSION LOGIC ---
                async expandNodeWithAI(parentNode) {
                    const contentEl = parentNode.element.querySelector('.wb-text-content');
                    const originalText = contentEl.innerText;

                    if (!originalText || originalText.trim().length === 0) {
                        App.ui.showToast("Please type a topic first!", "warning");
                        return;
                    }

                    const btn = parentNode.element.querySelector('[data-action="ai-spark"]');
                    const originalIcon = btn.innerHTML;
                    btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';

                    try {
                        const systemPrompt = `Act as a Context-Aware Expert AI Expander. Analyze the provided input.

                            If the input is a Broad Topic (e.g., 'Evolution'): Deconstruct it into 5-9 distinct, high-impact sub-topics or sub-concepts necessary to understand the main idea.

                            If the input is a Specific Request (e.g., '5 Classical Dances of India'): Provide the direct answers or specific items requested as the nodes.

                            Constraints:
                            - Keep each node concise (under 12 words).
                            - Return ONLY a raw JSON array of strings.
                            - NO Markdown formatting. NO Code fences.

                            Example Output: ["Answer 1", "Answer 2", "Answer 3"]`;
                        const response = await App.services.ai.queryGenerativeAI(systemPrompt, originalText);

                        if (!response) throw new Error("AI returned no content.");

                        let cleanResponse = response.trim();
                        // Sanitize Markdown code blocks if present
                        if (cleanResponse.startsWith('```json')) {
                            cleanResponse = cleanResponse.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                        } else if (cleanResponse.startsWith('```')) {
                            cleanResponse = cleanResponse.replace(/^```\s*/, '').replace(/\s*```$/, '');
                        }

                        let concepts;
                        try {
                            concepts = JSON.parse(cleanResponse);
                        } catch (e) {
                            console.error("AI JSON Parse Error:", e, cleanResponse);
                            throw new Error("AI response was not valid JSON.");
                        }

                        if (!Array.isArray(concepts) || concepts.length === 0) {
                            throw new Error("AI returned no concepts.");
                        }

                        this.layoutAndCreateChildNodes(parentNode, concepts);
                        App.ui.showToast(`Expanded with ${concepts.length} new ideas!`, "success");

                    } catch (error) {
                        console.error("AI Expansion Error:", error);
                        App.ui.showToast("AI couldn't think right now.", "error");
                    } finally {
                        if (btn) btn.innerHTML = originalIcon;
                    }
                },

                layoutAndCreateChildNodes(parentNode, concepts) {
                    const count = concepts.length;
                    const radius = 250; // Distance from parent

                    const angleStep = (2 * Math.PI) / count;
                    const canvasW = this.els.container.clientWidth;
                    const canvasH = this.els.container.clientHeight;
                    // Safety padding to prevent partial clipping
                    const padding = 50;
                    const boxW = 200; // Estimated box width
                    const boxH = 100; // Estimated box height

                    concepts.forEach((text, index) => {
                        const angle = index * angleStep;

                        let x = parentNode.x + radius * Math.cos(angle);
                        let y = parentNode.y + radius * Math.sin(angle);

                        // Clamp to within whiteboard bounds
                        x = Math.max(padding, Math.min(x, canvasW - boxW - padding));
                        y = Math.max(padding, Math.min(y, canvasH - boxH - padding));

                        // Create node
                        const childTb = this.addTextBox(x, y, parentNode.color);

                        // Set text
                        const contentEl = childTb.element.querySelector('.wb-text-content');
                        if (contentEl) contentEl.innerText = text;

                        // Create connector
                        this.state.connectors.push({
                            from: parentNode.id,
                            to: childTb.id,
                            color: parentNode.color
                        });
                    });

                    this.drawConnectors();
                },

                // --- AUTO-LAYOUT MAGIC WAND (6 MODES) ---
                autoLayout() {
                    // 0. Proactive CSS Fix


                    // 1. Cycle Layout Modes (0 to 5)
                    this.state.layoutMode = (this.state.layoutMode === undefined) ? 0 : (this.state.layoutMode + 1) % 6;
                    const MODES = [
                        'Radial Fit', 'Tree Horizontal', 'Tree Vertical',
                        'Mind Map (Split)', 'Grid Gallery', 'Golden Spiral'
                    ];
                    const modeIdx = this.state.layoutMode;

                    const nodes = this.state.textBoxes;
                    const connectors = this.state.connectors;
                    if (nodes.length === 0) return;

                    // 2. Build Graph
                    const adj = {};
                    const inDegree = {};
                    nodes.forEach(n => { adj[n.id] = []; inDegree[n.id] = 0; });
                    connectors.forEach(c => {
                        if (adj[c.from]) adj[c.from].push(c.to);
                        if (inDegree[c.to] !== undefined) inDegree[c.to]++;
                    });

                    let roots = nodes.filter(n => inDegree[n.id] === 0);
                    if (roots.length === 0 && nodes.length > 0) roots = [nodes[0]];

                    // Parameters
                    const W = this.els.container.clientWidth;
                    const H = this.els.container.clientHeight;
                    const margin = 100;
                    const centerX = W / 2;
                    const centerY = H / 2;

                    // Common Helpers
                    const getLeafCount = (nodeId, visited = new Set()) => {
                        if (visited.has(nodeId)) return 1;
                        visited.add(nodeId);
                        const children = adj[nodeId] || [];
                        if (children.length === 0) return 1;
                        return children.reduce((sum, c) => sum + getLeafCount(c, new Set(visited)), 0);
                    };

                    const getMaxDepth = (nodeId, d = 0, visited = new Set()) => {
                        if (visited.has(nodeId)) return d;
                        visited.add(nodeId);
                        const children = adj[nodeId] || [];
                        if (children.length === 0) return d;
                        return Math.max(...children.map(c => getMaxDepth(c, d + 1, new Set(visited))));
                    };

                    const moveTo = (nodeId, x, y) => {
                        const node = nodes.find(n => n.id === nodeId);
                        if (!node) return;
                        // Clamp
                        const safeX = Math.max(20, Math.min(x, W - 160));
                        const safeY = Math.max(20, Math.min(y, H - 90));

                        node.x = safeX; node.y = safeY;
                        node.element.style.transition = 'left 0.8s cubic-bezier(0.16, 1, 0.3, 1), top 0.8s cubic-bezier(0.16, 1, 0.3, 1)';
                        node.element.style.left = safeX + 'px';
                        node.element.style.top = safeY + 'px';
                        setTimeout(() => { node.element.style.transition = ''; }, 850);
                    };

                    // --- ALGORITHMS ---

                    if (modeIdx === 0) {
                        // 1. RADIAL FIT
                        let maxDepth = 0;
                        roots.forEach(r => maxDepth = Math.max(maxDepth, getMaxDepth(r.id)));
                        const rStepX = (W / 2 - margin) / Math.max(1, maxDepth);
                        const rStepY = (H / 2 - margin) / Math.max(1, maxDepth);

                        const getRadialWeight = (nid, visited = new Set()) => {
                            if (visited.has(nid)) return 0;
                            visited.add(nid);
                            const children = adj[nid] || [];
                            if (children.length === 0) return 1;
                            return children.reduce((s, c) => s + getRadialWeight(c, new Set(visited)), 0);
                        }

                        const placeRadial = (nid, startA, endA, level, visited = new Set()) => {
                            if (visited.has(nid)) return;
                            visited.add(nid);
                            const children = (adj[nid] || []).filter(c => !visited.has(c));
                            const totalW = children.reduce((s, c) => s + getRadialWeight(c, new Set(visited)), 0);
                            let curA = startA;
                            children.forEach(cid => {
                                const w = getRadialWeight(cid, new Set(visited));
                                const share = (w / totalW) * (endA - startA);
                                const mid = curA + share / 2;
                                const radX = (level + 1) * rStepX;
                                const radY = (level + 1) * rStepY;
                                moveTo(cid, centerX + radX * Math.cos(mid), centerY + radY * Math.sin(mid));
                                placeRadial(cid, curA, curA + share, level + 1, new Set(visited));
                                curA += share;
                            });
                        };
                        const rootGap = (W - 2 * margin) / (roots.length + 1);
                        const gV = new Set();
                        roots.forEach((r, i) => {
                            moveTo(r.id, margin + rootGap * (i + 1), centerY);
                            placeRadial(r.id, 0, 2 * Math.PI, 0, gV);
                        });

                    } else if (modeIdx === 1) {
                        // 2. TREE HORIZONTAL (Left -> Right)
                        let maxDepth = 0;
                        roots.forEach(r => maxDepth = Math.max(maxDepth, getMaxDepth(r.id)));
                        const xStep = (W - 2 * margin) / Math.max(1, maxDepth);

                        const placeTreeH = (nid, x, yStart, yEnd, visited = new Set()) => {
                            if (visited.has(nid)) return;
                            visited.add(nid);
                            const yMid = (yStart + yEnd) / 2;
                            moveTo(nid, x, yMid);

                            const children = (adj[nid] || []).filter(c => !visited.has(c));
                            if (children.length === 0) return;

                            const totalLeaves = children.reduce((s, c) => s + getLeafCount(c, new Set(visited)), 0);
                            const hAvailable = yEnd - yStart;
                            let curY = yStart;

                            children.forEach(cid => {
                                const leaves = getLeafCount(cid, new Set(visited));
                                const hShare = (leaves / totalLeaves) * hAvailable;
                                placeTreeH(cid, x + xStep, curY, curY + hShare, new Set(visited));
                                curY += hShare;
                            });
                        };

                        const totalLeaves = roots.reduce((s, r) => s + getLeafCount(r.id), 0);
                        let curRootY = margin;
                        const gV = new Set();
                        roots.forEach(r => {
                            const leaves = getLeafCount(r.id);
                            const hShare = (leaves / totalLeaves) * (H - 2 * margin);
                            placeTreeH(r.id, margin, curRootY, curRootY + hShare, gV);
                            curRootY += hShare;
                        });

                    } else if (modeIdx === 2) {
                        // 3. TREE VERTICAL (Top -> Down)
                        let maxDepth = 0;
                        roots.forEach(r => maxDepth = Math.max(maxDepth, getMaxDepth(r.id)));
                        const yStep = (H - 2 * margin) / Math.max(1, maxDepth);

                        const placeTreeV = (nid, y, xStart, xEnd, visited = new Set()) => {
                            if (visited.has(nid)) return;
                            visited.add(nid);
                            const xMid = (xStart + xEnd) / 2;
                            moveTo(nid, xMid, y);
                            const children = (adj[nid] || []).filter(c => !visited.has(c));
                            if (children.length === 0) return;
                            const totalLeaves = children.reduce((s, c) => s + getLeafCount(c, new Set(visited)), 0);
                            const wAvailable = xEnd - xStart;
                            let curX = xStart;
                            children.forEach(cid => {
                                const leaves = getLeafCount(cid, new Set(visited));
                                const wShare = (leaves / totalLeaves) * wAvailable;
                                placeTreeV(cid, y + yStep, curX, curX + wShare, new Set(visited));
                                curX += wShare;
                            });
                        };
                        const totalLeaves = roots.reduce((s, r) => s + getLeafCount(r.id), 0);
                        let curRootX = margin;
                        const gV = new Set();
                        roots.forEach(r => {
                            const leaves = getLeafCount(r.id);
                            const wShare = (leaves / totalLeaves) * (W - 2 * margin);
                            placeTreeV(r.id, margin, curRootX, curRootX + wShare, gV);
                            curRootX += wShare;
                        });

                    } else if (modeIdx === 3) {
                        // 4. MIND MAP (Double Split Horizontal)
                        // Split roots or first-level children into Left/Right groups based on balance
                        let leftNodes = [], rightNodes = [];
                        let leftWeight = 0, rightWeight = 0;
                        const gV = new Set();

                        // For single root with many children, split children
                        if (roots.length === 1 && (adj[roots[0].id] || []).length > 1) {
                            const r = roots[0];
                            gV.add(r.id);
                            const children = adj[r.id];
                            // Sort children by size to balance
                            children.sort((a, b) => getLeafCount(b) - getLeafCount(a));
                            children.forEach(c => {
                                if (leftWeight <= rightWeight) { leftNodes.push(c); leftWeight += getLeafCount(c); }
                                else { rightNodes.push(c); rightWeight += getLeafCount(c); }
                            });
                            // Place Root Center
                            moveTo(r.id, centerX, centerY);
                        } else {
                            // Multiple roots, split roots
                            roots.sort((a, b) => getLeafCount(b.id) - getLeafCount(a.id));
                            roots.forEach(r => {
                                if (leftWeight <= rightWeight) { leftNodes.push(r.id); leftWeight += getLeafCount(r.id); }
                                else { rightNodes.push(r.id); rightWeight += getLeafCount(r.id); }
                            });
                        }

                        let maxDepth = 0;
                        nodes.forEach(n => maxDepth = Math.max(maxDepth, getMaxDepth(n.id)));
                        const xStep = (W / 2 - margin) / Math.max(1, maxDepth); // Half width available

                        // Generalized Tree H with direction multiplier
                        const placeSide = (nid, x, yStart, yEnd, dir, visited) => {
                            if (visited.has(nid)) return;
                            visited.add(nid);
                            const yMid = (yStart + yEnd) / 2;
                            moveTo(nid, x, yMid);

                            const children = (adj[nid] || []).filter(c => !visited.has(c));
                            if (children.length === 0) return;
                            const totalLeaves = children.reduce((s, c) => s + getLeafCount(c, new Set(visited)), 0);
                            const hAvailable = yEnd - yStart;
                            let curY = yStart;
                            children.forEach(cid => {
                                const leaves = getLeafCount(cid, new Set(visited));
                                const hShare = (leaves / totalLeaves) * hAvailable;
                                placeSide(cid, x + (xStep * dir), curY, curY + hShare, dir, visited);
                                curY += hShare;
                            });
                        };

                        // Process Left
                        let curY = margin;
                        leftNodes.forEach(nid => {
                            const leaves = getLeafCount(nid);
                            const hShare = (leaves / Math.max(1, leftWeight)) * (H - 2 * margin);
                            const startX = roots.length === 1 ? centerX - xStep : centerX - 50;
                            placeSide(nid, startX, curY, curY + hShare, -1, gV);
                            curY += hShare;
                        });
                        // Process Right
                        curY = margin;
                        rightNodes.forEach(nid => {
                            const leaves = getLeafCount(nid);
                            const hShare = (leaves / Math.max(1, rightWeight)) * (H - 2 * margin);
                            const startX = roots.length === 1 ? centerX + xStep : centerX + 50;
                            placeSide(nid, startX, curY, curY + hShare, 1, gV);
                            curY += hShare;
                        });

                    } else if (modeIdx === 4) {
                        // 5. GRID GALLERY (Grid Sort)
                        // Ignore tree structure, pack by BFS order or ID
                        // Let's use BFS from roots to keep related items somewhat near
                        const sortedNodes = [];
                        const visited = new Set();
                        const queue = [...roots];

                        while (queue.length > 0) {
                            const r = queue.shift();
                            if (visited.has(r.id)) continue;
                            visited.add(r.id);
                            sortedNodes.push(r);
                            const children = adj[r.id] || [];
                            queue.push(...children.map(cid => nodes.find(n => n.id === cid)).filter(x => x));
                        }
                        // Add any disconnected nodes
                        nodes.forEach(n => { if (!visited.has(n.id)) sortedNodes.push(n); });

                        const N = sortedNodes.length;
                        const ratio = W / H;
                        const cols = Math.ceil(Math.sqrt(N * ratio));
                        const rows = Math.ceil(N / cols);

                        const cellW = (W - 2 * margin) / cols;
                        const cellH = (H - 2 * margin) / rows;

                        sortedNodes.forEach((n, i) => {
                            const c = i % cols;
                            const r = Math.floor(i / cols);
                            moveTo(n.id, margin + c * cellW + cellW / 2, margin + r * cellH + cellH / 2);
                        });

                    } else if (modeIdx === 5) {
                        // 6. GOLDEN SPIRAL
                        // Nodes in BFS order
                        const sortedNodes = [];
                        const visited = new Set();
                        const queue = [...roots];
                        while (queue.length > 0) {
                            const r = queue.shift();
                            if (visited.has(r.id)) continue;
                            visited.add(r.id);
                            sortedNodes.push(r);
                            const children = adj[r.id] || [];
                            queue.push(...children.map(cid => nodes.find(n => n.id === cid)).filter(x => x));
                        }
                        nodes.forEach(n => { if (!visited.has(n.id)) sortedNodes.push(n); });

                        // Spiral Math
                        const N = sortedNodes.length;
                        // Determine max Radius needed to fit screen
                        const maxR = Math.min(W, H) / 2 - margin;
                        const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.399 rad

                        // We choose parameters such that the last node lands at roughly maxR
                        // r = c * sqrt(i)
                        // maxR = c * sqrt(N) => c = maxR / sqrt(N)
                        const c = maxR / Math.sqrt(Math.max(1, N));

                        sortedNodes.forEach((n, i) => {
                            if (i === 0) {
                                moveTo(n.id, centerX, centerY);
                            } else {
                                const dist = c * Math.sqrt(i);
                                const theta = i * goldenAngle;
                                const x = centerX + dist * Math.cos(theta);
                                const y = centerY + dist * Math.sin(theta);
                                moveTo(n.id, x, y);
                            }
                        });
                    }

                    // Loop Animation
                    let start = null;
                    const animateConnectors = (timestamp) => {
                        if (!start) start = timestamp;
                        if (timestamp - start < 700) {
                            this.drawConnectors();
                            requestAnimationFrame(animateConnectors);
                        } else {
                            this.drawConnectors();
                        }
                    };
                    requestAnimationFrame(animateConnectors);

                    App.ui.showToast(`Layout: ${MODES[modeIdx]} (${modeIdx + 1}/6) `, "success");
                },

                setupTextBoxInteractions(tb) {
                    const box = tb.element;
                    const content = box.querySelector('.wb-text-content');
                    const resizeHandle = box.querySelector('.wb-text-resize');
                    const self = this;

                    // Prevent canvas drawing when interacting with text box
                    box.addEventListener('mousedown', (e) => e.stopPropagation());
                    box.addEventListener('touchstart', (e) => e.stopPropagation());

                    // Select on click
                    box.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // If connecting, finish connection
                        if (self.state.isConnecting && self.state.connectFromId !== tb.id) {
                            self.finishConnection(tb);
                            return;
                        }
                        self.selectTextBox(tb);
                    });

                    // Control buttons
                    box.querySelectorAll('[data-action]').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const action = btn.dataset.action;
                            if (action === 'style') self.cycleBoxStyle(tb);
                            else if (action === 'font-family') self.cycleFontFamily(tb);
                            else if (action === 'font-down') self.changeFontSize(tb, -2);
                            else if (action === 'font-up') self.changeFontSize(tb, 2);
                            else if (action === 'delete') self.deleteTextBox(tb);
                            else if (action === 'ai-spark') self.expandNodeWithAI(tb);
                        });
                    });

                    // === DRAG FUNCTIONALITY ===
                    let dragState = { active: false, startX: 0, startY: 0, boxX: 0, boxY: 0 };

                    const onDragStart = (e) => {
                        // Ignore if clicking on controls, content, resize, or any connector dot
                        if (e.target.closest('.wb-text-controls') ||
                            e.target.closest('.wb-text-content') ||
                            e.target === resizeHandle ||
                            e.target.closest('.wb-connector-dot') ||
                            e.target.closest('.nk-accordion-control-btn')) return;

                        dragState.active = true;
                        dragState.startX = e.clientX;
                        dragState.startY = e.clientY;
                        dragState.boxX = tb.x;
                        dragState.boxY = tb.y;
                        box.classList.add('dragging');
                        e.preventDefault();
                    };

                    const onDragMove = (e) => {
                        if (!dragState.active) return;
                        const dx = e.clientX - dragState.startX;
                        const dy = e.clientY - dragState.startY;
                        tb.x = dragState.boxX + dx;
                        tb.y = dragState.boxY + dy;
                        box.style.left = tb.x + 'px';
                        box.style.top = tb.y + 'px';
                        self.drawConnectors();
                    };

                    const onDragEnd = () => {
                        if (dragState.active) {
                            dragState.active = false;
                            box.classList.remove('dragging');
                        }
                    };

                    box.addEventListener('mousedown', onDragStart);
                    document.addEventListener('mousemove', onDragMove);
                    document.addEventListener('mouseup', onDragEnd);

                    // === RESIZE FUNCTIONALITY ===
                    let resizeState = { active: false, startX: 0, startY: 0, w: 0, h: 0 };

                    resizeHandle.addEventListener('mousedown', (e) => {
                        resizeState.active = true;
                        resizeState.startX = e.clientX;
                        resizeState.startY = e.clientY;
                        resizeState.w = box.offsetWidth;
                        resizeState.h = box.offsetHeight;
                        e.stopPropagation();
                        e.preventDefault();
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (!resizeState.active) return;
                        box.style.width = Math.max(100, resizeState.w + (e.clientX - resizeState.startX)) + 'px';
                        box.style.height = Math.max(50, resizeState.h + (e.clientY - resizeState.startY)) + 'px';
                        self.drawConnectors();
                    });

                    document.addEventListener('mouseup', () => {
                        resizeState.active = false;
                    });

                    // === CONNECTOR DOT CLICK - Single dot for connections ===
                    const connectorDot = box.querySelector('.wb-connector-dot');
                    if (connectorDot) {
                        connectorDot.addEventListener('click', (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            self.spawnChildTextBox(tb);
                        });
                    }
                },

                changeFontSize(tb, delta) {
                    tb.fontSize = Math.min(48, Math.max(10, (tb.fontSize || 16) + delta));
                    const content = tb.element.querySelector('.wb-text-content');
                    content.style.fontSize = tb.fontSize + 'px';
                },

                cycleFontFamily(tb) {
                    // Cycle to next font family
                    tb.fontFamilyIndex = ((tb.fontFamilyIndex || 0) + 1) % this.fontFamilies.length;
                    const font = this.fontFamilies[tb.fontFamilyIndex];
                    const content = tb.element.querySelector('.wb-text-content');
                    content.style.fontFamily = font.value;
                    App.ui.showToast(`Font: ${font.name}`, { duration: 1200 });
                },

                cycleBoxStyle(tb) {
                    // Cycle through box styles: default  filled  glass  outline
                    const styles = ['default', 'filled', 'glass', 'minimal'];
                    const styleNames = ['Gradient', 'Filled', 'Glass', 'Outline'];
                    tb.boxStyleIndex = ((tb.boxStyleIndex || 0) + 1) % styles.length;
                    const newStyle = styles[tb.boxStyleIndex];
                    tb.element.setAttribute('data-box-style', newStyle);

                    this.updateTextBoxVisuals(tb);

                    App.ui.showToast(`Style: ${styleNames[tb.boxStyleIndex]}`, { duration: 1200 });
                },

                // ========================
                // CONNECTOR FUNCTIONALITY
                // ========================
                // startConnection and finishConnection removed (deprecated)

                // Get edge point on a box based on angle to target
                getEdgePoint(box, targetCx, targetCy) {
                    const el = box.element;
                    const cx = box.x + el.offsetWidth / 2;
                    const cy = box.y + el.offsetHeight / 2;
                    const w = el.offsetWidth / 2;
                    const h = el.offsetHeight / 2;

                    const dx = targetCx - cx;
                    const dy = targetCy - cy;
                    const angle = Math.atan2(dy, dx);

                    // Determine which edge based on angle
                    const tanAngle = Math.abs(dy / (dx || 0.001));
                    const boxTan = h / w;

                    let edgeX, edgeY;
                    if (tanAngle <= boxTan) {
                        // Hits left or right edge
                        edgeX = dx > 0 ? box.x + el.offsetWidth : box.x;
                        edgeY = cy + (edgeX - cx) * Math.tan(angle);
                    } else {
                        // Hits top or bottom edge
                        edgeY = dy > 0 ? box.y + el.offsetHeight : box.y;
                        edgeX = cx + (edgeY - cy) / Math.tan(angle);
                    }

                    return { x: edgeX, y: edgeY };
                },

                // ========================
                // PASTE & IMAGE FUNCTIONALITY
                // Handle native paste event (Ctrl+V) - No permissions prompt usually!
                handleDragOver(e) { e.preventDefault(); e.stopPropagation(); },

                handleDrop(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!e.dataTransfer || !e.dataTransfer.items) return;

                    const items = e.dataTransfer.items;
                    for (let i = 0; i < items.length; i++) {
                        const item = items[i];
                        if (item.kind === 'file' && item.type.startsWith('image/')) {
                            const blob = item.getAsFile();
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                const img = new Image();
                                img.onload = () => {
                                    // --- Image Compression ---
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    const jpegQuality = App.settings.get('jpegQuality') || 0.8;

                                    let naturalWidth = img.width;
                                    let naturalHeight = img.height;

                                    if (App.config && App.config.image && App.config.image.maxWidth) {
                                        const maxWidth = App.config.image.maxWidth;
                                        if (naturalWidth > maxWidth) {
                                            naturalHeight = (maxWidth / naturalWidth) * naturalHeight;
                                            naturalWidth = maxWidth;
                                        }
                                    }

                                    canvas.width = naturalWidth;
                                    canvas.height = naturalHeight;
                                    ctx.drawImage(img, 0, 0, naturalWidth, naturalHeight);
                                    const compressedDataUrl = canvas.toDataURL('image/jpeg', jpegQuality);

                                    // Display size
                                    let w = naturalWidth;
                                    let h = naturalHeight;
                                    const maxW = 300;
                                    if (w > maxW) {
                                        h = (maxW / w) * h;
                                        w = maxW;
                                    }

                                    // Place at drop position relative to container
                                    const containerRect = this.els.container.getBoundingClientRect();
                                    const x = (e.clientX - containerRect.left) + this.els.container.scrollLeft - (w / 2);
                                    const y = (e.clientY - containerRect.top) + this.els.container.scrollTop - (h / 2);

                                    this.addImageBox(x, y, compressedDataUrl, w, h);
                                    App.ui.showToast('Image pasted from drop!', { duration: 2000 });
                                };
                                img.src = event.target.result;
                            };
                            reader.readAsDataURL(blob);
                        }
                    }
                },

                onPaste(e) {
                    if (!this.state.isOpen) return;
                    // Don't intercept if user is typing in a real input
                    if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.contentEditable === 'true')) return;

                    e.preventDefault();

                    if (!e.clipboardData || !e.clipboardData.items) return;

                    const items = e.clipboardData.items;

                    for (let i = 0; i < items.length; i++) {
                        const item = items[i];

                        if (item.type.indexOf('image') !== -1) {
                            const blob = item.getAsFile();
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                const img = new Image();
                                img.onload = () => {
                                    // --- Image Compression ---
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    const jpegQuality = App.settings.get('jpegQuality') || 0.8;

                                    let naturalWidth = img.width;
                                    let naturalHeight = img.height;

                                    if (App.config && App.config.image && App.config.image.maxWidth) {
                                        const maxWidth = App.config.image.maxWidth;
                                        if (naturalWidth > maxWidth) {
                                            naturalHeight = (maxWidth / naturalWidth) * naturalHeight;
                                            naturalWidth = maxWidth;
                                        }
                                    }

                                    canvas.width = naturalWidth;
                                    canvas.height = naturalHeight;
                                    ctx.drawImage(img, 0, 0, naturalWidth, naturalHeight);
                                    const compressedDataUrl = canvas.toDataURL('image/jpeg', jpegQuality);

                                    // Calculate center
                                    const rect = this.els.container.getBoundingClientRect();
                                    const cx = rect.width / 2;
                                    const cy = rect.height / 2;

                                    let w = naturalWidth;
                                    let h = naturalHeight;
                                    const maxW = 300;
                                    if (w > maxW) {
                                        h = (maxW / w) * h;
                                        w = maxW;
                                    }

                                    this.addImageBox(cx - w / 2, cy - h / 2, compressedDataUrl, w, h);
                                    App.ui.showToast('Image pasted via shortcut!', { duration: 2000 });
                                };
                                img.src = event.target.result;
                            };
                            reader.readAsDataURL(blob);
                        } else if (item.type === 'text/plain') {
                            item.getAsString((text) => {
                                if (text) {
                                    const rect = this.els.container.getBoundingClientRect();
                                    this.addTextBox(rect.width / 2 - 100, rect.height / 2 - 20, text);
                                    App.ui.showToast('Text pasted via shortcut!', { duration: 2000 });
                                }
                            });
                        }
                    }
                },

                // Smart Paste: Text or Image (Button Click)
                async pasteContent() {
                    try {
                        const items = await navigator.clipboard.read();
                        for (const item of items) {
                            // Check for image
                            const imageType = item.types.find(type => type.startsWith('image/'));
                            if (imageType) {
                                const blob = await item.getType(imageType);
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    const img = new Image();
                                    img.onload = () => {
                                        // --- Image Compression ---
                                        const canvas = document.createElement('canvas');
                                        const ctx = canvas.getContext('2d');
                                        const jpegQuality = App.settings.get('jpegQuality') || 0.8;

                                        let naturalWidth = img.width;
                                        let naturalHeight = img.height;

                                        if (App.config && App.config.image && App.config.image.maxWidth) {
                                            const maxWidth = App.config.image.maxWidth;
                                            if (naturalWidth > maxWidth) {
                                                naturalHeight = (maxWidth / naturalWidth) * naturalHeight;
                                                naturalWidth = maxWidth;
                                            }
                                        }

                                        canvas.width = naturalWidth;
                                        canvas.height = naturalHeight;
                                        ctx.drawImage(img, 0, 0, naturalWidth, naturalHeight);
                                        const compressedDataUrl = canvas.toDataURL('image/jpeg', jpegQuality);

                                        // Default size
                                        let w = naturalWidth;
                                        let h = naturalHeight;
                                        const maxW = 300;
                                        if (w > maxW) {
                                            h = (maxW / w) * h;
                                            w = maxW;
                                        }

                                        // Center on screen
                                        const rect = this.els.container.getBoundingClientRect();
                                        const x = this.els.container.scrollLeft + (rect.width / 2) - (w / 2);
                                        const y = this.els.container.scrollTop + (rect.height / 2) - (h / 2);

                                        this.addImageBox(x, y, compressedDataUrl, w, h);
                                        App.ui.showToast('Image pasted from clipboard!', { duration: 2000 });
                                    };
                                    img.src = e.target.result;
                                };
                                reader.readAsDataURL(blob);
                                return;
                            }

                            // Check for text
                            const textType = item.types.find(type => type === 'text/plain');
                            if (textType) {
                                const blob = await item.getType(textType);
                                const text = await blob.text();
                                if (text.trim()) {
                                    const rect = this.els.container.getBoundingClientRect();
                                    const x = this.els.container.scrollLeft + (rect.width / 2) - 100;
                                    const y = this.els.container.scrollTop + (rect.height / 2) - 20;
                                    const tb = this.addTextBox(x, y, this.getActiveColor());
                                    const content = tb.element.querySelector('.wb-text-content');
                                    // Use innerText to preserve line breaks
                                    content.textContent = text;
                                    App.ui.showToast('Text pasted from clipboard!', { duration: 2000 });
                                }
                                return;
                            }
                        }
                    } catch (err) {
                        console.warn('Clipboard API Read failed (probably permission denied or insecure context). Trying text fallback...', err);
                        // Fallback for simple text
                        try {
                            const text = await navigator.clipboard.readText();
                            if (text && text.trim()) {
                                const rect = this.els.container.getBoundingClientRect();
                                const x = this.els.container.scrollLeft + (rect.width / 2) - 100;
                                const y = this.els.container.scrollTop + (rect.height / 2) - 20;
                                const tb = this.addTextBox(x, y, this.getActiveColor());
                                tb.element.querySelector('.wb-text-content').textContent = text;
                                App.ui.showToast('Text pasted (Image paste requires Ctrl+V in this mode)', { duration: 3000 });
                                return; // Success text
                            }
                        } catch (e2) {
                            // Ignore text error, show main error
                        }

                        App.ui.showToast('Could not access clipboard directly. Please use Ctrl+V / Cmd+V to paste.', { type: 'error', duration: 4000 });
                    }
                },

                addImageBox(x, y, src, w, h) {
                    const id = ++this.state.textBoxIdCounter; // Shared ID counter for simplicity

                    const box = document.createElement('div');
                    box.className = 'wb-image-box wb-spawn';
                    box.setAttribute('data-id', id);
                    box.style.left = x + 'px';
                    box.style.top = y + 'px';
                    box.style.width = w + 'px';
                    box.style.height = h + 'px';

                    box.innerHTML = `
                        <div class="wb-image-move-handle" title="Move"></div>
                        <div class="wb-image-delete-handle" title="Delete"></div>
                        <img src="${src}" draggable="false">
                        <div class="wb-image-resize-handle"></div>
                    `;

                    this.els.container.appendChild(box);
                    setTimeout(() => box.classList.remove('wb-spawn'), 300);

                    const imageBoxData = {
                        id,
                        element: box,
                        x, y, w, h,
                        src
                    };

                    if (!this.state.imageBoxes) this.state.imageBoxes = [];
                    this.state.imageBoxes.push(imageBoxData);

                    this.setupImageBoxInteractions(imageBoxData);
                    return imageBoxData;
                },

                setupImageBoxInteractions(ib) {
                    const box = ib.element;
                    const resizeHandle = box.querySelector('.wb-image-resize-handle');
                    const self = this;

                    // Stop propagation ONLY on interactive elements
                    // box.addEventListener('mousedown', (e) => e.stopPropagation()); -> Removed to allow drawing through
                    // box.addEventListener('touchstart', (e) => e.stopPropagation()); -> Removed

                    // Selection - Handled by Move Handle mostly, but we can allow click selection only if clicking explicitly (rare if pointer events none)
                    // With pointer-events: none on box, this click listener won't fire for the image body, which is what we want.
                    box.addEventListener('click', (e) => {
                        // This might not fire due to pointer-events: none, but if we ever re-enable, we want to prevent bubbling
                        e.stopPropagation();
                    });

                    // Delete interaction
                    const deleteHandle = box.querySelector('.wb-image-delete-handle');
                    if (deleteHandle) {
                        deleteHandle.addEventListener('click', (e) => {
                            e.stopPropagation();
                            box.remove();
                            self.state.imageBoxes = self.state.imageBoxes.filter(i => i.id !== ib.id);
                        });
                        // Prevent click from bubbling to select (though pointer-events handles this, good safety)
                        deleteHandle.addEventListener('mousedown', (e) => e.stopPropagation());
                    }

                    // Move Handle (Drag)
                    const moveHandle = box.querySelector('.wb-image-move-handle');
                    if (moveHandle) {
                        moveHandle.addEventListener('click', (e) => {
                            e.stopPropagation();
                            // Select interaction
                            self.state.textBoxes.forEach(t => t.element.classList.remove('active'));
                            if (self.state.imageBoxes) self.state.imageBoxes.forEach(i => i.element.classList.remove('active'));
                            box.classList.add('active');
                            self.state.activeTextBox = null;
                        });

                        // Drag
                        let dragState = { active: false, startX: 0, startY: 0, boxX: 0, boxY: 0 };
                        const onDragStart = (e) => {
                            dragState.active = true;
                            dragState.startX = e.clientX;
                            dragState.startY = e.clientY;
                            dragState.boxX = ib.x;
                            dragState.boxY = ib.y;
                            box.classList.add('dragging');
                            // Select on drag start
                            self.state.textBoxes.forEach(t => t.element.classList.remove('active'));
                            if (self.state.imageBoxes) self.state.imageBoxes.forEach(i => i.element.classList.remove('active'));
                            box.classList.add('active');
                            e.preventDefault();
                            e.stopPropagation(); // Prevent canvas drawing
                        };

                        moveHandle.addEventListener('mousedown', onDragStart);

                        const onDragMove = (e) => {
                            if (!dragState.active) return;
                            const dx = e.clientX - dragState.startX;
                            const dy = e.clientY - dragState.startY;
                            ib.x = dragState.boxX + dx;
                            ib.y = dragState.boxY + dy;
                            box.style.left = ib.x + 'px';
                            box.style.top = ib.y + 'px';
                        };

                        const onDragEnd = () => {
                            if (dragState.active) {
                                dragState.active = false;
                                box.classList.remove('dragging');
                            }
                        };

                        document.addEventListener('mousemove', onDragMove);
                        document.addEventListener('mouseup', onDragEnd);
                    }

                    // Remove generic box mousedown that blocked drawing
                    // box.addEventListener('mousedown', ...); -> REMOVED

                    // Resize
                    let resizeState = { active: false, startX: 0, startY: 0, w: 0, h: 0 };
                    resizeHandle.addEventListener('mousedown', (e) => {
                        resizeState.active = true;
                        resizeState.startX = e.clientX;
                        resizeState.startY = e.clientY;
                        resizeState.w = ib.w;
                        resizeState.h = ib.h;
                        e.stopPropagation(); // Prevent drag
                        e.preventDefault();
                    });
                    const onResizeMove = (e) => {
                        if (!resizeState.active) return;
                        const dx = e.clientX - resizeState.startX;
                        const dy = e.clientY - resizeState.startY;
                        ib.w = Math.max(50, resizeState.w + dx);
                        ib.h = Math.max(50, resizeState.h + dy);
                        box.style.width = ib.w + 'px';
                        box.style.height = ib.h + 'px';
                    };
                    const onResizeEnd = () => {
                        resizeState.active = false;
                    };
                    document.addEventListener('mousemove', onResizeMove);
                    document.addEventListener('mouseup', onResizeEnd);
                },

                // ========================
                // OCCLUSION TAPE FUNCTIONS
                // ========================
                addTapeBox(x, y, w, h) {
                    const id = ++this.state.tapeIdCounter;

                    const box = document.createElement('div');
                    box.className = 'wb-tape-box wb-spawn';
                    box.setAttribute('data-tape-id', id);
                    box.style.left = x + 'px';
                    box.style.top = y + 'px';
                    box.style.width = Math.max(40, w) + 'px';
                    box.style.height = Math.max(20, h) + 'px';

                    box.innerHTML = `
                        <div class="wb-tape-delete" title="Delete"></div>
                        <div class="wb-tape-resize"></div>
                    `;

                    this.els.container.appendChild(box);
                    setTimeout(() => box.classList.remove('wb-spawn'), 300);

                    const tapeData = {
                        id,
                        element: box,
                        x, y,
                        w: Math.max(40, w),
                        h: Math.max(20, h),
                        revealed: false
                    };

                    this.state.tapeBoxes.push(tapeData);
                    this.setupTapeBoxInteractions(tapeData);

                    return tapeData;
                },

                setupTapeBoxInteractions(tb) {
                    const box = tb.element;
                    const resizeHandle = box.querySelector('.wb-tape-resize');
                    const deleteBtn = box.querySelector('.wb-tape-delete');
                    const self = this;

                    // Prevent canvas drawing when interacting with tape
                    box.addEventListener('mousedown', (e) => e.stopPropagation());
                    box.addEventListener('touchstart', (e) => e.stopPropagation());

                    // Toggle reveal on click (but not on delete/resize)
                    box.addEventListener('click', (e) => {
                        if (e.target.closest('.wb-tape-delete') || e.target.closest('.wb-tape-resize')) return;
                        e.stopPropagation();

                        // Toggle revealed state
                        tb.revealed = !tb.revealed;
                        box.classList.toggle('revealed', tb.revealed);

                        // Deselect other tapes, select this one
                        self.state.tapeBoxes.forEach(t => t.element.classList.remove('active'));
                        box.classList.add('active');
                    });

                    // Delete handler
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        self.deleteTapeBox(tb);
                    });

                    // === DRAG FUNCTIONALITY ===
                    let dragState = { active: false, startX: 0, startY: 0, boxX: 0, boxY: 0 };

                    const onDragStart = (e) => {
                        if (e.target.closest('.wb-tape-delete') || e.target.closest('.wb-tape-resize')) return;

                        dragState.active = true;
                        dragState.startX = e.clientX;
                        dragState.startY = e.clientY;
                        dragState.boxX = tb.x;
                        dragState.boxY = tb.y;
                        box.classList.add('dragging');
                        e.preventDefault();
                    };

                    const onDragMove = (e) => {
                        if (!dragState.active) return;
                        const dx = e.clientX - dragState.startX;
                        const dy = e.clientY - dragState.startY;
                        tb.x = dragState.boxX + dx;
                        tb.y = dragState.boxY + dy;
                        box.style.left = tb.x + 'px';
                        box.style.top = tb.y + 'px';
                    };

                    const onDragEnd = () => {
                        if (dragState.active) {
                            dragState.active = false;
                            box.classList.remove('dragging');
                        }
                    };

                    box.addEventListener('mousedown', onDragStart);
                    document.addEventListener('mousemove', onDragMove);
                    document.addEventListener('mouseup', onDragEnd);

                    // === RESIZE FUNCTIONALITY ===
                    let resizeState = { active: false, startX: 0, startY: 0, w: 0, h: 0 };

                    resizeHandle.addEventListener('mousedown', (e) => {
                        resizeState.active = true;
                        resizeState.startX = e.clientX;
                        resizeState.startY = e.clientY;
                        resizeState.w = tb.w;
                        resizeState.h = tb.h;
                        e.stopPropagation();
                        e.preventDefault();
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (!resizeState.active) return;
                        tb.w = Math.max(40, resizeState.w + (e.clientX - resizeState.startX));
                        tb.h = Math.max(20, resizeState.h + (e.clientY - resizeState.startY));
                        box.style.width = tb.w + 'px';
                        box.style.height = tb.h + 'px';
                    });

                    document.addEventListener('mouseup', () => {
                        resizeState.active = false;
                    });
                },

                deleteTapeBox(tb) {
                    tb.element.remove();
                    this.state.tapeBoxes = this.state.tapeBoxes.filter(t => t.id !== tb.id);
                },

                drawConnectors() {
                    if (!this.els.connectorsSvg) return;

                    let svg = '';

                    // Add SVG filter for subtle connector shadows
                    svg += `<defs>
                        <filter id="connectorShadow" x="-50%" y="-50%" width="200%" height="200%">
                            <feDropShadow dx="0" dy="1" stdDeviation="2" flood-opacity="0.12"/>
                        </filter>
                    </defs>`;

                    this.state.connectors.forEach((conn) => {
                        const fromBox = this.state.textBoxes.find(t => t.id === conn.from);
                        const toBox = this.state.textBoxes.find(t => t.id === conn.to);
                        if (!fromBox || !toBox) return;

                        const fromEl = fromBox.element;
                        const toEl = toBox.element;

                        // Get center points
                        const fromCx = fromBox.x + fromEl.offsetWidth / 2;
                        const fromCy = fromBox.y + fromEl.offsetHeight / 2;
                        const toCx = toBox.x + toEl.offsetWidth / 2;
                        const toCy = toBox.y + toEl.offsetHeight / 2;

                        // Calculate edge points (border-to-border)
                        const fromEdge = this.getEdgePoint(fromBox, toCx, toCy);
                        const toEdge = this.getEdgePoint(toBox, fromCx, fromCy);

                        // Use connection color (from parent box)
                        const strokeColor = conn.color || 'var(--primary-color)';

                        // --- SMART BEZIER CURVES ---
                        const startX = fromEdge.x;
                        const startY = fromEdge.y;
                        const endX = toEdge.x;
                        const endY = toEdge.y;

                        const dx = endX - startX;
                        const dy = endY - startY;

                        // Determine orientation for natural flow (Vertical vs Horizontal)
                        const isHorizontal = Math.abs(dx) > Math.abs(dy);

                        let pathD = '';
                        // Curvature intensity allows for organic flow
                        const intensity = 0.5;

                        if (isHorizontal) {
                            // Horizontal "S" Curve
                            // Control points extracted horizontally
                            const cp1X = startX + dx * intensity;
                            const cp1Y = startY;
                            const cp2X = endX - dx * intensity;
                            const cp2Y = endY;
                            pathD = `M ${startX} ${startY} C ${cp1X} ${cp1Y}, ${cp2X} ${cp2Y}, ${endX} ${endY}`;
                        } else {
                            // Vertical "S" Curve
                            // Control points extracted vertically
                            const cp1X = startX;
                            const cp1Y = startY + dy * intensity;
                            const cp2X = endX;
                            const cp2Y = endY - dy * intensity;
                            pathD = `M ${startX} ${startY} C ${cp1X} ${cp1Y}, ${cp2X} ${cp2Y}, ${endX} ${endY}`;
                        }

                        // Draw organic path connector
                        svg += `<path d="${pathD}" 
                            stroke="${strokeColor}" 
                            stroke-width="2.5" 
                            fill="none"
                            stroke-linecap="round"
                            filter="url(#connectorShadow)"
                            style="opacity: 0.85; transition: stroke 0.3s ease;"/>`;
                    });

                    this.els.connectorsSvg.innerHTML = svg;
                },

                selectTextBox(tb) {
                    this.deselectAllTextBoxes();
                    tb.element.classList.add('active');
                    this.state.activeTextBox = tb;
                },

                deselectAllTextBoxes() {
                    this.state.textBoxes.forEach(tb => {
                        tb.element.classList.remove('active');
                    });
                    this.state.activeTextBox = null;
                },

                deleteTextBox(tb) {
                    tb.element.remove();
                    this.state.textBoxes = this.state.textBoxes.filter(t => t.id !== tb.id);

                    // Remove associated connectors
                    this.state.connectors = this.state.connectors.filter(c => c.from !== tb.id && c.to !== tb.id);
                    this.drawConnectors();

                    if (this.state.activeTextBox?.id === tb.id) {
                        this.state.activeTextBox = null;
                    }
                },

                // ========================
                // DRAWING FUNCTIONALITY
                // ========================
                startDrawing(e) {
                    const rect = this.els.canvas.getBoundingClientRect();

                    this.state.startPos = {
                        x: (e.clientX - rect.left) / this.state.zoom,
                        y: (e.clientY - rect.top) / this.state.zoom
                    };
                    this.state.lastPos = { ...this.state.startPos };

                    // Save current state for undo before starting new stroke
                    this.saveToHistory();

                    this.state.isDrawing = true;

                    if (this.state.tool === 'pen' || this.state.tool === 'eraser') {
                        this.els.ctx.beginPath();
                        this.els.ctx.moveTo(this.state.lastPos.x, this.state.lastPos.y);
                    }

                    // For shape tools, save the image to restore during preview
                    if (['line', 'rect', 'circle'].includes(this.state.tool)) {
                        this.state.previewImageData = this.els.ctx.getImageData(0, 0, this.els.canvas.width, this.els.canvas.height);
                    }
                },

                draw(e) {
                    if (!this.state.isDrawing) return;

                    const rect = this.els.canvas.getBoundingClientRect();
                    const pos = {
                        x: (e.clientX - rect.left) / this.state.zoom,
                        y: (e.clientY - rect.top) / this.state.zoom
                    };

                    const ctx = this.els.ctx;

                    if (this.state.tool === 'pen') {
                        ctx.strokeStyle = this.getActiveColor();
                        ctx.lineWidth = this.state.thickness;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        // Smooth curve algorithm: Draw from previous mid to new mid
                        // using the previous point as control point
                        const midPoint = {
                            x: (this.state.lastPos.x + pos.x) / 2,
                            y: (this.state.lastPos.y + pos.y) / 2
                        };

                        ctx.quadraticCurveTo(this.state.lastPos.x, this.state.lastPos.y, midPoint.x, midPoint.y);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(midPoint.x, midPoint.y);
                        this.state.lastPos = pos;
                    } else if (this.state.tool === 'eraser') {
                        ctx.save();
                        ctx.globalCompositeOperation = 'destination-out';
                        ctx.strokeStyle = 'rgba(0,0,0,1)';
                        ctx.lineWidth = this.state.thickness * 8; // Larger eraser for better usability
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y);
                        ctx.restore();
                        this.state.lastPos = pos;
                    } else {
                        // Shapes: redraw preview
                        if (this.state.previewImageData) {
                            ctx.putImageData(this.state.previewImageData, 0, 0);
                        }
                        this.drawShape(this.state.startPos, pos);
                    }
                },

                stopDrawing(e) {
                    if (!this.state.isDrawing) return;

                    // Finish smooth curve for pen (connect last midpoint to actual end)
                    if (this.state.tool === 'pen') {
                        this.els.ctx.lineTo(this.state.lastPos.x, this.state.lastPos.y);
                        this.els.ctx.stroke();
                        this.els.ctx.closePath();
                    }

                    this.state.isDrawing = false;

                    // Finalize shape if drawing a shape
                    if (['line', 'rect', 'circle'].includes(this.state.tool) && e) {
                        const rect = this.els.canvas.getBoundingClientRect();
                        const pos = {
                            x: (e.clientX - rect.left) / this.state.zoom,
                            y: (e.clientY - rect.top) / this.state.zoom
                        };
                        // Clear the preview and draw final shape
                        if (this.state.previewImageData) {
                            this.els.ctx.putImageData(this.state.previewImageData, 0, 0);
                        }
                        this.drawShape(this.state.startPos, pos);
                        this.state.previewImageData = null;
                    }

                    // End any ongoing paths
                    this.els.ctx.beginPath();
                },

                drawShape(start, end) {
                    const ctx = this.els.ctx;
                    ctx.strokeStyle = this.getActiveColor();
                    ctx.lineWidth = this.state.thickness;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    ctx.beginPath();

                    if (this.state.tool === 'line') {
                        ctx.moveTo(start.x, start.y);
                        ctx.lineTo(end.x, end.y);
                    } else if (this.state.tool === 'rect') {
                        ctx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
                    } else if (this.state.tool === 'circle') {
                        const radius = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
                        ctx.arc(start.x, start.y, radius, 0, Math.PI * 2);
                    }

                    ctx.stroke();
                },

                saveToHistory() {
                    const imageData = this.els.ctx.getImageData(0, 0, this.els.canvas.width, this.els.canvas.height);
                    // Truncate history if we've undone and are adding new actions
                    if (this.state.historyIndex < this.state.history.length - 1) {
                        this.state.history = this.state.history.slice(0, this.state.historyIndex + 1);
                    }
                    this.state.history.push(imageData);
                    this.state.historyIndex = this.state.history.length - 1;
                    // Limit history to 30 steps
                    if (this.state.history.length > 30) {
                        this.state.history.shift();
                        this.state.historyIndex--;
                    }
                },

                undo() {
                    if (this.state.historyIndex < 0) {
                        App.ui.showToast('Nothing to undo', { duration: 1000 });
                        return;
                    }
                    if (this.state.historyIndex === 0) {
                        // Clear to initial state
                        this.els.ctx.clearRect(0, 0, this.els.canvas.width, this.els.canvas.height);
                        this.state.historyIndex = -1;

                        // Redraw background image if in annotation mode (and not using separate element)
                        if (this.state.isImageAnnotation && this.state.backgroundImage && this.state.bgImageData && !this.state.useSeparateBgImage) {
                            const bg = this.state.bgImageData;
                            this.els.ctx.drawImage(this.state.backgroundImage, bg.x, bg.y, bg.w, bg.h);
                        }
                    } else {
                        this.state.historyIndex--;
                        const imageData = this.state.history[this.state.historyIndex];
                        this.els.ctx.putImageData(imageData, 0, 0);
                    }
                },

                clear() {
                    this.state.history = [];
                    this.state.historyIndex = -1;
                    this.els.ctx.clearRect(0, 0, this.els.canvas.width, this.els.canvas.height);

                    // Redraw background image if in annotation mode (and not using separate element)
                    if (this.state.isImageAnnotation && this.state.backgroundImage && this.state.bgImageData && !this.state.useSeparateBgImage) {
                        const bg = this.state.bgImageData;
                        this.els.ctx.drawImage(this.state.backgroundImage, bg.x, bg.y, bg.w, bg.h);
                    }

                    // Also clear text boxes and connectors
                    this.state.textBoxes.forEach(tb => tb.element?.remove());
                    this.state.textBoxes = [];
                    if (this.state.imageBoxes) {
                        this.state.imageBoxes.forEach(ib => ib.element?.remove());
                        this.state.imageBoxes = [];
                    }
                    this.state.activeTextBox = null;
                    this.state.connectors = [];
                    if (this.els.connectorsSvg) this.els.connectorsSvg.innerHTML = '';
                },

                // Keyboard shortcuts removed per user request - users prefer clicking

                async addToArticle() {
                    const dpr = window.devicePixelRatio || 1;
                    const displayWidth = this.els.canvas.width / dpr;
                    const displayHeight = this.els.canvas.height / dpr;


                    // WYSIWYG EXPORT: Use html-to-image for perfect DOM snapshot
                    try {
                        // Hide all interactive elements before snapshot
                        const controlsToHide = this.els.container.querySelectorAll('.wb-text-controls, .wb-text-resize, .wb-connector-dot, .wb-img-box-controls, .wb-img-box-resize, .wb-tape-box-controls, .wb-tape-box-resize');
                        controlsToHide.forEach(el => {
                            el.style.display = 'none';
                        });

                        // Also hide any active selection/focus states
                        document.querySelectorAll('.wb-text-box.selected, .wb-img-box.selected, .wb-tape-box.selected').forEach(el => {
                            el.classList.remove('selected');
                        });


                        const bgImg = document.getElementById('whiteboard-bg-image');
                        const bgImgParent = bgImg ? bgImg.parentNode : null;
                        const bgImgNextSibling = bgImg ? bgImg.nextSibling : null;

                        // Only remove background image if we are NOT using it as the main content (Stage Mode)
                        const shouldRemoveBg = bgImg && !this.state.useSeparateBgImage;
                        if (shouldRemoveBg) {
                            bgImg.remove();
                        }

                        const exportOptions = {
                            quality: 1.0,
                            pixelRatio: 2, // 2x for crisp export
                            backgroundColor: null, // Preserve transparency
                            cacheBust: true, // REVERTED: Match v8.176 behavior
                            skipAutoScale: true
                        };

                        // Generate PNG from actual DOM
                        let dataUrl = await htmlToImage.toPng(this.els.container, exportOptions);

                        const activeOcclusions = (this.state.tapeBoxes || []).filter(tb => !tb.revealed);
                        const isVisualFlashcard = activeOcclusions.length > 0;

                        let dataUrlBack = null;

                        if (isVisualFlashcard) {
                            dataUrlBack = dataUrl;

                            this.state.tapeBoxes.forEach(tb => {
                                if (tb.element && !tb.revealed) {
                                    tb.element.style.display = 'block';
                                    tb.element.style.opacity = '1';
                                }
                            });

                            // Capture FRONT image (with tape)
                            const dataUrlFront = await htmlToImage.toPng(this.els.container, exportOptions);

                            // Swap: front becomes main dataUrl
                            const temp = dataUrl;
                            dataUrl = dataUrlFront;
                        }

                        // Restore background image
                        if (shouldRemoveBg && bgImg && bgImgParent) {
                            bgImgParent.insertBefore(bgImg, bgImgNextSibling);
                        }

                        // Restore visibility of controls
                        controlsToHide.forEach(el => {
                            el.style.display = '';
                        });

                        // === NON-DESTRUCTIVE EMBED: Serialize and store state ===
                        const whiteboardState = this.serializeState();
                        const stateBase64 = btoa(unescape(encodeURIComponent(JSON.stringify(whiteboardState))));

                        const blockId = this.state.editingBlockId || `wb-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                        const scriptId = `wbs-${blockId}`;

                        const maxDisplayWidth = Math.min(displayWidth, 700);

                        const dataVaultHTML = `<div id="${scriptId}" class="wb-data-vault" style="display:none;" data-role="wb-vault">${stateBase64}</div>`;

                        let html;
                        if (isVisualFlashcard) {
                            const editIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.85 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg>`;
                            html = `<div class="nk-visual-flashcard wb-embed" contenteditable="false" data-wb-id="${blockId}" data-wb-state-id="${scriptId}" style="max-width:${maxDisplayWidth}px;">
                                <div class="nk-vfc-inner">
                                    <div class="nk-vfc-front">
                                        <img src="${dataUrl}" alt="Visual Flashcard (Front)" data-original-width="${displayWidth}" data-original-height="${displayHeight}">
                                        <button class="nk-vfc-edit-btn" title="Edit in Whiteboard">${editIcon}</button>
                                    </div>
                                    <div class="nk-vfc-back">
                                        <img src="${dataUrlBack}" alt="Visual Flashcard (Back)" data-original-width="${displayWidth}" data-original-height="${displayHeight}">
                                    </div>
                                </div>
                                <div class="resize-handle resize-handle-se"></div>
                                ${dataVaultHTML}
                            </div>`;
                        } else {
                            // Standard Whiteboard HTML
                            html = `<div class="image-container wb-embed" contenteditable="false" data-wb-id="${blockId}" data-wb-state-id="${scriptId}"><img src="${dataUrl}" alt="Whiteboard sketch" data-original-width="${displayWidth}" data-original-height="${displayHeight}" style="width:${maxDisplayWidth}px; height:auto; border-radius: 16px; box-shadow: 0 4px 16px rgba(0,0,0,0.12);"><div class="resize-handle resize-handle-se"></div>${dataVaultHTML}</div>`;
                        }

                        // Check if we're in stage mode (whiteboard opened from presentation)
                        const stageArticleId = this.state.stageModeSrcArticleId;

                        // Check if we're in Read Mode (whiteboard opened from read mode toolbar)
                        const isReadMode = App.state.currentMode === 'read';
                        const currentArticleId = App.state.currentArticleId;

                        // CASE 1: STAGE MODE (Save directly to DB)
                        // Only for Stage Mode where editor is not context
                        if (stageArticleId) {
                            const targetId = stageArticleId || currentArticleId;
                            try {
                                const article = App.storage.getArticle(targetId);
                                if (article) {
                                    // Append the whiteboard HTML to the article content
                                    const newContent = (article.content || '') + `<p>${html}</p><p><br></p>`;
                                    await App.storage.updateArticle(targetId, {
                                        content: newContent,
                                        updatedAt: new Date().toISOString()
                                    });

                                    this.close();
                                    this.state.stageModeSrcArticleId = null; // Reset
                                    App.ui.showToast(' Sketch added to article!', { type: 'success' });

                                    // If in Read Mode, we might want to reload the article to show the change
                                    if (isReadMode) {
                                        // Optional: trigger reload if the app supports it, or just let the toast confirm
                                        // App.events.loadArticle(targetId); // Be careful not to reset scroll
                                    }
                                    return;
                                } else {
                                    App.ui.showToast('Article not found', { type: 'error' });
                                    return;
                                }
                            } catch (dbErr) {
                                console.error('Failed to save whiteboard to article:', dbErr);
                                App.ui.showToast('Failed to save to article: ' + dbErr.message, { type: 'error' });
                                return;
                            }
                        }

                        // CASE 2: WRITE MODE (Insert into visible Editor DOM)
                        // Try to insert into visible article-content
                        let contentDiv = document.getElementById('article-content');

                        if (!contentDiv) {
                            App.ui.showToast('No article open', { type: 'error' });
                            return;
                        }

                        // Check if we're UPDATING an existing embed (re-edit mode)
                        let wasUpdated = false;
                        if (this.state.editingBlockId) {
                            const existingEmbed = contentDiv.querySelector(`.wb-embed[data-wb-id="${this.state.editingBlockId}"]`);
                            if (existingEmbed) {
                                const isExistingFlashcard = existingEmbed.classList.contains('nk-visual-flashcard');

                                // If structure changed (normal <-> flashcard), replace entire embed
                                if (isVisualFlashcard !== isExistingFlashcard) {
                                    existingEmbed.outerHTML = html;
                                    console.log('Whiteboard type changed, replaced entire embed');
                                } else if (isVisualFlashcard) {
                                    const frontImg = existingEmbed.querySelector('.nk-vfc-front img');
                                    const backImg = existingEmbed.querySelector('.nk-vfc-back img');
                                    if (backImg) backImg.src = dataUrlBack;
                                    console.log('Visual Flashcard updated with front/back images');
                                } else {
                                    const existingImg = existingEmbed.querySelector('img');
                                    if (existingImg) {
                                        existingImg.src = dataUrl;
                                        existingImg.setAttribute('data-original-width', displayWidth);
                                        existingImg.setAttribute('data-original-height', displayHeight);
                                    }
                                }

                                // 4. Update the Data Storage
                                const scriptId = `wbs-${this.state.editingBlockId}`;
                                let scriptTag = document.getElementById(scriptId);

                                if (!scriptTag) {
                                    // Create new data vault if it doesn't exist (inside the container)
                                    scriptTag = document.createElement('div');
                                    scriptTag.id = scriptId;
                                    scriptTag.className = 'wb-data-vault';
                                    scriptTag.style.display = 'none';
                                    scriptTag.dataset.role = 'wb-vault';
                                    existingEmbed.appendChild(scriptTag); // CHANGED: append inside, not after
                                    existingEmbed.setAttribute('data-wb-state-id', scriptId);
                                }
                                // Update content
                                scriptTag.textContent = stateBase64;

                                console.log('Whiteboard updated (robust storage):', {
                                    blockId: this.state.editingBlockId,
                                    scriptId
                                });

                                wasUpdated = true;
                                this.state.editingBlockId = null;
                            } else {
                                // Fallback in case existingEmbed not found despite ID
                                contentDiv.insertAdjacentHTML('beforeend', `<p>${html}</p><p><br></p>`);
                            }
                        } else if (this.state.isImageAnnotation && this.state.sourceImageContainer) {
                            // INSERT annotated image AFTER the original (preserve original)
                            const oldContainer = this.state.sourceImageContainer;
                            if (contentDiv.contains(oldContainer)) {
                                // Find the parent paragraph or container to insert after
                                let insertAfter = oldContainer;
                                if (oldContainer.parentElement && oldContainer.parentElement.tagName === 'P') {
                                    insertAfter = oldContainer.parentElement;
                                }
                                insertAfter.insertAdjacentHTML('afterend', `<p>${html}</p><p><br></p>`);
                                App.ui.showToast(' Annotated image added!', { type: 'success' });
                            } else {
                                // Fallback if container was removed/lost
                                contentDiv.insertAdjacentHTML('beforeend', `<p>${html}</p><p><br></p>`);
                            }
                        } else if (this.state.insertMode === 'cursor' && App.state.currentMode === 'write') {
                            const selection = window.getSelection();
                            if (selection.rangeCount > 0 && contentDiv.contains(selection.anchorNode)) {
                                document.execCommand('insertHTML', false, `<p>${html}</p><p><br></p>`);
                            } else {
                                contentDiv.insertAdjacentHTML('beforeend', `<p>${html}</p><p><br></p>`);
                            }
                        } else {
                            contentDiv.insertAdjacentHTML('beforeend', `<p>${html}</p><p><br></p>`);
                        }
                        // Mark dirty BEFORE save
                        App.state.isArticleDirty = true;

                        // IMPORTANT: Force a single save immediately to persist the change
                        App.events.saveArticle({ isAutosave: false }).then(() => {
                            console.log("Whiteboard image saved to article.");
                        });


                        this.close();

                        // Show appropriate toast (avoid duplicate for update case)
                        if (wasUpdated) {
                            App.ui.showToast(isVisualFlashcard ? ' Visual Flashcard updated!' : ' Whiteboard updated!', { type: 'success' });
                        } else if (!this.state.isImageAnnotation) {
                            App.ui.showToast(isVisualFlashcard ? ' Visual Flashcard added!' : ' Sketch added to article!', { type: 'success' });
                        }
                    } catch (error) {
                        console.error('Error exporting whiteboard:', error);
                        App.ui.showToast(' Failed to export: ' + (error.message || 'Unknown error'), { type: 'error' });

                        // RESTORE UI ON ERROR (Critical for usability if export fails)

                        // 1. Restore Background Image if it was removed
                        if (this.els.bgImage && !this.els.bgImage.parentNode && this.els.canvas && this.els.canvas.parentNode) {
                            this.els.canvas.parentNode.insertBefore(this.els.bgImage, this.els.canvas);
                        }

                        // 2. Restore Controls Visibility
                        const controls = this.els.container.querySelectorAll('.wb-text-controls, .wb-text-resize, .wb-connector-dot, .wb-img-box-controls, .wb-img-box-resize, .wb-tape-box-controls, .wb-tape-box-resize');
                        controls.forEach(el => el.style.display = '');

                    }
                },

                // Reopen whiteboard from an existing wb-embed container
                reopenFromEmbed(embedContainer) {
                    if (!embedContainer || !embedContainer.classList.contains('wb-embed')) {
                        App.ui.showToast('This image is not an editable whiteboard', { type: 'info' });
                        return;
                    }

                    // Debug: Log container info
                    console.log('Reopening whiteboard from embed:', {
                        hasWbState: !!embedContainer.dataset.wbState,
                        wbId: embedContainer.dataset.wbId,
                        stateLength: embedContainer.dataset.wbState?.length || 0,
                        rawAttribute: embedContainer.getAttribute('data-wb-state')?.length || 0
                    });

                    // 1. Load from Robust Storage (Script Tag)
                    let stateBase64 = null;
                    const linkedScriptId = embedContainer.dataset.wbStateId;

                    if (linkedScriptId) {
                        const scriptTag = document.getElementById(linkedScriptId);
                        if (scriptTag) {
                            stateBase64 = scriptTag.textContent;
                            console.log('Restoring from Robust Data Vault:', linkedScriptId);
                        }
                    }

                    if (!stateBase64) {
                        console.error('No linked script storage found for whiteboard:', embedContainer);
                        App.ui.showToast('No whiteboard data found', { type: 'error' });
                        return;
                    }

                    try {
                        // Decode the base64 state
                        const stateJson = decodeURIComponent(escape(atob(stateBase64)));
                        const savedState = JSON.parse(stateJson);

                        // Generate a unique ID for this embed if not present
                        let embedId = embedContainer.dataset.wbId;
                        if (!embedId) {
                            embedId = 'wb-' + Date.now();
                            embedContainer.dataset.wbId = embedId;
                        }

                        // Open whiteboard in edit mode
                        this.state.insertMode = 'cursor';
                        this.state.isOpen = true;
                        this.state.editingBlockId = embedId; // Track which embed we're editing
                        this.state.pan = { x: 0, y: 0 };
                        this.state.textBoxes = [];
                        this.state.imageBoxes = [];
                        this.state.tapeBoxes = [];
                        this.state.tapeIdCounter = 0;
                        this.state.activeTextBox = null;
                        this.state.connectors = [];
                        this.state.isConnecting = false;
                        this.state.connectFromId = null;
                        this.state.connectFromColor = null;
                        this.state.isImageAnnotation = false;
                        this.state.sourceImageContainer = null;
                        this.state.backgroundImage = null;
                        this.state.bgImageData = null;

                        // Restore background style
                        this.state.backgroundStyle = savedState.backgroundStyle || 0;

                        // Apply background visual
                        if (this.els.container) {
                            const bgColors = { 0: 'transparent', 1: '#ffffff', 2: '#1a1a2e', 3: '#fafafa' };
                            this.els.container.style.background = bgColors[this.state.backgroundStyle] || 'transparent';
                            if (this.state.backgroundStyle === 3) {
                                this.els.container.style.backgroundImage =
                                    'linear-gradient(rgba(0,0,0,0.06) 1px, transparent 1px), ' +
                                    'linear-gradient(90deg, rgba(0,0,0,0.06) 1px, transparent 1px)';
                                this.els.container.style.backgroundSize = '20px 20px';
                            } else {
                                this.els.container.style.backgroundImage = 'none';
                            }
                            if (this.state.backgroundStyle === 2) {
                                this.els.container.classList.add('wb-theme-dark');
                            } else {
                                this.els.container.classList.remove('wb-theme-dark');
                            }
                        }

                        this.els.overlay.classList.add('active');
                        this.els.overlay.focus();
                        document.body.style.overflow = 'hidden';

                        // Resize canvas and restore drawing content
                        this.resizeCanvas();

                        // Restore canvas drawing from saved data
                        if (savedState.canvasData) {
                            const img = new Image();
                            img.onload = () => {
                                const dpr = window.devicePixelRatio || 1;
                                this.els.ctx.setTransform(1, 0, 0, 1, 0, 0);
                                this.els.ctx.clearRect(0, 0, this.els.canvas.width, this.els.canvas.height);
                                this.els.ctx.scale(dpr, dpr);
                                // Draw restored image scaled to current canvas
                                this.els.ctx.drawImage(img, 0, 0, this.els.canvas.width / dpr, this.els.canvas.height / dpr);
                            };
                            img.src = savedState.canvasData;
                        }

                        // Restore image boxes
                        if (savedState.imageBoxes && savedState.imageBoxes.length > 0) {
                            if (!this.state.imageBoxes) this.state.imageBoxes = [];
                            savedState.imageBoxes.forEach(ibData => {
                                this.addImageBox(ibData.x, ibData.y, ibData.src, ibData.w, ibData.h);
                            });
                        }

                        // Restore text boxes
                        if (savedState.textBoxes && savedState.textBoxes.length > 0) {
                            savedState.textBoxes.forEach(tbData => {
                                const tb = this.addTextBox(tbData.x, tbData.y, tbData.color || this.getActiveColor());
                                const content = tb.element.querySelector('.wb-text-content');
                                if (content && tbData.text) {
                                    content.textContent = tbData.text;
                                }
                                if (tbData.fontSize) {
                                    tb.fontSize = tbData.fontSize;
                                    content.style.fontSize = tbData.fontSize + 'px';
                                }
                                if (tbData.fontFamilyIndex !== undefined) {
                                    tb.fontFamilyIndex = tbData.fontFamilyIndex;
                                    const font = this.fontFamilies[tbData.fontFamilyIndex];
                                    if (font) content.style.fontFamily = font.value;
                                }
                                if (tbData.boxStyleIndex !== undefined) {
                                    tb.boxStyleIndex = tbData.boxStyleIndex;
                                    const styles = ['default', 'filled', 'glass', 'minimal'];
                                    tb.element.setAttribute('data-box-style', styles[tbData.boxStyleIndex] || 'default');
                                    this.updateTextBoxVisuals(tb);
                                }
                                if (tbData.width) tb.element.style.width = tbData.width + 'px';
                                if (tbData.height) tb.element.style.minHeight = tbData.height + 'px';

                                // Map old ID to new ID for connector restoration
                                tbData._newId = tb.id;
                            });
                        }

                        // Restore connectors (map old IDs to new IDs)
                        if (savedState.connectors && savedState.connectors.length > 0 && savedState.textBoxes) {
                            const idMap = {};
                            savedState.textBoxes.forEach((tb, idx) => {
                                if (this.state.textBoxes[idx]) {
                                    idMap[tb.id] = this.state.textBoxes[idx].id;
                                }
                            });

                            savedState.connectors.forEach(conn => {
                                const newFrom = idMap[conn.from];
                                const newTo = idMap[conn.to];
                                if (newFrom && newTo) {
                                    this.state.connectors.push({
                                        from: newFrom,
                                        to: newTo,
                                        color: conn.color
                                    });
                                }
                            });
                            this.drawConnectors();
                        }

                        // Set default tool
                        this.setTool(savedState.tool || 'pen');
                        if (savedState.color) this.state.color = savedState.color;
                        if (savedState.thickness) this.state.thickness = savedState.thickness;

                        // Clear history for fresh start
                        this.state.history = [];
                        this.state.historyIndex = -1;

                        App.ui.showToast(' Whiteboard reopened for editing', { type: 'success' });

                    } catch (err) {
                        console.error('Failed to restore whiteboard state:', err);
                        App.ui.showToast('Failed to restore whiteboard', { type: 'error' });
                    }
                },

                // Serialize current whiteboard state for storage
                serializeState() {
                    const dpr = window.devicePixelRatio || 1;
                    return {
                        version: 1,
                        canvasData: this.els.canvas.toDataURL('image/png', 0.8),
                        canvasWidth: this.els.canvas.width,
                        canvasHeight: this.els.canvas.height,
                        dpr: dpr,
                        backgroundStyle: this.state.backgroundStyle,
                        textBoxes: this.state.textBoxes.map(tb => ({
                            id: tb.id,
                            x: tb.x,
                            y: tb.y,
                            color: tb.color,
                            fontSize: tb.fontSize,
                            fontFamilyIndex: tb.fontFamilyIndex || 0,
                            boxStyleIndex: tb.boxStyleIndex || 0,
                            text: tb.element?.querySelector('.wb-text-content')?.textContent || '',
                            width: tb.element?.offsetWidth || 200,
                            height: tb.element?.offsetHeight || 100
                        })),
                        imageBoxes: (this.state.imageBoxes || []).map(ib => ({
                            id: ib.id,
                            x: ib.x,
                            y: ib.y,
                            w: ib.w,
                            h: ib.h,
                            src: ib.src
                        })),
                        connectors: this.state.connectors.map(c => ({
                            from: c.from,
                            to: c.to,
                            color: c.color
                        })),
                        tapeBoxes: (this.state.tapeBoxes || []).map(tb => ({
                            id: tb.id,
                            x: tb.x,
                            y: tb.y,
                            w: tb.w,
                            h: tb.h,
                            revealed: tb.revealed || false
                        })),
                        tool: this.state.tool,
                        color: this.state.color,
                        thickness: this.state.thickness
                    };
                },

                // Generate a thumbnail preview of the whiteboard
                generateThumbnail() {
                    const dpr = window.devicePixelRatio || 1;
                    const displayWidth = this.els.canvas.width / dpr;
                    const displayHeight = this.els.canvas.height / dpr;

                    // Create thumbnail canvas at smaller size
                    const thumbCanvas = document.createElement('canvas');
                    const thumbWidth = Math.min(displayWidth, 600);
                    const scale = thumbWidth / displayWidth;
                    thumbCanvas.width = thumbWidth;
                    thumbCanvas.height = displayHeight * scale;
                    const thumbCtx = thumbCanvas.getContext('2d');

                    // Fill with theme background
                    const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--bg-primary').trim() || '#ffffff';
                    thumbCtx.fillStyle = bgColor;
                    thumbCtx.fillRect(0, 0, thumbCanvas.width, thumbCanvas.height);

                    // Scale and draw canvas content
                    thumbCtx.scale(scale, scale);
                    thumbCtx.drawImage(this.els.canvas, 0, 0, displayWidth, displayHeight);

                    // Draw connectors
                    thumbCtx.lineWidth = 2.5;
                    thumbCtx.lineCap = 'round';
                    const defaultLineColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#6366f1';
                    this.state.connectors.forEach(conn => {
                        const fromBox = this.state.textBoxes.find(t => t.id === conn.from);
                        const toBox = this.state.textBoxes.find(t => t.id === conn.to);
                        if (!fromBox || !toBox) return;

                        const fromCx = fromBox.x + fromBox.element.offsetWidth / 2;
                        const fromCy = fromBox.y + fromBox.element.offsetHeight / 2;
                        const toCx = toBox.x + toBox.element.offsetWidth / 2;
                        const toCy = toBox.y + toBox.element.offsetHeight / 2;

                        const fromEdge = this.getEdgePoint(fromBox, toCx, toCy);
                        const toEdge = this.getEdgePoint(toBox, fromCx, fromCy);

                        const dx = toEdge.x - fromEdge.x;
                        const dy = toEdge.y - fromEdge.y;
                        const isMoreHorizontal = Math.abs(dx) > Math.abs(dy);

                        let cp1x, cp1y, cp2x, cp2y;
                        if (isMoreHorizontal) {
                            cp1x = fromEdge.x + dx * 0.25; cp1y = fromEdge.y;
                            cp2x = fromEdge.x + dx * 0.75; cp2y = toEdge.y;
                        } else {
                            cp1x = fromEdge.x; cp1y = fromEdge.y + dy * 0.25;
                            cp2x = toEdge.x; cp2y = fromEdge.y + dy * 0.75;
                        }

                        thumbCtx.strokeStyle = conn.color || defaultLineColor;
                        thumbCtx.beginPath();
                        thumbCtx.moveTo(fromEdge.x, fromEdge.y);
                        thumbCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, toEdge.x, toEdge.y);
                        thumbCtx.stroke();
                    });

                    // 3.5 Render Image Boxes (draw to canvas)
                    if (this.state.imageBoxes) {
                        this.state.imageBoxes.forEach(ib => {
                            const imgEl = ib.element.querySelector('img');
                            if (imgEl) {
                                thumbCtx.drawImage(imgEl, ib.x, ib.y, ib.w, ib.h);
                            }
                        });
                    }

                    // Draw text boxes
                    this.state.textBoxes.forEach(tb => {
                        const content = tb.element?.querySelector('.wb-text-content');
                        const text = content?.textContent || '';
                        const x = tb.x;
                        const y = tb.y;
                        const w = tb.element?.offsetWidth || 200;
                        const h = tb.element?.offsetHeight || 100;

                        thumbCtx.strokeStyle = tb.color;
                        thumbCtx.lineWidth = 2;
                        this.roundRect(thumbCtx, x, y, w, h, 8);
                        thumbCtx.stroke();

                        if (text.trim()) {
                            thumbCtx.font = `${tb.fontSize || 16}px ${content?.style.fontFamily || 'sans-serif'} `;
                            thumbCtx.fillStyle = tb.color;
                            thumbCtx.textBaseline = 'middle';
                            thumbCtx.textAlign = 'center';
                            thumbCtx.fillText(text, x + w / 2, y + h / 2);
                        }
                    });

                    // Render Tape Boxes for thumbnail
                    if (this.state.tapeBoxes) {
                        this.state.tapeBoxes.forEach(tb => {
                            if (tb.revealed) return;

                            const x = tb.x;
                            const y = tb.y;
                            const w = tb.w;
                            const h = tb.h;
                            const chamfer = 8;

                            thumbCtx.save();
                            thumbCtx.beginPath();
                            thumbCtx.moveTo(x + chamfer, y);
                            thumbCtx.lineTo(x + w - chamfer, y);
                            thumbCtx.lineTo(x + w, y + chamfer);
                            thumbCtx.lineTo(x + w, y + h - chamfer);
                            thumbCtx.lineTo(x + w - chamfer, y + h);
                            thumbCtx.lineTo(x + chamfer, y + h);
                            thumbCtx.lineTo(x, y + h - chamfer);
                            thumbCtx.lineTo(x, y + chamfer);
                            thumbCtx.closePath();
                            thumbCtx.fillStyle = '#fbbf24';
                            thumbCtx.fill();
                            thumbCtx.restore();
                        });
                    }

                    return thumbCanvas.toDataURL('image/png', 0.7);
                },

                // Restore whiteboard state from saved data
                deserializeState(data) {
                    if (!data || data.version !== 1) return;

                    // Clear current state
                    this.state.textBoxes.forEach(tb => tb.element?.remove());
                    this.state.textBoxes = [];
                    // Clear tape boxes
                    (this.state.tapeBoxes || []).forEach(tb => tb.element?.remove());
                    this.state.tapeBoxes = [];
                    this.state.connectors = [];
                    if (this.els.connectorsSvg) this.els.connectorsSvg.innerHTML = '';

                    // Restore canvas
                    const img = new Image();
                    img.onload = () => {
                        this.els.ctx.clearRect(0, 0, this.els.canvas.width, this.els.canvas.height);
                        this.els.ctx.drawImage(img, 0, 0);
                    };
                    img.src = data.canvasData;

                    // Restore text boxes
                    data.textBoxes.forEach(tb => {
                        const box = this.createTextBoxFromData(tb);
                        this.state.textBoxes.push(box);
                    });

                    // Restore connectors
                    this.state.connectors = data.connectors.map(c => ({
                        from: c.from,
                        to: c.to,
                        color: c.color
                    }));

                    // Restore tape boxes (Visual Flashcard occlusions)
                    if (data.tapeBoxes && data.tapeBoxes.length > 0) {
                        data.tapeBoxes.forEach(tb => {
                            const tapeData = this.addTapeBox(tb.x, tb.y, tb.w, tb.h);
                            // Restore revealed state
                            if (tb.revealed) {
                                tapeData.revealed = true;
                                tapeData.element.classList.add('revealed');
                            }
                        });
                        // Update tape ID counter
                        const maxId = Math.max(...data.tapeBoxes.map(t => t.id || 0));
                        if (maxId >= this.state.tapeIdCounter) {
                            this.state.tapeIdCounter = maxId + 1;
                        }
                    }

                    // Restore tool settings
                    if (data.tool) this.setTool(data.tool);
                    if (data.color) this.setColor(data.color);
                    if (data.thickness) this.state.thickness = data.thickness;

                    // Redraw connectors
                    setTimeout(() => this.drawConnectors(), 100);
                },

                // Create a text box from saved data
                createTextBoxFromData(data) {
                    const box = document.createElement('div');
                    box.className = 'wb-text-box';
                    box.style.cssText = `left: ${data.x} px; top: ${data.y} px; width: ${data.width} px; min - height: ${data.height} px; `;
                    box.dataset.id = data.id;

                    box.innerHTML = `
                                < div class="wb-text-controls" >
                            <button class="wb-text-font-btn" title="Change Font">Aa</button>
                            <button class="wb-text-size-btn" title="Increase Font Size">A+</button>
                            <button class="wb-text-delete-btn" title="Delete">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </button>
                        </div >
                        <div class="wb-text-content" contenteditable="true" style="font-size: ${data.fontSize || 16}px; font-family: ${data.fontFamily || 'var(--font-body)'}; color: ${data.color || 'var(--text-primary)'}">${data.text || ''}</div>
                        <div class="wb-text-resize"></div>
                        <div class="wb-connector-dot" title="Click to connect"></div>
        `;

                    box.style.borderColor = data.color;
                    this.els.container.appendChild(box);

                    const tb = {
                        id: data.id,
                        element: box,
                        x: data.x,
                        y: data.y,
                        color: data.color,
                        fontSize: data.fontSize,
                        fontFamily: data.fontFamily
                    };

                    this.setupTextBoxInteractions(tb);

                    // Update text box ID counter
                    const idNum = parseInt(data.id.replace('tb-', ''));
                    if (idNum >= this.state.textBoxIdCounter) {
                        this.state.textBoxIdCounter = idNum + 1;
                    }

                    return tb;
                },

                // Helper to draw rounded rectangles on canvas
                roundRect(ctx, x, y, width, height, radius) {
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x + width - radius, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                    ctx.lineTo(x + width, y + height - radius);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    ctx.lineTo(x + radius, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                    ctx.lineTo(x, y + radius);
                    ctx.quadraticCurveTo(x, y, x + radius, y);
                    ctx.closePath();
                },

                // Helper to wrap text for canvas rendering
                wrapText(ctx, text, maxWidth) {
                    const words = text.split(/\s+/);
                    const lines = [];
                    let currentLine = '';

                    words.forEach(word => {
                        const testLine = currentLine ? currentLine + ' ' + word : word;
                        const metrics = ctx.measureText(testLine);
                        if (metrics.width > maxWidth && currentLine) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            currentLine = testLine;
                        }
                    });

                    if (currentLine) {
                        lines.push(currentLine);
                    }

                    return lines.length ? lines : [text];
                },

                // Helper to convert any CSS color to rgba with custom alpha
                colorToRgba(color, alpha) {
                    if (!color) return `rgba(99, 102, 241, ${alpha})`; // Default indigo

                    // Already rgba - extract values and replace alpha
                    if (color.startsWith('rgba')) {
                        const match = color.match(/[\d.]+/g);
                        if (match && match.length >= 3) {
                            return `rgba(${match[0]}, ${match[1]}, ${match[2]}, ${alpha})`;
                        }
                    }

                    // rgb - extract values and add alpha
                    if (color.startsWith('rgb')) {
                        const match = color.match(/[\d.]+/g);
                        if (match && match.length >= 3) {
                            return `rgba(${match[0]}, ${match[1]}, ${match[2]}, ${alpha})`;
                        }
                    }

                    // Hex color
                    if (color.startsWith('#')) {
                        let hex = color.slice(1);
                        // Handle shorthand hex (#RGB -> #RRGGBB)
                        if (hex.length === 3) {
                            hex = hex.split('').map(c => c + c).join('');
                        }
                        const r = parseInt(hex.substr(0, 2), 16);
                        const g = parseInt(hex.substr(2, 2), 16);
                        const b = parseInt(hex.substr(4, 2), 16);
                        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    }

                    // Fallback - return as-is with hope it works
                    return color;
                }
            },


            // ==========================================================================
            // 3.21. PDF MODULE (NEW - STABLE IMPLEMENTATION)
            // ==========================================================================

            annotationEngine: {
                state: {
                    context: null,
                    isActive: false,
                    isDrawing: false,
                    tool: 'rect',
                    colors: ['#ef4444', '#f97316', '#f0b70c', '#00ff00', '#22c55e', '#06b6d4', '#0000ff', '#8b5cf6', '#ff00ff', '#8b4513', '#64748b', '#7fffd4'],
                    thicknesses: [1, 2, 3, 5, 6, 8, 10, 12, 15, 22],
                    colorIndex: 0,
                    thicknessIndex: 0,
                    lastPos: { x: 0, y: 0 },
                    currentPath: null,
                },

                init() {
                    this.state = { ...this.state, context: null, isActive: false, isDrawing: false, tool: 'rect', currentPath: null };
                },

                getCanvasAndContext() {
                    const canvas = (this.state.context === 'pdf')
                        ? document.getElementById('annotation-layer')
                        : document.getElementById('annotation-canvas');
                    return { canvas, ctx: canvas ? canvas.getContext('2d') : null };
                },


                toggle(context) {
                    if (this.state.isActive && this.state.context !== context) {
                        this.toggle(this.state.context);
                    }

                    this.state.context = context;
                    this.state.isActive = !this.state.isActive;
                    const isPdf = context === 'pdf';

                    const container = isPdf ? document.getElementById('pdf-viewer-container') : document.querySelector('.focus-mode-overlay');
                    const toolbar = isPdf ? document.getElementById('pdf-annotation-toolbar') : document.getElementById('annotation-toolbar');
                    const toggleBtn = isPdf ? document.getElementById('pdf-annotate-toggle') : container?.querySelector('.annotation-btn');
                    const { canvas } = this.getCanvasAndContext();

                    if (!canvas || !container || !toolbar || !toggleBtn) {
                        this.init();
                        return;
                    }

                    container.classList.toggle('annotation-active', this.state.isActive);
                    toggleBtn.classList.toggle('active', this.state.isActive);
                    toolbar.style.display = this.state.isActive ? 'flex' : 'none';
                    if (isPdf) toolbar.classList.toggle('hidden', !this.state.isActive);

                    const newCanvas = canvas.cloneNode(true);
                    canvas.parentNode.replaceChild(newCanvas, canvas);

                    if (this.state.isActive) {
                        if (context === 'focus') {
                            const bodyEl = container.querySelector('.focus-mode-body');
                            newCanvas.width = bodyEl.scrollWidth;
                            newCanvas.height = bodyEl.scrollHeight;
                            this.redrawPageAnnotations();
                        } else if (context === 'pdf') {
                            this.redrawPageAnnotations(App.pdf.state.pageNum);
                        }

                        this.updateToolbarUI();
                        newCanvas.addEventListener('mousedown', this.startDrawing.bind(this));
                        newCanvas.addEventListener('mousemove', this.draw.bind(this));
                        newCanvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                        newCanvas.addEventListener('mouseleave', this.stopDrawing.bind(this));
                        newCanvas.addEventListener('touchstart', (e) => this.startDrawing(e.touches[0]), { passive: false });
                        newCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); this.draw(e.touches[0]); }, { passive: false });
                        newCanvas.addEventListener('touchend', (e) => this.stopDrawing(e.changedTouches[0]));
                    } else {
                        // NEW: Save logic for Stage Mode annotations.
                        if (context === 'focus') {
                            const session = App.state.focusSession;
                            const article = session.articles[session.currentIndex];
                            if (article) {
                                // NEW: Skip saving if in Sigma Article Mode (Temporary annotations)
                                if (session.sigmaMode === 'article') {
                                    // Do not persist to disk.
                                    App.ui.showToast('Sigma Note annotations are temporary.', { type: 'info' });
                                } else {
                                    const articleInState = App.storage.getArticle(article.id);
                                    if (articleInState) {
                                        const currentAnnotationsJSON = JSON.stringify(articleInState.stageAnnotations || {});
                                        const newAnnotationsJSON = JSON.stringify(session.annotations);

                                        if (currentAnnotationsJSON !== newAnnotationsJSON) {
                                            App.storage.updateArticle(article.id, { stageAnnotations: session.annotations });
                                            App.ui.showToast('Stage annotations saved!', { type: 'success' });
                                        }
                                    }
                                }
                            }
                        }
                        this.state.isActive = false;
                        this.state.isDrawing = false;
                        this.state.currentPath = null;
                    }
                },

                updateToolbarUI() {
                    const isPDF = this.state.context === 'pdf';
                    const toolPrefix = isPDF ? 'pdf-tool-' : 'focus-tool-';
                    const colorCyclerId = isPDF ? 'pdf-color-cycler' : 'focus-color-cycler';
                    const thicknessBtnId = isPDF ? 'pdf-thickness-cycler' : 'focus-thickness-cycler';

                    ['pen', 'rect', 'eraser'].forEach(t => {
                        const btn = document.getElementById(`${toolPrefix}${t}`); // FIX: Removed extra space
                        if (btn) btn.classList.toggle('active', this.state.tool === t);
                    });
                    const colorCyclerBtn = document.getElementById(colorCyclerId);
                    if (colorCyclerBtn) {
                        colorCyclerBtn.innerHTML = '<div class="color-cycler-inner"></div>';
                        const inner = colorCyclerBtn.querySelector('.color-cycler-inner');
                        if (inner) {
                            inner.style.backgroundColor = this.state.colors[this.state.colorIndex];
                            const isDark = ['#212529'].includes(this.state.colors[this.state.colorIndex]);
                            inner.style.border = isDark ? '2px solid var(--border-color)' : 'none';
                        }
                    }
                    const thicknessBtn = document.getElementById(thicknessBtnId);
                    if (thicknessBtn) {
                        const r = this.state.thicknesses[this.state.thicknessIndex];
                        const circle = thicknessBtn.querySelector('svg circle');
                        if (circle) circle.setAttribute('r', r * 0.5 + 1);
                    }
                },

                cycleColor() {
                    this.state.colorIndex = (this.state.colorIndex + 1) % this.state.colors.length;
                    this.updateToolbarUI();
                    App.ui.showToast(`Color changed`, { duration: 1500 });
                },
                setTool(tool) { this.state.tool = tool; this.updateToolbarUI(); },
                cycleThickness() {
                    this.state.thicknessIndex = (this.state.thicknessIndex + 1) % this.state.thicknesses.length;
                    this.updateToolbarUI();
                    App.ui.showToast(`Thickness changed`, { duration: 1500 });
                },
                _getDataStore() {
                    if (this.state.context === 'pdf') {
                        return { pageKey: App.pdf.state.pageNum, data: App.pdf.state.annotationsByPage };
                    }
                    if (this.state.context === 'focus') {
                        // NEW: Handle Sigma Article Mode context
                        if (App.state.focusSession && App.state.focusSession.sigmaMode === 'article') {
                            // Use a single page 'article' for all sigma content (scrolling canvas)
                            return { pageKey: 'article', data: App.state.focusSession.sigmaAnnotations || {} };
                        }
                        return { pageKey: App.state.focusSession.currentSlideIndex, data: App.state.focusSession.annotations };
                    }
                    return { pageKey: null, data: null };
                },

                redrawPageAnnotations() {
                    const { canvas, ctx } = this.getCanvasAndContext();
                    const { pageKey, data } = this._getDataStore();
                    if (!ctx || pageKey === null || !data) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const annotations = data[pageKey] || [];
                    const scrollTop = this.state.context === 'focus' ? document.querySelector('.focus-mode-body').scrollTop : 0;

                    annotations.forEach(annotation => {
                        ctx.lineWidth = annotation.thickness;
                        ctx.strokeStyle = annotation.color;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        // DPR scaling factor for scroll offset
                        const dprScale = canvas.height / canvas.scrollHeight;

                        if (annotation.type === 'pen' && annotation.points.length > 1) {
                            ctx.beginPath();
                            const p0 = annotation.points[0];
                            const startX = p0[0] * canvas.width;
                            const startY = (p0[1] * canvas.height) - (scrollTop * dprScale);
                            ctx.moveTo(startX, startY);

                            for (let i = 1; i < annotation.points.length; i++) {
                                const p = annotation.points[i];
                                const x = p[0] * canvas.width;
                                const y = (p[1] * canvas.height) - (scrollTop * dprScale);

                                // For the first point, just lineTo
                                if (i === 1) {
                                    ctx.lineTo(x, y);
                                } else {
                                    // Quadratic curve to midpoint
                                    const prevP = annotation.points[i - 1];
                                    const prevX = prevP[0] * canvas.width;
                                    const prevY = (prevP[1] * canvas.height) - (scrollTop * dprScale);

                                    const midX = (prevX + x) / 2;
                                    const midY = (prevY + y) / 2;

                                    ctx.quadraticCurveTo(prevX, prevY, midX, midY);
                                }
                            }
                            // Connect to final point
                            if (annotation.points.length > 2) {
                                const last = annotation.points[annotation.points.length - 1];
                                ctx.lineTo(last[0] * canvas.width, (last[1] * canvas.height) - (scrollTop * dprScale));
                            }
                            ctx.stroke();
                        } else if (annotation.type === 'rect') {
                            const b = annotation.bounds;
                            const x = b.x * canvas.width;
                            const y = (b.y * canvas.height) - (scrollTop * dprScale);
                            const w = b.w * canvas.width;
                            const h = b.h * canvas.height;
                            const radius = Math.min(8 * (canvas.width / 800), w / 4, h / 4); // Scale radius, cap at 25% of size

                            // Use multiply blend mode for classic highlighter effect - text pops through
                            ctx.save();
                            ctx.globalCompositeOperation = 'multiply';

                            // Slightly saturated fill for vibrant highlight
                            ctx.fillStyle = App.util.hexToRgba(annotation.color, 0.28);
                            ctx.beginPath();
                            ctx.roundRect(x, y, w, h, radius);
                            ctx.fill();

                            ctx.restore(); // Return to normal blend mode

                            // Subtle border with soft inner glow effect
                            ctx.strokeStyle = App.util.hexToRgba(annotation.color, 0.4);
                            ctx.lineWidth = 1.2 * (canvas.width / 800); // Scale with canvas
                            ctx.beginPath();
                            ctx.roundRect(x, y, w, h, radius);
                            ctx.stroke();

                        }
                    });
                },


                startDrawing(e) {
                    const { canvas, ctx } = this.getCanvasAndContext();
                    const { pageKey, data } = this._getDataStore();
                    if (!ctx || !this.state.isActive || pageKey === null || !data) return;

                    this.state.isDrawing = true;
                    const rect = canvas.getBoundingClientRect();

                    // FIX: Conditionally add scroll position ONLY for focus mode.
                    const scrollTop = this.state.context === 'focus' ? document.querySelector('.focus-mode-body').scrollTop : 0;
                    const pos = { x: e.clientX - rect.left, y: e.clientY - rect.top + scrollTop };
                    this.state.lastPos = pos;
                    this.state.latestDrawPos = pos; // Track raw pixels for efficient drawing logic

                    if (!data[pageKey]) data[pageKey] = [];

                    if (this.state.tool === 'eraser') {
                        // Eraser logic... (remains unchanged and safe)
                        const annotations = data[pageKey];
                        let deleted = false;
                        for (let i = annotations.length - 1; i >= 0; i--) {
                            const annotation = annotations[i];
                            const relPos = { x: pos.x / rect.width, y: pos.y / rect.height };
                            let inBounds = false;
                            if (annotation.type === 'pen') {
                                const minX = Math.min(...annotation.points.map(p => p[0])), maxX = Math.max(...annotation.points.map(p => p[0])),
                                    minY = Math.min(...annotation.points.map(p => p[1])), maxY = Math.max(...annotation.points.map(p => p[1]));
                                if (relPos.x >= minX && relPos.x <= maxX && relPos.y >= minY && relPos.y <= maxY) inBounds = true;
                            } else if (annotation.type === 'rect') {
                                const b = annotation.bounds;
                                if (relPos.x >= b.x && relPos.x <= b.x + b.w && relPos.y >= b.y && relPos.y <= b.y + b.h) inBounds = true;
                            }
                            if (inBounds) { annotations.splice(i, 1); deleted = true; break; }
                        }
                        if (deleted) this.redrawPageAnnotations();
                        this.state.isDrawing = false;
                    } else {
                        this.state.currentPath = { type: this.state.tool, color: this.state.colors[this.state.colorIndex], thickness: this.state.thicknesses[this.state.thicknessIndex] };
                        if (this.state.tool === 'pen') this.state.currentPath.points = [[pos.x / rect.width, pos.y / rect.height]];
                        else if (this.state.tool === 'rect') this.state.currentPath.bounds = { x: pos.x / rect.width, y: pos.y / rect.height, w: 0, h: 0 };
                    }
                },

                draw(e) {
                    if (!this.state.isDrawing || !this.state.currentPath) return;
                    const { canvas, ctx } = this.getCanvasAndContext();
                    if (!ctx) return;
                    const rect = canvas.getBoundingClientRect();
                    const scrollTop = this.state.context === 'focus' ? document.querySelector('.focus-mode-body').scrollTop : 0;
                    const currentPos = { x: e.clientX - rect.left, y: e.clientY - rect.top + scrollTop };

                    // FIX: Scale coordinates for High DPI (Retina) displays where canvas.width > rect.width
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;

                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    if (this.state.tool === 'pen') {
                        ctx.lineWidth = this.state.currentPath.thickness;
                        ctx.strokeStyle = this.state.currentPath.color;

                        // Last pos relative to canvas (scaled):
                        const lastX = (this.state.latestDrawPos ? this.state.latestDrawPos.x : this.state.lastPos.x) * scaleX;
                        const lastY = (this.state.latestDrawPos ? this.state.latestDrawPos.y : this.state.lastPos.y) * scaleY;
                        const currX = currentPos.x * scaleX;
                        const currY = currentPos.y * scaleY;

                        ctx.beginPath();
                        ctx.moveTo(lastX, lastY);
                        ctx.lineTo(currX, currY);
                        ctx.stroke();

                        this.state.currentPath.points.push([currentPos.x / rect.width, currentPos.y / rect.height]);
                        this.state.latestDrawPos = { x: currentPos.x, y: currentPos.y }; // Keep visual coords

                    } else if (this.state.tool === 'rect') {
                        // For RECT, we MUST redraw the underlying page to clear the previous frame's rectangle
                        this.redrawPageAnnotations();

                        // Scaling start pos and size to canvas internal pixels
                        const startX = this.state.lastPos.x * scaleX;
                        const startY = this.state.lastPos.y * scaleY;
                        const width = (currentPos.x - this.state.lastPos.x) * scaleX;
                        const height = (currentPos.y - this.state.lastPos.y) * scaleY;

                        // Visual styling for rect draft
                        ctx.globalCompositeOperation = 'multiply';
                        ctx.fillStyle = App.util.hexToRgba(this.state.currentPath.color, 0.35);
                        ctx.beginPath();
                        ctx.rect(startX, startY, width, height);
                        ctx.fill();
                        ctx.globalCompositeOperation = 'source-over';

                        ctx.strokeStyle = this.state.currentPath.color;
                        ctx.lineWidth = this.state.currentPath.thickness;
                        ctx.beginPath();
                        ctx.rect(startX, startY, width, height);
                        ctx.stroke();
                    }
                },

                stopDrawing(e) {
                    if (!this.state.isDrawing || !this.state.currentPath) return;
                    this.state.isDrawing = false;
                    const { canvas } = this.getCanvasAndContext();
                    if (!canvas) return;
                    const { pageKey, data } = this._getDataStore();
                    const rect = canvas.getBoundingClientRect();

                    // FIX: Conditionally add scroll position ONLY for focus mode.
                    const scrollTop = this.state.context === 'focus' ? document.querySelector('.focus-mode-body').scrollTop : 0;
                    const currentPos = { x: e.clientX - rect.left, y: e.clientY - rect.top + scrollTop };

                    if (this.state.tool === 'rect') {
                        const startX = this.state.lastPos.x / rect.width;
                        const startY = this.state.lastPos.y / rect.height;
                        const endX = currentPos.x / rect.width;
                        const endY = currentPos.y / rect.height;
                        this.state.currentPath.bounds = { x: Math.min(startX, endX), y: Math.min(startY, endY), w: Math.abs(endX - startX), h: Math.abs(endY - startY) };
                    }

                    if ((this.state.currentPath.type === 'pen' && this.state.currentPath.points.length > 1) || (this.state.currentPath.type === 'rect' && this.state.currentPath.bounds.w > 0)) {
                        data[pageKey].push(this.state.currentPath);
                    }
                    this.state.currentPath = null;
                    this.redrawPageAnnotations();
                },

                undo() {
                    const { pageKey, data } = this._getDataStore();
                    if (data && data[pageKey] && data[pageKey].length > 0) {
                        data[pageKey].pop();
                        this.redrawPageAnnotations();
                    }
                },
                clearCurrentPage() {
                    const { pageKey, data } = this._getDataStore();
                    if (data) {
                        data[pageKey] = [];
                        this.redrawPageAnnotations();
                        App.ui.showToast('Annotations for this view cleared.', 'info');
                    }
                },
            },

            pdf: {
                state: {
                    isInitialized: false,
                    pdfDoc: null,
                    currentPageText: null,
                    pageNum: 1,
                    pageRendering: false,
                    pageNumPending: null,
                    scale: 1.5,
                    currentAttachment: null,
                    currentAttachment: null,
                    annotationsByPage: {},
                    isPanMode: false,
                },

                // --- NEW: PDF HIGHLIGHTS SUB-MODULE ---
                highlights: {
                    add(text, className) {
                        const article = App.storage.getArticle(App.state.activeArticleId);
                        const attachment = App.pdf.state.currentAttachment;
                        if (!article || !attachment) return;

                        const attachmentIndex = article.attachments.findIndex(att => att.id === attachment.id);
                        if (attachmentIndex === -1) return;

                        if (!article.attachments[attachmentIndex].highlights) {
                            article.attachments[attachmentIndex].highlights = [];
                        }

                        const exists = article.attachments[attachmentIndex].highlights.some(h =>
                            h.page === App.pdf.state.pageNum && h.text === text && h.class === className
                        );

                        if (!exists) {
                            article.attachments[attachmentIndex].highlights.push({
                                page: App.pdf.state.pageNum,
                                text: text,
                                class: className
                            });
                            App.state.isArticleDirty = true; // Mark the main article for autosave
                        }
                    },

                    apply() {
                        const article = App.storage.getArticle(App.state.activeArticleId);
                        const attachment = App.pdf.state.currentAttachment;
                        const textContentDiv = document.getElementById('pdf-text-view-content');
                        const preElement = textContentDiv ? textContentDiv.querySelector('pre') : null;

                        if (!article || !attachment || !preElement || !attachment.highlights) return;

                        const pageHighlights = attachment.highlights.filter(h => h.page === App.pdf.state.pageNum);
                        if (pageHighlights.length === 0) return;

                        let content = preElement.textContent;

                        pageHighlights.forEach(highlight => {
                            if (!highlight.text) return;
                            const regex = new RegExp(App.util.escapeRegex(highlight.text), 'g');
                            const escapedHighlightText = App.util.escapeHtml(highlight.text);
                            content = content.replace(regex, `< span class="${highlight.class}" > ${escapedHighlightText}</span > `);
                        });

                        preElement.innerHTML = content;
                    },

                    async copyPage() {
                        App.pdf.viewer.toggleMoreMenu(true);
                        const article = App.storage.getArticle(App.state.activeArticleId);
                        const attachment = App.pdf.state.currentAttachment;
                        if (!article || !attachment || !attachment.highlights) {
                            App.ui.showToast('No snips to copy.', 'info');
                            return;
                        }
                        const pageHighlights = attachment.highlights.filter(h => h.page === App.pdf.state.pageNum);
                        if (pageHighlights.length === 0) {
                            App.ui.showToast('No snips on this page to copy.', 'info');
                            return;
                        }

                        const textToCopy = pageHighlights.map(h => ` ${h.text} `).join('\n');
                        navigator.clipboard.writeText(textToCopy);
                        App.ui.showToast(`Copied ${pageHighlights.length} snip(s) from page ${App.pdf.state.pageNum}.`, 'success');

                        try {
                            const pdfName = App.util.escapeHtml(attachment.name.replace(/\.pdf$/i, ''));
                            const pageNum = App.pdf.state.pageNum;
                            const highlightsHtml = pageHighlights.map(h => `< li > ${App.util.escapeHtml(h.text)}</li > `).join('');
                            const snippetHtml = `< blockquote ><ul>${highlightsHtml}</ul><footer><small> Snips extracted from page ${pageNum} of "${pdfName}"</small></footer></blockquote > <p><br></p>`;
                            const updatedContent = article.content + snippetHtml;

                            const result = await App.storage.updateArticle(article.id, { content: updatedContent });

                            if (result.success) {
                                App.ui.showToast('Page snips also added to your note!', 'success');
                            } else {
                                throw new Error('Failed to update the article.');
                            }
                        } catch (e) {
                            console.error('Failed to append page snips to article:', e);
                            App.ui.showToast('Could not add snips to note.', 'error');
                        }
                    },

                    async copyAll() {
                        App.pdf.viewer.toggleMoreMenu(true);
                        const article = App.storage.getArticle(App.state.activeArticleId);
                        const attachment = App.pdf.state.currentAttachment;
                        if (!article || !attachment || !attachment.highlights || attachment.highlights.length === 0) {
                            App.ui.showToast('No snips in this document to copy.', 'info');
                            return;
                        }

                        const highlightsByPage = attachment.highlights.reduce((acc, h) => {
                            (acc[h.page] = acc[h.page] || []).push(h.text);
                            return acc;
                        }, {});

                        let textToCopy = `Highlights from "${attachment.name.replace(/\.pdf$/i, '')}"\n\n`;
                        Object.keys(highlightsByPage).sort((a, b) => a - b).forEach(pageNum => {
                            textToCopy += `-- - Page ${pageNum} ---\n`;
                            textToCopy += highlightsByPage[pageNum].map(text => ` ${text} `).join('\n') + '\n\n';
                        });
                        navigator.clipboard.writeText(textToCopy.trim());
                        App.ui.showToast(`Copied all ${attachment.highlights.length} snip(s).`, 'success');

                        try {
                            const pdfName = App.util.escapeHtml(attachment.name.replace(/\.pdf$/i, ''));
                            let allHighlightsHtml = '';
                            Object.keys(highlightsByPage).sort((a, b) => a - b).forEach(pageNum => {
                                allHighlightsHtml += `< p > <b>Page ${pageNum}:</b></p > <ul>`;
                                allHighlightsHtml += highlightsByPage[pageNum].map(text => `<li>${App.util.escapeHtml(text)}</li>`).join('');
                                allHighlightsHtml += '</ul>';
                            });

                            const snippetHtml = `<blockquote>${allHighlightsHtml}<footer><small> All snips extracted from "${pdfName}"</small></footer></blockquote><p><br></p>`;
                            const updatedContent = article.content + snippetHtml;

                            const result = await App.storage.updateArticle(article.id, { content: updatedContent });

                            if (result.success) {
                                App.ui.showToast('All snips also added to your note!', 'success');
                            } else {
                                throw new Error('Failed to update the article.');
                            }
                        } catch (e) {
                            console.error('Failed to append all snips to article:', e);
                            App.ui.showToast('Could not add all snips to note.', 'error');
                        }
                    },

                    async clearPage() {
                        App.pdf.viewer.toggleMoreMenu(true); // Close the menu immediately

                        const article = App.storage.getArticle(App.state.activeArticleId);
                        const attachment = App.pdf.state.currentAttachment;
                        if (!article || !attachment || !attachment.highlights) {
                            App.ui.showToast('No highlights to clear on this page.', 'info');
                            return;
                        }

                        const attachmentIndex = article.attachments.findIndex(att => att.id === attachment.id);
                        if (attachmentIndex === -1) return;

                        const highlightsOnPage = article.attachments[attachmentIndex].highlights.some(h => h.page === App.pdf.state.pageNum);
                        if (!highlightsOnPage) {
                            App.ui.showToast('No highlights to clear on this page.', 'info');
                            return;
                        }
                        const highlightsToKeep = article.attachments[attachmentIndex].highlights.filter(h => h.page !== App.pdf.state.pageNum);

                        article.attachments[attachmentIndex].highlights = highlightsToKeep;

                        await App.events.saveArticle({ isAutosave: true });
                        await App.pdf.viewer.renderTextViewForPage(App.pdf.state.pageNum);
                        App.ui.showToast(`Page Snips Cleared`, 'success');
                    },
                },


                init() {
                    if (this.state.isInitialized) return;
                    this.state.isInitialized = true;

                    if (window.pdfjsLib) {
                        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;
                    }
                    const input = document.getElementById('pdf-import-input');
                    if (input) {
                        input.addEventListener('change', (e) => this.handleFileSelect(e));
                    }
                },

                triggerImport() {
                    if (!this.state.isInitialized) {
                        this.init();
                        this.state.isInitialized = true;
                    }
                    const input = document.getElementById('pdf-import-input');
                    if (input) {
                        input.click();
                    } else {
                        App.ui.showToast("PDF import feature is not properly configured.", "error");
                    }
                },

                async handleFileSelect(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    // --- PDF IMPORT (Existing Logic) ---
                    if (file.type === 'application/pdf') {
                        // LOCK UI: Prevent saving or navigating away while processing
                        App.ui.migrationScreen.show("Attaching PDF...");

                        try {
                            const reader = new FileReader();
                            reader.onload = async (e) => {
                                try {
                                    const safeId = 'pdf_' + Date.now().toString(36) + Math.random().toString(36).substr(2);
                                    const fileData = {
                                        id: safeId,
                                        name: file.name,
                                        type: file.type,
                                        data: e.target.result
                                    };
                                    await this.saveAttachment(fileData);
                                    this.insertAttachmentPill(fileData);
                                    App.ui.showToast(`Attached "${file.name}"`, 'success');
                                } catch (err) {
                                    console.error('Error saving attachment:', err);
                                    App.ui.showToast('Error attaching PDF.', 'error');
                                } finally {
                                    App.ui.migrationScreen.hide();
                                }
                            };
                            reader.onerror = () => {
                                App.ui.showToast('Error reading file.', 'error');
                                App.ui.migrationScreen.hide();
                            };
                            reader.readAsDataURL(file);
                        } catch (err) {
                            App.ui.showToast('Error initiating import.', 'error');
                            App.ui.migrationScreen.hide();
                        } finally {
                            event.target.value = null;
                        }
                        return;
                    }

                    // --- TXT IMPORT ---
                    if (file.name.toLowerCase().endsWith('.txt')) {
                        App.ui.migrationScreen.show("Importing Text...");
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const text = e.target.result;
                                // Helper to sanitize and insert text
                                const cleanText = App.util.escapeHtml(text).replace(/\n/g, '<br>');

                                if (document.queryCommandSupported('insertHTML')) {
                                    document.execCommand('insertHTML', false, cleanText);
                                } else {
                                    // Fallback: simple append if command not supported (unlikely)
                                    const article = App.storage.getArticle(App.state.activeArticleId);
                                    if (article) {
                                        article.content += `<div>${cleanText}</div>`;
                                        App.editor.setContent(article.content);
                                    }
                                }
                                App.ui.showToast(`Imported "${file.name}"`, 'success');
                            } catch (err) {
                                console.error("Text import failed", err);
                                App.ui.showToast("Failed to import text file.", 'error');
                            } finally {
                                App.ui.migrationScreen.hide();
                            }
                        };
                        reader.readAsText(file);
                        event.target.value = null;
                        return;
                    }

                    // --- DOC/DOCX IMPORT (via Mammoth) ---
                    if (file.name.toLowerCase().endsWith('.doc') || file.name.toLowerCase().endsWith('.docx')) {
                        if (typeof mammoth === 'undefined') {
                            App.ui.showToast('DOCX conversion library not loaded. Please check internet connection.', 'error');
                            event.target.value = null;
                            return;
                        }

                        App.ui.migrationScreen.show("Converting Document...");
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            try {
                                const arrayBuffer = e.target.result;
                                const result = await mammoth.convertToHtml({ arrayBuffer: arrayBuffer });
                                const html = result.value;

                                // Insert the converted HTML
                                if (document.queryCommandSupported('insertHTML')) {
                                    document.execCommand('insertHTML', false, html);
                                } else {
                                    const article = App.storage.getArticle(App.state.activeArticleId);
                                    if (article) {
                                        article.content += `<div>${html}</div>`;
                                        App.editor.setContent(article.content);
                                    }
                                }

                                App.ui.showToast(`Imported "${file.name}"`, 'success');
                            } catch (err) {
                                console.error("Mammoth conversion failed", err);
                                App.ui.showToast("Failed to convert document.", 'error');
                            } finally {
                                App.ui.migrationScreen.hide();
                            }
                        };
                        reader.readAsArrayBuffer(file);
                        event.target.value = null;
                        return;
                    }

                    // --- UNSUPPORTED TYPE ---
                    App.ui.showToast('Unsupported file type. Please select PDF, TXT, DOC, or DOCX.', 'warning');
                    event.target.value = null;
                },

                insertAttachmentPill(fileData) {
                    const displayName = fileData.name.replace(/\.pdf$/i, '');
                    const isWriteMode = App.state.currentMode === 'write';
                    const pillHTML = `
                    <span class="pdf-attachment-pill" data-pdf-id="${fileData.id}" data-original-name="${App.util.escapeHtml(fileData.name)}">
                        <span class="pdf-attachment-name" contenteditable="${isWriteMode}">${App.util.escapeHtml(displayName)}</span>
                    </span>`;
                    App.util.insertGuardianBlock(pillHTML);
                },

                async saveAttachment(fileData) {
                    const articleId = App.state.activeArticleId;
                    if (!articleId || articleId === 'temp_new_article') {
                        App.ui.showToast("Please save the note before attaching files.", 'warning');
                        return;
                    }
                    const article = App.storage.getArticle(articleId);
                    if (!article) {
                        App.ui.showToast("Could not find the current article to save to.", 'error');
                        return;
                    }
                    const attachments = article.attachments || [];
                    attachments.push(fileData);
                    await App.storage.updateArticle(articleId, { attachments });
                },

                viewer: {
                    toggleMoreMenu(forceClose = false) {
                        const menu = document.getElementById('pdf-more-menu');
                        if (!menu) return;
                        const closeHandler = (event) => {
                            const isClickInside = menu.contains(event.target) || event.target.closest('#pdf-more-btn');
                            if (!isClickInside) { this.toggleMoreMenu(true); }
                        };
                        if (forceClose || menu.classList.contains('visible')) {
                            menu.classList.remove('visible');
                            document.removeEventListener('click', closeHandler, true);
                        } else {
                            menu.classList.add('visible');
                            setTimeout(() => { document.addEventListener('click', closeHandler, { capture: true, once: true }); }, 0);
                        }
                    },

                    togglePanMode() {
                        const container = document.getElementById('pdf-viewer-container');
                        App.pdf.state.isPanMode = !App.pdf.state.isPanMode;
                        container.classList.toggle('pan-active', App.pdf.state.isPanMode);

                        // Turn off annotation mode if panning to avoid conflict
                        if (App.pdf.state.isPanMode && App.annotationEngine.state.isActive) {
                            App.annotationEngine.toggle('pdf');
                        }

                        const btn = document.getElementById('pdf-pan-toggle');
                        if (btn) {
                            btn.classList.toggle('btn-primary', App.pdf.state.isPanMode);
                            btn.classList.toggle('btn-secondary', !App.pdf.state.isPanMode);
                        }

                        App.ui.showToast(App.pdf.state.isPanMode ? "Pan Mode Enabled: Drag to move" : "Pan Mode Disabled", "info");
                        this.toggleMoreMenu(true);
                    },

                    cycleTextViewFontSize() {
                        const fontSizes = ['0.9rem', '1.1rem', '1.3rem', '1.5rem', '1.7rem', '1.8rem', '2rem', '2.2rem', '2.5rem', '2.8rem', '3rem'];
                        const currentSize = App.settings.get('pdfTextViewFontSize') || '1.1rem';
                        const currentIndex = fontSizes.indexOf(currentSize);
                        const nextIndex = (currentIndex + 1) % fontSizes.length;
                        const newSize = fontSizes[nextIndex];
                        App.settings.set('pdfTextViewFontSize', newSize);
                        this.applyTextViewFontSize();
                        App.ui.showToast(`Font size: ${newSize}`, { duration: 1500 });
                    },

                    applyTextViewFontSize() {
                        const size = App.settings.get('pdfTextViewFontSize');
                        const textContentDiv = document.getElementById('pdf-text-view-content');
                        if (textContentDiv) { textContentDiv.style.fontSize = size; }
                    },

                    cycleTextViewTheme() {
                        const themes = App.events.presentation.themes;
                        const currentTheme = App.settings.get('pdfTextViewTheme') || 'default';
                        const currentIndex = themes.indexOf(currentTheme);
                        const nextIndex = (currentIndex + 1) % themes.length;
                        const newTheme = themes[nextIndex];
                        App.settings.set('pdfTextViewTheme', newTheme);
                        this.applyTextViewTheme();
                        const themeName = newTheme.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        App.ui.showToast(`${themeName} Theme`, { type: 'info', duration: 1500 });
                    },

                    applyTextViewTheme() {
                        const theme = App.settings.get('pdfTextViewTheme');
                        const container = document.getElementById('pdf-viewer-container');
                        if (!container) return;
                        container.className = container.className.replace(/\bambiance-\S+/g, '').trim();
                        if (theme && theme !== 'default') {
                            container.classList.add(`ambiance-${theme}`);
                        }
                    },

                    applyTextViewHighlight() {
                        const selection = window.getSelection();
                        if (!selection || selection.isCollapsed) {
                            App.ui.showToast('Please select text to highlight.', 'warning');
                            return;
                        }
                        const textToHighlight = selection.toString();
                        if (!textToHighlight) return;

                        App.pdf.highlights.add(textToHighlight, 'highlight-1');
                        this.renderTextViewForPage(App.pdf.state.pageNum);
                        selection.removeAllRanges();
                    },

                    toggleTextView() {
                        const container = document.getElementById('pdf-viewer-container');
                        const toggleBtn = document.getElementById('pdf-text-view-toggle');
                        if (!container || !toggleBtn) return;

                        if (App.annotationEngine.state.isActive) {
                            App.annotationEngine.toggle('pdf');
                        }

                        const isActive = container.classList.toggle('text-view-active');

                        if (isActive) {
                            toggleBtn.innerHTML = App.util.icons.pdf;
                            toggleBtn.title = 'Switch to PDF View';
                            toggleBtn.classList.add('active');
                            App.ui.showToast('Text View Enabled', { type: 'info' });
                        } else {
                            toggleBtn.innerHTML = App.util.icons.textView;
                            toggleBtn.title = 'Switch to Text View';
                            toggleBtn.classList.remove('active');
                            App.ui.showToast('PDF View Enabled', { type: 'info' });
                        }
                        this.queueRenderPage(App.pdf.state.pageNum);

                        this.toggleMoreMenu(true);
                    },

                    async capturePage() {
                        this.toggleMoreMenu(true);
                        const container = document.getElementById('pdf-viewer-container');
                        if (!container) return;

                        if (container.classList.contains('text-view-active')) {
                            // TEXT VIEW: Copy with branded footer
                            const textContentDiv = document.getElementById('pdf-text-view-content');
                            if (!textContentDiv) { App.ui.showToast("Cannot find text content to copy.", "error"); return; }
                            try {
                                const brandedFooter = `\n\n\n Made smarter with NoteKash.com\n AI-Powered Notes   Smart Flashcards   Visual Mind Maps\n`;

                                const htmlBranded = textContentDiv.innerHTML + `<div style="margin-top:24px;padding:12px;border-top:1px solid #ddd;color:#666;font-size:12px;text-align:center;"> Made smarter with <a href="https://NoteKash.com" style="color:#2563eb;font-weight:600;">NoteKash.com</a>  AI-Powered Notes  Smart Flashcards  Visual Mind Maps</div>`;
                                const textBranded = textContentDiv.innerText + brandedFooter;

                                const htmlBlob = new Blob([htmlBranded], { type: 'text/html' });
                                const textBlob = new Blob([textBranded], { type: 'text/plain' });
                                await navigator.clipboard.write([new ClipboardItem({ 'text/html': htmlBlob, 'text/plain': textBlob })]);
                                App.ui.showToast('Text view content copied!', 'success');
                            } catch (err) {
                                console.error('Failed to copy text content:', err);
                                App.ui.showToast('Could not copy text. Check browser permissions.', 'error');
                            }
                        } else {
                            // IMAGE VIEW: Capture with engraved watermark
                            if (typeof htmlToImage === 'undefined') { App.ui.showToast("Capture library is not available.", "error"); return; }

                            const pageContainer = document.querySelector('.pdf-page-container');
                            if (!pageContainer) { App.ui.showToast("Cannot find PDF page to capture.", "error"); return; }

                            const toastId = App.ui.showToast('Capturing page...', { type: 'info', duration: 0 });
                            try {
                                const pixelRatio = window.devicePixelRatio || 2;
                                const originalBlob = await htmlToImage.toBlob(pageContainer, { pixelRatio });

                                // Create canvas to add watermark
                                const img = new Image();
                                const loadPromise = new Promise((resolve, reject) => {
                                    img.onload = resolve;
                                    img.onerror = reject;
                                });
                                img.src = URL.createObjectURL(originalBlob);
                                await loadPromise;

                                const canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');

                                // Draw original image
                                ctx.drawImage(img, 0, 0);
                                URL.revokeObjectURL(img.src);

                                // Add engraved watermark in top-right
                                const fontSize = Math.max(14, Math.round(canvas.width * 0.018)); // Scale with image
                                const padding = fontSize * 0.8;
                                const watermarkText = 'NoteKash.com';

                                ctx.font = `600 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
                                ctx.textAlign = 'right';
                                ctx.textBaseline = 'top';

                                const x = canvas.width - padding;
                                const y = padding;

                                // 3D Engraved effect: dark shadow (inset), light highlight, semi-transparent main text

                                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                                ctx.fillText(watermarkText, x + 1, y + 1);


                                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                                ctx.fillText(watermarkText, x - 0.5, y - 0.5);


                                ctx.fillStyle = 'rgba(60, 60, 80, 0.45)';
                                ctx.fillText(watermarkText, x, y);

                                const watermarkedBlob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));

                                await navigator.clipboard.write([new ClipboardItem({ 'image/png': watermarkedBlob })]);
                                App.ui.hideToast(toastId);
                                App.ui.showToast('Page image with annotations copied to clipboard!', 'success');
                            } catch (err) {
                                App.ui.hideToast(toastId);
                                console.error('Failed to copy PDF page to clipboard:', err);
                                App.ui.showToast('Could not copy image. Check browser permissions.', 'error');
                            }
                        }
                    },

                    open(attachmentId) {
                        App.pdf.init(); // Ensure worker is loaded
                        const copilotToggle = document.getElementById('kash-copilot-toggle');
                        if (copilotToggle) copilotToggle.style.display = 'flex';
                        this.applyTextViewTheme();
                        const article = App.storage.getArticle(App.state.activeArticleId);
                        const attachment = article?.attachments?.find(att => att.id === attachmentId);
                        if (!attachment) { App.ui.showToast('Could not find attached PDF data.', 'error'); return; }

                        // Load existing annotations into the in-memory store
                        App.pdf.state.currentAttachment = attachment;
                        App.pdf.state.annotationsByPage = attachment.annotations ? JSON.parse(JSON.stringify(attachment.annotations)) : {};

                        App.annotationEngine.init();
                        App.annotationEngine.state.context = 'pdf';

                        document.body.classList.add('pdf-viewer-active');

                        const container = document.getElementById('pdf-viewer-container');
                        container.classList.add('visible');
                        const displayName = attachment.name.replace(/\.pdf$/i, '');

                        container.innerHTML = `
                        <div class="pdf-viewer-header">
                            <div class="pdf-viewer-controls">
                                <button id="pdf-thumbnails-toggle" class="btn-icon" title="Toggle Page Thumbnails (T)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M3 3h8v8H3V3m0 10h8v8H3v-8m10-10h8v8h-8V3m0 10h8v8h-8v-8z"/></svg></button>
                                <div class="control-divider"></div>
                                <button id="pdf-annotate-toggle" class="btn-icon" title="Toggle Annotation Mode (A)"></button>

                                <div id="pdf-annotation-toolbar" class="pdf-viewer-controls hidden">
                                    <div class="control-divider"></div>
                                    <button id="pdf-tool-rect" class="btn-icon" title="Rectangle Tool (R)"></button>
                                    <button id="pdf-tool-pen" class="btn-icon" title="Pen Tool (P)"></button>
                                    
                                    <button id="pdf-tool-eraser" class="btn-icon" title="Eraser Tool (E)"></button>
                                    <div class="control-divider"></div>
                                    <button id="pdf-color-cycler" class="btn-icon" style="border-radius: 50%;" title="Cycle Color (C)"></button>
                                    <button id="pdf-thickness-cycler" class="btn-icon" title="Cycle Thickness (T)"></button>
                                    <div class="control-divider"></div>
                                    <button id="pdf-undo-btn" class="btn-icon" title="Undo Last Annotation (U)">${App.util.icons.reset}</button>
                                    <button class="btn-icon" title="Clear Annotations on Page">${App.util.icons.trash}</button>
                                </div>
                            </div>
                            <span class="pdf-viewer-title" title="${App.util.escapeHtml(attachment.name)}">${App.util.escapeHtml(displayName)}</span>
                            <div class="pdf-viewer-controls">
                                <button id="pdf-prev" class="btn-icon" title="Previous Page ()"></button>
                                <span class="pdf-page-indicator"><input type="number" id="pdf-page-num" min="1"> &nbsp;of&nbsp; <span id="pdf-page-count"></span></span>
                                <button id="pdf-next" class="btn-icon" title="Next Page ()"></button>
                                <div class="control-divider"></div>
                                <button id="pdf-text-highlight-btn" class="btn-icon text-view-only-btn"></button>
                                <button id="pdf-text-view-toggle" class="btn-icon" title="Switch to Text View"></button>
                                <button id="pdf-fullscreen-toggle" class="btn-icon" title="Toggle Fullscreen (F)"></button>
                                <div class="pdf-more-menu-container">
                                    <button id="pdf-more-btn" class="btn-icon" title="More Options"></button>
                                    <div id="pdf-more-menu" class="pdf-more-menu"></div>
                                </div>
                                <button id="pdf-close" class="btn-icon" title="Close Viewer (Esc)"></button>
                            </div>
                        </div>
                        <div class="pdf-viewer-main">
                            <div id="pdf-thumbnails-bar"></div>
                            <div class="pdf-viewer-canvas-wrapper">
                                <div class="pdf-page-container"><canvas id="pdf-viewer-canvas"></canvas></div>
                                <div id="pdf-text-view-content" class="ui-card"></div>
                            </div>
                        </div>`;

                        // Re-populate icons and re-attach listeners
                        const header = container.querySelector('.pdf-viewer-header');
                        header.querySelector('#pdf-annotate-toggle').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" /></svg>`;
                        header.querySelector('#pdf-tool-pen').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 15c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/></svg>`;
                        header.querySelector('#pdf-tool-rect').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 7.5A2.25 2.25 0 017.5 5.25h9a2.25 2.25 0 012.25 2.25v9a2.25 2.25 0 01-2.25 2.25h-9a2.25 2.25 0 01-2.25-2.25v-9z" /></svg>`;
                        header.querySelector('#pdf-tool-eraser').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M11.25 4.5l7.5 7.5-7.5 7.5" /><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`;
                        header.querySelector('#pdf-thickness-cycler').innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3" fill="currentColor"/></svg>`;

                        header.querySelector('#pdf-prev').innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>';
                        header.querySelector('#pdf-next').innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>';
                        header.querySelector('#pdf-text-highlight-btn').innerHTML = App.util.icons.pen;
                        header.querySelector('#pdf-text-view-toggle').innerHTML = App.util.icons.textView;
                        header.querySelector('#pdf-fullscreen-toggle').innerHTML = App.util.icons.expand;
                        header.querySelector('#pdf-more-btn').innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>';
                        header.querySelector('#pdf-close').innerHTML = App.util.icons.close;
                        header.querySelector('#pdf-more-menu').innerHTML = `
                        <button class="btn btn-secondary mobile-only-btn" onclick="App.pdf.viewer.toggleThumbnails()"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M3 3h8v8H3V3m0 10h8v8H3v-8m10-10h8v8h-8V3m0 10h8v8h-8v-8z"/></svg> Page Snips</button>
                        <button class="btn btn-secondary mobile-only-btn" onclick="App.pdf.viewer.toggleFullscreen()">${App.util.icons.expand} Fullscreen</button>
                        <div class="control-divider mobile-only-btn" style="margin: 4px 8px; height: auto; width: calc(100% - 16px);"></div>
                        <button id="pdf-pan-toggle" class="btn btn-secondary" onclick="App.pdf.viewer.togglePanMode()"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;"><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg> Pan Mode</button>
                        <button class="btn btn-secondary" id="pdf-zoom-out" title="Zoom Out (-)">${App.util.icons.zoomOut} Zoom Out</button>
                        <button class="btn btn-secondary" id="pdf-zoom-percent" title="Reset Zoom">100%</button>
                        <button class="btn btn-secondary" id="pdf-zoom-in" title="Zoom In (+)">${App.util.icons.zoomIn} Zoom In</button>
                        <div class="control-divider text-view-only-btn" style="margin: 4px 8px; height: auto; width: calc(100% - 16px);"></div>
                        <button id="pdf-text-font-size-toggle" class="btn btn-secondary text-view-only-btn" onclick="App.pdf.viewer.cycleTextViewFontSize()" title="Cycle Font Size">${App.util.icons.actions} Font Size</button>
                        <button id="pdf-text-theme-toggle" class="btn btn-secondary text-view-only-btn" onclick="App.pdf.viewer.cycleTextViewTheme()" title="Cycle Ambiance Theme">${App.util.icons.theme} Color Ambiance</button>
                        <button class="btn btn-secondary text-view-only-btn" onclick="App.pdf.highlights.copyPage()" title="Copy highlights from this page">${App.util.icons.copy} Page Snips</button>
                        <button class="btn btn-secondary text-view-only-btn" onclick="App.pdf.highlights.copyAll()" title="Copy all highlights from this document">${App.util.icons.copy} All Snips</button>
                        <button class="btn btn-danger text-view-only-btn" onclick="App.pdf.highlights.clearPage()" title="Permanently remove all highlights from this page">${App.util.icons.trash} Clear Snips</button>
                        <div class="control-divider" style="margin: 4px 8px; height: auto; width: calc(100% - 16px);"></div>
                        <button id="pdf-capture-btn" class="btn btn-secondary" onclick="App.pdf.viewer.capturePage()">${App.util.icons.save} Capture</button>
                        <button id="pdf-share" class="btn btn-secondary">${App.util.icons.actions} Share</button>
                    `;

                        document.getElementById('pdf-thumbnails-toggle').onclick = () => App.pdf.viewer.toggleThumbnails();
                        document.getElementById('pdf-prev').onclick = () => App.pdf.viewer.onPrevPage();
                        document.getElementById('pdf-next').onclick = () => App.pdf.viewer.onNextPage();
                        document.getElementById('pdf-page-num').addEventListener('change', (e) => App.pdf.viewer.goToPage(parseInt(e.target.value, 10)));
                        document.getElementById('pdf-zoom-in').onclick = () => App.pdf.viewer.zoom(0.1);
                        document.getElementById('pdf-zoom-out').onclick = () => App.pdf.viewer.zoom(-0.1);
                        document.getElementById('pdf-zoom-percent').onclick = () => App.pdf.viewer.zoom(0);
                        document.getElementById('pdf-text-view-toggle').onclick = () => App.pdf.viewer.toggleTextView();
                        document.getElementById('pdf-text-highlight-btn').onclick = () => App.pdf.viewer.applyTextViewHighlight();
                        document.getElementById('pdf-fullscreen-toggle').onclick = () => App.pdf.viewer.toggleFullscreen();
                        document.getElementById('pdf-more-btn').onclick = () => App.pdf.viewer.toggleMoreMenu();
                        document.getElementById('pdf-close').onclick = () => App.pdf.viewer.close();
                        document.getElementById('pdf-capture-btn').onclick = () => App.pdf.viewer.capturePage();
                        document.getElementById('pdf-text-font-size-toggle').onclick = () => App.pdf.viewer.cycleTextViewFontSize();
                        document.getElementById('pdf-text-theme-toggle').onclick = () => App.pdf.viewer.cycleTextViewTheme();

                        if (navigator.share) {
                            document.getElementById('pdf-share').onclick = () => App.pdf.viewer.share();
                        } else {
                            const shareBtn = document.getElementById('pdf-share');
                            if (shareBtn) shareBtn.style.display = 'none';
                        }

                        document.getElementById('pdf-annotate-toggle').onclick = () => App.annotationEngine.toggle('pdf');
                        document.getElementById('pdf-tool-pen').onclick = () => App.annotationEngine.setTool('pen');
                        document.getElementById('pdf-tool-rect').onclick = () => App.annotationEngine.setTool('rect');
                        document.getElementById('pdf-tool-eraser').onclick = () => App.annotationEngine.setTool('eraser');
                        document.getElementById('pdf-color-cycler').onclick = () => App.annotationEngine.cycleColor();
                        document.getElementById('pdf-thickness-cycler').onclick = () => App.annotationEngine.cycleThickness();
                        document.getElementById('pdf-undo-btn').onclick = () => App.annotationEngine.undo();
                        header.querySelector('button[title="Clear Annotations on Page"]').onclick = () => App.annotationEngine.clearCurrentPage();
                        header.querySelector('button[title="Clear Annotations on Page"]').onclick = () => App.annotationEngine.clearCurrentPage();
                        document.addEventListener('keydown', this.handleKeyDown);
                        document.addEventListener('keyup', this.handleKeyUp);

                        // Attach Pan Listeners
                        const wrapper = container.querySelector('.pdf-viewer-canvas-wrapper');
                        let isDown = false;
                        let startX, startY, scrollLeft, scrollTop;

                        // Zoom on Wheel (Ctrl/Meta + Wheel)
                        wrapper.addEventListener('wheel', (e) => {
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                const delta = e.deltaY || e.deltaX;
                                const zoomStep = Math.abs(delta) < 50 ? 0.05 : 0.1;
                                App.pdf.viewer.zoom(delta < 0 ? zoomStep : -zoomStep);
                            }
                        }, { passive: false });

                        wrapper.addEventListener('mousedown', (e) => {
                            // Enable pan for: PanMode, Middle Click, or Spacebar held
                            const isMiddleClick = e.button === 1;
                            const isSpacePan = App.pdf.state.isSpacePan;

                            if (!App.pdf.state.isPanMode && !isMiddleClick && !isSpacePan) return;

                            if (isMiddleClick || isSpacePan) e.preventDefault();
                            isDown = true;
                            container.classList.add('is-dragging');
                            startX = e.pageX - wrapper.offsetLeft;
                            startY = e.pageY - wrapper.offsetTop;
                            scrollLeft = wrapper.scrollLeft;
                            scrollTop = wrapper.scrollTop;
                        });
                        wrapper.addEventListener('mouseleave', () => {
                            isDown = false;
                            container.classList.remove('is-dragging');
                        });
                        wrapper.addEventListener('mouseup', () => {
                            isDown = false;
                            container.classList.remove('is-dragging');
                        });
                        wrapper.addEventListener('mousemove', (e) => {
                            if (!isDown) return;
                            e.preventDefault();
                            const x = e.pageX - wrapper.offsetLeft;
                            const y = e.pageY - wrapper.offsetTop;
                            const walkX = (x - startX);
                            const walkY = (y - startY);
                            wrapper.scrollLeft = scrollLeft - walkX;
                            wrapper.scrollTop = scrollTop - walkY;
                        });

                        const pdfData = atob(attachment.data.substring(attachment.data.indexOf(',') + 1));
                        pdfjsLib.getDocument({ data: pdfData }).promise.then(pdfDoc_ => {
                            App.pdf.state.pdfDoc = pdfDoc_;
                            document.getElementById('pdf-page-count').textContent = App.pdf.state.pdfDoc.numPages;
                            document.getElementById('pdf-page-num').max = App.pdf.state.pdfDoc.numPages;
                            App.pdf.state.pageNum = attachment.lastPage || 1;
                            this.renderPage(App.pdf.state.pageNum);
                            this.buildThumbnails();
                        });
                    },

                    async renderTextViewForPage(pageNum) {
                        if (!App.pdf.state.pdfDoc) return;
                        try {
                            const page = await App.pdf.state.pdfDoc.getPage(pageNum);
                            const textContent = await page.getTextContent();

                            const pageText = textContent.items.map(item => item.str).join(' ');
                            App.pdf.state.currentPageText = pageText;

                            this.renderTextViewContent(textContent);
                        } catch (error) {
                            console.error(`Failed to render text view for page ${pageNum}:`, error);
                            App.pdf.state.currentPageText = null; // Clear text on error
                            const textContentDiv = document.getElementById('pdf-text-view-content');
                            if (textContentDiv) textContentDiv.innerHTML = '<p>Error loading text content for this page.</p>';
                        }
                    },

                    async getTextContentForPage(pageNum) {
                        if (!App.pdf.state.pdfDoc || pageNum < 1 || pageNum > App.pdf.state.pdfDoc.numPages) {
                            return "";
                        }
                        try {
                            const page = await App.pdf.state.pdfDoc.getPage(pageNum);
                            await page.getOperatorList();

                            const textContent = await page.getTextContent();
                            return textContent.items.map(item => item.str).join(' ');
                        } catch (error) {
                            console.error(`Failed to get text content for page ${pageNum}:`, error);
                            return "";
                        }
                    },

                    renderPage(num) {
                        // Clear any pending zoom debounce since we are rendering now
                        if (this.zoomTimeout) {
                            clearTimeout(this.zoomTimeout);
                            this.zoomTimeout = null;
                        }

                        App.pdf.state.pageRendering = true;

                        // Update rendered scale state to match the current requested scale
                        App.pdf.state.renderedScale = App.pdf.state.scale;

                        // Reset CSS transform as we are about to render at the correct resolution
                        const pageContainer = document.querySelector('.pdf-page-container');
                        if (pageContainer) {
                            pageContainer.style.transform = 'none';
                            pageContainer.style.transformOrigin = 'top center';
                        }

                        const container = document.getElementById('pdf-viewer-container');
                        const isInTextView = container.classList.contains('text-view-active');

                        App.pdf.state.pdfDoc.getPage(num).then(page => {
                            const pageContainer = document.querySelector('.pdf-page-container');
                            if (pageContainer.querySelector('#annotation-layer')) {
                                pageContainer.querySelector('#annotation-layer').remove();
                            }

                            if (!isInTextView) {
                                const canvas = document.getElementById('pdf-viewer-canvas');
                                const scale = App.pdf.state.scale;

                                const dpr = window.devicePixelRatio || 1;
                                const outputScale = scale * dpr;

                                const viewport = page.getViewport({ scale: outputScale });
                                const displayViewport = page.getViewport({ scale: scale });

                                canvas.width = viewport.width;
                                canvas.height = viewport.height;

                                // CSS display size (original) - THIS IS KEY FOR ANNOTATION SAFETY
                                canvas.style.width = displayViewport.width + 'px';
                                canvas.style.height = displayViewport.height + 'px';

                                const annotationLayer = document.createElement('canvas');
                                annotationLayer.id = 'annotation-layer';
                                annotationLayer.width = viewport.width;
                                annotationLayer.height = viewport.height;
                                annotationLayer.style.width = displayViewport.width + 'px';
                                annotationLayer.style.height = displayViewport.height + 'px';
                                pageContainer.appendChild(annotationLayer);

                                page.render({
                                    canvasContext: canvas.getContext('2d'),
                                    viewport: viewport
                                }).promise.then(() => {
                                    App.pdf.state.pageRendering = false;

                                    if (App.annotationEngine.state.isActive) {
                                        const newCanvas = annotationLayer.cloneNode(true);
                                        annotationLayer.parentNode.replaceChild(newCanvas, annotationLayer);
                                        newCanvas.addEventListener('mousedown', App.annotationEngine.startDrawing.bind(App.annotationEngine));
                                        newCanvas.addEventListener('mousemove', App.annotationEngine.draw.bind(App.annotationEngine));
                                        newCanvas.addEventListener('mouseup', App.annotationEngine.stopDrawing.bind(App.annotationEngine));
                                        newCanvas.addEventListener('mouseleave', App.annotationEngine.stopDrawing.bind(App.annotationEngine));
                                        newCanvas.addEventListener('touchstart', (e) => App.annotationEngine.startDrawing(e.touches[0]), { passive: false });
                                        newCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); App.annotationEngine.draw(e.touches[0]); }, { passive: false });
                                        newCanvas.addEventListener('touchend', (e) => App.annotationEngine.stopDrawing(e.changedTouches[0]));
                                    }

                                    // FIX: ALWAYS redraw annotations after all canvas setup (visible in all modes)
                                    App.annotationEngine.redrawPageAnnotations(num);

                                    if (App.pdf.state.pageNumPending !== null) {
                                        this.renderPage(App.pdf.state.pageNumPending);
                                        App.pdf.state.pageNumPending = null;
                                    }
                                });
                            }

                            // The text view rendering remains unchanged.
                            this.renderTextViewForPage(num);

                            if (isInTextView) {
                                App.pdf.state.pageRendering = false;
                                if (App.pdf.state.pageNumPending !== null) {
                                    this.renderPage(App.pdf.state.pageNumPending);
                                    App.pdf.state.pageNumPending = null;
                                }
                            }
                        });

                        document.getElementById('pdf-page-num').value = num;
                        document.getElementById('pdf-zoom-percent').textContent = `${Math.round(App.pdf.state.scale * 100)}%`;
                        const thumbnailsBar = document.getElementById('pdf-thumbnails-bar');
                        if (thumbnailsBar) {
                            thumbnailsBar.querySelectorAll('.pdf-thumbnail.active').forEach(t => t.classList.remove('active'));
                            const activeThumbnail = thumbnailsBar.querySelector(`.pdf-thumbnail[data-page-num="${num}"]`);
                            if (activeThumbnail) {
                                activeThumbnail.classList.add('active');
                                activeThumbnail.scrollIntoView({ block: 'nearest' });
                            }
                        }
                    },

                    renderTextViewContent(textContent) {
                        const textContentDiv = document.getElementById('pdf-text-view-content');
                        if (!textContentDiv) return;

                        this.applyTextViewFontSize();
                        textContentDiv.innerHTML = '';

                        if (!textContent || textContent.items.length === 0) {
                            textContentDiv.innerHTML = '<p style="text-align: center; padding: 2rem;">No text content found on this page.</p>';
                            return;
                        }

                        const items = textContent.items;
                        let finalHtml = '';
                        let lastY = -1;
                        let lastX = -1;
                        const lineThreshold = 5;

                        const sortedItems = [...items].sort((a, b) => {
                            const yA = a.transform[5];
                            const yB = b.transform[5];
                            if (Math.abs(yA - yB) > lineThreshold) return yB - yA;
                            return a.transform[4] - b.transform[4];
                        });

                        sortedItems.forEach(item => {
                            if (!item.str.trim()) return;
                            const currentY = item.transform[5];
                            const currentX = item.transform[4];

                            if (lastY !== -1 && Math.abs(currentY - lastY) > lineThreshold) {
                                finalHtml += '\n';
                            }

                            if (lastY !== -1 && Math.abs(currentY - lastY) <= lineThreshold) {
                                const spaceWidth = 8;
                                const itemWidth = items.find(i => i.transform[4] === lastX)?.width || 0;
                                const gap = currentX - (lastX + itemWidth);
                                if (gap > spaceWidth) {
                                    finalHtml += ' '.repeat(Math.round(gap / spaceWidth));
                                } else {
                                    finalHtml += ' ';
                                }
                            }

                            finalHtml += item.str;
                            lastY = currentY;
                            lastX = currentX;
                        });

                        const pre = document.createElement('pre');
                        pre.textContent = finalHtml.trim();
                        textContentDiv.appendChild(pre);

                        App.pdf.highlights.apply();
                    },

                    queueRenderPage(num) { if (App.pdf.state.pageRendering) { App.pdf.state.pageNumPending = num; } else { this.renderPage(num); } },
                    onPrevPage() { if (App.pdf.state.pageNum <= 1) return; App.pdf.state.pageNum--; this.queueRenderPage(App.pdf.state.pageNum); },
                    onNextPage() { if (App.pdf.state.pageNum >= App.pdf.state.pdfDoc.numPages) return; App.pdf.state.pageNum++; this.queueRenderPage(App.pdf.state.pageNum); },
                    goToPage(num) {
                        const pageNum = Math.max(1, Math.min(App.pdf.state.pdfDoc.numPages, num));
                        if (pageNum !== App.pdf.state.pageNum) { App.pdf.state.pageNum = pageNum; this.queueRenderPage(pageNum); }
                    },
                    zoom(amount) {
                        if (amount === 0) App.pdf.state.scale = 1.0;
                        else App.pdf.state.scale = Math.max(0.5, Math.min(3, App.pdf.state.scale + amount));

                        if (!App.pdf.state.renderedScale) App.pdf.state.renderedScale = 1.0;

                        const cssScale = App.pdf.state.scale / App.pdf.state.renderedScale;
                        const pageContainer = document.querySelector('.pdf-page-container');

                        if (pageContainer) {
                            pageContainer.style.transformOrigin = 'top center';
                            pageContainer.style.transform = `scale(${cssScale})`;
                        }

                        if (this.zoomTimeout) clearTimeout(this.zoomTimeout);

                        this.zoomTimeout = setTimeout(() => {
                            this.queueRenderPage(App.pdf.state.pageNum);
                        }, 200);
                    },
                    toggleFullscreen() {
                        const container = document.getElementById('pdf-viewer-container');
                        if (!container) return;
                        container.classList.toggle('pdf-fullscreen-active');
                    },

                    handleKeyDown: (e) => {
                        if (App.coPilot.state.isOpen) return;

                        // Spacebar for Pan Mode (Hold)
                        if (e.code === 'Space' && !e.repeat && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && !e.target.isContentEditable) {
                            App.pdf.state.isSpacePan = true;
                            const container = document.getElementById('pdf-viewer-container');
                            if (container) container.classList.add('grab-mode');
                        }

                        if (e.target.id === 'pdf-page-num') return;
                        const isAnnotationActive = App.annotationEngine.state.isActive && App.annotationEngine.state.context === 'pdf';

                        switch (e.key.toLowerCase()) {
                            case 'escape': App.pdf.viewer.close(); break;
                            case 'arrowleft': if (!isAnnotationActive) App.pdf.viewer.onPrevPage(); break;
                            case 'arrowright': if (!isAnnotationActive) App.pdf.viewer.onNextPage(); break;
                            case '+': case '=': if (!isAnnotationActive) { App.pdf.viewer.zoom(0.1); e.preventDefault(); } break;
                            case '-': if (!isAnnotationActive) { App.pdf.viewer.zoom(-0.1); e.preventDefault(); } break;
                            case 't':
                                if (isAnnotationActive) App.annotationEngine.cycleThickness();
                                else App.pdf.viewer.toggleThumbnails();
                                break;
                            case 'f': App.pdf.viewer.toggleFullscreen(); break;
                            case 'a': App.annotationEngine.toggle('pdf'); break;
                            case 'p': if (isAnnotationActive) { App.annotationEngine.setTool('pen'); e.preventDefault(); } break;
                            case 'r': if (isAnnotationActive) { App.annotationEngine.setTool('rect'); e.preventDefault(); } break;
                            case 'e': if (isAnnotationActive) { App.annotationEngine.setTool('eraser'); e.preventDefault(); } break;
                        }
                    },

                    handleKeyUp: (e) => {
                        if (e.code === 'Space') {
                            App.pdf.state.isSpacePan = false;
                            const container = document.getElementById('pdf-viewer-container');
                            if (container) container.classList.remove('grab-mode');
                        }
                    },

                    async share() {
                        const attachment = App.pdf.state.currentAttachment; if (!attachment || !navigator.share) return;
                        try {
                            const blob = App.util.dataURLtoBlob(attachment.data); if (!blob) throw new Error("Could not convert PDF data.");
                            const file = new File([blob], attachment.name, { type: blob.type });
                            if (navigator.canShare && navigator.canShare({ files: [file] })) { await navigator.share({ files: [file], title: attachment.name }); }
                            else { App.ui.showToast("Cannot share this file type.", 'warning'); }
                        } catch (err) { if (err.name !== 'AbortError') App.ui.showToast("Could not share PDF.", 'error'); }
                    },
                    toggleThumbnails() {
                        const main = document.querySelector('.pdf-viewer-main'); const btn = document.getElementById('pdf-thumbnails-toggle');
                        if (main && btn) { main.classList.toggle('thumbnails-active'); btn.classList.toggle('active'); }
                    },
                    async buildThumbnails() {
                        const bar = document.getElementById('pdf-thumbnails-bar'); const doc = App.pdf.state.pdfDoc; bar.innerHTML = '';
                        for (let i = 1; i <= doc.numPages; i++) {
                            const page = await doc.getPage(i); const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); const viewport = page.getViewport({ scale: 0.2 });
                            canvas.width = viewport.width; canvas.height = viewport.height;
                            await page.render({ canvasContext: ctx, viewport: viewport, backgroundColor: '#FFFFFF' }).promise;
                            const thumbDiv = document.createElement('div'); thumbDiv.className = 'pdf-thumbnail'; thumbDiv.dataset.pageNum = i; thumbDiv.appendChild(canvas);
                            const pageLabel = document.createElement('span'); pageLabel.textContent = i; thumbDiv.appendChild(pageLabel);
                            thumbDiv.onclick = () => this.goToPage(i); bar.appendChild(thumbDiv);
                        }
                    },

                    async close() {
                        document.getElementById('kash-copilot-toggle').style.display = 'none';
                        if (App.coPilot.state.isOpen) App.coPilot.toggle();

                        if (App.annotationEngine.state.isActive) {
                            App.annotationEngine.toggle('pdf');
                        }


                        let needsSave = this.saveAnnotationsToAttachment();

                        // Save Last Read Page
                        const article = App.storage.getArticle(App.state.activeArticleId);
                        const attachment = App.pdf.state.currentAttachment;
                        if (article && attachment) {
                            const att = article.attachments.find(a => a.id === attachment.id);
                            if (att && att.lastPage !== App.pdf.state.pageNum) {
                                att.lastPage = App.pdf.state.pageNum;
                                needsSave = true;
                            }
                        }

                        if (needsSave) {
                            await App.events.saveArticle({ isAutosave: true });
                        }

                        const container = document.getElementById('pdf-viewer-container');
                        container.classList.remove('visible', 'text-view-active', 'annotation-active');
                        container.innerHTML = '';
                        document.removeEventListener('keydown', this.handleKeyDown);
                        document.removeEventListener('keyup', this.handleKeyUp);

                        App.pdf.state.pdfDoc = null;
                        App.pdf.state.pageNum = 1;
                        App.pdf.state.pageRendering = false;
                        App.pdf.state.pageNumPending = null;
                        App.pdf.state.currentAttachment = null;
                        App.pdf.state.annotationsByPage = {};
                        container.classList.remove('pdf-fullscreen-active');
                        document.body.classList.remove('pdf-viewer-active');
                    },

                    saveAnnotationsToAttachment() {
                        const article = App.storage.getArticle(App.state.activeArticleId);
                        const attachment = App.pdf.state.currentAttachment;
                        if (!article || !attachment) return false;

                        const attachmentIndex = article.attachments.findIndex(att => att.id === attachment.id);
                        if (attachmentIndex === -1) return false;

                        const currentAnnotations = JSON.stringify(article.attachments[attachmentIndex].annotations || {});
                        const newAnnotations = JSON.stringify(App.pdf.state.annotationsByPage);

                        if (currentAnnotations !== newAnnotations) {
                            article.attachments[attachmentIndex].annotations = JSON.parse(newAnnotations);
                            App.state.isArticleDirty = true;
                            App.ui.showToast('PDF annotations saved!', { type: 'success', duration: 1500 });
                            return true;
                        }
                        return false;
                    },
                }
            },



            // ==========================================================================
            // 3.22. GLOBAL SEARCH MODULE (v2)
            // ==========================================================================
            globalSearch: {
                fuse: null,
                searchableData: [],
                selectedIndex: -1,
                results: [],
                isInitialized: false,

                els: {
                    overlay: null, modal: null, input: null,
                    resultsContainer: null, searchBtn: null,
                },

                commandRegistry: [
                    { name: 'note', keywords: ['note', 'n'] },
                    { name: 'task', keywords: ['task', 't'] }
                ],

                init() {
                    this.els.overlay = document.getElementById('global-search-overlay');
                    this.els.modal = document.getElementById('global-search-modal');
                    this.els.input = document.getElementById('global-search-input');
                    this.els.resultsContainer = document.getElementById('global-search-results');
                    this.els.searchBtn = document.getElementById('global-search-btn');

                    this.els.searchBtn.addEventListener('click', () => this.openSearch());
                    this.els.overlay.addEventListener('click', (e) => { if (e.target === this.els.overlay) this.closeSearch(); });
                    this.els.input.addEventListener('input', () => this.handleInput());
                    document.addEventListener('keydown', (e) => this._handleKeyDown(e));
                },

                openSearch() {
                    if (!this.isInitialized) this.buildIndex();
                    this.els.overlay.classList.remove('hidden');
                    this.els.input.value = '';
                    this.els.resultsContainer.innerHTML = '';
                    this.els.input.focus();
                    this.els.input.style.height = 'auto';
                    this.buildIndex();
                },

                closeSearch() {
                    this.els.overlay.classList.add('hidden');
                    this.els.modal.classList.remove('expanded-input');
                },

                handleInput() {
                    this.selectedIndex = -1;
                    const query = this.els.input.value;
                    this.els.input.classList.toggle('expanded', query.includes('>>'));

                    const lowerQuery = query.trim().toLowerCase();

                    // NEW: Handle the "kashask:" command hint
                    if (lowerQuery.startsWith('kashask')) {
                        let hintItem;
                        if (lowerQuery === 'kashask') {
                            hintItem = {
                                type: 'suggestion',
                                displayText: 'Add a colon and type your question...',
                                categoryText: 'e.g., kashask: who invented the lightbulb?'
                            };
                        } else if (lowerQuery === 'kashask:') {
                            hintItem = {
                                type: 'suggestion',
                                displayText: 'Type your question for the AI...',
                                categoryText: 'Press Enter to ask'
                            };
                        } else if (lowerQuery.startsWith('kashask:')) {
                            const promptText = query.substring(8).trim();
                            hintItem = {
                                type: 'suggestion',
                                displayText: `Ask AI: "${promptText}"`,
                                categoryText: 'Ready to ask...'
                            };
                        }
                        if (hintItem) {
                            this.results = [hintItem];
                            this._renderResults(this.results);
                            return;
                        }
                    }

                    // 1. Handle Navigation Commands (%)
                    if (lowerQuery.startsWith('%')) {
                        const navTerm = lowerQuery.substring(1);
                        const navCommands = [
                            { id: 'library', name: 'Go to Library', icon: '' },
                            { id: 'all-snippets', name: 'View All Snippets', icon: '' },
                            { id: 'new', name: 'Create New Article', icon: '' },
                            { id: 'task', name: 'Go to Task Window', icon: '' },
                            { id: 'study', name: 'Start Study Session', icon: '' },
                            { id: 'quiz', name: 'Start a Quiz', icon: '' },
                            { id: 'visual-map', name: 'Go to Visual Map', icon: '' },
                            { id: 'mindmap', name: 'Go to Mind Map', icon: '' },
                            { id: 'flashcard', name: 'Go to Flashcards', icon: '' },
                            { id: 'stats-dashboard', name: 'Go to Stats', icon: '' },
                            { id: 'tags', name: 'Go to Tags View', icon: '' },
                            { id: 'settings', name: 'Go to Settings', icon: '' }
                        ];

                        const categoryCommands = App.config.categories.map(cat => ({
                            id: cat,
                            name: `Go to Category: ${App.util.getCategoryDisplayName(cat)}`,
                            icon: '',
                            isCategory: true
                        }));

                        const flashcardCategoryCommands = App.config.categories.map(cat => ({
                            id: `flashcard-${cat.toLowerCase()}`,
                            name: `Go to Flashcard Deck: ${App.util.getCategoryDisplayName(cat)}`,
                            icon: '',
                            isFlashcardCategory: true,
                            category: cat
                        }));

                        const allCommands = [...navCommands, ...categoryCommands, ...flashcardCategoryCommands];


                        if (navTerm === '') { // User just typed "%"
                            this.results = allCommands.map(cmd => ({ type: 'navigate', ...cmd }));
                        } else { // User is typing a command
                            this.results = allCommands
                                .filter(cmd => cmd.id.toLowerCase().startsWith(navTerm) || App.util.getCategoryDisplayName(cmd.id).toLowerCase().startsWith(navTerm))
                                .map(cmd => ({ type: 'navigate', ...cmd }));
                        }
                        this._renderResults(this.results);
                        return;
                    }

                    // New logic for the image filter
                    if (lowerQuery.startsWith('image')) {
                        const searchTerm = lowerQuery.replace(/^image:?\s*/, '');
                        let itemsToSearch = this.searchableData.filter(item => item.type === 'image');

                        if (searchTerm.trim()) {
                            const fuse = App.offline.safeFuse(itemsToSearch, { keys: ['title'], threshold: 0.4, includeScore: true });
                            this.results = fuse.search(searchTerm).map(r => r.item);
                        } else {
                            this.results = itemsToSearch;
                        }
                        this._renderResults(this.results);
                        return;
                    }

                    if (lowerQuery.startsWith('pdf')) {
                        const searchTerm = lowerQuery.replace(/^pdf:?\s*/, '');
                        let itemsToSearch = this.searchableData.filter(item => item.type === 'pdf');
                        if (searchTerm.trim()) {
                            const fuse = App.offline.safeFuse(itemsToSearch, { keys: ['title', 'content'], threshold: 0.4, includeScore: true });
                            this.results = fuse.search(searchTerm).map(r => r.item);
                        } else {
                            this.results = itemsToSearch;
                        }
                        this._renderResults(this.results);
                        return;
                    }

                    const filterMatch = lowerQuery.match(/^(title|flashcard|snip|tag):\s*(.*)/);
                    if (filterMatch) {
                        const typeMap = { snip: 'snippet', title: 'note' };
                        const searchType = typeMap[filterMatch[1]] || filterMatch[1];
                        const searchTerm = filterMatch[2];

                        let itemsToSearch = this.searchableData.filter(item => item.type === searchType);

                        if (searchTerm.trim()) {
                            const keys = searchType === 'note' ? ['title'] : ['title', 'content'];
                            const fuse = App.offline.safeFuse(itemsToSearch, { keys: keys, threshold: 0.4, includeScore: true });
                            this.results = fuse.search(searchTerm).map(r => r.item);
                        } else {
                            this.results = itemsToSearch;
                        }
                        this._renderResults(this.results);
                        return;
                    }

                    const genericSearches = {
                        'title': { type: 'note', hint: 'Filter by title with "title: [term]"' },
                        'task': { type: 'task', hint: 'Create new: "task: your task name"' },
                        'flashcard': { type: 'flashcard', hint: 'Filter with "flashcard: [term]"' },
                        'tag': { type: 'tag', hint: 'Filter tags with "tag: [term]" or view snippets with "snip: [term]"' },
                        'snip': { type: 'snippet', hint: 'Filter snippets with "snip: [term]"' }
                    };
                    if (genericSearches[lowerQuery]) {
                        const config = genericSearches[lowerQuery];
                        const allItems = this.searchableData.filter(item => item.type === config.type);
                        const suggestion = {
                            type: 'suggestion',
                            displayText: config.hint,
                            categoryText: 'Command Hint'
                        };
                        this.results = [suggestion, ...allItems];
                        this._renderResults(this.results);
                        return;
                    }

                    const commandPrefix = this.commandRegistry.find(cmd => cmd.keywords.some(kw => lowerQuery.startsWith(kw + ':')));
                    if (commandPrefix && !query.includes('>>')) {
                        let hint = '';
                        if (commandPrefix.name === 'note') {
                            hint = 'Syntax: `note:[category]: Title >> Content`';
                        } else if (commandPrefix.name === 'task') {
                            hint = 'Syntax: `task:[category]: Task Name #priority`';
                        }
                        this.results = [{ type: 'suggestion', displayText: hint, categoryText: 'Command Syntax Hint' }];
                        this._renderResults(this.results);
                        return;
                    }

                    const commandAction = this.parseCommand(query);
                    if (commandAction) {
                        this.results = [commandAction];
                        this._renderResults(this.results);
                        return;
                    }

                    this.results = this.search(query);
                    this._renderResults(this.results);
                },

                parseCommand(query) {
                    const trimmedQuery = query.trim();
                    const lowerQuery = trimmedQuery.toLowerCase();

                    const command = this.commandRegistry.find(cmd => cmd.keywords.some(kw => lowerQuery.startsWith(kw + ':') || lowerQuery.startsWith(kw + ' ')));
                    if (!command) return null;

                    const findCategory = (catIdentifier) => {

                        if (!catIdentifier) {
                            const defaultCat = App.settings.get('userCategories').find(c => c.isDefault);
                            return defaultCat ? defaultCat.name : 'General';
                        }
                        const lowerCat = catIdentifier.toLowerCase();
                        const userCategories = App.settings.get('userCategories');
                        const exactMatch = userCategories.find(c =>
                            (c.displayName && c.displayName.toLowerCase() === lowerCat) ||
                            c.name.toLowerCase() === lowerCat
                        );
                        if (exactMatch) return exactMatch.name;
                        const partialMatch = userCategories.find(c =>
                            (c.displayName && c.displayName.toLowerCase().startsWith(lowerCat)) ||
                            c.name.toLowerCase().startsWith(lowerCat)
                        );
                        if (partialMatch) return partialMatch.name;

                        const defaultCat = userCategories.find(c => c.isDefault);
                        return defaultCat ? defaultCat.name : 'General';
                    };
                    let action = { type: 'command', command: command.name };

                    if (command.name === 'note') {
                        const noteRegex = /^(?:note|n):?(?:([^:]+):)?\s*(.*?)\s*>>\s*(.*)$/s;
                        const match = trimmedQuery.match(noteRegex);
                        if (!match) return null;
                        let [, category, title, content] = match;
                        if (!title.trim() && !content?.trim()) return null;
                        action.title = title.trim();
                        action.category = findCategory(category);
                        action.content = content ? App.util.textToHtml(content.trim()) : '<p><br></p>';
                        action.displayText = `Create Note: "${action.title}"`;
                        action.categoryText = `in ${App.util.getCategoryDisplayName(action.category)}`;
                    } else if (command.name === 'task') {
                        const taskRegex = /^(?:task|t):?(?:([\w-]+):)?\s*(.*?)(?:\s*#(\w+))?$/;
                        const match = trimmedQuery.match(taskRegex);
                        if (!match) return null;
                        let [, category, title, priority] = match;
                        if (!title.trim()) return null;
                        action.title = title.trim().replace(/#(\w+)$/, '').trim();
                        action.category = findCategory(category);
                        const priorities = ['low', 'medium', 'high'];
                        action.priority = priorities.find(p => p.startsWith(priority?.toLowerCase())) || 'low';
                        action.displayText = `Create Task: "${action.title}"`;
                        action.categoryText = `Priority: ${action.priority}`;
                    }
                    return action;
                },

                buildIndex() {
                    if (!App.state || (!App.state.articles && !App.state.tasks)) return;
                    this.searchableData = [];

                    (App.state.articles || []).forEach(note => this.searchableData.push({ id: note.id, type: 'note', title: note.title, content: note.content.substring(0, 100), action: 'openNote' }));
                    (App.hub.state.tasks || []).forEach(task => this.searchableData.push({ id: task.id, type: 'task', title: task.title, action: 'openTask' }));


                    (App.util.getAllFlashcards() || []).forEach(card => {
                        let title = '';
                        let content = '';

                        // Intelligently determine the primary text based on flashcard type
                        if (card.type === 'mcq') {
                            title = card.question || '';
                            content = (card.options || []).map(opt => opt.text).join(' ');
                        } else if (card.type === 'collapsible') {
                            title = card.frontText || '';
                            content = card.backText || '';
                        } else { // Default to cloze
                            title = card.fullText || '';
                        }

                        this.searchableData.push({
                            id: card.id,
                            type: 'flashcard',
                            title: title,
                            content: content,
                            action: 'openFlashcard',
                            category: card.category
                        });
                    });

                    Object.values(App.state.tags || {}).forEach(tag => this.searchableData.push({ id: tag.id, type: 'tag', title: tag.displayName, action: 'filterNotesByTag' }));

                    const allSnippets = App.util.extractSnippets(null, ['highlight', 'tag']);


                    // Process snippets, separating text from images
                    allSnippets.forEach(snip => {
                        const article = App.storage.getArticle(snip.articleId);
                        if (!article) return;

                        if (snip.isImage) {
                            // This is our new logic to add images as a distinct type
                            this.searchableData.push({
                                ...snip,
                                type: 'image',
                                title: snip.text, // The caption is the searchable text
                                content: `In: ${article.title}`,
                                action: 'openImage' // A new action we will create
                            });
                        } else {
                            // This is the existing logic for text snippets
                            this.searchableData.push({
                                ...snip,
                                type: 'snippet',
                                title: snip.text,
                                content: `In: ${article.title}`,
                                action: 'openSnippet'
                            });
                        }
                    });
                    (App.state.articles || []).forEach(note => {
                        if (note.attachments && note.attachments.length > 0) {
                            note.attachments.forEach(attachment => {
                                if (attachment.type === 'application/pdf') {
                                    this.searchableData.push({
                                        id: attachment.id,
                                        type: 'pdf',
                                        title: attachment.name.replace(/\.pdf$/i, ''),
                                        content: `In: ${note.title}`,
                                        action: 'openPdfArticle',
                                        articleId: note.id
                                    });
                                }
                            });
                        }
                    });

                    const options = { includeScore: true, keys: ['title', 'content'], threshold: 0.4 };
                    this.fuse = App.offline.safeFuse(this.searchableData, options);
                    this.isInitialized = true;
                },

                search(query) {
                    if (!query || !this.fuse) { this.results = []; return []; }
                    this.results = this.fuse.search(query).map(result => result.item);
                    return this.results;
                },

                async executeAction(item) {
                    if (!item) return;
                    if (item.type === 'suggestion') return;

                    if (item.type !== 'command') {
                        this.closeSearch();
                    }

                    switch (item.type) {
                        case 'navigate':
                            switch (item.id) {
                                case 'all-snippets':
                                    App.router.navigateTo('category', 'All');
                                    break;
                                case 'flashcard':
                                    await App.settings.set('flashcardCategory', 'All');
                                    App.router.navigateTo('flashcard');
                                    break;
                                case 'study':
                                    App.events.study.start();
                                    break;
                                case 'quiz':
                                    App.quiz.start();
                                    break;
                                case 'settings':
                                    App.ui.showSettingsModal();
                                    break;
                                case 'new':
                                    App.events.createNewArticle();
                                    break;
                                case 'task':
                                    App.hub.ui.showProductivityModal();
                                    break;
                                default:
                                    if (item.isFlashcardCategory) {
                                        await App.settings.set('flashcardCategory', item.category);
                                        App.router.navigateTo('flashcard');
                                    } else {
                                        const destination = item.isCategory ? 'category' : item.id;
                                        const data = item.isCategory ? item.id : null;
                                        App.router.navigateTo(destination, data);
                                    }
                                    break;
                            }
                            break;

                        case 'command':
                            switch (item.command) {
                                case 'note':
                                    if (!App.license.isPremium() && App.state.articles.length >= App.config.sparkTierLimit) {
                                        App.ui.showAscensionModal();
                                        App.ui.showToast('Note limit reached. Go Premium for unlimited notes.', 'warning');
                                        this.closeSearch();
                                        return; // Stop execution
                                    }
                                    const noteData = { title: item.title, content: item.content, category: item.category };
                                    const newNote = await App.storage.createArticle(noteData);
                                    if (newNote) {
                                        App.ui.showToast(`Note "${newNote.title}" created!`, { type: 'success' });
                                        this.closeSearch();
                                        App.router.navigateTo('article', { id: newNote.id, mode: 'write' });
                                    }
                                    break;
                                case 'task':
                                    App.hub.tasks.state.composer = { title: item.title, category: item.category, priority: item.priority, due: App.hub.util.getTodayISO(), pomodoroGoal: 0 };
                                    await App.hub.tasks.add();
                                    App.ui.showToast(`Task "${item.title}" created!`, { type: 'success' });
                                    this.closeSearch();
                                    break;
                            }
                            break;

                        default:
                            switch (item.action) {
                                case 'openNote':
                                    App.router.navigateTo('article', { id: item.id, mode: 'read' });
                                    break;
                                case 'openTask':
                                    const task = App.hub.state.tasks.find(t => t.id === item.id);
                                    if (task) {
                                        App.hub.pomodoro.startCycle(task);
                                        App.hub.ui.showProductivityModal();
                                    }
                                    break;
                                case 'openSnippet':
                                    App.router.navigateTo('article', { id: item.articleId, mode: 'read', scrollToSnippetId: item.id });
                                    break;
                                case 'openImage':
                                    App.router.navigateTo('article', { id: item.articleId, mode: 'read', scrollToSnippetId: item.id });
                                    break;

                                case 'openPdfArticle':
                                    App.router.navigateTo('article', { id: item.articleId, mode: 'read', scrollToSnippetId: item.id });
                                    break;
                                case 'openFlashcard':
                                    await App.settings.set('flashcardCategory', item.category);
                                    App.router.navigateTo('flashcard');
                                    break;
                                case 'filterNotesByTag':
                                    App.events.showTagModal(item.id);
                                    break;
                            }
                            break;
                    }
                },

                _renderResults(results) {
                    this.els.resultsContainer.innerHTML = '';

                    const isPremium = App.license.isPremium();
                    const searchLimit = 5;

                    // RATIONALE: Changed from .push() to .unshift() to make the premium message the FIRST item.
                    if (!isPremium && results.length > searchLimit) {
                        results = results.slice(0, searchLimit);
                        results.unshift({
                            type: 'premium-upsell',
                            title: 'Unlock Ultimate Search',
                            category: App.util.getRandomMessage(App.util.wittyDeveloperMessages),
                            icon: App.util.getTierBadgeHTML('Diamond', 24)
                        });
                    }

                    if (this.els.input.value && results.length === 0) {
                        this.els.resultsContainer.innerHTML = `<div class="no-results-item">No results found.</div>`; return;
                    }


                    results.forEach((item, index) => {
                        const itemEl = document.createElement('div');
                        itemEl.className = 'search-result-item';
                        itemEl.dataset.index = index;

                        let icon, title, category;
                        if (item.type === 'ai_result') {
                            icon = item.icon;
                            title = `<div style="white-space: pre-wrap; line-height: 1.6;">${item.title}</div>`; // <-- The fix is removing App.util.escapeHtml()
                            category = item.category;
                            itemEl.addEventListener('click', () => {
                                this._saveKashAskResult(item.prompt, item.response);
                            });
                        } else if (item.type === 'command' || item.type === 'suggestion') {
                            icon = item.type === 'command' ? '' : '';
                            title = item.displayText;
                            category = item.categoryText;
                        } else if (item.type === 'premium-upsell') {
                            icon = item.icon;
                            title = item.title;
                            category = item.category;
                        } else if (item.type === 'navigate') {
                            icon = item.icon;
                            title = item.name;
                            category = 'Navigation Command';
                        } else {
                            const icons = {
                                note: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>`,
                                pdf: App.util.icons.pdf,
                                task: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><path d="m9 12 2 2 4-4"></path></svg>`,
                                flashcard: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg>`,
                                tag: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M2 2v4.586a1 1 0 0 0 .293.707l7 7a1 1 0 0 0 1.414 0l4.586-4.586a1 1 0 0 0 0-1.414l-7-7A1 1 0 0 0 7.586 2H2zm1 5.586 7 7L15.586 9l-7-7H3v4.586z"></path><path d="M5 5a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"></path></svg>`,
                                'tag-snippet': `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12.586 2.586a2 2 0 0 0-2.828 0L2.172 10.172a2 2 0 0 0 0 2.828l7.414 7.414a2 2 0 0 0 2.828 0l7.414-7.414a2 2 0 0 0 0-2.828L12.586 2.586z"></path><line x1="9" y1="9" x2="9.01" y2="9"></line></svg>`,
                                snippet: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 21h18M7 12v4h10v-4M5 12V3h14v9M11 3h2"></path></svg>`,
                                image: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>`
                            };
                            icon = icons[item.type] || '';
                            category = (item.type === 'image' || item.type === 'tag-snippet')
                                ? `Image in: ${App.storage.getArticle(item.articleId)?.title || 'Unknown'}`
                                : item.type;

                            if (item.type === 'image') {
                                title = `<div class="search-result-image-wrapper">
                                        <img src="${item.src}" alt="Image snippet">
                                        ${item.title ? `<div class="search-result-caption">${App.util.escapeHtml(item.title)}</div>` : ''}
                                    </div>`;
                            } else if ((item.type === 'snippet' || item.type === 'tag-snippet') && item.html) {
                                title = item.html;
                            } else if (item.type === 'tag') {
                                title = `<span class="rendered-tag">${item.title}</span>`;
                            } else if (item.type === 'flashcard') {
                                // Use our new cleaning utility for a beautiful display
                                title = App.util.escapeHtml(App.util.cleanFlashcardTextForDisplay(item.title));
                            } else {
                                title = App.util.escapeHtml(item.title);
                            }
                        }

                        itemEl.innerHTML = `<div class="result-icon">${icon}</div><div class="result-content"><div class="result-text">${title}</div><div class="result-category">${category}</div></div>`;

                        if (item.type === 'premium-upsell') {
                            itemEl.classList.add('selected');
                            itemEl.addEventListener('click', () => { App.ui.showAscensionModal(); this.closeSearch(); });
                        } else if (item.type !== 'suggestion') {
                            itemEl.addEventListener('click', () => { this.selectedIndex = index; this.executeAction(this.results[this.selectedIndex]); });
                        } else {
                            itemEl.style.opacity = '0.7';
                            itemEl.style.cursor = 'default';
                        }
                        this.els.resultsContainer.appendChild(itemEl);
                    });

                    if (results.length > 0) {
                        this.selectedIndex = 0;
                        this._updateSelection();
                    }
                },

                _handleKeyDown(e) {
                    if (this.els.overlay.classList.contains('hidden')) return;

                    // NEW: kashask logic takes priority on Enter key
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const query = this.els.input.value.trim();
                        if (query.toLowerCase().startsWith('kashask:')) {
                            this._executeKashAsk(query);
                            return;
                        }
                    }
                    if (e.key === 'Tab') {
                        if (this.selectedIndex !== -1 && this.results[this.selectedIndex]?.type === 'ai_result') {
                            e.preventDefault(); // Prevent default browser behavior for Tab
                            const selectedItem = this.results[this.selectedIndex];
                            this._saveKashAskResult(selectedItem.prompt, selectedItem.response);
                            return;
                        }
                    }

                    if (e.key === 'Escape') { this.closeSearch(); }
                    else if (e.key === 'ArrowDown') { e.preventDefault(); if (this.selectedIndex < this.results.length - 1) { this.selectedIndex++; this._updateSelection(); } }
                    else if (e.key === 'ArrowUp') { e.preventDefault(); if (this.selectedIndex > 0) { this.selectedIndex--; this._updateSelection(); } }
                    else if (e.key === 'Enter') { // This part remains for other searches
                        e.preventDefault();
                        if (this.selectedIndex !== -1 && this.results[this.selectedIndex]) {
                            this.executeAction(this.results[this.selectedIndex]);
                        }
                    }
                },

                _executeKashAsk: async function (fullQuery) {
                    const prompt = fullQuery.substring(8).trim();
                    if (!prompt) {
                        App.ui.showToast("Please enter a question after 'kashask:'.", "warning");
                        return;
                    }

                    this.results = [{ type: 'suggestion', displayText: 'Your Second Brain is thinking...', categoryText: 'Please wait a moment.' }];
                    this._renderResults(this.results);

                    try {
                        const systemPrompt = "You are a knowledgeable and adaptive assistant. Analyze the users prompt/question/query carefully and respond while Acting as Subject Expert of that field.  Use clear, natural language that fits the users intent  concise for short factual queries, detailed for conceptual or how-to questions. You may freely choose the best structure (<p>, <b>, <i>, <ul>, <ol>, <li>, <small>) depending on context, you can also use revision tables (in html) wherever required and other things too. Always keep answers accurate, readable, in-depth and directly Useful. The final output must be reliable, stylish looking HTML ready for display. CRITICAL RULE: Your entire response must ONLY be HTML content itself. DO NOT include ```html, markdown fences, or any text outside of the HTML tags..";
                        const aiResponse = await App.services.ai.queryGenerativeAI(systemPrompt, prompt);

                        if (!aiResponse || !aiResponse.trim()) {
                            throw new Error("AI returned an empty response.");
                        }

                        const cleanedResponse = aiResponse.trim().replace(/(\r\n|\n|\r)/gm, "");

                        this.results = [{
                            type: 'ai_result',
                            title: cleanedResponse, // <-- Use the cleaned response
                            category: 'Click or Press Tab to save as New Note',
                            icon: '',
                            prompt: prompt,
                            response: cleanedResponse // <-- Use the cleaned response here too
                        }];
                        this._renderResults(this.results);
                        this.selectedIndex = 0;
                        this._updateSelection();

                    } catch (error) {
                        console.error("KashAsk execution error:", error);
                        App.ui.showToast(`AI query failed: ${error.message}`, "error");
                        this.results = [{ type: 'suggestion', displayText: 'Sorry, the AI query failed.', categoryText: 'Please check your API key or try again.' }];
                        this._renderResults(this.results);
                    }
                },

                _saveKashAskResult: async function (prompt, response) {
                    try {
                        const category = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                        const noteData = {
                            title: prompt,
                            content: `<p>${response.replace(/\n/g, '</p><p>')}</p>`, // Convert newlines to paragraphs
                            category: category
                        };
                        const newNote = await App.storage.createArticle(noteData);
                        if (newNote) {
                            App.ui.showToast('Saved Article', 'success');

                            if (App.router.getActiveView() === 'library') {

                                App.ui.filterAndRenderArticles();
                            }
                            this.closeSearch();
                        } else {
                            throw new Error("Failed to create the article file.");
                        }
                    } catch (error) {
                        console.error("Failed to save KashAsk result:", error);
                        App.ui.showToast('Error saving the note.', 'error');
                    }
                },

                // --- DATA BINDING: Checkbox Listener ---
                _initCheckboxListener() {
                    const articleContent = document.getElementById('article-content');
                    if (!articleContent) return;

                    articleContent.addEventListener('change', async (e) => {
                        if (e.target.matches('input[type="checkbox"]')) {
                            // Only apply in Read/Stage/Focus modes (where content isn't editable directly)
                            if (App.state.currentMode === 'write') return;

                            const id = App.state.activeArticleId;
                            const article = App.storage.getArticle(id);
                            if (!article) return;

                            const allCheckboxes = Array.from(articleContent.querySelectorAll('input[type="checkbox"]'));
                            const index = allCheckboxes.indexOf(e.target);

                            if (index > -1) {
                                // Find N-th checkbox in source content and update it
                                let matchIndex = -1;
                                const regex = /<input[^>]+type=["']checkbox["'][^>]*>/gi;
                                let occurrence = 0;

                                const newContent = article.content.replace(regex, (match) => {
                                    if (occurrence === index) {
                                        const isChecked = e.target.checked;
                                        if (isChecked) {
                                            if (!match.includes('checked')) {
                                                return match.replace(/>$/, ' checked>');
                                            }
                                        } else {
                                            return match.replace(/ checked(=["']?checked["']?)?/i, '');
                                        }
                                        return match;
                                    }
                                    occurrence++;
                                    return match;
                                });

                                if (newContent !== article.content) {
                                    // Save quietly
                                    await App.events.saveArticle({ content: newContent, isAutosave: true });
                                    // Make sure we update the in-memory article so subsequent clicks work on fresh data
                                    article.content = newContent;
                                }
                            }
                        }
                    });
                },

                _updateSelection() {
                    const items = this.els.resultsContainer.querySelectorAll('.search-result-item');
                    items.forEach((item, index) => {
                        item.classList.toggle('selected', index === this.selectedIndex);
                        if (index === this.selectedIndex) item.scrollIntoView({ block: 'nearest' });
                    });
                },
            },


        };

        document.addEventListener('DOMContentLoaded', () => {
            const handleResize = () => {
                const isMobile = window.innerWidth <= 612; // Optimized for maximum density before switching
                document.body.classList.toggle('mobile-view', isMobile);
            };
            window.addEventListener('resize', handleResize);
            handleResize(); // Initial check

            if (App.splitScreen.handleSplitMode()) {
            }
            App.init();
            App.globalSearch.init();
            App.commandPalette.init();
            App.whiteboard.init();
            App.coPilot.init();
            App.globalSearch._initCheckboxListener(); // Using globalSearch object as carrier (awkward but safe context) OR just init directly?


            if (App.ui.aiMagicModal) App.ui.aiMagicModal.init();

            // --- GLOBAL MAP CONTROL LISTENER (Fix for Read Mode Fullscreen) ---
            document.addEventListener('click', (e) => {
                const mapBtn = e.target.closest('.nk-map-btn');
                if (mapBtn && (document.body.classList.contains('read-mode') || document.body.contains(mapBtn))) {
                    let action = mapBtn.dataset.action;
                    if (!action) {
                        const title = mapBtn.getAttribute('title') || '';
                        if (title.includes('Fullscreen') || title.includes('Exit Fullscreen')) action = 'fullscreen';
                        else if (title.includes('Edit')) action = 'edit';
                        else if (title.includes('Remove')) action = 'delete';
                        else if (mapBtn.classList.contains('is-delete')) action = 'delete';
                    }

                    if (action && typeof App.handleMapAction === 'function') {
                        // Mock event to satisfy handleMapAction's dependence on currentTarget
                        const mockEvent = {
                            preventDefault: () => { e.preventDefault(); },
                            stopPropagation: () => { e.stopPropagation(); },
                            currentTarget: mapBtn,
                            target: e.target
                        };
                        App.handleMapAction(mockEvent, action);
                    }
                }
            });
        });


    </script>

    <div id="global-search-overlay" class="hidden">
        <div id="global-search-modal">
            <div class="search-input-wrapper">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
                <textarea id="global-search-input" placeholder="Search or create notes, tasks, flashcards and tags..."
                    rows="1"></textarea>
            </div>
            <div id="global-search-results"></div>
            <div class="search-footer">
                <span> to navigate</span>
                <span> to select</span>
                <span>ESC to close</span>
            </div>
        </div>
    </div>
    <div id="command-palette" role="dialog" aria-modal="true" style="display: none;">
        <div id="command-palette-input-wrapper">
            <input type="text" id="command-palette-input" placeholder="Type a command or search..." autocomplete="off">
        </div>
        <div id="command-palette-list"></div>
    </div>
    <div id="ascension-modal-backdrop" class="modal-backdrop" style="display: none;">
        <div class="modal-content ascension-modal ui-card">
            <button class="modal-close-btn" onclick="App.ui.closeAscensionModal()">&times;</button>
            <div id="ascension-witty-message" class="witty-gradient-text"></div>

            <h4>Choose Your Ascension</h4>
            <div class="ascension-badges-container">
            </div>

            <div class="ascension-features">
                <h5>Unlock Your Full Potential:</h5>
                <ul>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            class="bi bi-check-circle-fill" viewBox="0 0 16 16">
                            <path
                                d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z" />
                        </svg> Unlimited Notes & Flashcards</li>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            class="bi bi-check-circle-fill" viewBox="0 0 16 16">
                            <path
                                d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z" />
                        </svg> Unlimited Search Results</li>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            class="bi bi-check-circle-fill" viewBox="0 0 16 16">
                            <path
                                d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z" />
                        </svg> Advanced Pro Commands</li>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            class="bi bi-check-circle-fill" viewBox="0 0 16 16">
                            <path
                                d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z" />
                        </svg> All Export Options (PDF, MD)</li>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            class="bi bi-check-circle-fill" viewBox="0 0 16 16">
                            <path
                                d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z" />
                        </svg> All Themes & Fonts</li>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            class="bi bi-check-circle-fill" viewBox="0 0 16 16">
                            <path
                                d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z" />
                        </svg> Automatic Cloud Sync</li>
                </ul>
            </div>
            <div class="ascension-footer">
                <a href="#" id="ascension-contact-link">Prefer to Donate or Get the Discount? Contact me
                    directly.</a>
            </div>
        </div>
    </div>
    <button id="kash-copilot-toggle" class="btn-icon" title="Toggle Kash Co-Pilot (Alt+A)" style="display: none;">
    </button>
    <div id="kash-copilot-sidebar" class="ui-card" style="display: none;">
        <div id="copilot-resize-handle"></div>
        <div id="copilot-header">
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <button class="btn-icon" onclick="App.coPilot.clearConversation()" title="Clear Conversation">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                        viewBox="0 0 16 16">
                        <path
                            d="M2.5 1a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1H3v9a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V4h.5a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H10a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1H2.5zM8 5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7A.5.5 0 0 1 8 5zm3 .5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 1 0z" />
                    </svg>
                </button>
                <button class="btn-icon" onclick="App.coPilot.saveConversationAsNote()"
                    title="Save Conversation as New Note">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                        viewBox="0 0 16 16">
                        <path
                            d="M8.5 6.5a.5.5 0 0 0-1 0V8H6a.5.5 0 0 0 0 1h1.5v1.5a.5.5 0 0 0 1 0V9H10a.5.5 0 0 0 0-1H8.5V6.5z" />
                        <path
                            d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z" />
                    </svg>
                </button>
            </div>
            <span class="witty-gradient-text">NoteKash AI</span>
            <button class="btn-icon" onclick="App.coPilot.toggle()" title="Close Co-Pilot (Esc)">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div id="copilot-conversation-area">
        </div>
        <div id="copilot-input-container">
            <div id="copilot-command-list" class="context-menu"
                style="display: none; bottom: 100%; width: 95%; left: 2.5%; margin-bottom: 5px;"></div>
            <textarea id="copilot-input" placeholder="Anyting in your mind..." rows="1"></textarea>
            <button id="copilot-send-btn" class="btn-icon btn-primary" title="Send (Enter)">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16">
                    <path
                        d="M15.854.146a.5.5 0 0 1 .11.54l-5.819 14.547a.75.75 0 0 1-1.329.124l-3.178-4.995L.643 7.184a.75.75 0 0 1 .124-1.33L15.314.037a.5.5 0 0 1 .54.11zM6.636 10.07l2.761 4.338L14.13 2.576 6.636 10.07zm6.787-8.201L1.591 6.602l4.339 2.76 7.494-7.493z" />
                </svg>
            </button>
        </div>
    </div>



    <script>
        // Map Interaction Handler
        if (typeof App !== 'undefined') {
            App.handleMapAction = function (event, action) {
                event.preventDefault();
                event.stopPropagation();
                const btn = event.currentTarget.closest('.nk-map-btn'); // Robust selector
                const container = btn.closest('.nk-map-embed');
                const iframe = container.querySelector('iframe');

                if (action === 'delete') {
                    // Custom Confirm Modal
                    const modalId = `confirm-modal-${Date.now()}`;
                    const modalHTML = `
                    <div id="${modalId}" class="modal-backdrop" style="animation: fadeIn 0.2s ease-out; z-index: 20000; background-color: rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; position:fixed; top:0; left:0; width:100%; height:100%;">
                        <div class="modal-content ui-card" style="max-width: 400px; width:90%; transform-origin: center center; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); background: var(--bg-secondary); padding: 20px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                            <h3 style="margin-top:0; margin-bottom: 10px;">Remove Map?</h3>
                            <p style="margin-bottom: 20px; opacity: 0.8;">Are you sure you want to remove this map from your note?</p>
                            <div class="modal-buttons" style="margin-top: 0; display:flex; justify-content: flex-end; gap: 10px;">
                                <button class="btn btn-secondary" id="${modalId}-cancel">Cancel</button>
                                <button class="btn btn-primary" id="${modalId}-confirm" style="background: var(--danger-color); border-color: var(--danger-color);">Remove</button>
                            </div>
                        </div>
                    </div>`;

                    document.body.insertAdjacentHTML('beforeend', modalHTML);
                    const modalEl = document.getElementById(modalId);
                    const cancelBtn = document.getElementById(`${modalId}-cancel`);
                    const confirmBtn = document.getElementById(`${modalId}-confirm`);

                    const cleanup = () => modalEl.remove();

                    confirmBtn.onclick = () => {
                        // Check if we are in fullscreen (reparented) mode
                        const placeholderId = container.dataset.placeholderId;
                        if (placeholderId) {
                            const placeholder = document.getElementById(placeholderId);
                            if (placeholder) {
                                // Remove the placeholder from the flow
                                if (placeholder.nextElementSibling && placeholder.nextElementSibling.tagName === 'P' && placeholder.nextElementSibling.textContent.trim() === '') {
                                    placeholder.nextElementSibling.remove();
                                }
                                placeholder.remove();
                            }
                        } else {
                            // Standard removal
                            if (container.nextElementSibling && container.nextElementSibling.tagName === 'P' && container.nextElementSibling.textContent.trim() === '') {
                                container.nextElementSibling.remove();
                            }
                        }

                        container.remove();
                        App.state.isArticleDirty = true;
                        App.ui.showToast('Map removed.', { type: 'success' });
                        cleanup();
                    };

                    cancelBtn.onclick = cleanup;
                    modalEl.onclick = (e) => { if (e.target === modalEl) cleanup(); };

                } else if (action === 'fullscreen') {
                    // Theater Mode (In-Window Fullscreen via Reparenting)
                    const isFullscreen = container.classList.contains('is-viewport-fullscreen');
                    const icon = btn.querySelector('i');

                    if (isFullscreen) {
                        const placeholderId = container.dataset.placeholderId;
                        const placeholder = document.getElementById(placeholderId);

                        if (placeholder) {
                            placeholder.replaceWith(container);
                        } else {
                            console.warn("Map placeholder missing, leaving map at body root.");
                        }

                        container.classList.remove('is-viewport-fullscreen');
                        delete container.dataset.placeholderId;

                        // Update Icon
                        icon.classList.replace('fa-compress', 'fa-expand');
                        btn.title = "Toggle Fullscreen";
                        container.style.zIndex = '';

                    } else {
                        // ENTER Fullscreen
                        // 1. Create placeholder
                        const placeholder = document.createElement('div');
                        placeholder.id = `map-placeholder-${Date.now()}`;
                        placeholder.className = 'nk-map-placeholder';
                        const rect = container.getBoundingClientRect();
                        placeholder.style.width = container.style.width || '100%';
                        placeholder.style.height = container.style.height || rect.height + 'px';
                        placeholder.style.margin = container.style.margin;

                        // 2. Mark container
                        container.dataset.placeholderId = placeholder.id;

                        // 3. Swap
                        container.replaceWith(placeholder);
                        document.body.appendChild(container);

                        // 4. Apply Fixed Styles
                        container.classList.add('is-viewport-fullscreen');

                        icon.classList.replace('fa-expand', 'fa-compress');
                        btn.title = "Exit Fullscreen";
                        container.style.zIndex = '1000000';
                    }

                } else if (action === 'edit') {
                    const currentSrc = iframe.src;
                    const urlMatch = currentSrc.match(/q=([^&]+)/);
                    const currentQuery = urlMatch ? decodeURIComponent(urlMatch[1]) : '';

                    App.ui.showInputModal(
                        "Update Map Location",
                        "Enter city, country, or landmark...",
                        currentQuery,
                        (newLocation) => {
                            if (newLocation && newLocation !== currentQuery) {
                                const newSrc = currentSrc.replace(/q=([^&]+)/, `q=${encodeURIComponent(newLocation)}`);
                                iframe.src = newSrc;
                                App.ui.showToast(`Map updated to: ${newLocation}`, { type: 'success' });
                            }
                        }
                    );
                }
            };
        }
    </script>
</body>

</html