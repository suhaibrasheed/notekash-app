<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NoteKash v2 - Your Second Brain</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#4a5568"/>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Allura&family=Arvo&family=Bitter&family=Cabin&family=Cabin+Sketch&family=Changa+One&family=Cinzel&family=Crimson+Text&family=Dancing+Script&family=Exo+2&family=Fira+Code&family=Great+Vibes&family=Inconsolata&family=Jersey+20&family=Josefin+Sans&family=Kaushan+Script&family=Lato&family=Libre+Baskerville&family=Lobster&family=Merriweather&family=Metal+Mania&family=Montserrat&family=Pacifico&family=Parisienne&family=Patrick+Hand&family=Playfair+Display&family=Protest+Revolution&family=Righteous&family=Roboto&family=Rochester&family=Salsa&family=Satisfy&family=Sofia&family=Source+Code+Pro&family=Special+Elite&family=Syne+Mono&family=Ubuntu&family=Vollkorn&family=Zilla+Slab&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script type="module" src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mozilla/readability@0.5.0/Readability.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KGXNNGWKEX"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-KGXNNGWKEX');
    </script>

    <style>
      /* ==========================================================================
         1. STYLES & THEMING (v2 SUPERTAGS UPDATE)
         ========================================================================== */
        :root {
            /* --- Base & Layout --- */
            --bg-primary: #f8f9fa; --bg-secondary: #ffffff; --bg-tertiary: #e9ecef;
            --bg-primary-rgb: 248, 249, 250; --bg-secondary-rgb: 255, 255, 255;
            --text-primary: #212529; --text-secondary: #6c757d; --text-on-primary: #ffffff;
            --border-color: #dee2e6; --primary-color: #0d9488; --primary-color-hover: #0f766e;
            --primary-color-rgb: 74, 85, 104;
            --shadow: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --danger-color: #dc3545; --danger-color-hover: #b02a37;
            --success-color: #198754; --warning-color: #ffc107; --text-warning: #000;
            --font-body: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            --font-serif: Georgia, 'Times New Roman', Times, serif;
            --font-display: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --spacing-unit: 8px; --border-radius: 8px; --border-radius-lg: 16px;
            --transition-fast: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --article-font-family: Georgia, serif;
            --article-font-size: 1.15rem;
            --article-line-height: 1.7;
            --ui-opacity: 1.0; 
            --blur-intensity: 8px;

            /* --- Light Theme Colors --- */
            --hl-1-bg: #fef08a; --hl-1-border: #facc15; --hl-2-bg: #dcfce7; --hl-2-border: #4ade80; --hl-3-bg: #dceffc; --hl-3-border: #38bdf8; --hl-4-bg: #ffd6d6; --hl-4-border: #f87171; --hl-5-bg: #fae8ff; --hl-5-border: #e879f9; --hl-6-bg: #dcdcff; --hl-6-border: #828ffe;
            --hl-7-bg: #fce7f3; --hl-7-border: #ec4899; /* SuperTag Rendered */
            --hl-text: #1f2937; 
            --text-red: #D32F2F; --text-green: #388E3C; --text-blue: #0f72d5; --text-magenta: #d946ef; /* SuperTag Suggestion */
            --text-orange: #f97316; --text-teal: #11aad5; --text-slate: #877408;
            /* --- Category, SM2 & Hub Colors --- */
            /* --- A. Unified Text Color (Light Theme) --- */
            --category-pill-text: #1f2937; /* A strong, dark gray for all light-theme pills */
            /* --- B. Indexed Background Palette (Light Theme) --- */
            --cat-color-0-bg: #f3f4f6;  /* Light Gray */
            --cat-color-1-bg: #a7f3d0;  /* Vibrant Mint */
            --cat-color-2-bg: #fed7aa;  /* Soft Amber */
            --cat-color-3-bg: #c7d2fe;  /* Periwinkle */
            --cat-color-4-bg: #bfdbfe;  /* Sky Blue */
            --cat-color-5-bg: #fecaca;  /* Soft Rose */
            --cat-color-6-bg: #bae6fd;  /* Powder Blue */
            --cat-color-7-bg: #d9f99d;  /* Bright Lime */
            --cat-color-8-bg: #fef08a;  /* Sunny Yellow */
            --cat-color-9-bg: #e9d5ff;  /* Light Lilac */
            --cat-color-10-bg: #fbcfe8; /* Pastel Pink */
            --cat-color-11-bg: #e2e8f0; /* Slate */
            --cat-color-12-bg: #d1d5db; /* Cool Gray */
            --cat-color-13-bg: #fda4af; /* Coral */
            --cat-color-14-bg: #86efac; /* Jade */
            --cat-color-15-bg: #fbbf24; /* Golden */
            --cat-color-16-bg: #a5b4fc; /* Indigo Pastel */
            --cat-color-17-bg: #f472b6; /* Hot Pink */
            --cat-color-18-bg: #99f6e4; /* Aqua */
            --cat-color-19-bg: #fde68a; /* Gold */
            --action-button-gradient: linear-gradient(135deg, #14b8a6, #0d9488);



            --sm2-red: #a3002e;
            --sm2-orange: #f87355;
            --sm2-purple: #a855f7;
            --sm2-skyblue: #43c1f8;
            --sm2-green: #22c55e;
            --sm2-unrated: #adb5bd;
            --text-on-sm2: #ffffff;
            --priority-high: #dc3545; --priority-medium: #0d6efd; --priority-low: #198754;
            --pomo-color-1: #ef4444; --pomo-color-2: #f97316; --pomo-color-3: #f59e0b; --pomo-color-4: #eab308; --pomo-color-5: #84cc16; --pomo-color-6: #22c55e; --pomo-color-7: #10b981; --pomo-color-8: #14b8a6; --pomo-color-9: #06b6d4; --pomo-color-10: #3b82f6; --pomo-color-11: #6366f1; --pomo-color-12: #8b5cf6;
            --cycle-color-1: #3b82f6; --cycle-color-2: #16a34a; --cycle-color-3: #f97316; --cycle-color-4: #8b5cf6; --break-color: #0891b2;
            --heat-0: var(--bg-tertiary); --heat-1: #6c757d; --heat-2: #ef4444; --heat-3: #f97316; --heat-4: #8b5cf6; --heat-5: #3b82f6; --heat-6: #22c55e;
            
            /* --- Flashcard Base --- */
            --cloze-bg: rgba(187, 247, 208, 0.5); --cloze-border: #28a745;
            --cloze-revealed-text: #388E3C; --cloze-hidden-text: #D32F2F;
            
            /* --- Visual Map Base --- */
            --node-text-color: #343a40;
            --node-category: #fd7e14; --node-tag: #0d6efd; --node-article: #198754; --node-orphan: #6c757d;
            --node-article-duplicate: #20c997;
            --search-highlight-bg: #f59e0b;
            --mindmap-snippet-bg: #fef08a; --mindmap-snippet-border: #facc15;
            /* --- Read Counter Progression --- */
            --rc-0-gray: #adb5bd;    /* 0 reads */
            --rc-1-red: #d90429;     /* 1 read */
            --rc-2-orange: #f46d43;  /* 2 reads */
            --rc-3-pink: #ec4899;    /* 3 reads */
            --rc-4-purple: #a855f7;  /* 4 reads */
            --rc-5-indigo: #6366f1;  /* 5 reads */
            --rc-6-teal: #14b8a6;    /* 6 reads */
            --rc-7-green-light: #a3e635; /* 7 reads */
            --rc-8-green-med: #22c55e;   /* 8 reads */
            --rc-9-green-bright: #15803d;/* 9 reads */
            --rc-10-green-best: #059669; /* 10+ reads */
            /* --- Mindmap Palettes Light --- */
            --mindmap-c1-root: #d00000; --mindmap-c1-child-bg: #ffcdd2; --mindmap-c1-child-text: #212529;
            --mindmap-c2-root: #4361ee; --mindmap-c2-child-bg: #e3f2fd; --mindmap-c2-child-text: #212529;
            --mindmap-c3-root: #55a630; --mindmap-c3-child-bg: #e8f5e9; --mindmap-c3-child-text: #212529;
            --mindmap-c4-root: #f77f00; --mindmap-c4-child-bg: #fff3e0; --mindmap-c4-child-text: #212529;
            --mindmap-c5-root: #7209b7; --mindmap-c5-child-bg: #f3e5f5; --mindmap-c5-child-text: #212529;
            --mindmap-c6-root: #00897b; --mindmap-c6-child-bg: #e0f2f1; --mindmap-c6-child-text: #212529;
            --mindmap-c7-root: #d81b60; --mindmap-c7-child-bg: #f8bbd0; --mindmap-c7-child-text: #212529;
            --mindmap-c8-root: #039be5; --mindmap-c8-child-bg: #b3e5fc; --mindmap-c8-child-text: #212529;
            --mindmap-c9-root: #e65100; --mindmap-c9-child-bg: #ffccbc; --mindmap-c9-child-text: #212529;
            --mindmap-c10-root: #5e35b1; --mindmap-c10-child-bg: #d1c4e9; --mindmap-c10-child-text: #212529;
            --mindmap-c11-root: #37474f; --mindmap-c11-child-bg: #cfd8dc; --mindmap-c11-child-text: #212529;
            --mindmap-c12-root: #c2185b; --mindmap-c12-child-bg: #f48fb1; --mindmap-c12-child-text: #212529;
            --mindmap-c13-root: #00796b; --mindmap-c13-child-bg: #b2dfdb; --mindmap-c13-child-text: #212529;
            --mindmap-c14-root: #afb42b; --mindmap-c14-child-bg: #f0f4c3; --mindmap-c14-child-text: #212529;
            --mindmap-c15-root: #f57c00; --mindmap-c15-child-bg: #ffe0b2; --mindmap-c15-child-text: #212529;
            
            /* --- Sticky Notes Light --- */
            --sticky-light-default-bg: #ffffff;      --sticky-light-default-text: #212529;
            --sticky-light-crimson-bg: #fee2e2;      --sticky-light-crimson-text: #7f1d1d;
            --sticky-light-tangerine-bg: #ffedd5;    --sticky-light-tangerine-text: #7c2d12;
            --sticky-light-sunflower-bg: #fef9c3;    --sticky-light-sunflower-text: #713f12;
            --sticky-light-lime-bg: #ecfccb;       --sticky-light-lime-text: #365314;
            --sticky-light-forest-bg: #dcfce7;      --sticky-light-forest-text: #14532d;
            --sticky-light-azure-bg: #e0f2fe;      --sticky-light-azure-text: #0c4a6e;
            --sticky-light-indigo-bg: #e0e7ff;      --sticky-light-indigo-text: #312e81;
            --sticky-light-amethyst-bg: #f5d0fe;    --sticky-light-amethyst-text: #6b21a8;
            --sticky-light-lavender-bg: #f3e8ff;    --sticky-light-lavender-text: #581c87;
            --sticky-light-fuchsia-bg: #fce7f3;     --sticky-light-fuchsia-text: #831843;
            --sticky-light-blush-bg: #fff1f2;       --sticky-light-blush-text: #9f1239;
            --sticky-light-terracotta-bg: #fae8ff;  --sticky-light-terracotta-text: #701a75;
            --sticky-light-teal-bg: #d6feec;       --sticky-light-teal-text: #115e59;
            --sticky-light-slate-bg: #f1f5f9;       --sticky-light-slate-text: #1e293b;
            --sticky-light-olive-bg: #f7fee7;      --sticky-light-olive-text: #3f6212;

            /* NEW: Text Tile Colors (Light Theme) */
            --textile-light-bg-1: #f3e8ff; --textile-light-border-1: #d8b4fe;  /* 1. Lavender */
            --textile-light-bg-2: #dcfce7; --textile-light-border-2: #86efac;  /* 2. Mint */
            --textile-light-bg-3: #fef9c3; --textile-light-border-3: #fde047;  /* 3. Sun */
            --textile-light-bg-4: #fee2e2; --textile-light-border-4: #fca5a5;  /* 4. Rose */
            --textile-light-bg-5: #e0f2fe; --textile-light-border-5: #7dd3fc;  /* 5. Sky */
            --textile-light-bg-6: #fed7aa; --textile-light-border-6: #fb923c;  /* 6. Amber */
            --textile-light-bg-7: #e5e7eb; --textile-light-border-7: #9ca3af;  /* 7. Stone */
            --textile-light-bg-8: #fecaca; --textile-light-border-8: #f87171;  /* 8. Crimson */
            --textile-light-bg-9: #c7d2fe; --textile-light-border-9: #818cf8;  /* 9. Indigo */
            --textile-light-bg-10: #bbf7d0; --textile-light-border-10: #4ade80; /* 10. Jade */
            /* Special Ghost/Outline styles */
            --textile-light-ghost-1: #a855f7; /* Ghost Purple */
            --textile-light-ghost-2: #059669; /* Ghost Green */

            /* --- NEW: Unified Article Font System --- */
            :is(
                /* Core Content & Titles */
                .library-title, .card-title, .article-title-input, .focus-mode-title,
                /* All Snippet & Content Containers */
                .snippet, .flashcard-tile-content, .study-card-content-box,
                .focus-mode-body, .result-text, .sticky-note-content,
                .mindmap-node .node-html-content,
                /* Special Block Components */
                .nk-text-tile-content, .nk-accordion-title, .nk-accordion-content,
                .nk-timeline-title, .nk-timeline-date, .nk-mcq-question, .nk-mcq-option-text,
                /* Metadata & Placeholders */
                .article-metadata-bar, .card-footer, [placeholder],
                /* Content-based Pills & Buttons */
                .category-chip, .flashcard-view-header .btn, .tag-item,
                /* Visualizations */
                .node-text,               /* Visual Map node labels */
                .sticky-note-header h5,   /* Sticky Note titles */
                /* Upsell Cards */
                .upsell-content, .upsell-cta, .premium-cta-text,
                /*Tag modal */
                .tag-modal h3,                 
                .tag-modal-article-title,
                /* Productivity & Notifications */
                .task-title, .pomodoro-task-title, .notification-header, .notification-message,
                .ascension-modal .witty-gradient-text
            ) {
                font-family: var(--article-font-family);
            }
            :is(
                #library-view,
                #flashcard-view,
                #tags-view,
                #category-view,
                .pomodoro-meta,
                .ascension-modal
            ) :is(.btn, .category-chip, .tag-item, .ascension-card) {
                font-family: var(--article-font-family);
            }
             /*  UI Font Override System */
            :is(
                .btn, .text-input, select,
                .modal-content h3, .ascension-card-name,
                .ascension-card-duration, .ascension-features,
                .license-form-grid label,
                header, .article-controls, .stage-mode-controls
            ) {
                font-family: var(--font-body);
            }
            flashcard-tile-content {
                font-size: calc(var(--article-font-size) * 0.9);
            }
            .node-text { 
                font-size: calc(var(--article-font-size) * 0.6);
            }
            .snippet {
                font-size: calc(var(--article-font-size) * 0.95);
            }
            .sticky-note-content {
                font-size: calc(var(--article-font-size) * 0.6);
            }


        }
        [data-theme="dark"] {
            --bg-primary: #0D1117; --bg-secondary: #161B22; --bg-tertiary: #21262D;
            --bg-primary-rgb: 13, 17, 23; --bg-secondary-rgb: 22, 27, 34;
            --text-primary: #e7e5cf; --text-secondary: #8B949E;
            --border-color: #30363D; --primary-color: #E0B453; --primary-color-hover: #F7C96D;
            --primary-color-rgb: 88, 166, 255;
            --shadow: 0 4px 12px rgba(0,0,0,0.2); --danger-color: #f87171; --danger-color-hover: #ef4444;
            --success-color: #22c55e; --warning-color: #f59e0b;
            --hl-text: #f9fafb;
            --hl-1-bg: #503C11; --hl-1-border: #daa724; --hl-2-bg: #1c492e; --hl-2-border: #1ebb58; --hl-3-bg: #161c93; --hl-3-border: #307df7; --hl-4-bg: #7f1d1d; --hl-4-border: #cc3737; --hl-5-bg: #581c87; --hl-5-border: #9347da; --hl-6-bg: #0c5876; --hl-6-border: #0b8fcd;
            --hl-7-bg: #581c87; --hl-7-border: #d946ef; /* SuperTag Rendered */
            --text-red: #ff5555; --text-green: #86efac; --text-blue: #5fa2fb; --text-magenta: #fe70f2; /* SuperTag Suggestion */
            --text-orange: #f6a054; --text-teal: #0fd7ff; --text-slate: #fcf006;
            --cat-tags: #f8f9fa; --cat-science: #22d3ee; --cat-society: #a78bfa; --cat-history: #fb923c; --cat-geography: #34d399; --cat-opinion: #1c65aa; --cat-misc: #90a4ae;
            --cloze-bg: rgba(22, 101, 52, 0.4); --cloze-border: #28a745;
            --cloze-revealed-text: #6ee7b7; --cloze-hidden-text: #fca5a5;
            --sm2-unrated: #6b7280;
            --priority-high: #f87171; --priority-medium: #60a5fa; --priority-low: #34d399;
            --cycle-color-1: #60a5fa; --cycle-color-2: #34d399; --cycle-color-3: #fb923c; --cycle-color-4: #a78bfa; --break-color: #22d3ee;
            --heat-0: #374151; --heat-1: #9ca3af; --heat-2: #f87171; --heat-3: #fb923c; --heat-4: #a78bfa; --heat-5: #60a5fa; --heat-6: #34d399;
            /* --- A. Unified Text Color (Dark Theme) --- */
            --category-pill-text: #f0f6fc; /* A bright, almost-white for all dark-theme pills */

            /* --- B. Indexed Background Palette (Dark Theme) --- */
            --cat-color-0-bg: #4b5563;  /* Gray */
            --cat-color-1-bg: #059669;  /* Emerald */
            --cat-color-2-bg: #b45309;  /* Amber */
            --cat-color-3-bg: #6d28d9;  /* Violet */
            --cat-color-4-bg: #2563eb;  /* Blue */
            --cat-color-5-bg: #be123c;  /* Rose */
            --cat-color-6-bg: #0e7490;  /* Cyan */
            --cat-color-7-bg: #4d7c0f;  /* Lime */
            --cat-color-8-bg: #d97706;  /* Golden */
            --cat-color-9-bg: #a21caf;  /* Fuchsia */
            --cat-color-10-bg: #7e22ce; /* Purple */
            --cat-color-11-bg: #1e40af; /* Indigo */
            --cat-color-12-bg: #374151; /* Slate */
            --cat-color-13-bg: #991b1b; /* Red */
            --cat-color-14-bg: #166534; /* Green */
            --cat-color-15-bg: #9a3412; /* Orange */
            --cat-color-16-bg: #4338ca; /* Indigo Dark */
            --cat-color-17-bg: #9d174d; /* Pink Dark */
            --cat-color-18-bg: #0f766e; /* Teal Dark */
            --cat-color-19-bg: #b45309; /* Amber Dark */
            --action-button-gradient: linear-gradient(45deg, #E0B453, #E6845E, #C159A1);


            /* --- Visual Map Dark --- */
            --node-text-color: #c9d1d9;
            --node-category: #f59e0b; --node-tag: #58a6ff; --node-article: #2ea043; --node-orphan: #8B949E;
            --node-article-duplicate: #39d353;
            --mindmap-snippet-bg: #4d441d; --mindmap-snippet-border: #a16207;

            /* --- Read Counter Progression --- */
            --rc-0-gray: #6b7280;
            --rc-1-red: #f87171;
            --rc-2-orange: #fb923c;
            --rc-3-pink: #f472b6;
            --rc-4-purple: #c084fc;
            --rc-5-indigo: #818cf8;
            --rc-6-teal: #2dd4bf;
            --rc-7-green-light: #bef264;
            --rc-8-green-med: #4ade80;
            --rc-9-green-bright: #22c55e;
            --rc-10-green-best: #34d399;
            /* --- Mindmap Palettes Dark --- */
            --mindmap-c1-root: #ff4d6d; --mindmap-c1-child-bg: #4d1924; --mindmap-c1-child-text: #f0f6fc;
            --mindmap-c2-root: #58a6ff; --mindmap-c2-child-bg: #1d3c5a; --mindmap-c2-child-text: #f0f6fc;
            --mindmap-c3-root: #39d353; --mindmap-c3-child-bg: #1a4d4a; --mindmap-c3-child-text: #f0f6fc;
            --mindmap-c4-root: #f59e0b; --mindmap-c4-child-bg: #6b320a; --mindmap-c4-child-text: #f0f6fc;
            --mindmap-c5-root: #c37aff; --mindmap-c5-child-bg: #3a2a5a; --mindmap-c5-child-text: #f0f6fc;
            --mindmap-c6-root: #48e9d9; --mindmap-c6-child-bg: #0a5246; --mindmap-c6-child-text: #f0f6fc;
            --mindmap-c7-root: #f06292; --mindmap-c7-child-bg: #5c1a35; --mindmap-c7-child-text: #f0f6fc;
            --mindmap-c8-root: #4fc3f7; --mindmap-c8-child-bg: #014664; --mindmap-c8-child-text: #f0f6fc;
            --mindmap-c9-root: #ff9800; --mindmap-c9-child-bg: #663c00; --mindmap-c9-child-text: #f0f6fc;
            --mindmap-c10-root: #9575cd; --mindmap-c10-child-bg: #322550; --mindmap-c10-child-text: #f0f6fc;
            --mindmap-c11-root: #90a4ae; --mindmap-c11-child-bg: #2c3336; --mindmap-c11-child-text: #f0f6fc;
            --mindmap-c12-root: #ec407a; --mindmap-c12-child-bg: #5d1930; --mindmap-c12-child-text: #f0f6fc;
            --mindmap-c13-root: #26a69a; --mindmap-c13-child-bg: #003d36; --mindmap-c13-child-text: #f0f6fc;
            --mindmap-c14-root: #d4e157; --mindmap-c14-child-bg: #525722; --mindmap-c14-child-text: #f0f6fc;
            --mindmap-c15-root: #ffa726; --mindmap-c15-child-bg: #66420f; --mindmap-c15-child-text: #f0f6fc;

            /* --- Sticky Notes Dark --- */
            --sticky-dark-default-bg: #1D2229;         --sticky-dark-default-text: #f0f6fc;
            --sticky-dark-crimson-bg: #450a0a;         --sticky-dark-crimson-text: #fecaca;
            --sticky-dark-tangerine-bg: #431407;       --sticky-dark-tangerine-text: #ffedd5;
            --sticky-dark-sunflower-bg: #422006;       --sticky-dark-sunflower-text: #fef08a;
            --sticky-dark-lime-bg: #1a2e05;         --sticky-dark-lime-text: #d9f99d;
            --sticky-dark-forest-bg: #062813;         --sticky-dark-forest-text: #dcfce7;
            --sticky-dark-azure-bg: #082f49;         --sticky-dark-azure-text: #e0f2fe;
            --sticky-dark-indigo-bg: #1e1b4b;         --sticky-dark-indigo-text: #c7d2fe;
            --sticky-dark-amethyst-bg: #2e1046;       --sticky-dark-amethyst-text: #f5d0fe;
            --sticky-dark-lavender-bg: #3b0764;       --sticky-dark-lavender-text: #f3e8ff;
            --sticky-dark-fuchsia-bg: #500724;         --sticky-dark-fuchsia-text: #fbcfe8;
            --sticky-dark-blush-bg: #581c22;         --sticky-dark-blush-text: #fff1f2;
            --sticky-dark-terracotta-bg: #4a044e;      --sticky-dark-terracotta-text: #fae8ff;
            --sticky-dark-teal-bg: #042f2e;         --sticky-dark-teal-text: #ccfbf1;
            --sticky-dark-slate-bg: #334155;         --sticky-dark-slate-text: #f1f5f9;
            --sticky-dark-olive-bg: #1c3202;         --sticky-dark-olive-text: #e7f5d0;


            /* NEW: Text Tile Colors (Dark Theme) */
            --textile-dark-bg-1: #2e1046; --textile-dark-border-1: #c084fc;   /* 1. Lavender */
            --textile-dark-bg-2: #163322; --textile-dark-border-2: #4ade80;   /* 2. Mint */
            --textile-dark-bg-3: #422006; --textile-dark-border-3: #facc15;   /* 3. Sun */
            --textile-dark-bg-4: #450a0a; --textile-dark-border-4: #f87171;   /* 4. Rose */
            --textile-dark-bg-5: #1e293b; --textile-dark-border-5: #38bdf8;   /* 5. Sky */
            --textile-dark-bg-6: #431407; --textile-dark-border-6: #f97316;   /* 6. Amber */
            --textile-dark-bg-7: #374151; --textile-dark-border-7: #9ca3af;   /* 7. Stone */
            --textile-dark-bg-8: #450a0a; --textile-dark-border-8: #ef4444;   /* 8. Crimson */
            --textile-dark-bg-9: #1e1b4b; --textile-dark-border-9: #6366f1;   /* 9. Indigo */
            --textile-dark-bg-10: #062813; --textile-dark-border-10: #22c55e; /* 10. Jade */
            /* Special Ghost/Outline styles */
            --textile-dark-ghost-1: #c084fc; /* Ghost Purple */
            --textile-dark-ghost-2: #6ee7b7; /* Ghost Green */

        }
        
        [data-theme="sepia"] {
            --bg-primary: #f4e9d8; --bg-secondary: #fbf0d9; --bg-tertiary: #e9dbbf;
            --bg-primary-rgb: 244, 233, 216; --bg-secondary-rgb: 251, 240, 217;
            --text-primary: #5b4636; --text-secondary: #7a6a57;
            --border-color: #dcd0b3; --primary-color: #8c6d46; --primary-color-hover: #73552a;
            --primary-color-rgb: 140, 109, 70;
            --shadow: 0 2px 8px rgba(91, 70, 54, 0.1); --danger-color: #c76a6a; --danger-color-hover: #a14949;
            --hl-text: #2c2a1a;
            --hl-1-bg: #fde68a; --hl-1-border: #eab308; --hl-2-bg: #bbf7d0; --hl-2-border: #15803d; --hl-3-bg: #c4ddfc; --hl-3-border: #1d4ed8;; --hl-4-bg: #fecaca; --hl-4-border: #ef4444; --hl-5-bg: #e9d5ff; --hl-5-border: #8b27e3; --hl-6-bg: #a3eff9; --hl-6-border: #07bada;
            --hl-7-bg: #fae8ff; --hl-7-border: #e879f9; /* SuperTag Rendered */
            --text-red: #ab0404; --text-green: #15803d; --text-blue: #2563eb; --text-magenta: #a855f7; /* SuperTag Suggestion */
            --text-orange: #e0550a; --text-teal: #0db9ee; --text-slate: #ab940f;
            --cloze-bg: rgba(204, 238, 204, 0.5); --cloze-border: #28a745;
            --cloze-revealed-text: #166534; --cloze-hidden-text: #c2410c;
            --sm2-unrated: #a89a84;
            --sticky-sepia-default: #fbf0d9;
            /* --- A. Unified Text Color (Sepia Theme) --- */
            --category-pill-text: #442d1e; /* A rich, dark brown for all sepia-theme pills */

            /* --- B. Indexed Background Palette (Sepia Theme) --- */
            --cat-color-0-bg: #d7ccc8;  /* Brown Gray */
            --cat-color-1-bg: #a5d6a7;  /* Muted Green */
            --cat-color-2-bg: #ffcc80;  /* Muted Orange */
            --cat-color-3-bg: #b39ddb;  /* Muted Purple */
            --cat-color-4-bg: #90caf9;  /* Muted Blue */
            --cat-color-5-bg: #ef9a9a;  /* Muted Red */
            --cat-color-6-bg: #80deea;  /* Muted Cyan */
            --cat-color-7-bg: #c5e1a5;  /* Muted Lime */
            --cat-color-8-bg: #ffe082;  /* Muted Yellow */
            --cat-color-9-bg: #ce93d8;  /* Muted Lilac */
            --cat-color-10-bg: #f48fb1; /* Muted Pink */
            --cat-color-11-bg: #b0bec5; /* Blue Gray */
            --cat-color-12-bg: #a1887f; /* Warm Gray */
            --cat-color-13-bg: #ef5350; /* Terracotta */
            --cat-color-14-bg: #66bb6a; /* Sage */
            --cat-color-15-bg: #ffa726; /* Marigold */
            --cat-color-16-bg: #7986cb; /* Periwinkle */
            --cat-color-17-bg: #ec407a; /* Raspberry */
            --cat-color-18-bg: #26a69a; /* Jade */
            --cat-color-19-bg: #ffca28; /* Goldenrod */
            --action-button-gradient: linear-gradient(45deg, #8c6d46, #704214);


            /* NEW: Text Tile Colors (Sepia Theme) */
            --textile-sepia-bg-1: #f5d0fe; --textile-sepia-border-1: #a855f7;   /* 1. Lavender */
            --textile-sepia-bg-2: #d1fae5; --textile-sepia-border-2: #34d399;   /* 2. Mint */
            --textile-sepia-bg-3: #fef3c7; --textile-sepia-border-3: #f59e0b;   /* 3. Sun */
            --textile-sepia-bg-4: #fee2e2; --textile-sepia-border-4: #ef4444;   /* 4. Rose */
            --textile-sepia-bg-5: #e0e7f2; --textile-sepia-border-5: #60a5fa;   /* 5. Sky */
            --textile-sepia-bg-6: #ffedd5; --textile-sepia-border-6: #ea580c;   /* 6. Amber */
            --textile-sepia-bg-7: #e5e7eb; --textile-sepia-border-7: #9ca3af;   /* 7. Stone */
            --textile-sepia-bg-8: #fee2e2; --textile-sepia-border-8: #dc2626;   /* 8. Crimson */
            --textile-sepia-bg-9: #e0e7ff; --textile-sepia-border-9: #4f46e5;   /* 9. Indigo */
            --textile-sepia-bg-10: #dcfce7; --textile-sepia-border-10: #16a34a; /* 10. Jade */
            /* Special Ghost/Outline styles */
            --textile-sepia-ghost-1: #9333ea; /* Ghost Purple */
            --textile-sepia-ghost-2: #059669; /* Ghost Green */
        }
        [data-theme="sepia"] .sticky-note-tile.color-default {
             background-color: var(--sticky-sepia-default);
        }
        /* Hover effect over icons */
        [data-theme="light"] header .btn-icon {
            color: #6c757d; /* Standard secondary text color */
            transition: color 0.2s ease-in-out;
        }
        [data-theme="light"] header .btn-icon:hover {
            color: var(--primary-color); /* Glow with the new Emerald Green on hover */
        }

        [data-theme="dark"] header .btn-icon {
            color: #9ca3af; /* A brighter gray for better visibility */
            transition: color 0.2s ease-in-out;
        }
        [data-theme="dark"] header .btn-icon:hover {
            color: var(--primary-color); /* Glow with the new gold color on hover */
        }
        [data-theme="sepia"] header .btn-icon {
            color: #9a6729; /* Standard secondary text color */
            transition: color 0.2s ease-in-out;
        }
        [data-theme="sepia"] header .btn-icon:hover {
            color: #af6000; /* Glow with the primary khaki color on hover */
        }


        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 10px; border: 2px solid var(--bg-primary); }
        ::-webkit-scrollbar-thumb:hover { background-color: var(--text-secondary); }

        :root.zero-opacity-active[data-theme="light"] .modal-backdrop .ui-card,
        :root.zero-opacity-active[data-theme="sepia"] .modal-backdrop .ui-card {
            --text-primary: #f8f9fa;
            --text-secondary: #adb5bd;
            --border-color: #495057;
            --primary-color: #79B8FF;
        }

        :root.zero-opacity-active[data-theme="light"] .modal-backdrop .ui-card .text-input,
        :root.zero-opacity-active[data-theme="sepia"] .modal-backdrop .ui-card .text-input {
            background-color: rgba(0, 0, 0, 0.2);
            border-color: var(--border-color);
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideUp {
            from { opacity: 0; transform: translateX(-50%) translateY(5px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        @keyframes growInFromCenter {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        @keyframes slideOutRight { from { opacity: 1; transform: translateX(0); } to { opacity: 0.5; transform: translateX(40px); } }
        .task-item.exiting { animation: slideOutRight 0.4s ease-out forwards; }
        @keyframes confetti-blast { 0% { opacity: 1; transform: translateY(0) rotate(0deg); } 100% { opacity: 0; transform: translateY(100px) rotate(360deg); } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .spin { animation: spin 1s linear infinite; }
        #app-background { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1; background-size: cover; background-position: center; transition: background-image 0.5s ease-in-out; }
        body.image-theme-active { --bg-primary: transparent; }
        .ui-card { background-color: rgba(var(--bg-secondary-rgb), var(--ui-opacity)); backdrop-filter: blur(var(--blur-intensity)); -webkit-backdrop-filter: blur(var(--blur-intensity)); transition: background-color 0.2s, backdrop-filter 0.2s; border-radius: var(--border-radius); }
        
        #the-line-container { position: fixed; top: 0; left: 0; width: 100%; height: 3px; z-index: 10000; background-color: var(--bg-tertiary); }
        #the-line { width: 100%; height: 100%; background-color: var(--primary-color); transform-origin: left; transform: scaleX(0); transition: transform 0.2s linear; }
        * { box-sizing: border-box; }
        [data-theme="light"] #the-line {
            background: linear-gradient(90deg, #FF8C42 0%, #FFD05A 35%, #00A896 55%, #A2E869 75%, #05A387 100%);
        }
        [data-theme="dark"] #the-line {
            background: linear-gradient(90deg, #E0B453 0%, #E6845E 50%, #C159A1 100%);
        }
        [data-theme="sepia"] #the-line {
            background: linear-gradient(90deg, #8c6d46 0%, #C2A582 50%, #704214 100%);
        }


        html { scroll-behavior: smooth; }
        .view.active { padding: 1rem; }
        .article-grid { gap: calc(var(--spacing-unit) * 2.5); }
        .container { max-width: 100%; margin: 0 auto; padding: calc(var(--spacing-unit) * 4); }
        .view { display: none; }
        .view.active { display: block; animation: fadeIn 0.3s ease-in-out; }
        .header-main-actions { display: flex; align-items: center; gap: 4px; }
        .header-actions { display: flex; align-items: center; gap: 4px; }
        .hidden { display: none !important; }
        .btn { padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5); border-radius: var(--border-radius); border: 1px solid transparent; font-weight: 500; font-size: 0.9rem; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        .btn:disabled { cursor: not-allowed; opacity: 0.6; }
        .btn:focus-visible { outline: 2px solid var(--primary-color); outline-offset: 2px; }
        .btn-primary { background-color: var(--primary-color); color: var(--text-on-primary); }
        .btn-primary:hover:not(:disabled) { background-color: var(--primary-color-hover); transform: translateY(-1px); }
        .btn-danger { background-color: var(--danger-color); color: var(--text-on-primary); }
        .btn-danger:hover { background-color: var(--danger-color-hover); }
        .btn-secondary { background-color: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); }
        .btn-secondary:hover:not(:disabled) { background-color: color-mix(in srgb, var(--border-color) 50%, var(--bg-tertiary)); }
        .btn-icon { background: none; border: none; color: var(--text-secondary); cursor: pointer; padding: 5px; border-radius: 50%; width: 36px; height: 36px; position: relative; }
        .btn-icon:hover { background-color: var(--bg-tertiary); color: var(--text-primary); }
        .btn-icon.btn-primary { background-color: var(--primary-color); color: var(--text-on-primary); }
        .btn-icon.btn-primary:hover:not(:disabled) { background-color: var(--primary-color-hover); }
        .text-input { width: 100%; padding: 10px 14px; font-size: 0.9rem; border-radius: var(--border-radius); border: 1px solid var(--border-color); background-color: var(--bg-secondary); color: var(--text-primary); transition: border-color 0.2s, box-shadow 0.2s; }
        .text-input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-color) 20%, transparent); }
        .text-input:read-only { background-color: var(--bg-tertiary); }
        
        .btn-icon.is-disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .category-pill {
            padding: 4px 12px;
            border-radius: 9999px; 
            font-weight: 600; 
            font-size: 0.9rem; 
            color: var(--category-pill-text); 
            display: inline-flex;
            align-items: center;
            white-space: nowrap;
            transition: background-color 0.2s ease-in-out; 
        }
         
                
        #install-pwa-btn { display: none; }
        .welcome-container { text-align: center; max-width: 600px; margin: 5rem auto; padding: 2rem; }
        .welcome-actions { display: flex; flex-direction: column; align-items: center; gap: 1rem; margin-top: 1rem; }
        .library-main { max-width: 1400px; margin: 0 auto; display: flex; flex-direction: column; gap: 16px; }
        .library-title { font-family: var(--font-display); font-size: 3rem; text-align: center; margin: 0; background: linear-gradient(45deg, #4facfe, #00f2fe); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .library-header a { text-decoration: none; color: inherit; }
        [data-theme="light"] .library-title {
            background: linear-gradient(45deg, #FF8C42, #FFD05A, #00A896, #A2E869, #05A387);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        [data-theme="dark"] .library-title {
            background: linear-gradient(45deg, #E0B453, #E6845E, #C159A1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        [data-theme="sepia"] .library-title, .focus-mode-title {
            background: linear-gradient(45deg, #8c6d46, #704214);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .search-and-filter-bar { display: flex; gap: 1.25rem; align-items: center; }
        
        .search-bar-container { position: relative; flex-grow: 1; }
        #search-input, #flashcard-search-input, #tag-search-input { width: 100%; padding: 12px 16px 12px 40px; font-size: 1rem; border-radius: 9999px; border: 1px solid var(--border-color); background-color: var(--bg-secondary); color: var(--text-primary); transition: border-color 0.2s, box-shadow 0.2s;}
        #search-input:focus, #flashcard-search-input:focus, #tag-search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }
        .search-bar-container svg { position: absolute; top: 50%; left: 12px; transform: translateY(-50%); color: var(--text-secondary); }
        #search-hint { font-size: 0.8rem; color: var(--text-secondary); height: 1.2em; text-align: left; padding-left: 8px; margin-top: 4px; }
        .category-filters { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: -6px; align-items: center; }
        .category-chip { padding: 4px 12px; border-radius: 18px; font-size: 0.9rem; font-weight: 600; border: 1px solid transparent; cursor: pointer; transition: all 0.2s; }
        .category-chip:hover { transform: translateY(-2px); box-shadow: var(--shadow); filter: brightness(1.1); }
        /* NEW: Unified styling for All, Tags, & Flash buttons (Gradient Text) */
        .category-action-btn {
            background: var(--action-button-gradient);
            color: #FFFFFF; /* High-contrast white text */
            -webkit-text-fill-color: initial; /* Ensure text color is not transparent */
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4); /* Crisper shadow for legibility */
            border: 1px solid rgba(0, 0, 0, 0.15);
            font-weight: 700;
            transition: all 0.2s ease-in-out;
        }
        
        .category-action-btn:hover {
            border-color: rgba(0, 0, 0, 0.25);
            box-shadow: 0 0 15px rgba(var(--primary-color-rgb), 0.4);
            filter: brightness(1.1);
            transform: translateY(-2px);
        }
       /* === REFINED: Active Flashcard Category Pill === */
        #flashcard-view .category-filters .category-chip {
            transition: all 0.2s ease-in-out; /* Keep the smooth transition */
        }
        #flashcard-view .category-filters .category-chip.active {
            transform: scale(1.05);
            box-shadow: 0 0 12px 2px color-mix(in srgb, var(--primary-color) 40%, transparent);
            border: 1.5px solid var(--primary-color);
        }
        #flashcard-view .category-filters .category-chip.active[onclick*="'All'"] {
            background-color: var(--primary-color) !important; /* Use !important to override inline styles */
            color: var(--text-on-primary) !important;
        }
        /* FIX: Unify all category filter button heights */
        .category-filters .category-chip,
        .category-filters .category-pill {
            padding: 8px 14px; 
            font-size: 1rem;  
            height: auto;    
        }            


        #article-grid-container { position: relative; min-height: 40vh; }
        .article-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: calc(var(--spacing-unit) * 2); }
        .article-card { padding: calc(var(--spacing-unit) * 2); border-left: 5px solid transparent; transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s, background-color 0.2s; cursor: pointer; display: flex; flex-direction: column; }
        .article-card:hover, .article-card:focus-visible { transform: translateY(-3px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); outline: 2px solid var(--border-color); outline-offset: 2px; }
        .article-card:focus { outline: none; }

        /* --- New Library Search Interaction Styles --- */
        .article-card.search-highlight-card {
            /* A static, subtle border for all matches */
            border-left-width: 6px;
            border-left-color: rgba(var(--primary-color-rgb), 0.8) !important;
        }
        .article-card.search-selected-card {
            /* A prominent, solid highlight for the active selection */
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 0 15px 3px rgba(var(--primary-color-rgb), 0.5);
            border: 3px solid var(--primary-color) !important;
            border-left-width: 5px !important;
        }

        .card-category-badge { padding: 4px 10px; border-radius: 12px; font-size: 0.80rem; font-weight: 700; }
        .library-premium-card .card-category-badge {
            align-self: flex-start;
            margin-bottom: 3px;
        }
        .card-header-info {
            display: flex;
            align-items: center;
            justify-content: space-between; 
            margin-bottom: 8px;
        }
        .card-read-count-badge {
            padding: 4px 10px; 
            border-radius: 12px; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-on-sm2);
            flex-shrink: 0;
        }
        .card-title { margin: 0 0 auto; font-family: var(--font-serif); font-size: 1.2rem; }
        .card-footer { font-size: 0.8rem; color: var(--text-secondary); margin-top: 12px; display: flex; flex-wrap: wrap; gap: 3.5px; justify-content: space-between; width: 100%; }
        .card-tag-chip { background-color: var(--bg-tertiary); color: var(--text-secondary); padding: 2px 8px; border-radius: 10px; font-size: 0.7rem; }
        .card-word-count, .card-date {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .article-view-wrapper { display: flex; justify-content: center; font-family: var(--article-font-family); font-size: var(--article-font-size); position: relative; }
        .article-container { width: 100%; max-width: 95vw; padding: 2rem 2rem 20vh 2rem; }
        body.fullscreen-active .article-container { max-width: 100%; padding: 1rem }
        .article-title-input { font-size: 1.75em; font-weight: 700; font-family: var(--font-serif); width: 100%; border: none; background: transparent; padding: 0; margin-bottom: 0; color: var(--text-primary); outline: none; border-left: 3px solid transparent; padding-left: 0.3em; transition: border-color 0.3s; }
        .article-title-input:focus { border-left-color: var(--primary-color); }
        .title-divider { border: none; border-top: 1px solid var(--border-color); margin: 1.5rem 0; }
        #article-content { line-height: var(--article-line-height); outline: none; min-height: 200px; overflow-x: auto; }
        #article-content p { margin-block-start: 0.5em; margin-block-end: 0.5em; }
        #article-content h2 { font-size: 1.5em; margin-top: 2em; margin-bottom: 1em; }
        #article-content blockquote { border-left: 3px solid var(--primary-color); margin-left: 0; padding-left: 1.5em; color: var(--text-secondary); font-style: italic; }
        #article-content hr { border: none; border-top: 1px solid var(--border-color); margin: 2em 0; }
        body.write-mode #article-content { border-left: 2px solid var(--border-color); padding-left: 1em; transition: border-color 0.3s; scroll-padding-top:30px;  }
        
        body.write-mode #article-content:focus-within { border-left-color: var(--primary-color); }
        #article-content[contenteditable=true].is-empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            pointer-events: none;
        }
        #article-content.drag-over { outline: 2px dashed var(--primary-color); outline-offset: 8px; background-color: rgba(var(--primary-color-rgb), 0.1); }
        #article-content table { width: 100%; border-collapse: separate; border-spacing: 0; margin: 1.5em 0; border: 1px solid var(--border-color); border-radius: var(--border-radius); overflow: hidden; }
        #article-content th, #article-content td { border-bottom: 1px solid var(--border-color); padding: 12px 16px; text-align: left; vertical-align: top; position: relative; }
        #article-content td { border-left: 1px solid var(--border-color); }
        #article-content td:first-child, #article-content th:first-child { border-left: none; }
        #article-content th { background-color: rgba(var(--primary-color-rgb), 0.07); font-weight: 600; }
        #article-content tr:last-child td { border-bottom: none; }
        #article-content td:focus-within, #article-content th:focus-within { background-color: var(--bg-tertiary); position: relative; z-index: 1; outline: 2px solid var(--primary-color); }
        #article-content .tile-box-table { border: none; margin: 1em 0; width: auto; display: inline-block; }
        #article-content .tile-cell { font-weight: bold; background-color: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: var(--border-radius); }
        #article-content ul.bullet-square { list-style-type: square; } 
        #article-content ul.bullet-triangle { list-style-type: 'â–º '; } 
        #article-content ul.bullet-empty-circle { list-style-type: circle; } 
        #article-content ul.bullet-hyphen { list-style-type: '- '; }
        ol[type="a"] { list-style-type: lower-alpha; }
        ul.bullet-empty-circle { list-style-type: circle; }
        body.write-mode #article-content.is-empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            pointer-events: none;
            position: absolute;
        }
        body.write-mode #article-content:focus-within {
            border-left-color: var(--primary-color);
        }

        /* --- NEW --- Fix for Clipped Image Border in Read Mode */
        body.read-mode #article-content {
            padding: 0 0.5em;
        }

        #article-content[contenteditable=true].is-empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            pointer-events: none;
        }
        #article-content a {
            color: var(--primary-color); /* Use the theme's main accent color */
            text-decoration: underline;
            text-decoration-color: color-mix(in srgb, var(--primary-color) 60%, transparent);
            transition: color 0.2s ease-in-out, text-decoration-color 0.2s ease-in-out;
        }
        #article-content a:hover {
            color: var(--primary-color-hover); /* Use the theme's hover color */
            text-decoration-color: var(--primary-color-hover);
        }



        .article-metadata-bar { display: flex; justify-content: space-between; align-items: center; font-size: 0.95rem; color: var(--text-secondary); margin-top: 1rem; margin-bottom: -1rem; transition: opacity 0.3s; }
        .article-view-wrapper[class*="ambiance-"] .article-metadata-bar {
            color: var(--text-primary);
        }
        body.fullscreen-active .article-metadata-bar { display: none; }
        [class^="highlight-"] { padding: 0.1em 0.3em; margin: 0 -0.1em; border-radius: 4px; color: var(--hl-text); border-bottom: 2px solid; }
        .highlight-1 { background-color: var(--hl-1-bg); border-color: var(--hl-1-border); } .highlight-2 { background-color: var(--hl-2-bg); border-color: var(--hl-2-border); } .highlight-3 { background-color: var(--hl-3-bg); border-color: var(--hl-3-border); } .highlight-4 { background-color: var(--hl-4-bg); border-color: var(--hl-4-border); } .highlight-5 { background-color: var(--hl-5-bg); border-color: var(--hl-5-border); } .highlight-6 { background-color: var(--hl-6-bg); border-color: var(--hl-6-border); }
        .highlight-7 { background-color: var(--hl-7-bg); border-color: var(--hl-7-border); } /* SuperTag Rendered */
        .text-red { color: var(--text-red); } .text-green { color: var(--text-green); } .text-blue { color: var(--text-blue); } .text-magenta { color: var(--text-magenta); } /* SuperTag Suggestion */
        .text-orange { color: var(--text-orange); }
        .text-teal { color: var(--text-teal); }
        .text-slate { color: var(--text-slate); }
        
        .text-underline { text-decoration: underline; }
        .rendered-tag { cursor: pointer; background-color: var(--hl-7-bg); padding: 2px 6px; border-radius: 4px; border-bottom: 2px solid var(--hl-7-border); margin: 0 2px; }
        .tag-suggestion { color: var(--text-magenta); border-bottom: 2px dotted var(--text-magenta); padding: 0.1em 0.3em; margin: 0 -0.1em; border-radius: 4px; cursor: pointer; }
        #category-view .rendered-tag,
        .focus-mode-body .rendered-tag, 
        #mindmap-view .rendered-tag {
            display: none !important;
        }

        
        mark.mindmap-snippet { background-color: var(--mindmap-snippet-bg); border-bottom: 2px solid var(--mindmap-snippet-border); }
        #article-content img { max-width: 100%; height: auto; border-radius: var(--border-radius); cursor: pointer; }
        .image-container { position: relative; display: inline-block; }
        .image-container.align-left { float: left; margin-right: 1.5em; margin-bottom: 0.5em; max-width: 50%; }
        .image-container.align-right { float: right; margin-left: 1.5em; margin-bottom: 0.5em; max-width: 50%; }
        .image-container.align-center { display: block; text-align: center; margin: 1em auto; }
        .image-container.align-center img { display: inline-block; }

        .resize-handle { position: absolute; width: 15px; height: 15px; background: var(--primary-color); border: 2px solid var(--bg-secondary); border-radius: 50%; display: none; z-index: 10 }
        .resize-handle-se { bottom: -6px; right: -6px; cursor: se-resize; }
        .image-container.selected .resize-handle { display: block; z-index: 10 }
        .image-container.selected img { outline: 2px solid var(--primary-color); }

        /* --- NEW --- Command Palette Preview Indicator */
        .article-container.is-in-preview-mode {
            outline: 6px dashed var(--danger-color);
            outline-offset: 3px;
        }

           /* --- NEW --- Image Highlighting & Mind Map Styling */
        #article-content .image-container.highlighted-image img {
            /* New "matted" border effect */
            box-shadow: 0 0 0 2px var(--bg-secondary), 0 0 0 4px var(--primary-color);
            filter: contrast(105%);
            border-radius: var(--border-radius);
            transition: all 0.3s ease;
        }
        #article-content .image-container.highlighted-image.selected img {
            box-shadow: 0 0 0 3px var(--bg-secondary), 0 0 0 6px var(--primary-color), 0 0 15px 6px rgba(var(--primary-color-rgb), 0.6);
            outline: none; /* Override the default thin outline to prevent visual clutter */
        }

        /* --- NEW --- Image Highlighting & Mind Map Styling */
        #article-content .image-container.highlighted-image img {
            box-shadow: 0 0 0 2px var(--bg-secondary), 0 0 0 4px var(--primary-color);
            filter: contrast(105%);
            border-radius: var(--border-radius);
            transition: all 0.3s ease;
        }
        #article-content .image-container.highlighted-image.selected img {
            box-shadow: 0 0 0 3px var(--bg-secondary), 0 0 0 6px var(--primary-color), 0 0 15px 6px rgba(var(--primary-color-rgb), 0.6);
            outline: none; 
        }

        .mindmap-node .node-html-content img {
            width: 100%;
            height: 100%;
            object-fit: cover;      
            object-position: center; 
            border-radius: calc(var(--border-radius-lg) - 2px); 
            display: block; 
        }
        .mindmap-node.image-node .node-html-content { 
            padding: 3.5px; 
        }

        
        
        /* --- NEW: Image Caption System (v2.0 ) --- */
       .image-container {
            --caption-align-items: flex-end; /* 'flex-end' for bottom, 'center' for middle, 'flex-start' for top */
        }
        .image-container[data-caption-align="top"] { --caption-align-items: flex-start; }
        .image-container[data-caption-align="middle"] { --caption-align-items: center; }
        .image-container[data-caption-align="bottom"] { --caption-align-items: flex-end; }

        .image-caption {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            align-items: var(--caption-align-items);
            justify-content: center;
            font-family: var(--font-body);
            font-size: 0.95rem;
            line-height: 1.4;
            padding: 12px;
            text-align: center;
            outline: none;
            max-height: 100%;
            overflow-y: auto;
            background-color: transparent;
            pointer-events: none;
            transition: all 0.2s ease;
            box-sizing: border-box;
            color: #ffffff;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 5px rgba(0,0,0,0.7);
        }

        /* === THE 15 CURATED CAPTION THEMES === */
        /* 1. Sharp Light:  */
        .image-container[data-caption-theme="sharp-light"] .image-caption {
            color: #ffffff;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 2px 4px rgba(0,0,0,0.5);
        }
        /* 2. Sharp Dark:*/
        .image-container[data-caption-theme="sharp-dark"] .image-caption {
            color: #111111;
            text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, 0 2px 4px rgba(0,0,0,0.3);
        }
        /* 3. Forest: */
        .image-container[data-caption-theme="forest"] .image-caption {
            color: #14532d; /* dark-green-900 */
            text-shadow: 0 1px 3px rgba(6, 40, 19, 0.9);
        }
        /* 4. Navy:*/
        .image-container[data-caption-theme="navy"] .image-caption {
            color: #1e3a8a; /* dark-blue-900 */
            text-shadow: 0 1px 3px rgba(23, 37, 84, 0.9);
        }
        /* 5. Maroon:  */
        .image-container[data-caption-theme="maroon"] .image-caption {
            color: #cb1c52; /* dark-rose-900 */
            text-shadow: 0 1px 3px rgba(76, 5, 25, 0.9);
        }
        /* 6. Chocolate:  */
        .image-container[data-caption-theme="chocolate"] .image-caption {
            color: #431407; /* dark-orange-950 */
            text-shadow: 0 1px 3px rgba(30, 7, 0, 0.95);
        }
        /* 7. Charcoal:*/
        .image-container[data-caption-theme="charcoal"] .image-caption {
            color: #334155; /* slate-700 */
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }
        /* 8. Sunbeam: */
        .image-container[data-caption-theme="sunbeam"] .image-caption {
            color: #fef08a; /* yellow-200 */
            text-shadow: 0 1px 4px rgba(120, 53, 15, 0.85);
        }
        /* 9. Aqua: */
        .image-container[data-caption-theme="aqua"] .image-caption {
            color: #7dd3fc; /* sky-300 */
            text-shadow: 0 1px 4px rgba(8, 47, 73, 0.9);
        }
        /* 10. Lime: */
        .image-container[data-caption-theme="lime"] .image-caption {
            color: #a3e635; /* lime-400 */
            text-shadow: 0 1px 3px rgba(24, 59, 0, 0.9);
        }
        /* 11. Rose: */
        .image-container[data-caption-theme="rose"] .image-caption {
            color: #fecaca; /* red-200 */
            text-shadow: 0 1px 4px rgba(88, 28, 135, 0.8);
        }
        /* 12. Lavender:*/
        .image-container[data-caption-theme="lavender"] .image-caption {
            color: #e0e7ff; /* indigo-200 */
            text-shadow: 0 1px 4px rgba(49, 46, 129, 0.8);
        }

        /* 13. Soft Glow: */
        .image-container[data-caption-theme="soft-glow"] .image-caption {
            color: #ffffff;
            text-shadow: 0 2px 8px rgba(0,0,0,0.9);
        }
        /* 14. Letterpress: */
        .image-container[data-caption-theme="letterpress"] .image-caption {
            color: #e2e8f0; /* slate-200 */
            text-shadow: 0 -1px 1px rgba(0,0,0,0.7);
        }
        /* 15. Gold Leaf:*/
        .image-container[data-caption-theme="gold-leaf"] .image-caption {
            color: #fffbeb; /* amber-50 */
            text-shadow: 0 0 8px #f59e0b, 0 0 12px rgba(245, 158, 11, 0.5);
        }

        /* --- Editable & Placeholder States (Unchanged) --- */
        .image-caption[contenteditable="true"] {
            background-color: rgba(0, 0, 0, 0.65);
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.7);
            pointer-events: auto;
            cursor: text;
            color: #ffffff !important;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5) !important;
        }
        .image-caption:empty:not([contenteditable="true"])::before {
            content: '';
        }
        .image-caption:empty[contenteditable="true"]::before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }




        /* --- NEW: Image Lightbox Styles --- */
        .lightbox-image-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease-out;
            cursor: grab;
        }
        .lightbox-image {
            max-width: 95vw;
            max-height: 90vh;
            object-fit: contain;
            user-select: none;
            -webkit-user-drag: none;
        }
        .lightbox-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            background-color: rgba(var(--bg-secondary-rgb), 0.8);
            backdrop-filter: blur(8px);
            padding: 0.5rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
        }
        .lightbox-controls .btn-icon {
            background-color: var(--bg-secondary);
        }

        .tags-view-container { padding: 1.5rem; }
        .tag-cloud { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
        .tag-item { cursor: pointer; background-color: var(--bg-tertiary); color: var(--text-secondary); padding: 6px 14px; border-radius: 16px; transition: all 0.2s; font-size: 0.9rem; font-weight: 500; border: 1px solid var(--border-color); }
        .tag-item:hover { background-color: var(--primary-color); color: var(--text-on-primary); transform: scale(1.05); border-color: transparent; }
        .article-tags-display { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border-color); }
        body.fullscreen-active .article-tags-display { display: none; }
        .tag-modal-article-title { font-weight: bold; cursor: pointer; padding: 8px; border-radius: 6px; margin-bottom: 4px; display: flex; justify-content: space-between; align-items: center; }
        .tag-modal-article-title:hover { background-color: var(--bg-tertiary); }
        .tag-modal-body { max-height: 60vh; overflow-y: auto; padding: 4px; }

        /* === Modern Settings UI Overhaul === */
        .settings-nav {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 0.5rem;
            border: none;
        }

        .settings-nav-item {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 12px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            color: var(--text-secondary);
            text-decoration: none;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            position: relative;
            overflow: hidden;
        }

        .settings-nav-item i {
            font-size: 1.1em;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: all 0.25s ease;
            z-index: 2;
        }

        .settings-nav-item span {
            z-index: 2;
        }

        .settings-nav-item:hover:not(.locked) {
            color: var(--text-on-primary);
            transform: scale(1.03);
            box-shadow: 0 4px 15px -5px rgba(var(--primary-color-rgb), 0.5);
        }

        .settings-nav-item:hover:not(.locked) i {
            color: var(--text-on-primary);
        }

        .settings-nav-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--action-button-gradient);
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .settings-nav-item:hover:not(.locked)::before {
            left: 0;
        }

        .settings-nav-item.locked {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .settings-nav-item.locked::after {
            content: 'ðŸ”’';
            margin-left: auto;
            font-size: 1em;
            z-index: 2;
        }
        #modal-container .modal-content {
            background: linear-gradient(145deg, var(--bg-primary), var(--bg-secondary));
            border: 1px solid var(--border-color);
        }
        /* === Modern Form Element Styling (Sub-Settings) === */
        .modal-content h3 {
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1.5rem; /* Add space below the title */
        }

        .modal-content .settings-section:first-of-type {
            border-top: none; /* Removes the second divider line */
            margin-top: 0;
            padding-top: 0;
        }

        .modal-content .settings-section h4 {
            color: var(--primary-color);
            font-weight: 600;
            font-size: 1rem;
            border-bottom: none;
            text-transform: none; /* Softer, more modern headings */
            letter-spacing: 0;
        }

        /* 2. Modern Buttons with a "3D" Feel */
        .modal-content .btn-secondary {
            font-weight: 600;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            border-bottom-width: 3px; /* Creates a subtle 3D edge */
            box-shadow: var(--shadow-sm);
            transition: all 0.15s ease-out;
        }

        .modal-content .btn-secondary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 0 12px -2px color-mix(in srgb, var(--primary-color) 40%, transparent);
            border-color: color-mix(in srgb, var(--primary-color) 50%, var(--border-color));
            background-color: var(--bg-secondary);
        }

        .modal-content .btn-secondary:active:not(:disabled) {
            transform: translateY(1px); /* Pushes the button "down" */
            border-bottom-width: 1px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); /* The "pressed in" effect */
        }

        /* 3. Modern Dropdowns (Select) */
        .modal-content select.btn-secondary {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%236c757d' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.1em;
            padding-right: 2.5rem;
            text-align: left;
        }

        /* 4. Modern Sliders (Range Inputs) */
        .modal-content input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            outline: none;
            transition: background 0.2s;
        }

        .modal-content input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid var(--bg-secondary);
            box-shadow: var(--shadow);
            transition: transform 0.2s ease;
        }

        .modal-content input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .modal-content input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid var(--bg-secondary);
            box-shadow: var(--shadow);
        }

        /* 5. Modern Toggle Switches */
        .modal-content .toggle-switch {
            border-radius: 9999px;
            width: 48px;
            height: 26px;
        }
        .modal-content .toggle-switch::before {
            width: 20px;
            height: 20px;
            top: 2px;
            left: 2px;
            box-shadow: var(--shadow-sm);
        }
        .modal-content .toggle-switch.active::before {
            transform: translateX(22px);
        }

        /* === ELEGANT FLOATING TOOLBAR (v2 POLISH) === */
        .article-controls {
            position: fixed;
            bottom: 0.8rem; 
            left: 50%;
            transform: translateX(-50%); 
            width: auto; 
            display: flex;
            justify-content: center;
            gap: 0; 
            /* Refined Glassmorphism */
            background-color: rgba(var(--bg-secondary-rgb), var(--ui-opacity));
            backdrop-filter: blur(var(--blur-intensity));
            -webkit-backdrop-filter: blur(var(--blur-intensity));

            padding: 4px; /* POLISH: Tighter padding */
            border-radius: 9999px; 
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg); 

            z-index: 1001;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
        }

        .toolbar-wrapper.vertical .control-divider {
            width: 80%; 
            height: 1px;
            margin: 4px auto;
        }
        .controls-wrapper {
            display: none;
            align-items: center;
            gap: 4px; 
        }

        /* --- NEW: Consistent Slider Control Styling --- */
        .slider-control-wrapper {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .slider-control-wrapper input[type="range"] {
            flex-grow: 1;
        }
        .slider-control-wrapper span {
            min-width: 50px; /* Prevents layout shifts as value changes */
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        /* --- Polished Button Styles within the Toolbar --- */
        .article-controls .btn-icon {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: transparent; 
            color: var(--text-secondary);
            transition: all 0.2s ease-in-out;
        }

        .article-controls .btn-icon:hover {
            transform: scale(1.1); 
            background-color: var(--bg-tertiary);
            color: var(--primary-color); 
        }

        /* --- Style for Primary Actions (Edit, Save) --- */
        .article-controls .btn-icon.btn-primary {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            box-shadow: 0 2px 8px -2px rgba(var(--primary-color-rgb), 0.7);
        }

        .article-controls .btn-icon.btn-primary:hover {
            background-color: var(--primary-color-hover);
            color: var(--text-on-primary); /* Keep text color on hover */
        }

        /* Mobile-specific adjustments for the floating bar */
        body.mobile-view .article-controls {
            max-width: 95vw; /* Prevents touching screen edges */
            bottom: 0.5rem; /* A bit closer for easier thumb reach */
            padding: 4px;
        }
        
        
        body.read-mode .read-mode-controls, body.write-mode .write-mode-controls { display: flex; }
        .control-divider { width: 1px; height: 20px; background-color: var(--border-color); }
        .read-count-badge { width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9rem; color: var(--text-on-sm2); cursor: pointer; }
        .done-btn-animated { animation: heart-pop 0.8s ease-in-out; }
        @keyframes heart-pop { 0% { transform: scale(1); } 25% { transform: scale(1.4); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        body.fullscreen-active header, body.fullscreen-active .article-controls { transform: translateY(100%); opacity: 0; pointer-events: none; }
        body.fullscreen-active header { display: none; }
        #focus-mode-toggle { position: fixed; bottom: 1.1rem; right: 1.5rem; z-index: 1002; display: none; animation: fadeIn 0.3s; }
        body.fullscreen-active #focus-mode-toggle { display: block; }
        #focus-mode-toggle.exit-active { animation: slow-pulse 4s infinite; }
        @keyframes slow-pulse { 0%, 100% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.05); opacity: 1; } }
        .category-summary-card { padding: 16px; margin-bottom: 16px; }
        .category-summary-card h3 { display: flex; align-items: center; gap: 12px; }
        .snippet { font-size: 0.95rem; color: var(--text-secondary); border-left: 3px solid var(--border-color); padding-left: 12px; margin: 3px 0; cursor: default; line-height: 1.5; }
        .snippet:hover { background-color: var(--bg-tertiary); }
        .context-menu { position: absolute; z-index: 1005; background-color: var(--bg-secondary); border-radius: var(--border-radius); box-shadow: var(--shadow); padding: 8px; display: flex; flex-direction: column; gap: 4px; border: 1px solid var(--border-color); }
        .context-menu button { background: none; border: none; text-align: left; padding: 8px 12px; width: 100%; cursor: pointer; border-radius: 6px; font-size: 0.9rem; color: var(--text-primary); }
        .context-menu button:hover { background-color: var(--bg-tertiary); }
        .empty-state { display:flex; flex-direction:column; justify-items:center; text-align: center; padding: 3rem 1rem; color: var(--text-secondary); opacity: 0.7; }
        .empty-state svg { display:block; width: 64px; height: 64px; margin: 0 auto 1rem auto; opacity: 0.7; }
        #toast-container { position: fixed; bottom: 20px; right: 20px; z-index: 99999; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; }
        .toast { background-color: #333; color: white; padding: 12px 20px; border-radius: var(--border-radius); box-shadow: var(--shadow-lg); opacity: 0; transform: translateY(20px); transition: all 0.4s ease; font-weight: 500; display: flex; align-items: center; gap: 1rem; line-height: 1.4; max-width: 350px; }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.error { background-color: var(--danger-color); } .toast.success { background-color: var(--success-color); } .toast.warning { background-color: var(--warning-color); color: var(--text-warning); }
        .toast small { opacity: 0.9; font-size: 0.9em; }



        #confetti-toast-container { position: fixed; z-index: 100000; pointer-events: none; }
        .confetti { position: absolute; width: 8px; height: 8px; background-color: var(--primary-color); opacity: 0; animation: confetti-blast 0.8s ease-out forwards; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; justify-content: center; align-items: center; padding: 1rem; animation: fadeIn 0.5s ease; backdrop-filter: blur(8px); }
        .modal-content { padding: 2rem; max-width: 600px; width: 90%; box-shadow: var(--shadow-lg); animation: fadeIn 0.3s ease; }
        .modal-content h3 { margin-top: 0; }
        .modal-buttons { display: flex; justify-content: flex-end; gap: 1rem; margin-top: 1rem; }
        .productivity-modal { max-width: 700px; padding: 0; display: flex; flex-direction: column; height: 85vh; max-height: 700px; }
        .task-filters { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; padding: 0.75rem 1.5rem; border-bottom: 1px solid var(--border-color); background: var(--bg-primary); }
        .task-filters::-webkit-scrollbar { display: none; }
        .task-filters { scrollbar-width: none; -ms-overflow-style: none; }
        .task-filters .btn { padding: 6px 12px; font-size: 0.85rem; width: 100%; }
        .task-filters .btn.active { background-color: var(--primary-color); color: var(--text-on-primary); border-color: var(--primary-color); }
        .task-area { flex-grow: 1; overflow-y: auto; padding: 1rem 1.5rem; display: flex; flex-direction: column; gap: 12px; }
        .task-item { display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: var(--border-radius); transition: var(--transition-fast); background-color: var(--bg-secondary); border-left: 4px solid transparent; }
        .task-item:hover { background-color: var(--bg-tertiary); transform: scale(1.01); }
        .task-item[data-priority="high"] { border-left-color: var(--priority-high); }
        .task-item[data-priority="medium"] { border-left-color: var(--priority-medium); }
        .task-item[data-priority="low"] { border-left-color: var(--priority-low); }
        .task-item.completed { border-left-color: var(--success-color); opacity: 0.8; } 
        .task-item.completed .task-title { text-decoration: line-through; color: var(--success-color); text-decoration-color: var(--success-color); }
        .task-checkbox { width: 20px; height: 20px; flex-shrink: 0; accent-color: var(--primary-color); }
        .task-title { flex-grow: 1; margin-right: 8px; white-space: normal; word-break: break-word; font-size: calc(var(--article-font-size) * 0.9); }
        .task-item.is-backlog { border-left-color: var(--danger-color) !important; }
        .task-item.is-backlog .task-title { color: var(--danger-color); font-weight: 500; }
        .task-meta { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; color: var(--text-secondary); flex-wrap: wrap; }
        .task-meta .due-date.overdue { color: var(--danger-color); font-weight: 500; }
        .task-meta .btn-icon { width: 32px; height: 32px; } .task-meta .btn-icon svg { width: 18px; height: 18px; }
        .task-meta .btn-danger { color: var(--danger-color); }
        .task-meta .btn-danger:hover { color: var(--danger-color-hover); background-color: color-mix(in srgb, var(--danger-color) 15%, transparent); }
        .pomo-counter-display { display: flex; align-items: center; gap: 4px; font-weight: 500; font-size: 0.8rem; background-color: var(--bg-tertiary); padding: 2px 8px; border-radius: 12px; }
        .pomo-counter-display svg { width: 14px; height: 14px; color: var(--primary-color); }
        .task-composer { padding: 12px; border: 1px solid var(--border-color); border-radius: var(--border-radius); margin-bottom: 8px; display: flex; flex-direction: column; gap: 10px; }
        .composer-input-row { display: flex; gap: 8px; align-items: center; }
        .composer-actions-row { display: flex; justify-content: flex-end; align-items: center; flex-wrap: wrap; gap: 10px; }
        .composer-meta-buttons { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
        #composer-date-input { border: 1px solid var(--border-color); background-color: var(--bg-secondary); text-align: center; font-weight: 500; color: var(--text-primary); padding: 6px 10px; border-radius: 6px; font-size: 0.85rem; }
        #composer-date-input:focus { outline: none; box-shadow: 0 0 0 2px var(--primary-color); }
        .priority-btn { border: none; color: var(--text-on-primary); font-size: 0.85rem; padding: 6px 10px; cursor: pointer; border-radius: 6px; font-weight: 500; }
        .priority-btn.high { background-color: var(--priority-high); } .priority-btn.medium { background-color: var(--priority-medium); } .priority-btn.low { background-color: var(--priority-low); }
        #category-select { font-size: 0.85rem; padding: 6px 10px; border-radius: 6px; background-color: var(--bg-secondary); border: 1px solid var(--border-color); color: var(--text-primary); font-weight: 500; }
        #pomo-goal-btn { background-color: var(--bg-secondary); border: 1px solid var(--border-color); color: var(--text-primary); display: flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 6px; font-size: 0.85rem; font-weight: 500; cursor: pointer; }
        #pomo-goal-btn svg { width: 16px; height: 16px; color: var(--primary-color); }
        #add-task-btn { width: 32px; height: 32px; padding-bottom: 8px; border-radius: 50%; flex-shrink: 0; font-size: 1.5rem; font-weight: 400; line-height: 1.2;}
        .pomodoro-section { padding: 1rem 1.5rem; border-top: 1px solid var(--border-color); background: var(--bg-tertiary); display: flex; flex-direction: column; align-items: center; gap: 1rem; }
        .pomodoro-display { position: relative; padding: 10px; border-radius: 12px; width: 100%; display: flex; flex-direction: column; align-items: center; box-shadow: inset 0 2px 4px rgba(0,0,0,0.06); }
        .pomodoro-progress-frame { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .progress-segment { position: absolute; background-color: var(--pomo-color-1); transition: background-color 0.5s ease; }
        .progress-top { top: 0; left: 0; height: 6px; border-radius: 6px 6px 0 0; }
        .progress-right { top: 0; right: 0; width: 6px; border-radius: 0 6px 6px 0; }
        .progress-bottom { bottom: 0; right: 0; height: 6px; border-radius: 0 0 6px 6px; }
        .progress-left { bottom: 0; left: 0; width: 6px; border-radius: 6px 0 0 6px; }
        .pomodoro-time-display { font-size: 3rem; font-weight: 700; line-height: 1; text-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .pomodoro-task-title { font-weight: 500; margin-top: 4px; transition: color 0.5s ease; max-width: 250px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .pomodoro-meta { display: flex; align-items: center; justify-content: center; gap: 8px; margin-top: 8px; }
        .pomodoro-controls { display: flex; gap: 1rem; align-items: center; }
        #pomodoro-settings-popup { display: flex; flex-direction: column; gap: 1rem; background-color: var(--bg-secondary); box-shadow: var(--shadow-lg); border-radius: var(--border-radius); padding: 1.5rem; z-index: 1; animation: slideUp 0.2s; }
        .cycle-pill { color: white; font-weight: 600; font-size: 0.75rem; padding: 3px 10px; border-radius: 16px; transition: background-color 0.3s ease; }
        .cycle-pill[data-cycle="1"] { background-color: var(--cycle-color-1); } .cycle-pill[data-cycle="2"] { background-color: var(--cycle-color-2); } .cycle-pill[data-cycle="3"] { background-color: var(--cycle-color-3); } .cycle-pill[data-cycle="4"] { background-color: var(--cycle-color-4); }
        .break-pill { background-color: var(--break-color); color: white; font-weight: 600; font-size: 0.75rem; padding: 3px 10px; border-radius: 16px; }
        .todo-badge { position: absolute; top: 4px; right: 4px; background-color: var(--danger-color); color: white; font-size: 10px; font-weight: bold; width: 16px; height: 16px; border-radius: 50%; display: flex; align-items: center; justify-content: center; }
        .settings-section { margin-top: 1.5rem; border-top: 1px solid var(--border-color); padding-top: 1.5rem; }
        .settings-section:first-child { margin-top: 0; border-top: none; padding-top: 0; }
        .settings-section h4 { display: flex; align-items: center; gap: 8px; margin-top: 0; margin-bottom: 1rem; color: var(--text-secondary); font-weight: 500; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.05em; }
        .settings-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; }
        .settings-label { display: flex; flex-direction: column; }
        .settings-label b { font-weight: 500; }
        .settings-label small { color: var(--text-secondary); font-size: 0.85rem; word-break: break-all; }
        .settings-grid { display: grid; grid-template-columns: auto 1fr; gap: 1rem; align-items: center; }
        .settings-grid label { font-weight: 500; justify-self: start; }
        .settings-grid .control-span { grid-column: 1 / -1; display: flex; align-items: center; gap: 1rem; }
        .toggle-switch { width: 50px; height: 28px; background: var(--bg-tertiary); border-radius: 14px; position: relative; cursor: pointer; border: 1px solid var(--border-color); }
        .toggle-switch::before { content: ''; position: absolute; width: 22px; height: 22px; border-radius: 50%; background: white; top: 2px; left: 3px; transition: transform 0.2s; }
        .toggle-switch.active { background: var(--primary-color); }
        .toggle-switch.active::before { transform: translateX(21px); }
        .sync-status-dot { width: 10px; height: 10px; border-radius: 50%; background-color: var(--danger-color); transition: background-color 0.3s; }
        .sync-status-dot.active { background-color: var(--success-color); }
        #custom-theme-controls { margin-top: 1.5rem; border-top: 1px solid var(--border-color); padding-top: 1.5rem; display: none; }
        .modal-content.is-custom-theme #custom-theme-controls { display: block; }
        .guide-content { display: none; margin-top: 1rem; max-height: 40vh; overflow-y: auto; padding: 1rem; background-color: var(--bg-primary); border-radius: var(--border-radius); border: 1px solid var(--border-color); }
        .guide-content code { background-color: var(--bg-tertiary); padding: 2px 6px; border-radius: 4px; font-family: monospace; }
        .guide-content ol, .guide-content ul { padding-left: 20px; }
        .guide-content li { margin-bottom: 0.8rem; }
        
        /* === ELEGANT FLOATING TOOLBAR (v2 POLISH) === */
        .toolbar-wrapper {
            display: flex;
            gap: 4px;
            align-items: center;
            padding: 6px;
            background: linear-gradient(145deg, rgba(var(--bg-secondary-rgb), 0.7), rgba(var(--bg-primary-rgb), 0.6));
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 9999px;
            box-shadow: var(--shadow-lg), inset 0 1px 1px rgba(255, 255, 255, 0.1); /* Added inner highlight */
            border: 1px solid color-mix(in srgb, var(--border-color) 60%, transparent); /* Softer border */
        }
        .toolbar-wrapper.vertical {
            flex-direction: column;
            width: auto;
            border-radius: var(--border-radius-lg); /* Softer corner for vertical mode */
        }
        .toolbar-drag-handle {
            cursor: move;
            color: var(--text-secondary);
            padding: 0 4px;
            opacity: 0.6;
            display: flex; /* Ensures SVG inside is centered */
            align-items: center;
        }
        #selection-toolbar .btn-icon {
            width: 34px;
            height: 34px;
            border-radius: 50%; /* Circular buttons inside the pill */
            transition: all 0.2s ease-in-out;
        }
        
        #selection-toolbar .btn-icon:hover {
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-tertiary));
            color: var(--primary-color);
            transform: scale(1.15);
            box-shadow: 0 0 8px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }
      
        #selection-toolbar .highlight-btn {
            width: 28px !important;
            height: 28px !important;
        }
        #ai-magic-btn {
            color: var(--primary-color);
            animation: copilot-glow 4s infinite alternate ease-in-out;

        }
        #ai-magic-btn:hover {
            animation-play-state: paused;
        }
       
        /* Changes for Bullet */
        .list-toolbar-group {
            position: relative;
        }
        .list-popover {
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-bottom: 8px;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            padding: 4px;
            z-index: 1002;
            display: flex;
            visibility: hidden;
            opacity: 0;
            transform: translateX(-50%) translateY(5px);
            transition: all 0.2s ease-out 0.5s;
            transition-property: visibility, opacity, transform;
        }
        .list-toolbar-group:hover .list-popover {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            transition-delay: 0s;
        }
        /* --- NEW: Compact Image Toolbar Styles --- */
        #image-toolbar .toolbar-wrapper {
            padding: 4px; /* Reduced padding for a tighter fit */
        }

        #image-toolbar .btn-icon {
            width: 36px; /* Slightly smaller icons */
            height: 36px;
        }
        /* Changes for Toolbar B,I,U */
        .format-toolbar-group {
            position: relative;
        }
        .format-popover {
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-bottom: 8px;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            padding: 4px;
            z-index: 1002;
            display: flex;
            
            /* --- NEW TRANSITION LOGIC --- */
            visibility: hidden;
            opacity: 0;
            transform: translateX(-50%) translateY(5px);
            transition: visibility 0s linear 0.5s, opacity 0.2s ease-out 0.5s, transform 0.2s ease-out 0.5s;
        }
        
        #format-group:hover .format-popover {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            /* Make it appear instantly on hover */
            transition-delay: 0s;
        }
        .format-popover .btn-icon {
            font-size: 1.2rem;
        }
         
        
        /* Changes for Checkbox */
        .nk-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 0.5em 0;
            cursor: pointer;
        }
        .nk-checkbox-box {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            transition: all 0.2s ease-in-out;
            position: relative;
        }
        .nk-checkbox-text {
            outline: none;
            flex-grow: 1;
            transition: opacity 0.3s ease-in-out;
        }
        .nk-checkbox-wrapper[data-checked="true"] .nk-checkbox-box {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            /* Add these lines for centering */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* The checkmark icon */
        .nk-checkbox-wrapper[data-checked="true"] .nk-checkbox-box::before {
            content: '';
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 3px 3px 0;
            transform: rotate(45deg) translateY(-1px);
        }
        .nk-checkbox-wrapper[data-checked="true"] .nk-checkbox-text {
            opacity: 0.45; 
        }


        #new-article-btn { width: 30px; height: 30px; padding: 0; gap: 3px; border-radius: var(--border-radius); flex-shrink: 0; }
        @keyframes subtle-glow { 0%, 100% { box-shadow: 0 0 4px rgba(96, 165, 250, 0); } 50% { box-shadow: 0 0 12px rgba(96, 165, 250, 0.5); } }
        [data-theme="dark"] #new-article-btn { }
        @keyframes subtle-glow-dark { 0%, 100% { box-shadow: 0 0 4px rgba(147, 197, 253, 0); } 50% { box-shadow: 0 0 12px rgba(147, 197, 253, 0.4); } }
        [data-theme="sepia"] #new-article-btn { }
        @keyframes subtle-glow-sepia { 0%, 100% { box-shadow: 0 0 4px rgba(140, 109, 70, 0); } 50% { box-shadow: 0 0 12px rgba(140, 109, 70, 0.5); } }
        .shortcut-modal-content kbd { background-color: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; padding: 2px 6px; font-family: monospace; }
        .cloze-flashcard { background-color: var(--cloze-bg); border-bottom: 2px dotted var(--cloze-border); padding: 2px 4px; border-radius: 4px; }
        .flashcard-view-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; flex-wrap: wrap; gap: 1rem; }
        .flashcard-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1rem; }
        .flashcard-tile { perspective: 1000px; background-color: transparent; min-height: 165px; border-left: 5px solid; border-radius: var(--border-radius); cursor: pointer; }
        .flashcard-tile-flipper { position: relative; width: 100%; height: 100%; transition: transform 0.7s ease-in-out; transform-style: preserve-3d; }
        .flashcard-tile.is-flipped .flashcard-tile-flipper { transform: rotateY(180deg); }
        .flashcard-tile-face {
            width: 100%;
            height: 100%;
            position: absolute;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            padding: 1rem;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .flashcard-tile-back {
            transform: rotateY(180deg);
        }

        .flashcard-tile-content {
            font-size: 0.95rem;
            line-height: 1.45;
            flex-grow: 1;
            overflow-y: auto;
            position: relative;
            scrollbar-width: none;
            padding-bottom: 30px; 
        }

        .flashcard-tile-content::-webkit-scrollbar {
            display: none;
        }

        .flashcard-tile-footer {
            position: absolute;
            bottom: 8px;
            right: 8px;

            background-color: rgba(var(--bg-secondary-rgb), 0.75);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
            border-radius: var(--border-radius);
            padding: 2px;

            opacity: 0;
            transform: translateY(5px);
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;

            display: flex;
            align-items: center;
            gap: 0;
            z-index: 1; 
           
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        /* RATIONALE: This rule now specifically targets the footer on the VISIBLE front face. */
        .flashcard-tile:hover .flashcard-tile-front .flashcard-tile-footer {
            opacity: 1;
            transform: translateY(0);
        }

        /* RATIONALE: This new rule targets the footer ONLY on the VISIBLE back face when flipped. */
        .flashcard-tile.is-flipped:hover .flashcard-tile-back .flashcard-tile-footer {
            opacity: 1;
            transform: translateY(0);
        }

        .flashcard-tile-footer .btn-icon {
            width: 28px;
            height: 28px;
            color: var(--text-secondary);
            transition: transform 0.15s ease-out, color 0.15s ease-out;
        }

        .flashcard-tile-footer .btn-icon:hover {
            color: var(--primary-color);
            transform: scale(1.15);
        }


        /* --- New Flashcard Search Interaction Styles --- */
        .flashcard-tile.search-highlight-card {
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.5);
        }
        .flashcard-tile.search-selected-card {
            transform: scale(1.03);
            box-shadow: 0 0 15px 3px rgba(var(--primary-color-rgb), 0.6);
            border-left-color: var(--primary-color) !important;
        }
        @media (max-width: 768px) {
            .flashcard-tile-footer {
                opacity: 1;
                transform: none;
                background: transparent;
                backdrop-filter: none;
                -webkit-backdrop-filter: none;
                box-shadow: none;
                border: none;
                padding: 0;
                gap: 4px;
            }

            .flashcard-tile-content {
                padding-bottom: 1px;
                -webkit-mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
                mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
            }

            .flashcard-tile-footer .btn-icon {
                width: 28px;
                height: 28px;
                border-radius: 50%;
                background-color: rgba(var(--bg-secondary-rgb), 0.8);
                box-shadow: var(--shadow-sm);
                border: 1px solid var(--border-color);
            }
            .flashcard-tile-footer .btn-icon:hover {
                color: var(--text-secondary);
                transform: none;
                background-color: rgba(var(--bg-secondary-rgb), 0.8);
            }
        }



        .study-view { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10001; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 1rem; padding-bottom: 120px; }
        .study-background { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-size: cover; background-position: center; }
        .study-content-container { width: 100%; flex-grow: 1; display: flex; align-items: center; justify-content: center; perspective: 1200px; }
        .study-card { width: 100%; height: 100%; max-height: 80vh; position: relative; transform-style: preserve-3d; transition: transform 0.7s ease-in-out; cursor: pointer; }
        .study-card.is-flipped { transform: rotateY(180deg); }
        .study-card-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; justify-content: center; align-items: center; overflow: hidden; }
        .study-card-back { transform: rotateY(180deg); }
        .study-card-content-box { width: 100%; max-width: 90ch; max-height: 100%; overflow-y: auto; padding: 2rem; background-color: var(--bg-secondary); border: 3px solid var(--border-color); border-radius: var(--border-radius); font-size: var(--study-card-font-size, 2.1rem); line-height: 1.5; font-family: var(--font-serif); text-align: left; transition: border-color 0.3s ease; }
        .cloze-hidden { color: var(--cloze-hidden-text); font-weight: bold; }
        .cloze-revealed-wrapper { background-color: var(--cloze-bg); border-radius: 4px; padding: 0.1em 0.3em; margin: 0 -0.1em; }
        .cloze-revealed { color: var(--cloze-revealed-text); font-weight: bold; }
        .study-controls-container { position: fixed; bottom: 0; left: 0; width: 100%; padding: 1rem; display: flex; flex-direction: column; align-items: center; gap: 1rem; background-color: rgba(var(--bg-primary-rgb), 0.8); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); }
        .study-progress-bar { width: 100%; max-width: 400px; height: 8px; -webkit-appearance: none; appearance: none; background-color: var(--bg-tertiary); border-radius: 4px; overflow: hidden; }
        .study-progress-bar::-webkit-progress-bar { background-color: var(--bg-tertiary); }
        .study-progress-bar::-webkit-progress-value { background-color: var(--primary-color); transition: width 0.3s ease; }
        .study-progress-wrapper {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            width: 100%;
            max-width: 400px; /* Match the progress bar's original width */
        }
        .study-progress-wrapper .study-progress-bar {
            flex-grow: 1; /* Allows the bar to fill available space */
        }
        .study-progress-wrapper .study-progress-counter {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-variant-numeric: tabular-nums;
            white-space: nowrap;
        }
        /* === POLISHED FLASHCARD BUTTONS (v9.0 - Glassmorphism) === */
        .study-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 700px;
            gap: 0.25rem;
        }
        .study-nav-and-ratings {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .study-controls .srs-rating-group {
            display: flex;
            gap: 0.5rem;
        }

        /* Base style for the new "frosted glass" buttons */
        .btn-study-rating {
            border: 1px solid rgba(255, 255, 255, 0.3);
            /* The semi-transparent background */
            background-color: rgba(255, 255, 255, 0.15);
            /* The magic for the frosted glass effect */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            /* Pill shape for a modern look */
            border-radius: 9999px;
            padding: 0.75rem 1.25rem;
            font-size: 0.95rem;
            color: var(--text-on-primary); /* White text */
            font-weight: 600; /* Bolder for clarity */
            text-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transition: all 0.2s ease-in-out;
        }

        /* Elegant glow effect on hover */
        .btn-study-rating:hover:not(:disabled) {
            transform: translateY(-2px) scale(1.05);
            background-color: rgba(255, 255, 255, 0.25);
        }
        .btn-again:hover:not(:disabled) { box-shadow: 0 0 15px 2px var(--sm2-red); }
        .btn-hard:hover:not(:disabled) { box-shadow: 0 0 15px 2px var(--sm2-orange); }
        .btn-good:hover:not(:disabled) { box-shadow: 0 0 15px 2px var(--sm2-skyblue); }
        .btn-easy:hover:not(:disabled) { box-shadow: 0 0 15px 2px var(--sm2-green); }
        .btn-hold:hover:not(:disabled) { box-shadow: 0 0 15px 2px var(--sm2-purple); }

        /* The 'pop' animation on click is preserved */
        .btn-study-rating.btn-popped { animation: btn-pop 0.8s ease; }
        @keyframes btn-pop { 0%, 100% { transform: scale(1); } 20% { transform: scale(1.2); } 40% { transform: scale(0.95); } 60% { transform: scale(1.1); } }

        /* The old individual color styles are no longer needed */
        .btn-again, .btn-hard, .btn-hold, .btn-good, .btn-easy {
        background: none; /* We remove the old gradients */
        }

        /* The nav and exit buttons are unchanged */
        .study-controls .btn-icon-nav,
        .study-controls .btn-exit-study {
            width: 35px;
            height: 35px;
            padding: 3px; /* Forces consistent padding */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Prevents shrinking in the flex container */
            transition: var(--transition-fast);
            box-sizing: border-box; /* Ensures border is included in the size */
        }

        /* Individual styles for appearance */
        .study-controls .btn-icon-nav {
            background-color: transparent;
            border: none;
            color: var(--text-secondary);
        }
        .study-controls .btn-exit-study {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary); /* Use primary text color for better visibility */
        }

        /* Hover states remain the same */
        .study-controls .btn-icon-nav:hover:not(:disabled) {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .study-controls .btn-exit-study:hover:not(:disabled) {
            background-color: color-mix(in srgb, var(--danger-color) 10%, var(--bg-tertiary));
            color: var(--danger-color);
            border-color: color-mix(in srgb, var(--danger-color) 40%, var(--border-color));
        }
        .study-controls .btn-icon-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .mcq-controls-right-group { display: flex; align-items: center; gap: 0.75rem; }

        /* FIX #3: Mobile Responsiveness */
        @media (max-width: 680px) {
            .study-controls {
                flex-wrap: wrap; 
                justify-content: space-between;
                align-items: center;
                gap: 6px; 
            }
            .study-controls .srs-rating-group {
                order: 1;
                width: 100%; 
                gap: 4px;
            }
            .btn-study-rating {
                flex-grow: 1; 
                padding: 0.75rem 0.5rem;
                font-size: 0.85rem;
            }
            .study-nav-and-ratings,
            .mcq-controls-right-group {
                order: 2;
            }
            .study-controls .btn-icon-nav,
            .study-controls .btn-exit-study {
                width: 35px;
                height: 35px;
            }
        }
        
        .study-card-content-box.rated-again { border-color: var(--sm2-red); animation: glow-red 1.5s ease; }
        .study-card-content-box.rated-hard { border-color: var(--sm2-orange); animation: glow-orange 1.5s ease; }
        .study-card-content-box.rated-hold { border-color: var(--sm2-purple); animation: glow-purple 1.5s ease; }
        .study-card-content-box.rated-good { border-color: var(--sm2-skyblue); animation: glow-skyblue 1.5s ease; }
        .study-card-content-box.rated-easy { border-color: var(--sm2-green); animation: glow-green 1.5s ease; }
        @keyframes glow-red { 0%, 100% { box-shadow: 0 0 0px var(--sm2-red); } 50% { box-shadow: 0 0 20px var(--sm2-red); } } @keyframes glow-orange { 0%, 100% { box-shadow: 0 0 0px var(--sm2-orange); } 50% { box-shadow: 0 0 20px var(--sm2-orange); } } @keyframes glow-purple { 0%, 100% { box-shadow: 0 0 0px var(--sm2-purple); } 50% { box-shadow: 0 0 20px var(--sm2-purple); } } @keyframes glow-skyblue { 0%, 100% { box-shadow: 0 0 0px var(--sm2-skyblue); } 50% { box-shadow: 0 0 20px var(--sm2-skyblue); } } @keyframes glow-green { 0%, 100% { box-shadow: 0 0 0px var(--sm2-green); } 50% { box-shadow: 0 0 20px var(--sm2-green); } }
        .btn-again { background: linear-gradient(45deg, #C70039, #900C3F); } .btn-hard { background: linear-gradient(45deg, #FF5733, #FF8D1A); } .btn-hold { background: linear-gradient(45deg, var(--sm2-purple), #c084fc); } .btn-good { background: linear-gradient(45deg, var(--sm2-skyblue), #7dd3fc); } .btn-easy { background: linear-gradient(45deg, var(--sm2-green), #4ade80); }
        
        /* CATEGORY SECTIONAL DESIGN */
        /* --- A. The New View Container & Controls (No Change) --- */
        .category-view-container { display: flex; flex-direction: column; gap: 1.5rem; }
        .category-controls-hub { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
        .category-controls-group { display: flex; align-items: center; gap: 0.75rem; }
        .export-dropdown-container { position: relative; display: inline-block; }
        .export-dropdown-menu { position: absolute; top: 100%; right: 0; margin-top: 8px; background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: var(--border-radius); box-shadow: var(--shadow-lg); z-index: 10; display: none; flex-direction: column; gap: 4px; padding: 4px; width: 160px; }
        .export-dropdown-menu.show { display: flex; }
        .export-dropdown-menu .btn { width: 100%; justify-content: flex-start; }

        /* --- B. The "Sectional Card" Component --- */
        .sectional-card { background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: var(--border-radius-lg); padding: 1.25rem 1.5rem; display: flex; flex-direction: column; gap: 0.75rem; transition: all 0.2s ease-in-out; box-shadow: var(--shadow-sm); }
        .sectional-card:hover { transform: translateY(-3px); box-shadow: var(--shadow); border-color: var(--primary-color); }
        .sectional-card-header { display: flex; justify-content: space-between; align-items: center; gap: 1rem; /* FIX #4a: Reduced padding for a more compact title area */ padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); }
        .sectional-card-title { font-size: 1.25rem; font-weight: 600; cursor: pointer; flex-grow: 1; }
        .sectional-card-body { display: flex; flex-direction: column; gap: 0.3rem; }
        
        .snippet { font-size: 1.1rem; color: var(--text-secondary); border-left: 3px solid var(--border-color); padding-left: 8px; margin: 0; cursor: default; }
        .sectional-card-body .snippet .image-container,
        .focus-mode-body .snippet .image-container {
            position: relative;
            display: block;
            overflow: hidden; /* This is crucial */
            border-radius: var(--border-radius-lg); /* A larger, softer radius */
            width: 100%;
            padding-top: 56.25%; /* Enforces a 16:9 aspect ratio */
            background-color: var(--bg-tertiary);
        }

        .sectional-card-body .snippet .image-container img,
        .focus-mode-body .snippet .image-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;  /* Use !important to override inline styles */
            height: 100% !important; /* This ensures the image fills the container */
            object-fit: cover;      /* This is the FIX for the aspect ratio */
            object-position: center;
        }

        /* NEW: Professional styling for the image caption overlay */
        .snippet .image-caption {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            color: white;
            padding: 0.2rem; 
            text-align: center;
            font-size: 0.9rem;
            font-weight: 500;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            pointer-events: none; /* Make it non-interactive in snippets */
            border-bottom-left-radius: var(--border-radius-lg);
            border-bottom-right-radius: var(--border-radius-lg);
        }
        /* --- C. The Highlight Toggle Effect --- */
        .category-view-container.hide-snippet-colors .snippet [class*="highlight-"],
        .category-view-container.hide-snippet-colors .snippet [class*="text-"],
        .focus-mode-body.hide-snippet-colors .snippet [class*="highlight-"],
        .focus-mode-body.hide-snippet-colors .snippet [class*="text-"] {
            background-color: transparent !important;
            border-color: transparent !important;
            color: var(--text-primary) !important;
            transition: all 0.3s ease-in-out;
        }
        

        /* --- D. Layout Toggle Button (No Change) --- */
        .layout-toggle-btn { display: flex; background-color: var(--bg-tertiary); padding: 4px; border-radius: var(--border-radius); border: 1px solid var(--border-color); }
        .layout-toggle-btn .btn-icon { width: 36px; height: 32px; border-radius: 6px; color: var(--text-secondary); }
        .layout-toggle-btn .btn-icon.active { background-color: var(--bg-secondary); color: var(--primary-color); box-shadow: var(--shadow-sm); }

        /* --- E. Masonry Grid Layout --- */
        @media (min-width: 768px) {
            .category-view-container.grid-mode-active .sectional-card-container { column-count: 2; column-gap: 0.6rem; }
            .category-view-container.grid-mode-active .sectional-card { break-inside: avoid; margin-bottom: 0.6rem; width: 100%; }
        }
        @media (min-width: 1200px) {
            .category-view-container.grid-mode-active .sectional-card-container { column-count: 3; }
        }
        .category-view-container.grid-mode-active .sectional-card img { max-width: 100%; height: auto; border-radius: var(--border-radius); }
        

        
        /* --- F. Immersive Focus Mode (v2 FINAL POLISH) --- */
        .focus-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: var(--bg-primary);
            z-index: 20000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            animation: fadeIn 0.3s ease;
        }
        .focus-mode-content {
            width: 100%;
            max-width: 95vw;
            height: 100%; 
            display: flex;
            flex-direction: column;
            text-align: center;
        }
        .focus-mode-title {
            font-weight: 700;
            margin-bottom: 0.25rem;
            padding-bottom: 0.25rem;
            font-size: 1.4rem;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            flex-shrink: 0;
        }
        @media (max-width: 768px) {
            .focus-mode-title {
                font-size: clamp(1.25rem, 6vw, 1.1rem);
                margin-bottom: 0.25rem;
                padding-bottom: 0.25rem;
            }
        }
        .focus-mode-body {
            display: flex;
            flex-direction: column;
            gap: 4px; 
            text-align: left;
            overflow-y: auto;
            overflow-x: visible;
            padding: 0.5rem;
            font-size: var(--focus-mode-font-size, 1.1rem);
            padding-bottom: 120px;
            scroll-padding-bottom: 120px;
        }
        /* FIX #2: Style the scrollbar to be less obtrusive and match the app's theme. */
        .focus-mode-body::-webkit-scrollbar { width: 10px; }
        .focus-mode-body::-webkit-scrollbar-track { background: transparent; }
        .focus-mode-body::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 10px; border: 2px solid var(--bg-primary); }
        .focus-mode-body::-webkit-scrollbar-thumb:hover { background-color: var(--text-secondary); }

        .focus-mode-body .snippet {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent;
            padding: 1px, 3px, 1px, 3px;
            border-radius: var(--border-radius);
            line-height: 1.5; 
        }
        .focus-mode-body .nk-accordion {
            margin: 0.25rem 0; 
            box-shadow: none; 
        }
        .focus-mode-body .nk-accordion:hover {
            border-color: var(--primary-color); 
            box-shadow: var(--shadow-sm); 
        }
        .focus-mode-body .snippet,
        .focus-mode-body .nk-text-tile-content,
        .focus-mode-body .nk-mcq-question,
        .focus-mode-body .nk-timeline-title,
        .focus-mode-body .nk-timeline-date,
        .focus-mode-body .nk-accordion-title,
        .focus-mode-body .nk-accordion-content {
            font-size: inherit;
        }
        .focus-mode-body .nk-text-tile {
            display: flex;    
            width: 100%;      
            max-width: 100%;   
            margin: 0;        
        }
        .focus-mode-body .snippet:focus,
        .focus-mode-body .snippet:hover {
            outline: none;
            border-color: var(--primary-color);
            background-color: var(--bg-tertiary);
        }
        .focus-mode-body .snippet.is-hidden {
            border: 2px dashed var(--border-color);
            background-color: transparent;
        }
        .focus-mode-body .snippet.is-hidden > * {
            opacity: 0.05; /* Keeps text hidden for recall practice */
            pointer-events: none;
        }
        .focus-mode-body .snippet.is-hidden:focus,
        .focus-mode-body .snippet.is-hidden:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--primary-color);
            box-shadow: 0 0 12px rgba(var(--primary-color-rgb), 0.4);
        }
        .focus-mode-controls {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            display: flex;
            gap: 4px;
            padding: 6px;
            border-radius: var(--border-radius-lg);
            /* FIX #4b & #2: Transparent background with a subtle blur for elegance. */
            background-color: rgba(var(--bg-secondary-rgb), 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
        }
        .focus-mode-controls .btn-icon, .focus-mode-controls .toggle-switch {
            width: 38px;  /* POLISH: Slightly smaller */
            height: 38px; /* POLISH: Slightly smaller */
            background-color: var(--bg-secondary);
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .focus-mode-controls .btn-icon svg {
            width: 22px;
            height: 22px;
        }
        .focus-mode-controls .btn-icon:hover {
            background-color: var(--bg-tertiary);
        }

        /* FIX #3: Styles for the new immersive mode toggle */
        .focus-mode-overlay.controls-hidden .focus-mode-controls {
            background: transparent;
            border-color: transparent;
            box-shadow: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }
        .focus-mode-overlay.controls-hidden .focus-mode-controls > *:not(.immersive-toggle-btn) {
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
            transition: all 0.2s ease-out;
        }
        .immersive-toggle-btn {
            transition: all 0.2s ease-in-out;
        }
        .focus-mode-overlay.controls-hidden .immersive-toggle-btn {
            opacity: 0.5;
            animation: slow-pulse 4s infinite;
        }
        .focus-mode-overlay.controls-hidden .immersive-toggle-btn:hover {
            opacity: 1;
        }

        /* --- G. Stage Presentation Mode ("Smart Scroll") --- */
        .focus-mode-overlay.stage-mode-active .focus-mode-body {
            scroll-behavior: smooth;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        .focus-mode-overlay.stage-mode-active .focus-mode-body::-webkit-scrollbar {
            display: none; /* Chrome, Safari, and Opera */
        }
        .focus-mode-overlay.stage-mode-active .focus-mode-controls {
            display: none; /* Hide the original controls */
        }
        .focus-mode-overlay.stage-mode-active .snippet {
            opacity: 0.3; /* Dim all snippets by default */
            transition: opacity 0.4s ease-in-out;
        }
        .focus-mode-overlay.stage-mode-active .snippet.is-visible {
            opacity: 1.0; /* Make only the visible snippets fully opaque */
        }
        .stage-mode-controls {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 0.25rem; 
            padding: 5px 8px; /* REDUCED: Smaller padding */
            border-radius: var(--border-radius-lg);
            background-color: rgba(var(--bg-secondary-rgb), 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            z-index: 20001;
        }
        /* RATIONALE: Only show controls on hover if annotation isn't active */
        .focus-mode-overlay.stage-mode-active:not(.annotation-active):hover .stage-mode-controls,
        .focus-mode-overlay.stage-mode-active .stage-mode-controls:hover {
            opacity: 1;
        }
        .focus-mode-overlay.stage-mode-active {
            padding: 1rem 2vw;
        }

        .stage-mode-controls .btn-icon,
        .stage-mode-controls .toggle-switch {
            width: 34px;  /* POLISH: Slightly smaller */
            height: 34px; /* POLISH: Slightly smaller */
            display: flex; 
            align-items: center;
            justify-content: center;
        }
        .stage-mode-controls .btn-icon svg {
            width: 20px;
            height: 20px;
        }


        .stage-snippet-counter {
            font-weight: 500; color: var(--text-secondary);
            font-variant-numeric: tabular-nums; user-select: none;
            padding: 0 4px; /* Add slight padding */
        }
        .stage-progress-indicator {
            display: flex;
            align-items: center;
            gap: 5px; /* REDUCED: Tighter dot spacing */
        }
        .progress-dot {
            width: 9px; /* REDUCED: Smaller dots */
            height: 9px; /* REDUCED: Smaller dots */
            background-color: var(--border-color);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .progress-dot:hover {
            transform: scale(1.3);
        }
        .progress-dot.active {
            background-color: var(--primary-color);
            transform: scale(1.4);
        }
        .laser-pointer {
            position: fixed;
            width: 15px; height: 15px;
            background-color: rgba(255, 20, 20, 0.8);
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 15px 5px rgba(255, 20, 20, 0.5);
            pointer-events: none;
            z-index: 99999;
            transform: translate(-50%, -50%);
            transition: transform 0.05s ease-out;
            display: none;
        }
        .focus-mode-body .is-visible.spotlight {
            opacity: 1 !important;
            transform: scale(1.03);
            box-shadow: 0 0 25px rgba(var(--primary-color-rgb), 0.5);
        }

        /* NEW: Style for keyboard-navigated spotlight */
        @keyframes glow-focus {
            from { box-shadow: 0 0 4px -2px var(--primary-color); }
            to { box-shadow: 0 0 13px 2.5px color-mix(in srgb, var(--primary-color) 60%, transparent); }
        }
        .focus-mode-body .spotlight-key-focus,
        .focus-mode-body .snippet:focus,
        .focus-mode-body .snippet:hover {
            border: 2px solid var(--primary-color) !important;
            animation: glow-focus 4.5s infinite alternate;
        }

        .focus-mode-body .spotlight-key-focus,
        .focus-mode-body .snippet:focus,
        .focus-mode-body .snippet:hover {
            border: 2px solid var(--primary-color) !important;
            animation: glow-focus 4.5s infinite alternate;
        }

        /* --- NEW: Cinematic Effects --- */
        .focus-mode-overlay.cinematic-active .focus-mode-body .snippet.is-visible,
        .focus-mode-overlay.cinematic-active .focus-mode-body .nk-mcq-block.is-visible,
        .focus-mode-overlay.cinematic-active .focus-mode-body .nk-accordion.is-visible {
            opacity: 0.20; 
            transform: translateY(10px) scaleY(1) scaleX(1);
            transition: opacity 0.4s ease-out, transform 0.4s ease-out, box-shadow 0.4s ease-out;
        }

        .focus-mode-overlay.cinematic-active .focus-mode-body .snippet.is-revealing,
        .focus-mode-overlay.cinematic-active .focus-mode-body .nk-mcq-block.is-revealing,
        .focus-mode-overlay.cinematic-active .focus-mode-body .nk-accordion.is-revealing {
            opacity: 1;
            transform: translateY(0) scaleY(1.03) scaleX(1.01);
            box-shadow: 0 8px 20px -5px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .reveal-word {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .reveal-word.visible {
            opacity: 1;
        }

        /* Ken Burns effect for images remains, but is now more subtle */
        @keyframes ken-burns {
            0% { transform: scale(1.0) translate(0, 0); }
            100% { transform: scale(1.05) translate(1%, -1%); }
        }

        /* The Ken Burns animation now only applies to the snippet being revealed */
        .focus-mode-overlay.cinematic-active .snippet.is-revealing .image-container {
            overflow: hidden;
        }

        .focus-mode-overlay.cinematic-active .snippet.is-revealing .image-container img {
            animation: ken-burns 20s ease-in-out infinite alternate;
        }

        /* --- NEW: Blackout Screen --- */
        #blackout-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 20002; /* Above content, below controls */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }
        .focus-mode-overlay.blackout-active #blackout-screen {
            opacity: 1;
            pointer-events: auto; /* Block clicks on content below */
        }

        /* --- NEW: Spotlight Effect --- */
        .focus-mode-body.spotlight-active .snippet.is-visible:not(.spotlight),
        .focus-mode-body.spotlight-active .nk-mcq-block.is-visible:not(.spotlight) {
            opacity: 0.1 !important; /* Force dimming */
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .focus-mode-body .is-visible.spotlight {
            opacity: 1 !important;
            transform: scale(1.03);
            box-shadow: 0 0 25px rgba(var(--primary-color-rgb), 0.5);
        }

        /* --- NEW: Live Annotation --- */
        /* FIX: The body container MUST be relative for the absolute canvas to be positioned correctly */
        .focus-mode-body {
            position: relative; 
        }
        /* FIX: This is the core fix. The canvas is now absolute, covering the entire scrollable area. */
        #annotation-canvas {
            position: absolute;
            top: 0;
            left: 0;
            max-width: 100%;
            z-index: 10;
            pointer-events: none; 
        }
        /* FIX: When active, the canvas captures all mouse events, preventing click-through. */
        .focus-mode-overlay.annotation-active #annotation-canvas {
            pointer-events: auto;
            cursor: crosshair;
        }
        .stage-mode-controls .btn-icon.annotation-btn.active {
            color: var(--text-on-primary);
            background-color: var(--primary-color);
        }

        /* --- UPGRADED: Teleprompter Mode (for Stage Mode) --- */
        .focus-mode-overlay.teleprompter-active {
            flex-direction: row;
            padding: 0; /* Full bleed for the two columns */
        }

        #teleprompter-sidebar {
            position: relative; /* This is new, to anchor the controls */
            width: 30%;
            height: 100%;
            flex-shrink: 0;
            background-color: rgba(var(--bg-secondary-rgb), 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 3rem 0.3rem 1.5rem 0.6rem;
            font-family: var(--font-serif);
            font-size: var(--teleprompter-font-size, 1.1rem);
            line-height: 1.6;
            animation: fadeIn 0.3s ease-out;
            z-index: 20002;
            white-space: normal;
            word-wrap: break-word;
            overflow-wrap: break-word;
            color: var(--text-primary);
            mask-image: linear-gradient(to bottom, 
                transparent 0%, 
                black 15%, 
                black 85%, 
                transparent 100%
            );
            scroll-behavior: smooth; 
        }
        /* --- NEW: Aesthetic Teleprompter Scrollbar --- */
        #teleprompter-sidebar::-webkit-scrollbar {
            width: 8px; /* Make scrollbar very thin */
        }
        #teleprompter-sidebar::-webkit-scrollbar-track {
            background: transparent; /* No visible track */
        }

        #teleprompter-sidebar::-webkit-scrollbar-thumb {
            background-color: var(--border-color); /* Use a subtle theme color */
            border-radius: 4px;
            border: 2px solid transparent; /* Creates a "padding" effect */
            background-clip: content-box;
        }
        #teleprompter-sidebar::-webkit-scrollbar-thumb:hover {
            background-color: var(--primary-color);
        }
        #teleprompter-sidebar blockquote {
            margin-left: 0.25em;  /* A tiny indent */
            padding-left: 0.5em; /* A much smaller padding */
            border-left: 3px solid var(--border-color); /* A more subtle border */
            font-style: italic;
        }
        /* --- NEW: "Smart" Text Highlight Logic --- */
        #teleprompter-sidebar :is(h1, h2, h3, h4, h5, h6, b, strong, [class*="highlight-"], [class*="text-"]) {
            color: var(--primary-color) !important;
            font-weight: 600 !important;
            background: none !important; /* Remove highlight backgrounds */
            border: none !important;
        }

        /* Hide complex blocks from the simple teleprompter view */
        #teleprompter-sidebar .nk-mcq-block,
        #teleprompter-sidebar .nk-timeline-block,
        #teleprompter-sidebar .chart-container,
        #teleprompter-sidebar .nk-accordion,
        #teleprompter-sidebar .nk-textile-deck,
        #teleprompter-sidebar .nk-audio-player,
        #teleprompter-sidebar .pdf-attachment-pill,
        #teleprompter-sidebar .image-container {
            display: none;
        }

        /* Ensure clean text flow */
        #teleprompter-sidebar p,
        #teleprompter-sidebar li {
            font-size: inherit !important;
            line-height: inherit !important;
            color: inherit !important;
        }
        #teleprompter-sidebar ul,
        #teleprompter-sidebar ol {
            padding-left: 1.5em; /* Base small indent */
        }

        #teleprompter-sidebar ul ul,
        #teleprompter-sidebar ol ol,
        #teleprompter-sidebar ol ul,
        #teleprompter-sidebar ul ol {
            padding-left: 0.25em; 
            margin-left: 0;
            list-style-type: square !important; 
        }

        .focus-mode-overlay.teleprompter-active .focus-mode-content {
            width: 70%;
            flex-grow: 1;
        }

        /* Re-center the stage controls over the 70% presentation panel */
        .focus-mode-overlay.teleprompter-active .stage-mode-controls {
            left: 65%;
        }

        /* Re-center the annotation toolbar */
        .focus-mode-overlay.teleprompter-active #annotation-toolbar {
            left: 65%;
        }

        /* --- UPGRADED: Mobile Teleprompter (Bottom Bar) --- */
        body.mobile-view .focus-mode-overlay.teleprompter-active {
            flex-direction: column; /* Stack vertically */
        }

        body.mobile-view .focus-mode-overlay.teleprompter-active .focus-mode-content {
            order: 1; /* Content (70%) comes first */
            width: 100%;
            height: 70%;
        }

        body.mobile-view #teleprompter-sidebar {
            order: 2; /* Teleprompter (30%) comes second */
            width: 100%;
            height: 30%;
            border-right: none; /* No side border */
            border-top: 1px solid var(--border-color); /* Top border instead */
        }

        /* Re-position controls to sit *above* the 30% teleprompter bar */
        body.mobile-view .focus-mode-overlay.teleprompter-active .stage-mode-controls,
        body.mobile-view .focus-mode-overlay.teleprompter-active #annotation-toolbar {
            left: 50%;
            bottom: 30%; /* Sit on top of the 30% bar */
            margin-bottom: 0.5rem; /* Add a small margin */
            transform: translateX(-50%); /* Keep it centered */
        }

        /* --- NEW: Teleprompter-Specific Controls (V2 Design) --- */
        #teleprompter-controls {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            z-index: 10;
            display: none; /* Hidden by default */
            align-items: center;
            gap: 4px;
            padding: 4px;
            background-color: rgba(var(--bg-secondary-rgb), 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow);
        }

        /* Only show the controls when the teleprompter is active */
        .focus-mode-overlay.teleprompter-active #teleprompter-controls {
            display: flex;
        }

        #teleprompter-controls .btn-icon {
            width: 32px;
            height: 32px;
            background-color: var(--bg-tertiary);
        }
/* --- NEW: Teleprompter Resizer Handle --- */
        #teleprompter-resizer {
            position: absolute;
            z-index: 15; /* Sits on top of the sidebar */
            background-color: transparent;
            transition: background-color 0.2s ease-in-out;
        }

        #teleprompter-resizer:hover,
        #teleprompter-resizer.is-resizing {
            background-color: var(--primary-color);
            opacity: 0.7;
        }

        /* Desktop (Vertical Handle) */
        body:not(.mobile-view) #teleprompter-resizer {
            top: 0;
            bottom: 0;
            left: 100%; /* Sits on the right edge of the sidebar */
            width: 8px;
            cursor: col-resize;
            transform: translateX(-50%); /* Center the 8px handle on the edge */
        }
        
        /* Mobile (Horizontal Handle) */
        body.mobile-view #teleprompter-resizer {
            left: 0;
            right: 0;
            top: 100%; /* Sits on the bottom edge of the sidebar */
            height: 8px;
            cursor: row-resize;
            transform: translateY(-50%); /* Center the 8px handle on the edge */
        }


        /* --- NEW: Annotation Toolbar Styles --- */
        #annotation-toolbar {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Hidden by default */
            align-items: center;
            gap: 8px;
            padding: 8px;
            background-color: rgba(var(--bg-secondary-rgb), 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-lg);
            z-index: 20004;
            animation: slideUp 0.3s ease;
        }
        #annotation-toolbar .tool-btn.active {
            background-color: var(--bg-tertiary);
            color: var(--primary-color);
        }
        #annotation-toolbar .color-pick {
            width: 24px; height: 24px; border-radius: 50%;
            border: 2px solid var(--border-color); cursor: pointer;
            transition: transform 0.2s ease;
        }
        #annotation-toolbar .color-pick:hover { transform: scale(1.1); }
        #annotation-toolbar .color-pick.active {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-color) 60%, transparent);
        }
        #annotation-toolbar .btn-icon { width: 32px; height: 32px; }

        #whiteboard-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--bg-primary);
            z-index: 20001; /* Below canvas, above content */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }
        .focus-mode-overlay.whiteboard-active #whiteboard-screen {
            opacity: 1;
        }
        /* FIX: Hide main stage controls when annotating to avoid clutter */
        .focus-mode-overlay.annotation-active .stage-mode-controls {
            opacity: 0;
            pointer-events: none;
        }


        /* --- NEW: Presentation/Reader Ambiance Themes --- */
        /* Gallery 1: High-Energy Brights */
        .ambiance-lime-ink { --bg-primary: #dfffbf; --bg-primary-rgb: 223, 255, 191; --text-primary: #1a1a1a; --primary-color: #007bff; }
        .ambiance-goldenrod-pad { --bg-primary: #ffea7f; --bg-primary-rgb: 255, 234, 127; --text-primary: #0d3b66; --primary-color: #e11d48; }
        .ambiance-mint-chip { --bg-primary: #e6fff1; --bg-primary-rgb: 230, 255, 241; --text-primary: #3e2723; --primary-color: #71ffaf; }
        .ambiance-aqua-sky { --bg-primary: #cffafe; --bg-primary-rgb: 207, 250, 254; --text-primary: #0c2d48; --primary-color: #f97316; }
        .ambiance-peach-sorbet { --bg-primary: #ffeadb; --bg-primary-rgb: 255, 234, 219; --text-primary: #5c001f; --primary-color: #14b8a6; }
        .ambiance-powder-snow { --bg-primary: #f9fafb; --bg-primary-rgb: 249, 250, 251; --text-primary: #000000; --primary-color: #3b82f6; }

        /* Gallery 2: Sophisticated Darks */
        .ambiance-terminal { --bg-primary: #000000; --bg-primary-rgb: 0, 0, 0; --text-primary: #ffc107; --primary-color: #23e000; }
        .ambiance-crimson-night { --bg-primary: #5c0000; --bg-primary-rgb: 92, 0, 0; --text-primary: #fdf6e3; --primary-color: #d4af37; }
        .ambiance-royal-indigo { --bg-primary: #2c005c; --bg-primary-rgb: 44, 0, 92; --text-primary: #ffffff; --primary-color: #e83e8c; }
        .ambiance-emerald-tablet { --bg-primary: #013220; --bg-primary-rgb: 1, 50, 32; --text-primary: #fff2c5; --primary-color: #858585; }
        .ambiance-obsidian-ruby { --bg-primary: #720072; --bg-primary-rgb: 27, 23, 23; --text-primary: #fff0f5; --primary-color: #1b1717; }
        .ambiance-blueprint { --bg-primary: #0c2d48; --bg-primary-rgb: 12, 45, 72; --text-primary: #afeeee; --primary-color:  #103e65; }
        .ambiance-midnight-sun { --bg-primary: #222222; --bg-primary-rgb: 34, 34, 34; --text-primary: #ffa467; --primary-color: #2fabe4; }

        /* Gallery 3: Natural & Earthy Tones */
        .ambiance-evergreen { --bg-primary: #f5f5dc; --bg-primary-rgb: 245, 245, 220; --text-primary: #004225; --primary-color: #cc5500; }
        .ambiance-clay-sky { --bg-primary: #f0a6dd; --bg-primary-rgb: 233, 150, 122; --text-primary: #2c3e50; --primary-color: #e7d748; }
        .ambiance-sandstone-agave { --bg-primary: #f0e6d2; --bg-primary-rgb: 240, 230, 210; --text-primary: #354e3c; --primary-color: #5c4033; }
        .ambiance-stone-moss { --bg-primary: #dddddd; --bg-primary-rgb: 211, 211, 211; --text-primary: #1e172a; --primary-color: #483d8b; }
        .ambiance-mahogany { --bg-primary: #3d0c02; --bg-primary-rgb: 61, 12, 2; --text-primary: #f3e5ab; --primary-color: #ffbf00; }
        .ambiance-riverbed { --bg-primary: #2e2b29; --bg-primary-rgb: 74, 68, 65; --text-primary: #c2c1ba; --primary-color: #008080; }
        .ambiance-matrix { --bg-primary: #000000; --bg-primary-rgb: 0, 0, 0; --text-primary: #00FF41; --primary-color: #00eb3c; }

        /* Gallery 4: Monochromatic & Minimalist */
        .ambiance-rosewater { --bg-primary: #fff0f5; --bg-primary-rgb: 255, 240, 245; --text-primary: #720072; --primary-color: #dc143c; }
        .ambiance-azure-depth { --bg-primary: #003153; --bg-primary-rgb: 0, 49, 83; --text-primary: #e0ffff; --primary-color: #7a7a7a; }
        .ambiance-olive-grove { --bg-primary: #3d402e; --bg-primary-rgb: 61, 64, 46; --text-primary: #c9c5ac; --primary-color: #cfb53b; }
        .ambiance-sterling { --bg-primary: #e0e0e0; --bg-primary-rgb: 224, 224, 224; --text-primary: #2c3840; --primary-color: #b22222; }
        .ambiance-greyscale { --bg-primary: #f0f0f0; --bg-primary-rgb: 240, 240, 240; --text-primary: #333333; --primary-color: #000000; }

        /* This rule makes sure the themes apply correctly in all four contexts */
        .focus-mode-overlay[class*="ambiance-"],
        #pdf-viewer-container[class*="ambiance-"],
        .article-view-wrapper[class*="ambiance-"],
        .study-view[class*="ambiance-"] { 
            --bg-secondary: var(--bg-primary); 
            --bg-tertiary: color-mix(in srgb, var(--text-primary) 10%, var(--bg-primary)); 
            --border-color: color-mix(in srgb, var(--text-primary) 20%, var(--bg-primary)); 
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out;
        }

        /* Scoped overrides for themed views */
        .focus-mode-overlay[class*="ambiance-"] .focus-mode-title,
        .article-view-wrapper[class*="ambiance-"] .article-title-input {
            background: none;
            -webkit-background-clip: unset;
            -webkit-text-fill-color: unset;
            color: var(--text-primary);
        }
        .article-view-wrapper[class*="ambiance-"] .article-container.ui-card {
            background-color: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            box-shadow: none;
            border: none;
        }
        .sectional-card-body .snippet:has(.nk-text-tile),
        .focus-mode-body .snippet:has(.nk-text-tile) {
            padding: 0;
            background: none;
        }

        /* This rule makes sure the themes apply correctly in all four contexts */
        .focus-mode-overlay[class*="ambiance-"],
        #pdf-viewer-container[class*="ambiance-"],
        .article-view-wrapper[class*="ambiance-"],
        .study-view[class*="ambiance-"] { 
            --bg-secondary: var(--bg-primary); 
            --bg-tertiary: color-mix(in srgb, var(--text-primary) 10%, var(--bg-primary)); 
            --border-color: color-mix(in srgb, var(--text-primary) 20%, var(--bg-primary)); 
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out;
        }

        /* Scoped overrides for themed views */
        .focus-mode-overlay[class*="ambiance-"] .focus-mode-title,
        .article-view-wrapper[class*="ambiance-"] .article-title-input {
            background: none;
            -webkit-background-clip: unset;
            -webkit-text-fill-color: unset;
            color: var(--text-primary);
        }
        .article-view-wrapper[class*="ambiance-"] .article-container.ui-card {
            background-color: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            box-shadow: none;
            border: none;
        }



        /* --- H. Vertical Timeline Layout (AESTHETIC REDESIGN) --- */
        .sectional-card-container.is-timeline {
            position: relative;
            padding-left: 5rem; /* Space for the timeline decorations */
        }
        /* The central vertical line */
        .sectional-card-container.is-timeline::before {
            content: '';
            position: absolute;
            left: 2.5rem; /* Position in the middle of the padding */
            transform: translateX(-50%);
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: var(--border-color);
        }
        .timeline-entry {
            position: relative;
            margin-bottom: 1rem; /* Tighter spacing between timeline entries */
            opacity: 0;
            transform: translateY(20px);
            animation: slideUpFadeIn 0.5s ease-out forwards;
        }
        @keyframes slideUpFadeIn {
            to { opacity: 1; transform: translateY(0); }
        }
        /* The decorative marker dot */
        .timeline-marker {
            position: absolute;
            left: -2.5rem;
            /* RATIONALE: Aligns the center of the marker with the center of the card's title area */
            top: 2rem; 
            transform: translate(-50%, -50%);
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background-color: var(--bg-secondary);
            border: 3px solid var(--primary-color);
            z-index: 1;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: var(--shadow);
        }
        /* FIX #3: Hover effect for the marker */
        .timeline-entry:hover .timeline-marker {
            transform: translate(-50%, -50%) scale(1.25);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary-color-hover);
        }
        /* FIX #3: Date text styled to be inside the marker */
        .timeline-date {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.1;
        }



        /* --- DEFINITIVE: Classic Bordered Accordion Styles (v2) --- */
        .nk-accordion {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            margin: 1.5em 0;
            background-color: var(--bg-secondary);
            transition: var(--transition-fast);
            overflow: hidden;
        }
        .nk-accordion:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow);
        }
        .nk-accordion-trigger {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            width: 100%;
            padding: 1rem 1.25rem;
            background-color: color-mix(in srgb, var(--border-color) 25%, var(--bg-tertiary));
            border: none;
            cursor: pointer;
            font-family: inherit;
            font-size: inherit;
            color: var(--text-primary);
            text-align: left;
        }
        .nk-accordion-trigger:hover {
            background-color: color-mix(in srgb, var(--border-color) 40%, var(--bg-tertiary));
        }
        .nk-accordion-title {
            flex-grow: 1;
            outline: none;
        }
        .nk-accordion-title:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            pointer-events: none;
        }
        .nk-accordion-chevron {
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            stroke: currentColor;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        body.read-mode .nk-accordion-chevron {
            display: none; /* Hides chevron in read mode as requested */
        }
        .nk-accordion-content {
            padding: 1rem 1.25rem;
            border-top: 1px solid var(--border-color);
            outline: none;
            transition: max-height 0.4s ease-in-out, opacity 0.3s ease-in-out, padding 0.4s ease-in-out;
        }
        .nk-accordion-content:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            pointer-events: none;
        }
        [data-state="closed"] > .nk-accordion-content {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
            border-top-color: transparent;
            overflow: hidden;
        }
        [data-state="open"] > .nk-accordion-content {
            max-height: 1000px;
            opacity: 1;
        }
        [data-state="open"] > .nk-accordion-trigger .nk-accordion-chevron {
            transform: rotate(180deg);
        }
        .nk-accordion-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        body.read-mode .nk-accordion-controls {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        body.read-mode .nk-accordion:hover .nk-accordion-controls {
            opacity: 1;
        }
        .nk-accordion-control-btn {
            background: none; border: none; color: var(--text-secondary);
            cursor: pointer; width: 24px; height: 24px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
        }
        .nk-accordion-control-btn:hover {
            background-color: var(--bg-tertiary);
        }
        .nk-accordion-control-btn.active {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
        }
        .nk-accordion-hint-editor {
            padding: 0.75rem 1.25rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-primary);
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        .nk-accordion-hint-content {
            outline: none;
        }
        .nk-accordion-hint-content:empty::before {
            content: attr(data-placeholder);
            font-style: italic;
        }
        .study-card-content-box img {
            max-width: 100%;
            height: auto;
            border-radius: var(--border-radius);
            margin-top: 1rem;
        }
        .flashcard-tile-content img {
            display: block;
            max-height: 60px;
            width: 100%;
            object-fit: contain;
            border-radius: var(--border-radius);
            margin-top: 2px;
        }
        .reversible-indicator {
            font-size: 0.8rem;
            color: var(--primary-color);
            margin-left: 8px;
        }
        .study-hint-container {
            margin-top: 1.5rem;
            font-size: 1rem;
            font-family: var(--font-body);
        }
        .study-hint-content {
            margin-top: 0.5rem;
            padding: 1rem;
            background-color: var(--bg-tertiary);
            border-radius: var(--border-radius);
            color: var(--text-secondary);
            font-style: italic;
            animation: fadeIn 0.3s ease;
        }
        body.read-mode .nk-accordion-controls {
            opacity: 0; /* Hide controls by default in read mode */
            transition: opacity 0.2s ease-in-out;
        }
        body.read-mode .nk-accordion:hover .nk-accordion-controls {
            opacity: 1; /* Show controls on hover */
        }
        
        body.study-mode-active header, body.study-mode-active #app-background, body.study-mode-active main { display: none; }
        .zen-mode-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-primary); z-index: 20000; display: flex; flex-direction: column; justify-content: center; align-items: center; animation: fadeIn 0.3s; padding: 2.5rem; text-align: center; }
        .zen-timer { font-size: clamp(8rem, 20vw, 15rem); font-weight: 700; line-height: 1; text-shadow: 0 4px 15px rgba(0,0,0,0.15); }
        .zen-meta-container { display: flex; flex-direction: column; align-items: center; gap: 1.5rem; margin-bottom: 1.5rem; }
        .zen-pills-row { display: flex; align-items: center; justify-content:center; gap: 12px; }
        .zen-pills-row .cycle-pill { margin-right: 20px; }
        .zen-pills-row > div { min-width: 80px; text-align: center; justify-content: center; display: inline-flex; align-items: center; transform: scale(1.2); }
        .zen-task-title { font-size: clamp(1.5rem, 3.5vw, 2.2rem); margin: 0; font-weight: 500; transition: color 0.5s ease; text-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 90vw; line-height: 1.3; white-space: normal; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; margin-top: 1.5rem; }
        .zen-bottom-controls { position: absolute; bottom: 2rem; display: flex; align-items: center; gap: 1.5rem; }
        .zen-progress-frame .progress-segment { height: 12px; width: 12px; }
        .stats-dashboard-view { padding: 1.5rem; max-width: 1400px; margin: 0 auto; }
        .stats-header { display: flex; justify-content: center; align-items: center; margin-bottom: 2rem;}
        .stats-header h1 { font-family: var(--font-display); font-size: 2.5rem; margin: 0; }
        .stats-section-title { font-size: 1.2rem; font-weight: 700; margin: 2.5rem 0 1rem 0; text-align: left; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 1rem; }
        .stat-card { background: linear-gradient(to right bottom, var(--bg-secondary), var(--bg-tertiary)); padding: 1.25rem; border-radius: var(--border-radius-lg); text-align: center; border: 1px solid var(--border-color); }
        .stat-card-value { font-size: 2rem; font-weight: 700; line-height: 1.2; color: var(--primary-color); }
        .stat-card-label { font-size: 0.9rem; color: var(--text-secondary); margin-top: 4px; }
        .category-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 0.75rem;}
        .category-section-container { background-color: var(--bg-primary); padding: 0.5rem 1.5rem 1.5rem 1.5rem; border-radius: var(--border-radius-lg); margin-top: 1rem; }
        .category-grid .category-card { padding: 0.85rem 1.15rem; }
        .category-grid .category-pill { padding: 6px 12px; font-size: 0.9rem; }
        .category-card { display: flex; justify-content: space-between; align-items: center; background-color: var(--bg-secondary); padding: 1rem 1.25rem; border-radius: var(--border-radius-lg); border: 1px solid var(--border-color); box-shadow: var(--shadow-sm); transition: var(--transition-fast); }
        .category-card:hover { transform: translateY(-2px); box-shadow: var(--shadow); }
        .category-card-info { display: flex; align-items: center; gap: 12px; }
        .category-card-value { font-size: 1.1rem; font-weight: 600; }
        .heatmap-container { padding: 1rem; background-color: var(--bg-secondary); border-radius: var(--border-radius-lg); margin-top: 1rem; }
        .heatmap-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; font-weight: 600; font-size: 1.1rem; }
        .heatmap-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; }
        .heatmap-day { width: 100%; aspect-ratio: 1; background-color: var(--heat-0); border-radius: 4px; transition: transform 0.2s; cursor: pointer; }
        .heatmap-day.empty { background-color: transparent; border: 1px dashed var(--border-color); cursor: default; }
        .heatmap-day:not(.empty):hover { transform: scale(1.1); }
        .heatmap-day.level-1 { background-color: var(--heat-1); } .heatmap-day.level-2 { background-color: var(--heat-2); } .heatmap-day.level-3 { background-color: var(--heat-3); } .heatmap-day.level-4 { background-color: var(--heat-4); } .heatmap-day.level-5 { background-color: var(--heat-5); } .heatmap-day.level-6 { background-color: var(--heat-6); }
        .quiz-result-card { max-width: 450px; text-align: center; }
        .quiz-score-display { font-size: 4rem; font-weight: 700; margin: 1.5rem 0; background: linear-gradient(45deg, var(--primary-color), var(--primary-color-hover)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .quiz-motivational-quote { font-size: 1.2rem; font-style: italic; color: var(--text-secondary); }
        .btn-quiz {
            border: 1px solid transparent;
            transition: all 0.2s ease-in-out;
        }
        .btn-quiz:hover:not(:disabled) {
            border-color: var(--primary-color);
            box-shadow: 0 0 8px 1px color-mix(in srgb, var(--primary-color) 40%, transparent);
        }

        .quiz-stats-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
        }
        .streak-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
            flex-wrap: wrap;
            width: 100%;
        }
        .streak-display.daily {
            width: clamp(130px, 15vw, 160px);
            height: clamp(130px, 15vw, 160px);
            border-radius: 50%;
            background: var(--bg-secondary);
            border: 5px solid var(--primary-color); /* Simplified */
            box-shadow: 0 5px 20px rgba(0,0,0,0.1), inset 0 3px 8px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 1rem;
            cursor: default;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        .streak-display.daily:hover {
            transform: translateY(-5px) scale(1.05);
        }
        .streak-value {
            font-size: clamp(2.8rem, 8vw, 4rem);
            font-weight: 700;
            line-height: 1;
            color: var(--primary-color); /* Simplified */
            text-shadow: 0 2px 3px rgba(0,0,0,0.2);
        }
        .streak-label {
            font-size: clamp(0.7rem, 2vw, 0.8rem);
            font-weight: 600;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .weekly-streak-calendar {
            display: flex;
            align-items: center;
            justify-content: space-around;
            background-color: var(--bg-tertiary);
            border-radius: var(--border-radius-lg);
            /* --- FIX: Responsive padding and height --- */
            padding: clamp(0.5rem, 2vw, 0.75rem);
            height: clamp(110px, 15vw, 140px);
            flex-grow: 1;
            max-width: clamp(320px, 40vw, 450px); /* --- FIX: Increased fluid width --- */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
            border: 2px solid var(--primary-color);
            transition: all 0.3s ease;
        }
        .week-day {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* --- FIX: Responsive width for each day column --- */
            width: clamp(34px, 5.5vw, 50px);
            gap: 0.25rem;
        }
        .day-letter {
            /* --- FIX: Responsive font size --- */
            font-size: clamp(0.7rem, 1.5vw, 0.85rem);
            font-weight: 600;
            color: var(--text-secondary);
        }
        .date-number {
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease-in-out;
            /* --- FIX: Responsive font size, width, and height for the number circle --- */
            font-size: clamp(1.1rem, 2.5vw, 1.4rem);
            width: clamp(32px, 5vw, 42px);
            height: clamp(32px, 5vw, 42px);
        }
        .week-day.today .date-number {
            box-shadow: 0 0 0 2px var(--primary-color);
        }
        .week-day.completed .date-number {
            background-color: var(--primary-color);
            color: var(--text-on-primary, #fff);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }


        .sub-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            width: 100%;
        }
        .stat-card-value {
            font-size: clamp(1.2rem, 3.5vw, 2rem);
            word-break: break-all;
        }
        @media (max-width: 768px) {
            .streak-container {
                flex-direction: column;
                gap: 1.5rem;
            }
            .weekly-streak-calendar {
                width: 100%;
                max-width: none;
                height: auto;
                padding: 0.5rem;
            }
        }

        

        @media (max-width: 640px) {
            .task-filters { display: flex; overflow-x: auto; }
            .task-filters .btn { width: auto; flex-shrink: 0; }
            .productivity-modal { height: 90vh; max-height: 90vh; }
            .pomodoro-time-display { font-size: 2.5rem; }
            .pomodoro-controls .btn-icon { transform: scale(0.9); }
            .stats-dashboard-view { padding: 1rem; }
            .stats-header h1 { font-size: 2rem; }
        }
        .custom-checkbox-container { position: relative; display: flex; align-items: center; justify-content: center; width: 20px; height: 20px; cursor: pointer; }
        .custom-checkbox-container input { position: absolute; opacity: 0; cursor: pointer; height: 0; width: 0; }
        .custom-checkbox { position: absolute; top: 0; left: 0; height: 20px; width: 20px; background-color: transparent; border: 2px solid var(--border-color); border-radius: 50%; transition: all 0.3s ease-in-out; display: flex; align-items: center; justify-content: center; box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.1); }
        .custom-checkbox-container:hover .custom-checkbox { border-color: var(--primary-color); }
        .custom-checkbox-container input:checked ~ .custom-checkbox { background-color: var(--success-color); border-color: var(--success-color); }
        .custom-checkbox-container input:checked ~ .custom-checkbox .check-icon { opacity: 1; transform: scale(1); }
        .task-item.is-backlog:not(.completed) .custom-checkbox { background-color: var(--danger-color); border-color: var(--danger-color); }
        .task-item.is-backlog:not(.completed) .custom-checkbox .cross-icon { opacity: 1; transform: scale(1); color: white; }
        .task-item.is-backlog.completed .custom-checkbox { background-color: var(--success-color); border-color: var(--success-color); }
        .task-item.is-backlog.completed .custom-checkbox .cross-icon { opacity: 0; }

        

        /* --- Canvas Focus Mode (Line Button) --- */
        .canvas-focus-line {
            width: 100%;
            height: 5.5px; /* Sleek and thin */
            background-color: var(--border-color);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0; /* Prevent it from shrinking */
        }
        .canvas-focus-line:hover {
            background-color: var(--primary-color);
            height: 8px; /* Slightly expand on hover */
        }

        /* When focus mode is active */
        body.canvas-focus-mode header,
        body.canvas-focus-mode #visual-map-controls,
        body.canvas-focus-mode #mindmap-controls {
            display: none;
        }
        body.canvas-focus-mode #visual-map-view.active,
        body.canvas-focus-mode #mindmap-view.active {
            padding: 0;
            gap: 0;
        }
        body.canvas-focus-mode .canvas-focus-line {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 20;
            border-radius: 0;
        }
        /* ==========================================================================
        v2: VISUALIZATION STYLES (FROM PROTOTAGS) - CORRECTED
        ========================================================================== */

        html, body {
            height: 100vh; /* fallback */
            height: 100dvh; /* Modern unit */
            margin: 0;
            overflow: hidden;
        }
        body {
            display: flex;
            flex-direction: column;
            font-family: var(--article-font-family), var(--font-body);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.2s, color 0.2s;
        }
        header {
            flex-shrink: 0; /* Prevent the header from shrinking */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 calc(var(--spacing-unit) * 1.2);
            border-bottom: 1px solid var(--border-color);
            height: 48px;
            z-index: 1000;
            background-color: rgba(var(--bg-primary-rgb), var(--ui-opacity));
            backdrop-filter: blur(var(--blur-intensity));
            -webkit-backdrop-filter: blur(var(--blur-intensity));
            transition: background-color 0.2s, backdrop-filter 0.2s;
        }
        main {
            flex-grow: 1; /* Allow main to take up all remaining space */
            display: flex;
            flex-direction: column;
            position: relative; /* Needed for positioning some child elements */
            overflow-y: auto; /* Allow main content (like library) to scroll */
            min-height: 0; /* A flexbox fix for overflowing content */
        }
        /* When a map is active, its parent (main) should not scroll */
        main:has(#visual-map-view.active),
        main:has(#mindmap-view.active) {
            overflow-y: hidden;
        }

        /* --- General View Styles (No changes needed here) --- */
        #visual-map-view.active, #mindmap-view.active {
            display: flex;
            flex-direction: column;
            flex: 1 1 auto;
            min-height: 0;
            overflow: hidden;
            padding: 3px calc(var(--spacing-unit) * 1.5) calc(var(--spacing-unit) * 1.5); /* TOP, LEFT/RIGHT, BOTTOM */
            gap: calc(var(--spacing-unit) * 0.35);
        }
    
       /* KEEP THIS RULE */
        #visual-map-controls, #mindmap-controls {
            display: flex;
            align-items: center;
            gap: 4px; 
            flex-wrap: wrap;
            padding: 0;
            margin-bottom: 0;
            flex-shrink: 0;
            min-height: 40px;
            position: relative;
            z-index: 2;
            pointer-events: auto;
        }

       /* Replace with this code */
        #visual-map-container, #mindmap-container {
            position: relative;
            flex: 1 1 auto;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: var(--bg-secondary);
            cursor: grab;
            outline: none;
            transition: background-color 0.2s;
            margin: 0;
            overflow: hidden;
        }
        #visual-map-container > svg, #mindmap-container > svg {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        .control-group { display: flex; align-items: center; flex-direction: row; background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: var(--border-radius); box-shadow: var(--shadow); overflow: hidden; }
        .control-btn { background: transparent; border: none; padding: 8px 10px; cursor: pointer; color: var(--text-secondary); display: flex; align-items: center; justify-content: center; border-left: 1px solid var(--border-color); }
        .control-btn:first-child { border-left: none; }
        .control-btn:hover { background-color: var(--bg-tertiary); color: var(--text-primary); }
        .control-btn.active { background-color: var(--primary-color); color: var(--text-on-primary); }
        .control-btn svg { width: 16px; height: 16px; stroke-width: 2; }
        /* --- NEW: Export Popover Styles --- */
        .control-group-popover {
            position: relative;
            display: flex;
        }
        .popover-menu {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(10px); 
            margin-bottom: 10px;      
            display: flex;
            gap: 4px;
            padding: 6px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);     
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out, visibility 0s 0.2s;
            z-index: 10;
        }
        .control-group-popover:hover .popover-menu,
        .control-group-popover.popover-active .popover-menu {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
            transition-delay: 0s;
        }

        .popover-menu .btn-icon {
            background-color: var(--bg-tertiary);
        }
                
        
        
        .search-input-wrapper { position: relative; }
        .search-results-list { position: absolute; top: 100%; left: 0; width: 250px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: var(--border-radius); max-height: 200px; overflow-y: auto; z-index: 10; margin-top: 4px; box-shadow: var(--shadow-lg); }
        .search-results-list ul { list-style: none; padding: 4px; margin: 0; }
        .search-results-list li a { display: block; padding: 6px 8px; border-radius: 4px; text-decoration: none; color: var(--text-primary); font-size: 0.9em; }
        .search-results-list li a:hover, .search-results-list li a.active { background-color: var(--bg-tertiary); }
        .search-input { border: none; padding: 8px 12px; outline: none; background-color: transparent; width: 180px; color: var(--text-primary); }
        #visual-map-container:active, #mindmap-container:active { cursor: grabbing; }
        .node-group { cursor: pointer; }
        .node-group.dragging { cursor: grabbing; }
        .node-group.selected > .node-main-body { stroke: var(--primary-color); stroke-width: 3px; }
        .node-highlight { pointer-events: none; }
        .node-text.lod-hidden { display: none; }
        .search-highlight { fill: var(--search-highlight-bg) !important; font-weight: 600; }
        .faded { opacity: 0.15; transition: opacity 0.5s ease-in-out; }
        .node-group:not(.faded), .link:not(.faded) { transition: opacity 0.5s ease-in-out; }
        .mindmap-node { cursor: pointer; }
        .mindmap-node.dragging { cursor: grabbing; }
        .mindmap-link { fill: none; stroke-width: 2.5px; opacity: 0.8; cursor: pointer; }
        .mindmap-node rect { stroke-width: 1.5px; rx: var(--border-radius-lg); ry: var(--border-radius-lg); filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1)); }
        .mindmap-node:hover rect { transform: translateY(-2px); filter: drop-shadow(0 8px 12px rgba(0,0,0,0.15)); }
        .mindmap-search-highlight rect { stroke: var(--search-highlight-bg) !important; stroke-width: 3px; }
        .mindmap-node .node-html-content { font-family: var(--font-body); font-size: 12px; line-height: 1.5; text-align: center; padding: 10px 14px 15px; height: 100%; overflow: hidden; scroll-behavior: smooth; word-wrap: break-word; display: flex; align-items: center; justify-content: center; }
        .mindmap-node.mindmap-root .node-html-content { font-weight: 600; font-size: 14px; }
        .mindmap-node .node-html-content.has-custom-scroll { mask-image: linear-gradient(to bottom, black 85%, transparent 100%); -webkit-mask-image: linear-gradient(to bottom, black 85%, transparent 100%); }
        .mindmap-node .has-custom-scroll { align-items: flex-start; justify-content: flex-start; text-align: left; }
        .node-content-wrapper { position: relative; height: 100%; width: 100%; }
        .mindmap-node .scroll-button-line { position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%); width: 80%; max-width: 200px; height: 5px; background-color: rgba(255, 255, 255, 0.5); border-radius: 3px; cursor: pointer; opacity: 0.50; transition: opacity 0.2s, background-color 0.2s; z-index: 10; }
        .mindmap-node .scroll-button-line:hover { opacity: 1; }
        [data-theme="light"] .mindmap-child .scroll-button-line { background-color: rgba(0, 0, 0, 0.3); }
        .mindmap-link.faded { opacity: 0.25; }
        .mindmap-node.faded rect { opacity: 0.8; }
        .mindmap-node.faded foreignObject { opacity: 0.08; }
        
        /* FIX: Position the sticky note layer correctly above the SVG */
        #visual-map-container > #sticky-note-layer {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5; /* Lifts the layer above the SVG canvas */
        }
        #sticky-note-layer { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
            overflow: visible; 
            transform-origin: 0 0; 
        }
        
         /* === FINAL POLISHED STICKY NOTE REDESIGN (v8.83) === */
        .sticky-note-tile {
            position: absolute;
            display: flex;
            flex-direction: column;
            border-radius: var(--border-radius-lg);
            box-shadow: 0 5px 15px rgba(0,0,0,0.07), 0 1px 3px rgba(0,0,0,0.05); /* Softer shadow */
            min-width: 180px; 
            min-height: 140px;
            max-width: 50vw;
            max-height: 70vh;
            pointer-events: all;
            cursor: move;
            transition: box-shadow 0.2s, border-color 0.3s, background-color 0.3s, color 0.3s, width 0.25s ease-in-out, height 0.25s ease-in-out;
            transform-origin: top left;
            border: 1px solid; /* Use the element's color property for the border */
            border-color: color-mix(in srgb, currentColor 40%, transparent); /* Make border a softer version of the text color */
            overflow: hidden;
            color: var(--text-primary); /* Default text color */
        }
        [data-theme="dark"] .sticky-note-tile { color: #f0f6fc; }


        /* Light Theme (Default) Application */
        .sticky-note-tile.color-default    { background-color: var(--sticky-light-default-bg);    color: var(--sticky-light-default-text); }
        .sticky-note-tile.color-crimson    { background-color: var(--sticky-light-crimson-bg);    color: var(--sticky-light-crimson-text); }
        .sticky-note-tile.color-tangerine  { background-color: var(--sticky-light-tangerine-bg);  color: var(--sticky-light-tangerine-text); }
        .sticky-note-tile.color-sunflower  { background-color: var(--sticky-light-sunflower-bg);  color: var(--sticky-light-sunflower-text); }
        .sticky-note-tile.color-lime       { background-color: var(--sticky-light-lime-bg);       color: var(--sticky-light-lime-text); }
        .sticky-note-tile.color-forest     { background-color: var(--sticky-light-forest-bg);     color: var(--sticky-light-forest-text); }
        .sticky-note-tile.color-azure      { background-color: var(--sticky-light-azure-bg);      color: var(--sticky-light-azure-text); }
        .sticky-note-tile.color-indigo     { background-color: var(--sticky-light-indigo-bg);     color: var(--sticky-light-indigo-text); }
        .sticky-note-tile.color-amethyst   { background-color: var(--sticky-light-amethyst-bg);   color: var(--sticky-light-amethyst-text); }
        .sticky-note-tile.color-lavender   { background-color: var(--sticky-light-lavender-bg);   color: var(--sticky-light-lavender-text); }
        .sticky-note-tile.color-fuchsia    { background-color: var(--sticky-light-fuchsia-bg);    color: var(--sticky-light-fuchsia-text); }
        .sticky-note-tile.color-blush      { background-color: var(--sticky-light-blush-bg);      color: var(--sticky-light-blush-text); }
        .sticky-note-tile.color-terracotta { background-color: var(--sticky-light-terracotta-bg); color: var(--sticky-light-terracotta-text); }
        .sticky-note-tile.color-teal       { background-color: var(--sticky-light-teal-bg);       color: var(--sticky-light-teal-text); }
        .sticky-note-tile.color-slate      { background-color: var(--sticky-light-slate-bg);      color: var(--sticky-light-slate-text); }
        .sticky-note-tile.color-olive      { background-color: var(--sticky-light-olive-bg);      color: var(--sticky-light-olive-text); }

        /* Dark Theme Overrides */
        [data-theme="dark"] .sticky-note-tile.color-default    { background-color: var(--sticky-dark-default-bg);    color: var(--sticky-dark-default-text); }
        [data-theme="dark"] .sticky-note-tile.color-crimson    { background-color: var(--sticky-dark-crimson-bg);    color: var(--sticky-dark-crimson-text); }
        [data-theme="dark"] .sticky-note-tile.color-tangerine  { background-color: var(--sticky-dark-tangerine-bg);  color: var(--sticky-dark-tangerine-text); }
        [data-theme="dark"] .sticky-note-tile.color-sunflower  { background-color: var(--sticky-dark-sunflower-bg);  color: var(--sticky-dark-sunflower-text); }
        [data-theme="dark"] .sticky-note-tile.color-lime       { background-color: var(--sticky-dark-lime-bg);       color: var(--sticky-dark-lime-text); }
        [data-theme="dark"] .sticky-note-tile.color-forest     { background-color: var(--sticky-dark-forest-bg);     color: var(--sticky-dark-forest-text); }
        [data-theme="dark"] .sticky-note-tile.color-azure      { background-color: var(--sticky-dark-azure-bg);      color: var(--sticky-dark-azure-text); }
        [data-theme="dark"] .sticky-note-tile.color-indigo     { background-color: var(--sticky-dark-indigo-bg);     color: var(--sticky-dark-indigo-text); }
        [data-theme="dark"] .sticky-note-tile.color-amethyst   { background-color: var(--sticky-dark-amethyst-bg);   color: var(--sticky-dark-amethyst-text); }
        [data-theme="dark"] .sticky-note-tile.color-lavender   { background-color: var(--sticky-dark-lavender-bg);   color: var(--sticky-dark-lavender-text); }
        [data-theme="dark"] .sticky-note-tile.color-fuchsia    { background-color: var(--sticky-dark-fuchsia-bg);    color: var(--sticky-dark-fuchsia-text); }
        [data-theme="dark"] .sticky-note-tile.color-blush      { background-color: var(--sticky-dark-blush-bg);      color: var(--sticky-dark-blush-text); }
        [data-theme="dark"] .sticky-note-tile.color-terracotta { background-color: var(--sticky-dark-terracotta-bg); color: var(--sticky-dark-terracotta-text); }
        [data-theme="dark"] .sticky-note-tile.color-teal       { background-color: var(--sticky-dark-teal-bg);       color: var(--sticky-dark-teal-text); }
        [data-theme="dark"] .sticky-note-tile.color-slate      { background-color: var(--sticky-dark-slate-bg);      color: var(--sticky-dark-slate-text); }
        [data-theme="dark"] .sticky-note-tile.color-olive      { background-color: var(--sticky-dark-olive-bg);      color: var(--sticky-dark-olive-text); }

        @keyframes spawn-card { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .sticky-note-tile.spawn { animation: spawn-card 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .sticky-note-tile:hover, .sticky-note-tile.dragging { 
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1);
            border-color: var(--primary-color);
        }
        
        .sticky-note-header { 
            padding: 6px 10px; 
            flex-shrink: 0; 
            border-bottom: 1px solid; /* Use the element's color property for the divider */
            border-bottom-color: color-mix(in srgb, currentColor 30%, transparent); /* Make divider even more subtle */
            background-color: color-mix(in srgb, currentColor 8%, transparent);
        }
        .sticky-note-header h5 { 
            margin: 0; 
            font-weight: 600; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            cursor: pointer; 
            font-size: calc(var(--article-font-size) * 0.7);
        }
        .sticky-note-header h5:hover { text-decoration: underline; }
        
        .sticky-note-content { 
            flex-grow: 1;
            padding: 10px 12px;
            padding-bottom: 38px; /* Space for floating controls */
            overflow-y: auto; 
            overflow-x: hidden; 
            font-family: var(--font-serif); 
            line-height: 1.6;
            font-size: calc(var(--article-font-size) * 0.65);
        }

        /* Content Parsing Rules (Unchanged) */
        .sticky-note-content * { line-height: 1.6 !important; font-weight: normal !important; margin: 0 0 5px 0 !important; color: inherit !important; background: transparent !important; all:unset; display: block; }
        .sticky-note-content b, .sticky-note-content strong { font-weight: bold !important; } .sticky-note-content i, .sticky-note-content em { font-style: italic !important; } .sticky-note-content u { text-decoration: underline !important; } .sticky-note-content ul, .sticky-note-content ol { list-style-position: inside !important; padding-left: 8px !important; } .sticky-note-content li { display: list-item !important; }
        .sticky-note-content .rendered-tag, .sticky-note-content .mindmap-snippet, .sticky-note-content [class*="highlight-"] { font-weight: 600 !important; padding: 1px 3px; border-radius: 3px; display: inline; border-bottom: 2px solid; }
        .sticky-note-content .rendered-tag { background-color: var(--hl-7-bg) !important; border-color: var(--hl-7-border) !important; }
        .sticky-note-content .mindmap-snippet, .sticky-note-content [class*="highlight-"] { background-color: var(--mindmap-snippet-bg) !important; border-color: var(--mindmap-snippet-border) !important; }
        .sticky-note-content > *:first-child { margin-top: 0 !important; } 
        .sticky-note-content > *:last-child { margin-bottom: 0 !important; }

        .sticky-note-content::-webkit-scrollbar { width: 8px; }
        .sticky-note-content::-webkit-scrollbar-track { background: transparent; }
        .sticky-note-content::-webkit-scrollbar-thumb { background-color: transparent; border-radius: 4px; }
       .sticky-note-content:hover::-webkit-scrollbar-thumb {
            background-color: color-mix(in srgb, currentColor 60%, transparent); /* Use the note's text color */
        }
        .sticky-note-content::-webkit-scrollbar-thumb:active {
            background-color: color-mix(in srgb, currentColor 80%, transparent); /* Darken slightly on click */
        }

        /* Polished Floating Controls */
        .sticky-note-controls {
            position: absolute;
            bottom: 8px;
            right: 8px;
            display: flex;
            align-items: center;
            gap: 0px; 
            padding: 0px; 
            border-radius: var(--border-radius);
            background-color: rgba(var(--bg-secondary-rgb), 0.75);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
            opacity: 0; /* Completely hidden by default */
            transform: translateY(5px); /* Start slightly lower */
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
            z-index: 10;
        }
        .sticky-note-tile:hover .sticky-note-controls,
        .sticky-note-tile.dragging .sticky-note-controls {
            opacity: 1; /* Fully visible on hover or drag */
            transform: translateY(0); /* Animate upwards into view */
        }
        .sticky-note-controls .btn-icon {
            width: 28px;
            height: 28px;
            color: var(--text-secondary);
            background-color: transparent;
            transition: transform 0.15s ease-out, color 0.15s ease-out; /* Add transition for hover effect */
        }
        .sticky-note-controls .btn-icon:hover {
            color: var(--primary-color);
            background-color: color-mix(in srgb, var(--border-color) 40%, transparent);
            transform: scale(1.15); /* Pop effect on individual button hover */
        }
        

        /* --- NoteKash AI Magic Module (Co-Pilot) - PREMIUM POLISH --- */
        .ai-magic-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(var(--bg-primary-rgb), 0.5) 0%, rgba(var(--bg-primary-rgb), 0.8) 100%);
            z-index: 10001;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            animation: fadeIn 0.3s ease;
        }
        @keyframes copilot-border-glow {
            from {
                border-color: color-mix(in srgb, var(--primary-color) 25%, transparent);
                box-shadow: 0 10px 40px -10px rgba(0,0,0,0.35), 
                            0 0 8px -2px color-mix(in srgb, var(--primary-color) 30%, transparent);
            }
            to {
                border-color: color-mix(in srgb, var(--primary-color) 65%, transparent);
                box-shadow: 0 10px 40px -10px rgba(0,0,0,0.35), 
                            0 0 25px 4px color-mix(in srgb, var(--primary-color) 25%, transparent);
            }
        }
        .ai-magic-modal {
            width: 100%;
            max-width: 720px;
            height: 85vh;
            max-height: 600px;
            display: flex;
            flex-direction: column;

            background-color: rgba(var(--bg-secondary-rgb), 0.6);
            background-image: 
                radial-gradient(at 0% 0%, color-mix(in srgb, var(--primary-color) 15%, transparent) 0px, transparent 50%),
                radial-gradient(at 100% 100%, color-mix(in srgb, var(--cat-color-3-bg) 20%, transparent) 0px, transparent 50%);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1.5px solid;
            border-radius: 20px;
            box-shadow: 0 10px 40px -10px rgba(0,0,0,0.35), 
                        inset 0 1px 1px rgba(255,255,255,0.1); /* Inner top highlight for 3D effect */
            animation: growInFromCenter 0.8s cubic-bezier(0.4, 0, 0.2, 1), 
               copilot-border-glow 5s infinite alternate ease-in-out;
            overflow: hidden;
        }
        .ai-magic-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            background-color: rgba(var(--bg-primary-rgb), 0.7);
            text-align: center;
        }
        
       .ai-magic-title {
            font-size: 1.5rem;
            font-weight: 700; /* BOLD, for clear presence */
            letter-spacing: 0.3px;
            margin-bottom: 0.75rem;
            padding: 0.25rem 0;
            background-image: none;
            background-clip: unset;
            -webkit-background-clip: unset;
            -webkit-text-fill-color: unset;
            color: var(--primary-color);
        }
     

        .ai-magic-prompt-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 4px 4px 4px 12px;
            transition: all 0.2s ease-in-out;
        }
        #ai-magic-prompt-input {
            width: 100%;
            font-size: 0.95rem;
            border: none;
            background: transparent;
            color: var(--text-primary);
            outline: none;
            flex-grow: 1;
            resize: none;
        }
        #ai-magic-prompt-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }
        .ai-magic-prompt-container:focus-within {
            border-color: var(--primary-color);
            background-color: var(--bg-secondary);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-color) 25%, transparent),
                        inset 0 1px 2px rgba(0,0,0,0.1);
        }
        #ai-magic-command-list {
            overflow-y: auto;
            flex-grow: 1;
            padding: 1rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Use the flexible grid by default */
            gap: 0.75rem;
        }
        #ai-magic-command-list.compact-grid {
            justify-content: start; /* Align grid items to the left */
            grid-template-columns: repeat(auto-fit, 180px); /* Use fixed-width columns for few items */
        }
        .ai-magic-command-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: var(--border-radius);
            background: linear-gradient(145deg, rgba(var(--bg-primary-rgb), 0.4), rgba(var(--bg-primary-rgb), 0.7));
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 1px solid var(--border-color);
            position: relative;
        }
        .ai-magic-command-item:hover {
            transform: translateY(-4px) scale(1.02); /* Slightly more subtle scale */
            border-color: color-mix(in srgb, var(--primary-color) 70%, var(--border-color));
            background: linear-gradient(145deg, rgba(var(--bg-secondary-rgb), 0.7), rgba(var(--bg-primary-rgb), 0.9)); /* "Lights up" */
            box-shadow: 0 0 20px 5px color-mix(in srgb, var(--primary-color) 15%, transparent); /* Inner glow effect */
        }
        .ai-magic-command-item.selected {
            transform: translateY(-4px) scale(1.03);
            background-color: var(--bg-primary);
            border-color: var(--primary-color);
            box-shadow: 0 0 20px -5px color-mix(in srgb, var(--primary-color) 40%, transparent);
        }
        .ai-magic-command-item.selected::after {
            content: 'âŽ';
            position: absolute;
            right: 8px;
            top: 8px;
            font-size: 0.9rem;
            color: var(--primary-color);
            font-weight: bold;
        }
        .ai-magic-command-item .command-icon {
            width: 36px;
            height: 36px;
            font-size: 1.3rem;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-color);
            background-color: var(--bg-tertiary);
            border-radius: 8px;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }
        .ai-magic-command-item .command-text {
            overflow: hidden;
        }
        .ai-magic-command-item .command-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        .ai-magic-separator {
            grid-column: 1 / -1;
            height: 1px;
            background-color: var(--border-color);
            margin: 4px 0;
            opacity: 0.6;
        }
        #ai-magic-prompt-send {
            flex-shrink: 0;
            background: var(--action-button-gradient); /* Use consistent action gradient */
            border: 1px solid rgba(0,0,0,0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        #ai-magic-prompt-send:hover {
            transform: scale(1.1);
            box-shadow: 0 0 12px color-mix(in srgb, var(--primary-color) 40%, transparent);
        }
        #ai-magic-prompt-send:active {
            transform: scale(0.95); /* A more subtle but firm press */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            transition-duration: 0.1s;
        }
        #ai-magic-prompt-send svg {
            transform: translateX(1px); /* Perfect horizontal centering */
        }

        /* --- NEW: Premium AI Upsell Card --- */
        .ai-upsell-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            padding: 2rem 1.5rem;
            height: 100%;
            box-sizing: border-box;
            justify-content: center;
            animation: fadeIn 0.5s ease-out 0.1s backwards;
            border-radius: var(--border-radius-lg);
            background: 
                linear-gradient(rgba(var(--bg-secondary-rgb), 0.8), rgba(var(--bg-secondary-rgb), 0.8)) padding-box,
                linear-gradient(145deg, var(--primary-color), color-mix(in srgb, var(--primary-color) 40%, transparent)) border-box;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
        }
        .ai-upsell-card .badge-icon {
            margin-bottom: 1.5rem;
            transform: scale(1.15);
        }
        .ai-upsell-card h4 {
            font-family: var(--font-display);
            font-size: 1.5rem;
            margin: 0 0 0.75rem 0;
            background-image: var(--action-button-gradient);
            background-size: 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        [data-theme="dark"] .ai-upsell-card h4 {
            background-image: linear-gradient(45deg, #E0B453, #E6845E);
        }
        .ai-upsell-card p {
            color: var(--text-secondary);
            max-width: 400px;
            line-height: 1.6;
            font-size: 1rem;
            margin: 0 0 2rem 0;
        }
        .ai-upsell-card .btn-primary {
            padding: 0.8rem 2rem;
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 0 25px -5px color-mix(in srgb, var(--primary-color) 50%, transparent);
            border: 1px solid rgba(0,0,0,0.1);
        }
        .ai-upsell-card .witty-gradient-text {
            font-size: 1rem;
            font-style: italic;
            opacity: 0.85;
        }




        /* --- Command Palette --- */
        #command-palette {
            position: absolute;
            z-index: 10002;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            width: 380px; /* Slightly wider */
            max-height: 400px; /* Slightly taller */
            padding: 0; /* Remove padding */
            display: flex; /* Use flexbox */
            flex-direction: column; /* Stack input and list vertically */
            overflow: hidden; /* Prevent content spill */
        }
        #command-palette-input-wrapper {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0; /* Prevent the input from shrinking */
        }
        #command-palette-input {
            width: 100%;
            padding: 8px 12px;
            font-size: 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            outline: none;
        }
        #command-palette-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }
        #command-palette-list {
            padding: 4px;
            overflow-y: auto; /* Allow only the list to scroll */
            flex-grow: 1; /* Allow the list to take remaining space */
        }
        .command-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
        }
        .command-item.selected {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
        }
        .command-item-icon {
            width: 32px;
            height: 32px;
            font-size: 1rem;
            flex-shrink: 0;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
        }
        .command-item.selected .command-item-icon {
            background-color: rgba(255,255,255,0.2);
        }
        .command-item-text {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .command-item-title {
            font-weight: 500;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .command-item-desc {
            font-size: 0.8rem;
            opacity: 0.7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .command-item.selected .command-item-desc {
            color: var(--text-on-primary);
        }
        
        .nk-stat-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background-color: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 4px 10px;
            border-radius: 16px;
            font-size: 0.85rem;
            font-family: var(--font-body);
            font-weight: 500;
            border: 1px solid var(--border-color);
            cursor: default;
            user-select: none;
            margin: 0 4px;
        }
        .nk-stat-badge i {
            font-size: 0.85em; /* Set icon size relative to text */
            line-height: 1;
            /* The color is automatically inherited from the parent .nk-stat-badge */
        }
        


        /* --- Timeline Block (Pixel-Perfect Alignment) --- */
        .nk-timeline-block {
            position: relative;
            padding: 2rem 0 0;
            margin: 2rem auto;
            max-width: 90ch;
        }

        .nk-timeline-block::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            bottom: 25px; 
            transform: translateX(-50%);
            width: 4px; 
            background: linear-gradient(
                to bottom,
                color-mix(in srgb, var(--primary-color) 80%, transparent),
                var(--border-color),
                var(--primary-color)
            );
            border-radius: 4px;
        }

        .nk-timeline-entry {
            position: relative;
            width: 50%;
            /* FIX: Removing top/bottom padding here aligns the child content box's context with the entry's context. */
            padding: 0 45px;
            margin-bottom: 25px;
        }

        .nk-timeline-entry:nth-child(odd) { left: 0; text-align: right; }
        .nk-timeline-entry:nth-child(even) { left: 50%; text-align: left; }

        /* The new solid dot icon, now perfectly centered horizontally and vertically. */
        .nk-timeline-entry::after {
            content: '';
            position: absolute;
            /* FIX: A clean, borderless circle */
            width: 16px;
            height: 16px;
            border: none;
            background-color: var(--primary-color);
            /* RATIONALE: This top value acts as a shared 'anchor line' for both the icon and the arrow. */
            top: 27px; 
            /* RATIONALE: This transform vertically centers the 16px dot on the 27px anchor line. */
            transform: translateY(-50%);
            border-radius: 50%;
            z-index: 1;
            transition: transform 0.2s ease-out;
        }

        /* FIX: Positioning the icon by exactly half its width (-8px) guarantees its center is on the timeline. */
        .nk-timeline-entry:nth-child(odd)::after { right: -8px; }
        .nk-timeline-entry:nth-child(even)::after { left: -8px; }

        .nk-timeline-entry:hover::after {
            transform: scale(1.2) translateY(-50%);
        }

        .nk-timeline-content {
            padding: 1.25rem;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow);
            border-top: 4px solid var(--primary-color);
            position: relative;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }

        .nk-timeline-content:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-lg);
        }

        /* The arrow, now perfectly aligned with the dot icon. */
        .nk-timeline-content::before {
            content: " ";
            height: 0;
            position: absolute;
            /* RATIONALE: It uses the exact same anchor and transform as the icon, ensuring they are always aligned. */
            top: 27px;
            transform: translateY(-50%);
            width: 0;
            z-index: 1;
            border: medium solid var(--border-color);
        }

        .nk-timeline-entry:nth-child(odd) .nk-timeline-content::before { right: -15px; border-width: 10px 0 10px 15px; border-color: transparent transparent transparent var(--border-color); }
        .nk-timeline-entry:nth-child(even) .nk-timeline-content::before { left: -15px; border-width: 10px 15px 10px 0; border-color: transparent var(--border-color) transparent transparent; }

        .nk-timeline-date {
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
            font-size: 0.9em;
            outline: none;
            opacity: 0.9;
        }
        .nk-timeline-title {
            font-weight: 500;
            font-size: 1.05em;
            outline: none;
        }

        /* The add button styling remains the same as the last fix. */
        .nk-timeline-add {
            text-align: center;
            position: relative;
            padding-bottom: 1rem;
        }
        .nk-timeline-add button {
            width: 40px; 
            height: 40px; 
            border-radius: 50%;
            border: 4px solid var(--bg-secondary);
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            font-size: 0; 
            line-height: 1;
            cursor: pointer; 
            transition: all 0.2s ease-out;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
        }
        .nk-timeline-add button:hover {
            background-color: var(--primary-color-hover);
            transform: scale(1.1);
            box-shadow: var(--shadow-lg);
            font-size: 1.8rem; 
        }
        .focus-mode-overlay .nk-timeline-block {
            max-width: 100%;
            margin-left: 0;
            margin-right: 0;
            padding-left: 1rem;
            padding-right: 1rem;
        }


        /* --- NEW: MCQ Block Styles (Feature #2) --- */
        .nk-mcq-block {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-left: 5px solid var(--primary-color);
            border-radius: var(--border-radius);
            padding: 0.5rem;
            margin: 0.3em 0;
            box-shadow: var(--shadow-sm);
        }
        .nk-mcq-question {
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 1rem;
            outline: none;
            line-height: 1.4;
        }
        .nk-mcq-question:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            font-weight: normal;
        }
        .nk-mcq-options {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .nk-mcq-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            transition: all 0.2s ease;
        }
        .nk-mcq-option-radio {
            width: 22px;
            height: 22px;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            position: relative;
        }
        .nk-mcq-option-text {
            flex-grow: 1;
            outline: none;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            border: 1px solid transparent;
            transition: all 0.2s ease-in-out;
        }
        .nk-mcq-option-text:focus-within {
            border-color: var(--primary-color);
            background-color: var(--bg-tertiary);
        }
        .nk-mcq-option-text:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
        }
        .nk-mcq-delete-option {
            background: none; border: none;
            color: var(--text-secondary); cursor: pointer;
            opacity: 0; transition: opacity 0.2s;
        }
        .nk-mcq-option:hover .nk-mcq-delete-option {
            opacity: 0.5;
        }
        .nk-mcq-delete-option:hover {
            opacity: 1; color: var(--danger-color);
        }
        /* --- Write Mode Specific Styles --- */
        body.write-mode .nk-mcq-option[data-is-correct="true"] .nk-mcq-option-radio {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }
        body.write-mode .nk-mcq-option[data-is-correct="true"] .nk-mcq-option-radio::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 8px; height: 8px; background-color: white;
            border-radius: 50%; transform: translate(-50%, -50%);
        }
        /* --- Read Mode Specific Styles --- */
        body.read-mode .nk-mcq-add-option,
        body.read-mode .nk-mcq-delete-option,
        body.read-mode .nk-mcq-option-radio,
        .focus-mode-overlay .nk-mcq-add-option {
            display: none;
        }

        body.read-mode .nk-mcq-option {
            padding: 8px 12px;
            border: 2px solid var(--border-color); /* Slightly thicker base border */
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        body.read-mode .nk-mcq-block:not([data-answered="true"]) .nk-mcq-option:hover {
            border-color: var(--primary-color);
            background-color: var(--bg-tertiary);
        }
        body.read-mode .nk-mcq-block[data-answered="true"] .nk-mcq-option {
            cursor: default;
        }
        /* NEW: A more subtle, border-focused style for the correct answer */
        body.read-mode .nk-mcq-option.correct {
            border: 3px solid var(--success-color);
            color: var(--text-primary);
            background-color: color-mix(in srgb, var(--success-color) 10%, var(--bg-secondary));
            padding: 7px 11px; /* Adjust padding to prevent layout shift */
        }
        /* NEW: A more subtle, border-focused style for the incorrect answer */
        body.read-mode .nk-mcq-option.incorrect {
            border: 3px solid var(--danger-color);
            color: var(--text-primary);
            background-color: color-mix(in srgb, var(--danger-color) 10%, var(--bg-secondary));
            padding: 7px 11px; /* Adjust padding to prevent layout shift */
        }
        /* --- NEW: MCQ Study Card Font Size Fix --- */
        .study-card-content-box.mcq-type {
            font-size: var(--study-card-font-size, 1.5rem); /* FIX: Use the CSS variable */
            line-height: 1.6;
        }
        
        .focus-mode-overlay .nk-mcq-block .nk-mcq-option-radio,
        .focus-mode-overlay .nk-mcq-block .nk-mcq-delete-option {
            display: none;
        }

        .focus-mode-overlay .nk-mcq-block .nk-mcq-option-text {
            padding: 0; /* Remove padding to match the container */
        }

        .focus-mode-overlay .nk-mcq-block .nk-mcq-option {
            padding: 8px 12px;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .focus-mode-overlay .nk-mcq-block:not([data-answered="true"]) .nk-mcq-option:hover {
            border-color: var(--primary-color);
            background-color: var(--bg-tertiary);
        }

        .focus-mode-overlay .nk-mcq-block[data-answered="true"] .nk-mcq-option {
            cursor: default;
        }

        .focus-mode-overlay .nk-mcq-block .nk-mcq-option.correct {
            border: 3px solid var(--success-color);
            background-color: color-mix(in srgb, var(--success-color) 10%, var(--bg-secondary));
            padding: 7px 11px;
        }

        .focus-mode-overlay .nk-mcq-block .nk-mcq-option.incorrect {
            border: 3px solid var(--danger-color);
            background-color: color-mix(in srgb, var(--danger-color) 10%, var(--bg-secondary));
            padding: 7px 11px;
        }
        /* --- NEW: Styles for MCQ Answer Explanation --- */
        .nk-mcq-explanation {
            outline: none;
            margin-top: 1.25rem;
            padding: 0.75rem 1rem;
            background-color: color-mix(in srgb, var(--border-color) 20%, transparent);
            border-radius: var(--border-radius);
            border-left: 3px solid var(--primary-color);
            font-size: 0.9em;
            color: var(--text-secondary);
            line-height: 1.6;
        }
        .nk-mcq-explanation:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            opacity: 0.7;
            font-style: italic;
        }
        /* Hide explanation in read/presentation mode by default */
        body.read-mode .nk-mcq-explanation,
        .focus-mode-overlay .nk-mcq-explanation {
            display: none;
        }
        /* Reveal explanation only after an answer has been selected */
        body.read-mode .nk-mcq-block[data-answered="true"] .nk-mcq-explanation,
        .focus-mode-overlay .nk-mcq-block[data-answered="true"] .nk-mcq-explanation {
            display: block;
            animation: fadeIn 0.4s ease 0.2s forwards;
            opacity: 0;
        }
        .nk-mcq-block[data-answered="true"] .nk-mcq-explanation:empty {
            display: none !important;
            margin: 0;
            padding: 0;
            border: none;
        }


        /* --- NEW: Text Tile (Feature #3 - "/textile" command) --- */
        .nk-text-tile {
            display: inline-flex;
            align-items: center;
            gap: 0.15rem; /* Space between icon and text */
            vertical-align: middle;
            border: 1px solid;
            border-radius: var(--border-radius-lg);
            padding: 0.25rem;
            box-shadow: var(--shadow-sm);
            position: relative;
            max-width: 100%; 
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        
        .nk-text-tile-icon {
            font-size: 1em;
            opacity: 0.9;
        }

        /* --- NEW TEXTILE RULES for Themes--- */
        .nk-text-tile.color-1 { background-color: var(--textile-light-bg-1); border-color: var(--textile-light-border-1); }
        .nk-text-tile.color-2 { background-color: var(--textile-light-bg-2); border-color: var(--textile-light-border-2); }
        .nk-text-tile.color-3 { background-color: var(--textile-light-bg-3); border-color: var(--textile-light-border-3); }
        .nk-text-tile.color-4 { background-color: var(--textile-light-bg-4); border-color: var(--textile-light-border-4); }
        .nk-text-tile.color-5 { background-color: var(--textile-light-bg-5); border-color: var(--textile-light-border-5); }
        .nk-text-tile.color-6 { background-color: var(--textile-light-bg-6); border-color: var(--textile-light-border-6); }
        .nk-text-tile.color-7 { background-color: var(--textile-light-bg-7); border-color: var(--textile-light-border-7); }
        .nk-text-tile.color-8 { background-color: var(--textile-light-bg-8); border-color: var(--textile-light-border-8); }
        .nk-text-tile.color-9 { background-color: var(--textile-light-bg-9); border-color: var(--textile-light-border-9); }
        .nk-text-tile.color-10 { background-color: var(--textile-light-bg-10); border-color: var(--textile-light-border-10); }

        [data-theme="dark"] .nk-text-tile.color-1 { background-color: var(--textile-dark-bg-1); border-color: var(--textile-dark-border-1); }
        [data-theme="dark"] .nk-text-tile.color-2 { background-color: var(--textile-dark-bg-2); border-color: var(--textile-dark-border-2); }
        [data-theme="dark"] .nk-text-tile.color-3 { background-color: var(--textile-dark-bg-3); border-color: var(--textile-dark-border-3); }
        [data-theme="dark"] .nk-text-tile.color-4 { background-color: var(--textile-dark-bg-4); border-color: var(--textile-dark-border-4); }
        [data-theme="dark"] .nk-text-tile.color-5 { background-color: var(--textile-dark-bg-5); border-color: var(--textile-dark-border-5); }
        [data-theme="dark"] .nk-text-tile.color-6 { background-color: var(--textile-dark-bg-6); border-color: var(--textile-dark-border-6); }
        [data-theme="dark"] .nk-text-tile.color-7 { background-color: var(--textile-dark-bg-7); border-color: var(--textile-dark-border-7); }
        [data-theme="dark"] .nk-text-tile.color-8 { background-color: var(--textile-dark-bg-8); border-color: var(--textile-dark-border-8); }
        [data-theme="dark"] .nk-text-tile.color-9 { background-color: var(--textile-dark-bg-9); border-color: var(--textile-dark-border-9); }
        [data-theme="dark"] .nk-text-tile.color-10 { background-color: var(--textile-dark-bg-10); border-color: var(--textile-dark-border-10); }

        [data-theme="sepia"] .nk-text-tile.color-1 { background-color: var(--textile-sepia-bg-1); border-color: var(--textile-sepia-border-1); }
        [data-theme="sepia"] .nk-text-tile.color-2 { background-color: var(--textile-sepia-bg-2); border-color: var(--textile-sepia-border-2); }
        [data-theme="sepia"] .nk-text-tile.color-3 { background-color: var(--textile-sepia-bg-3); border-color: var(--textile-sepia-border-3); }
        [data-theme="sepia"] .nk-text-tile.color-4 { background-color: var(--textile-sepia-bg-4); border-color: var(--textile-sepia-border-4); }
        [data-theme="sepia"] .nk-text-tile.color-5 { background-color: var(--textile-sepia-bg-5); border-color: var(--textile-sepia-border-5); }
        [data-theme="sepia"] .nk-text-tile.color-6 { background-color: var(--textile-sepia-bg-6); border-color: var(--textile-sepia-border-6); }
        [data-theme="sepia"] .nk-text-tile.color-7 { background-color: var(--textile-sepia-bg-7); border-color: var(--textile-sepia-border-7); }
        [data-theme="sepia"] .nk-text-tile.color-8 { background-color: var(--textile-sepia-bg-8); border-color: var(--textile-sepia-border-8); }
        [data-theme="sepia"] .nk-text-tile.color-9 { background-color: var(--textile-sepia-bg-9); border-color: var(--textile-sepia-border-9); }
        [data-theme="sepia"] .nk-text-tile.color-10 { background-color: var(--textile-sepia-bg-10); border-color: var(--textile-sepia-border-10); }

        /* Ghost & Outline Styles */
        .nk-text-tile.color-default { background-color: transparent; border-color: var(--border-color); }
        .nk-text-tile.color-ghost-1, .nk-text-tile.color-ghost-2 { background-color: transparent; border-width: 2px; }
        .nk-text-tile.color-ghost-1 { border-color: var(--textile-light-ghost-1); }
        .nk-text-tile.color-ghost-2 { border-color: var(--textile-light-ghost-2); }
        [data-theme="dark"] .nk-text-tile.color-ghost-1 { border-color: var(--textile-dark-ghost-1); }
        [data-theme="dark"] .nk-text-tile.color-ghost-2 { border-color: var(--textile-dark-ghost-2); }
        [data-theme="sepia"] .nk-text-tile.color-ghost-1 { border-color: var(--textile-sepia-ghost-1); }
        [data-theme="sepia"] .nk-text-tile.color-ghost-2 { border-color: var(--textile-sepia-ghost-2); }

        @keyframes ghost-glow-1 {
            from { box-shadow: 0 0 4px -2px var(--border-color); }
            to { box-shadow: 0 0 10px 1px var(--textile-light-ghost-1); }
        }
        @keyframes ghost-glow-2 {
            from { box-shadow: 0 0 4px -2px var(--border-color); }
            to { box-shadow: 0 0 10px 1px var(--textile-light-ghost-2); }
        }
        body.write-mode .nk-text-tile.color-ghost-1:hover { animation: ghost-glow-1 3s infinite alternate; }
        body.write-mode .nk-text-tile.color-ghost-2:hover { animation: ghost-glow-2 3s infinite alternate; }

        [data-theme="dark"] .nk-text-tile.color-ghost-1, [data-theme="sepia"] .nk-text-tile.color-ghost-1 {
            --textile-light-ghost-1: var(--textile-dark-ghost-1);
        }
        [data-theme="dark"] .nk-text-tile.color-ghost-2, [data-theme="sepia"] .nk-text-tile.color-ghost-2 {
            --textile-light-ghost-2: var(--textile-dark-ghost-2);
        }

        .nk-text-tile-content {
            outline: none;
            font-family: var(--font-body);
            font-size: 1.05rem;
            line-height: 1.5;
            color: var(--hl-text);
            min-width: 20px; 
        }
        .nk-text-tile-content:empty::before {
            content: attr(data-placeholder);
            color: var(--text-secondary);
            opacity: 0.7;
            font-style: italic;
            pointer-events: none;
        }
        .nk-text-tile-color-cycler {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s;
        }
        body.write-mode .nk-text-tile:hover .nk-text-tile-color-cycler {
            opacity: 1;
            transform: scale(1);
        }
        /* NEW: Read Mode Fading for Memorization */
        body.read-mode .nk-text-tile {
            cursor: pointer;
        }
        body.read-mode .nk-text-tile.faded {
            border-style: dashed;
            box-shadow: none;
        }
        body.read-mode .nk-text-tile.faded .nk-text-tile-content {
            color: transparent; /* Hides the text */
            user-select: none;
        }
        /* --- NEW: Text Tile & Decktile System --- */
        .nk-text-tile {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem; /* Space between icon and text */
            vertical-align: middle;
            border: 1px solid;
            border-radius: var(--border-radius-lg);
            padding: 0.5rem 1rem;
            margin: 0.25rem 0.5rem;
            box-shadow: var(--shadow-sm);
            position: relative;
            max-width: 90%; 
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            /* FIX: min-width is removed to allow tiles to shrink-to-fit their content */
        }
        
        .nk-text-tile-icon {
            font-size: 0.9em;
            opacity: 0.7;
        }
        .search-result-item .nk-text-tile {
            display: flex;
            width: 100%;
            max-width: 100%;
        }
        .search-result-item .nk-text-tile-content {
            font-size: inherit;
        }
        /* --- NEW: Decktile Container --- */
        .nk-textile-deck {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 1rem;
            border-radius: var(--border-radius-lg);
            border: 1px dashed var(--border-color);
            background-color: color-mix(in srgb, var(--border-color) 10%, transparent);
            margin: 1.5em 0;
            position: relative; /* For positioning the layout toggle */
        }
        /* A Textile inside a deck loses its margin to fit neatly */
        .nk-textile-deck .nk-text-tile {
            margin: 0;
            flex-grow: 1; /* Allows tiles to fill space nicely */
            min-width: 150px; /* Gives a minimum size inside the flex container */
        }
        
        /* NEW: Stack layout for Decks */
        .nk-textile-deck.layout-stack {
            flex-direction: column;
            align-items: stretch;
        }
        
        .deck-add-tile-btn {
            display: none; /* Hide by default */
            align-items: center;
            justify-content: center;
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius-lg);
            min-height: 50px;
            color: var(--text-secondary);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-grow: 1;
            min-width: 150px;
        }
        /* Show Add button ONLY in write mode */
        body.write-mode .deck-add-tile-btn {
            display: flex;
        }

        .deck-add-tile-btn:hover {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            border-color: var(--primary-color);
        }
        
        .deck-layout-toggle {
            position: absolute;
            top: -12px;
            right: 8px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            color: var(--text-secondary);
            cursor: pointer;
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }
        /* Show layout toggle on hover in BOTH modes */
        .nk-textile-deck:hover .deck-layout-toggle {
            display: flex;
        }
        .deck-layout-toggle:hover {
            color: var(--primary-color);
            transform: scale(1.1);
        }
        /* --- FIX: Make standalone text tiles full-width --- */
        #article-content > .nk-text-tile {
            display: flex;
            width: 100%;
            max-width: 100%;
            margin-left: 0;
            margin-right: 5px;
        }
        #article-content > .nk-text-tile .nk-text-tile-content {
            white-space: normal;
        }
        
        /* --- NEW: Power Quote Gradient Text (Theme-Sensitive v2) --- */
        .power-quote-gradient {
            font-weight: 500;
            font-style: italic;
            background-size: 200% auto;
            color: #000; /* Fallback color */
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: witty-text-glow 5s linear infinite;
            /* RATIONALE: This prevents it from behaving like a link, which it isn't. */
            cursor: default; 
        }

        /* Light Theme: A vibrant, optimistic gradient */
        [data-theme="light"] .power-quote-gradient {
            background-image: linear-gradient(90deg, #0d9488, #581c87, #0f766e);
        }

        /* Dark Theme: A luminous, inspiring gradient */
        [data-theme="dark"] .power-quote-gradient {
            background-image: linear-gradient(90deg, #E0B453, #34d399, #F7C96D);
        }

        /* Sepia Theme: An elegant, antique gradient */
        [data-theme="sepia"] .power-quote-gradient {
            background-image: linear-gradient(90deg, #8c6d46, #4d7c0f, #73552a);
        }


        /* KASH Co-Pilot (AI Sidebar) */
        @keyframes copilot-glow {
            from {
                box-shadow: 0 0 8px -2px color-mix(in srgb, var(--primary-color) 40%, transparent);
                border-color: color-mix(in srgb, var(--primary-color) 70%, transparent);
            }
            to {
                box-shadow: 0 0 20px 4px color-mix(in srgb, var(--primary-color) 25%, transparent);
                border-color: var(--primary-color);
            }
        }
        @keyframes subtle-pan {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #kash-copilot-toggle { /* This part remains unchanged */
            position: fixed; bottom: 1.5rem; right: 1.5rem; z-index: 25005;
            width: 38px; height: 38px; border-radius: 50%;
            background-color: rgba(var(--bg-secondary-rgb), 0.7);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            border: 1.5px solid var(--border-color); color: var(--primary-color);
            display: flex; align-items: center; justify-content: center;
            animation: copilot-glow 4s infinite alternate ease-in-out;
            transition: all 0.3s ease-in-out;
        }
        #kash-copilot-toggle:hover {
            transform: scale(1.1); border-color: var(--primary-color);
            background-color: rgba(var(--bg-secondary-rgb), 0.9);
            animation-play-state: paused;
        }
        #kash-copilot-toggle svg { padding-top: 2px; }

        #kash-copilot-sidebar {
            position: fixed; z-index: 25010; display: flex; flex-direction: column;
            border: 1px solid var(--border-color); box-shadow: var(--shadow-lg);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s;
            opacity: 0; transform: translateX(100%);
            
            /* NEW: Animated Gradient Background */
            background: radial-gradient(ellipse at top right, color-mix(in srgb, var(--primary-color) 20%, transparent), transparent 50%),
                        radial-gradient(ellipse at bottom left, color-mix(in srgb, var(--cat-color-3-bg) 30%, transparent), transparent 70%),
                        var(--bg-primary);
            background-size: 200% 200%;
            animation: subtle-pan 25s ease infinite;
        }
        #kash-copilot-sidebar.visible { opacity: 1; transform: translateX(0); }

        /* Media queries remain unchanged */
        @media (min-width: 769px) { #kash-copilot-sidebar { top: 60px; right: 1rem; bottom: 1.5rem; width: clamp(420px, 45%, 600px); border-radius: var(--border-radius-lg); } }
        @media (max-width: 768px) { #kash-copilot-toggle { bottom: 1rem; right: 1rem; } #kash-copilot-sidebar { bottom: 0; left: 0; right: 0; width: 100%; height: 62vh; border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0; transform: translateY(100%); } }

        #copilot-header {
            flex-shrink: 0; display: flex; justify-content: space-between; align-items: center;
            padding: 0.5rem 0.75rem; border-bottom: 1px solid var(--border-color);
            /* NEW: Glassmorphic header */
            background-color: rgba(var(--bg-secondary-rgb), 0.5);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        }
        #copilot-header .btn-icon:hover { transform: scale(1.1); color: var(--primary-color); }

        #copilot-conversation-area {
            flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column;
        }
        .copilot-empty-state {
            flex-grow: 1; display: flex; flex-direction: column;
            justify-content: center; align-items: center; gap: 2rem;
            padding: 1rem; text-align: center;
        }
        /* NEW: Centered Header Container */
        .copilot-centered-header {
            display: flex; flex-direction: column; align-items: center;
        }
        .copilot-centered-header h2 { font-size: 1.5rem; margin: 0; }
        .copilot-centered-header p { color: var(--text-secondary); margin: 0.25rem 0 0 0; }
        
        /* NEW: Glassmorphic Prompt Cards */
        .copilot-prompt-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; width: 100%;
        }
        .copilot-prompt-card {
            background-color: rgba(var(--bg-secondary-rgb), 0.4);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 0.75rem;
            display: flex; flex-direction: column; align-items: center; gap: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-size: 0.85rem; font-weight: 500;
        }
        .copilot-prompt-card:hover {
            transform: translateY(-3px);
            background-color: rgba(var(--bg-secondary-rgb), 0.7);
            border-color: var(--primary-color);
            box-shadow: 0 0 10px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }
        .copilot-prompt-card i { font-size: 1.1rem; color: var(--primary-color); }

        /* The rest of the styles are slightly refined for the new theme */
        #copilot-conversation-area { padding: 1rem; gap: 1.25rem; }
        .copilot-message { display: flex; gap: 0.75rem; max-width: 100%; }
        .copilot-message.user { justify-content: flex-end; }
        .copilot-message-bubble { padding: 0.75rem 1rem; border-radius: var(--border-radius-lg); line-height: 1.6; max-width: 90%; box-shadow: var(--shadow-sm); }
        .copilot-message.user .copilot-message-bubble { background-color: var(--primary-color); color: var(--text-on-primary); border-bottom-right-radius: 4px; }
        .copilot-message.ai .copilot-message-bubble { background-color: var(--bg-primary); border: 1px solid var(--border-color); border-bottom-left-radius: 4px; }
        .copilot-message.ai .copilot-message-bubble[contenteditable="true"]:focus-within { box-shadow: 0 0 0 2px var(--primary-color); }
        #copilot-input-container {
            position: relative; flex-shrink: 0; padding: 0.75rem;
            border-top: 1px solid var(--border-color); display: flex; align-items: flex-end; gap: 0.5rem;
            background-color: rgba(var(--bg-tertiary-rgb), 0.7); /* Glassmorphic input area */
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        }
        #copilot-input {
            flex-grow: 1; resize: none; max-height: 150px; font-size: 0.95rem; line-height: 1.5; padding: 10px 14px;
            border: 1px solid var(--border-color); background-color: var(--bg-secondary);
            color: var(--text-primary); border-radius: var(--border-radius);
        }
        #copilot-input:focus {
            outline: none; border-color: var(--primary-color);
            box-shadow: 0 0 8px 2px color-mix(in srgb, var(--primary-color) 40%, transparent); /* NEW: Focus glow */
        }
        #copilot-send-btn { width: 40px; height: 40px; }
        #copilot-send-btn svg {
            transform: translate(0px, 1.5px); 
        }
        .copilot-bubble-actions { display: none; justify-content: flex-end; gap: 0.5rem; margin-top: 0.75rem; padding-top: 0.5rem; border-top: 1px solid color-mix(in srgb, var(--border-color) 50%, transparent); }
        .copilot-message.ai .copilot-message-bubble:hover .copilot-bubble-actions { display: flex; }
        .copilot-bubble-actions .btn { font-size: 0.8rem; padding: 4px 10px; }
        #copilot-command-list button { display: flex; align-items: center; gap: 12px; font-size: 0.85rem; }
        #copilot-command-list button.selected { background-color: var(--primary-color); color: var(--text-on-primary); }
        #copilot-command-list .command-icon { font-size: 1.1em; width: 24px; text-align: center; }




        /* === NEW: Aesthetic Welcome Screen (v2.101 FINAL) === */
        @keyframes warm-glow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .welcome-hero .library-title {
            background: linear-gradient(90deg, #f43f5e, #fbbf24, #0d9488, #f43f5e);
            background-size: 250% 250%;
            animation: warm-glow 15s ease infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .welcome-container {
            max-width: 800px;
            margin: 8vh auto;
            animation: fadeIn 0.5s ease-out forwards;
        }
        .welcome-hero h1 {
            font-size: 3.5rem;
            margin-bottom: 0.5rem;
        }
        .welcome-hero p {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-top: 0;
            max-width: 550px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }
        .welcome-choices {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-top: 3rem;
        }
        @keyframes welcome-card-glow {
            from {
                box-shadow: 0 0 5px -5px color-mix(in srgb, var(--primary-color) 60%, transparent);
            }
            to {
                box-shadow: 0 0 15px 3px color-mix(in srgb, var(--primary-color) 20%, transparent);
            }
        }

        .welcome-card {
            background-color: var(--bg-secondary);
            padding: 1.5rem;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            text-align: left;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
            position: relative; /* Needed for the glow effect */
        }
        .welcome-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary-color);
            animation: welcome-card-glow 3s infinite alternate;
        }
        .welcome-card.recommended {
            border-width: 2px;
            border-color: var(--primary-color);
            box-shadow: 0 0 20px -5px color-mix(in srgb, var(--primary-color) 30%, transparent);
        }
        .welcome-card.disabled {
            opacity: 0.6; cursor: not-allowed;
            background-color: var(--bg-tertiary);
        }
        .welcome-card.disabled:hover {
            transform: none; box-shadow: none;
            border-color: var(--border-color);
        }
        .welcome-card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        .card-icon {
            width: 40px;
            height: 40px;
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-tertiary));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-color);
            flex-shrink: 0;
        }
        .card-title {
            font-size: 1.15rem;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        .card-description {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin: 0;
        }
        .welcome-prompt-actions {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-top: 2rem;
        }
        .welcome-prompt-alternatives {
            display: flex;
            gap: 1rem;
            align-items: center;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        .welcome-prompt-alternatives a {
            color: var(--text-secondary);
            text-decoration: underline;
            cursor: pointer;
        }
        .welcome-prompt-alternatives a:hover {
            color: var(--primary-color);
        }
        @media (max-width: 768px) {
            .welcome-choices {
                grid-template-columns: 1fr;
            }
            .welcome-hero h1 {
                font-size: 2.5rem;
            }
        }
        .welcome-container .library-title {
            font-size: 4rem; /* Larger, more impactful title */
            margin-bottom: 0.25rem;
        }
        #welcome-subtitle {
            font-size: 1.55rem;
            color: var(--text-secondary);
            height: 2em; /* Reserve space to prevent layout shift */
            font-family: cursive;

        }
        #welcome-subtitle .typewriter-cursor {
            animation: blink 0.7s infinite;
            color: var(--primary-color);
        }
        @keyframes blink {
            50% { opacity: 0; }
        }
        /* Fade-out animation */
        @keyframes fadeOutAndShrink {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.95);
            }
        }
        .view.fading-out {
            animation: fadeOutAndShrink 0.5s ease-out forwards;
        }

        /* GLOBAL SEARCH MODULE */
        #global-search-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 15vh;
            backdrop-filter: blur(4px);
        }

        #global-search-overlay.hidden {
            display: none;
        }

        #global-search-modal {
            width: 100%;
            max-width: 750px;
            background-color: rgba(var(--bg-secondary-rgb), var(--ui-opacity));
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        #global-search-modal .search-input-wrapper {
            display: flex;
            align-items: flex-start; /* Aligns items to the top */
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
        }


        .search-input-wrapper svg {
            color: var(--text-secondary); /* Corrected variable */
            margin-right: 12px;
            margin-top: 0.2em; /* Aligns icon with first line of text */
        }

        #global-search-input {
            width: 100%;
            font-size: 1.2em;
            border: none;
            outline: none;
            background: transparent;
            color: var(--text-primary);
            resize: none;
            overflow-y: hidden;
            line-height: 1.4;
            font-family: inherit;
        }
        #global-search-input.expanded {
            min-height: 90px;
            white-space: pre-wrap;
        }

        #global-search-results {
            max-height: 500px;
            overflow-y: auto;
        }
        #global-search-btn {
            background: transparent;
            border: none;
        }
        .search-result-item {
            display: flex;
            align-items: center;
            padding: 14px 18px; /* Increased padding */
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.2s ease; /* Smooth transition */
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background-color: var(--background-color-secondary); /* Subtle hover effect */
        }

        .search-result-item.selected {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
        }

        .search-result-item.selected .result-text,
        .search-result-item.selected .result-category,
        .search-result-item.selected .result-icon { /* Make icon white on selection */
            color: var(--text-on-primary);
        }

        /* --- Unified Image Snippet Styling --- */
        /* For Global Search Thumbnails */
        .search-result-image-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .search-result-image-wrapper img {
            width: 320px;
            height: 250px;
            object-fit: cover;
            border-radius: 6px;
            flex-shrink: 0;
        }
        .search-result-caption {
            font-size: 0.9em;
            font-style: italic;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        .search-result-item.selected .search-result-caption {
            color: var(--text-on-primary);
        }

        /* For Category View (Read Mode Style) */
        .category-summary-card .snippet .image-container {
            max-width: 100%;
            display: inline-block; /* Prevents flex stretching issues */
        }
        .category-summary-card .snippet img {
            max-width: 100% !important; /* Force image to fit container */ 
            height: auto !important;    /* Maintain aspect ratio */
        }

        .result-icon {
            margin-right: 16px;
            width: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result-icon svg {
            width: 20px;
            height: 20px;
            stroke-width: 2px;
            color: var(--text-secondary);
        }

        .result-content {
            display: flex;
            flex-direction: column;
        }

        .result-text {
            font-size: 1.05em; /* Slightly larger text */
            font-weight: 500;
            line-height: 1.3;
            color: var(--text-color);
        }

        .result-category {
            font-size: 0.75em;
            color: var(--text-color-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px; /* Add some letter spacing */
            margin-top: 4px;
        }

        /* Style for the "No results found" message */
        .no-results-item {
            padding: 20px;
            text-align: center;
            color: var(--text-color-secondary);
        }
    
        .search-footer {
            display: flex;
            justify-content: space-around;
            padding: 8px 16px;
            background-color: var(--background-color-secondary);
            font-size: 0.8em;
            color: var(--text-color-secondary);
        }
        #global-search-modal .result-icon .badge-icon svg {
            color: inherit;
        }

        /* --- Readability fix for 0% Opacity --- */
        :root.zero-opacity-active header .btn-icon,
        :root.zero-opacity-active .article-controls .btn-icon {
            color: #ffffff; /* Change icon color to white */
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.7));
        }

        :root.zero-opacity-active header .btn-icon:hover,
        :root.zero-opacity-active .article-controls .btn-icon:hover {
            background-color: rgba(255, 255, 255, 0.2); 
            color: #ffffff;
        }

        /* MOBILE VIEW ADAPTATIONS (v2+) */
        
        body.mobile-view .card-header-info {
            justify-content: flex-start;
            gap: 4px;
        }
        body.mobile-view .article-container,
        body.mobile-view .category-view-container,
        body.mobile-view .tags-view-container,
        body.mobile-view .flashcard-grid,
        body.mobile-view .stats-dashboard-view {
            padding-left: 0.25rem;
            padding-right: 0.25rem;
        }
        body.mobile-view .modal-content {
            padding: 1.5rem 1rem;
        }
        body.mobile-view .category-filters .category-chip {
            padding: 6px 8px;
            font-size: 0.85rem;
        }
        /* --- REFINED MOBILE FLASHCARD FOOTER (OVERLAY STYLE) --- */
        body.mobile-view .flashcard-tile-footer {
            opacity: 1;
            transform: none;
            background: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            box-shadow: none;
            border: none;
            padding: 0;
            gap: 4px;
        }
        body.mobile-view .flashcard-tile-content {
            padding-bottom: 1px;
            -webkit-mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
            mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
        }
        body.mobile-view .flashcard-tile-footer .btn-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: rgba(var(--bg-secondary-rgb), 0.8);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
        }
        body.mobile-view .flashcard-tile-footer .btn-icon:hover {
            color: var(--text-secondary);
            transform: none;
            background-color: rgba(var(--bg-secondary-rgb), 0.8);
        }

        body.mobile-view {
            font-size: 15px;
            -webkit-tap-highlight-color: transparent; 
        }
        body.mobile-view main .view.active,
        body.mobile-view .library-main,
        body.mobile-view .tags-view-container,
        body.mobile-view .stats-dashboard-view {
            padding: 0.75rem;
        }

        /* --- 2A. Global Layout & Header --- */
        body.mobile-view header {
            padding: 0 4px; /* Tighter padding for mobile header */
        }
        .mobile-header-more-btn {
            display: none;
            margin-top: 7px;
        }
        body.mobile-view header .header-main-actions,
        body.mobile-view header .header-actions {
            gap: 3px; 
        }
        /* Hide specific less-used icons in mobile view */
        body.mobile-view #stats-header-btn,
        body.mobile-view #visual-map-header-btn,
        body.mobile-view #mindmap-header-btn,
        body.mobile-view #install-pwa-btn,
        body.mobile-view #folder-btn,
        body.mobile-view #settings-btn {
            display: none;
        }
        /* Show the "More" button only on mobile */
        body.mobile-view .mobile-header-more-btn {
            display: flex;
        }
        /* When more is clicked, show the hidden buttons in a flex-column popup */
        body.mobile-view.mobile-header-expanded header {
            position: relative;
            flex-wrap: wrap;
        }
        body.mobile-view.mobile-header-expanded .header-actions {
            position: absolute;
            top: 100%;
            right: 5px;
            flex-direction: column;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            padding: 4px;
            z-index: 1001;
            /* The min-width property has been removed */
        }

        body.mobile-view.mobile-header-expanded #stats-header-btn,
        body.mobile-view.mobile-header-expanded #visual-map-header-btn, /* <-- ADD THIS */
        body.mobile-view.mobile-header-expanded #mindmap-header-btn,   /* <-- ADD THIS */
        body.mobile-view.mobile-header-expanded #install-pwa-btn,
        body.mobile-view.mobile-header-expanded #folder-btn,
        body.mobile-view.mobile-header-expanded #settings-btn {
            display: flex; /* Show them inside the popup */
        }

        /* --- 2B. Library View --- */
        body.mobile-view .article-grid {
            grid-template-columns: 1fr; /* Single column layout */
            gap: 12px;
        }
        body.mobile-view .library-title {
            font-size: 2.5rem;
        }
        body.mobile-view .search-and-filter-bar {
            display: flex; /* Ensure it's a flex container */
            flex-direction: row; /* Align items horizontally */
            gap: 0.5rem; /* Reduce the gap between items */
            align-items: center; /* Vertically align items */
        }
        body.mobile-view .category-chip {
            min-width: 55px; /* Ensures a consistent minimum width */
            text-align: center;
            padding: 8px 10px; /* Adjust padding for a pill shape */
        }
        /* Make the search bar container take up all available space */
        body.mobile-view .search-and-filter-bar .search-bar-container {
            flex-grow: 1;
        }

        /* Make the sort button compact */
        body.mobile-view .search-and-filter-bar #sort-filter {
            flex-shrink: 0; /* Prevent the button from shrinking */
            padding: 8px 12px; /* Reduce padding to make it smaller */
            font-size: 0.8rem; /* Reduce font size */
        }
        body.mobile-view .category-filters {
            width: 100%;
            flex-wrap: wrap; /* Allow buttons to wrap to the next line */
            justify-content: center; /* Center the wrapped buttons for a clean look */
            padding-bottom: 8px;
            gap: 3px; /* Ensure consistent spacing */
        }
        body.mobile-view .category-filters::-webkit-scrollbar {
            height: 3px; /* Make the scrollbar track thinner */
        }
        body.mobile-view .category-filters::-webkit-scrollbar-track {
            background: transparent; /* Make the track invisible */
        }
        body.mobile-view .category-filters .btn {
            flex-shrink: 0; /* Prevent buttons from shrinking, forcing the container to scroll */
        }

        /* --- 2C. Article View & Controls --- */
        body.mobile-view.write-mode main {
            /* Adds space at the bottom so the keyboard doesn't hide the text */
            scroll-padding-bottom: 50vh;
        }
        body.mobile-view .article-container {
            padding: 1rem 1rem 20vh 1rem; /* Less horizontal padding */
        }
        body.mobile-view #article-controls {
            padding: 4px;
            gap: 4px;
        }

        body.mobile-view .controls-wrapper {
            gap: 4px;
        }
        body.mobile-view .article-controls {
            max-width: 95vw; 
            bottom: 1rem; 
            padding: 4px;
        }

        /* NEW: This ensures the tutorial buttons are spaced evenly and look great */
        body.mobile-view .article-controls .controls-wrapper {
            width: 100%;
        }
        body.mobile-view .article-controls .btn-gradient-text {
            flex-grow: 1; /* Allows buttons to share the space */
            padding: 12px 8px; /* Tweak padding for mobile */
            font-size: 1rem;
        }

        /* Read Mode: Show only essential controls */
        body.mobile-view .read-mode-controls .control-divider,
        body.mobile-view .read-mode-controls [data-action="goToCategory"],
        body.mobile-view .read-mode-controls [data-action="copyHighlights"],
        body.mobile-view .read-mode-controls [data-action="exportHtml"] {
            display: none;
        }
        /* Write Mode: Hide formatting tools that are on the selection toolbar */
        body.mobile-view .write-mode-controls .control-divider,
        body.mobile-view .write-mode-controls [data-action="format"],
        body.mobile-view .write-mode-controls [data-action="manageTable"],
        body.mobile-view .write-mode-controls #list-group,
        body.mobile-view .write-mode-controls #format-group,
        body.mobile-view .write-mode-controls [data-action="insertCheckbox"],
        body.mobile-view .write-mode-controls [data-action="insertAccordion"] {
            display: none;
        }
        body.mobile-view #category-selector {
            max-width: 110px; /* Prevent category selector from taking too much space */
        }

        /* --- 2D. Flashcard Study View --- */
        body.mobile-view .study-view {
            padding: 0.5rem;
            padding-bottom: 150px; /* More space for controls */
        }
        body.mobile-view .study-card-content-box {
            font-size: var(--study-card-font-size, 1.5rem);
        }
        body.mobile-view .study-controls {
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }
        body.mobile-view .btn-study-rating {
            padding: 10px 16px;
            font-size: 0.9rem;
        }
        body.mobile-view .flashcard-view-header {
            justify-content: center;
        }

        /* --- 2E. Modals (Hub, Settings, etc.) --- */
        body.mobile-view .modal-backdrop {
            padding: 0;
            top: 48px; /* Position it below the 48px header */
            height: calc(100% - 48px);
        }
        body.mobile-view .modal-content:not(.productivity-modal) {
            /* This rule now applies to all OTHER modals (Settings, etc) */
            width: 100%;
            max-width: 100%;
            height: 100%;
            max-height: 100vh;
            border-radius: 0;
            display: flex;
            flex-direction: column;
        }

        body.mobile-view .productivity-modal {
            width: 100%;
            max-width: 100%;
            height: 100%; /* Fill the backdrop */
            max-height: 100%;
            border-radius: 0;
            box-shadow: none;
            border: none;
        }
        body.mobile-view .tag-modal-body,
        body.mobile-view .guide-content,
        body.mobile-view .shortcut-modal-content > div {
            max-height: calc(100vh - 150px); /* Ensure modal content is scrollable */
        }

        /* --- 2F. General UI Tweaks --- */
        body.mobile-view .btn {
            padding: 8px 10px;
            white-space: nowrap;
        }
        body.mobile-view .btn-icon {
            width: 40px;
            height: 40px;
        }
        
        /* --- NEW: Command Palette Mobile Style --- */
        body.mobile-view #command-palette {
            width: 95vw;
            max-width: 400px; /* Set a max width as well */
        }
        body.mobile-view header,
        body.mobile-view #article-controls,
        body.mobile-view .modal-buttons,
        body.mobile-view .btn,
        body.mobile-view .category-chip {
            text-align: center;
            padding: 8px 12px; /* A balanced padding for a 4-letter word */
        }

        body.mobile-view .btn,
        body.mobile-view .article-card,
        body.mobile-view .flashcard-tile,
        body.mobile-view .category-chip,
        body.mobile-view .tag-item {
            position: relative; /* Necessary for the pseudo-element */
            overflow: hidden;   /* Keeps the effect contained */
        }
 
        body.mobile-view *:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary-color) 40%, transparent);
        }
        /* --- 2E-2. Map Views (Mind Map & Visual Map) --- */
        body.mobile-view #visual-map-view.active,
        body.mobile-view #mindmap-view.active {
            padding: 0.75rem; /* Consistent padding with other mobile views */
            gap: 0.75rem;     /* A healthier gap for touch interfaces */
        }

        body.mobile-view #visual-map-controls,
        body.mobile-view #mindmap-controls {
            gap: 6px; /* Tighter gaps between control groups on mobile */
            min-height: auto; /* Allow controls to wrap naturally without forcing a large height */
        }

        body.mobile-view #visual-map-container,
        body.mobile-view #mindmap-container {
            /* A slightly larger radius looks better and more modern on mobile */
            border-radius: var(--border-radius-lg); 
        }

        body.mobile-view .control-group .search-input {
            /* Make the search input more compact on mobile */
            width: 140px;
        }
        /* --- 2G. Zen Mode Mobile Responsiveness --- */
        
        body.mobile-view .zen-mode-overlay {
            padding: 1.5rem 1rem; /* Reduce padding on smaller screens */
        }

        body.mobile-view .zen-timer {
            /* Make the timer font smaller and more responsive to screen width */
            font-size: clamp(5.5rem, 22vw, 8rem);
        }

        body.mobile-view .zen-task-title {
            /* Adjust the task title font size */
            font-size: clamp(1.2rem, 5vw, 1.5rem);
            -webkit-line-clamp: 2; /* Allow a maximum of 2 lines */
        }

        body.mobile-view .zen-bottom-controls {
            bottom: 2.5rem; /* More space from the bottom edge */
            gap: 2rem;      /* Wider gap between buttons */
        }

        body.mobile-view .zen-bottom-controls .btn-icon {
            transform: scale(1.2); /* Make touch targets larger */
        }
        /* --- Audio Recording Indicator --- */
        @keyframes red-pulse {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }
        .write-mode-controls .btn-icon.is-recording {
            color: var(--danger-color);
            animation: red-pulse 2s infinite;
            border-radius: 50%;
        }

        html.mobile-view {
            scroll-behavior: smooth;
        }

        /* --- Ascension & License System (v2.0 REDESIGN) --- */
        #profile-hub {
            position: relative; /* For positioning the notification card */
            display: flex; /* Always display to ensure position */
            align-items: center;
            margin-right: 0.5rem; /* Maintain spacing */
            height: 100%; /* Occupy header height */
        }
        #profile-badge {
            cursor: pointer;
            width: 36px; 
            height: 36px;
            border-radius: 50%; /* Perfect circle */
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            overflow: hidden; 
        }

        #profile-badge .badge-icon {
            width: 33px;  /* Slightly smaller to fit inside the 40px container */
            height: 33px;
            transform: scale(0.95); /* A slight scale down for better visual fit */
            box-shadow: none; /* The outer container will handle hover effects */
        }
        #profile-badge .badge-icon .inner-icon {
            width: 65%;
            height: 65%;
        }

        #profile-badge:hover {
            transform: scale(1.05); /* Retain the satisfying hover effect */
            border-color: var(--primary-color);
            box-shadow: 0 0 10px rgba(var(--primary-color-rgb), 0.3);
        }
        /* Add a subtle shine to the badge */
        #profile-badge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 50%, rgba(255,255,255,0.1) 100%);
            opacity: 0;
            transition: opacity 0.3s ease-out;
            border-radius: inherit;
            pointer-events: none;
        }
        #profile-badge:hover::before {
            opacity: 1;
        }

        #profile-badge:hover {
            transform: scale(1.05); /* Slightly larger on hover */
            background-color: var(--bg-tertiary); /* Highlight on hover */
        }
        #profile-badge.active {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 10px rgba(var(--primary-color-rgb), 0.3);
        }
        /* Hide the welcome text */
        #profile-welcome { display: none; } 

        /* NEW: Profile Notification Card */
        #profile-notification-card {
            position: absolute;
            top: calc(100% + 10px); /* Position below the badge */
            right: 0;
            width: 300px; /* Fixed width for consistency */
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-lg);
            padding: 1rem;
            z-index: 1000; /* Ensure it's above other elements */
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 0.75rem;
            transform-origin: top right;
            animation: fadeInScale 0.2s ease-out forwards;
        }

        /* Pointer/Arrow for the card */
        #profile-notification-card::before {
            content: '';
            position: absolute;
            top: -10px; /* Position above the card */
            right: 15px; /* Align with the badge */
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 10px solid var(--border-color); /* Outer border color */
        }
        #profile-notification-card::after {
            content: '';
            position: absolute;
            top: -9px; /* Slightly lower for inner part */
            right: 15px; /* Align with the badge */
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 10px solid var(--bg-primary); /* Inner background color */
        }

        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .notification-header {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--primary-color);
            font-size: 1rem;
        }
        .notification-message {
            color: var(--text-secondary);
            font-size: 0.95rem;
            line-height: 1.4;
            /* NEW: Make the message area a clickable CTA */
            cursor: pointer;
            padding: 0.75rem;
            margin: 0 -0.75rem -0.75rem; /* Extend clickable area to the edges */
            border-radius: var(--border-radius);
            transition: background-color 0.2s ease-in-out;
        }
        .notification-message:hover {
            background-color: var(--bg-tertiary);
        }



        /* NEW ELEGANT LOCKED STYLE */
        .premium-feature-locked {
            /* THE FIX: Changed to inline-block to make the border hug the button. */
            display: inline-block; 
            opacity: 0.6;
            cursor: not-allowed !important;
            position: relative;
            overflow: hidden;
            border-radius: var(--border-radius); /* Match the button's radius */
        }

        /* --- DEFINITIVE REGRESSION FIX --- */
        .control-group.premium-feature-locked {
            display: flex;
            flex-direction: row;
        }

        .premium-feature-locked::before {
            content: '';
            position: absolute;
            /* ... rest of the ::before rule is unchanged */
        }
        .premium-feature-locked::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: inherit; /* Match the button's border radius */
            border: 1px dashed color-mix(in srgb, var(--primary-color) 60%, transparent);
            pointer-events: none;
        }
        .premium-feature-locked:hover::before {
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 8px color-mix(in srgb, var(--primary-color) 30%, transparent);
        }
        

        /* FIX #3: Profile & License Modal Polish */
        .license-header-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem 0 1.5rem;
            text-align: center;
        }

        .license-header-badge {
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 6px 16px;
            border-radius: 20px;
            color: var(--text-on-primary, #fff); /* Ensure readable text */
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            margin-bottom: 0.75rem;
            font-size: 1.1em;
        }
        .license-header-info p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }
        .license-status-display {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-top: 1.5rem;
            text-align: center;
        }
        .license-status-display p {
            margin-bottom: 0.5rem;
            font-size: 1.05rem;
            color: var(--text-primary);
        }
        .license-status-display p strong {
            color: var(--primary-color);
        }
        .license-form-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        @media (min-width: 600px) {
            .license-form-grid {
                grid-template-columns: 120px 1fr;
                align-items: center;
                gap: 1.25rem;
            }
            .license-form-grid label {
                text-align: right;
                padding-right: 1rem;
                color: var(--text-secondary);
                font-weight: 500;
            }
        }
        .license-form-grid textarea {
            resize: vertical;
            min-height: 70px;
        }
        .license-footer-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 1.5rem;
        }
        .modal-hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 1rem 0 2rem;
        }
        /* NEW: Style for the New Article button when limit is reached */
        #new-article-btn.limit-reached {
            background-color: var(--bg-tertiary);
            cursor: pointer; /* Make it clickable to show the modal */
            animation: none; /* Stop the glow */
        }
        #new-article-btn.limit-reached svg {
            color: var(--danger-color);
        }

        /* --- REDESIGNED ASCENSION MODAL --- */
        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: transparent;
            border: none;
            font-size: 1.5rem;
            line-height: 1;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.5rem;
            transition: transform 0.2s ease, color 0.2s ease;
        }
        .modal-close-btn:hover {
            color: var(--text-primary);
            transform: scale(1.1);
        }
        .ascension-modal {
            max-width: 720px;
            width: 100%;
            text-align: center;
            border: 1px solid var(--border-color);
            background: linear-gradient(145deg, var(--bg-primary), var(--bg-secondary));
            /* FIX: Enable scrolling on small screens */
            max-height: 90vh;
            overflow-y: auto;
        }
        /* --- NEW: Ascension Modal Gradient Text (v2) --- */
        .witty-gradient-text {
            font-weight: 700;
            background-size: 200% auto;
            color: #000; /* Fallback */
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: witty-text-glow 6s linear infinite;
        }

        /* Light Theme: A sophisticated, professional gradient */
        [data-theme="light"] .witty-gradient-text {
            background-image: linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488);
        }
        /* Dark Theme: A vibrant, glowing gradient */
        [data-theme="dark"] .witty-gradient-text {
            background-image: linear-gradient(90deg, #F7C96D, #34d399, #f06292, #F7C96D);
        }
        /* Sepia Theme: A rich, antique gradient */
        [data-theme="sepia"] .witty-gradient-text {
            background-image: linear-gradient(90deg, #8c6d46, #4d7c0f, #a16207, #8c6d46);
        }

        @keyframes witty-text-glow {
            to { background-position: -200% center; }
        }

        .ascension-badges-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1.25rem;
            margin: 2rem 0;
        }
        .ascension-badge {
            padding: 1.25rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
        }
        .ascension-badge:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: var(--primary-color);
            box-shadow: var(--shadow-lg);
        }
        .ascension-badge .badge-icon {
            font-size: 3rem;
            line-height: 1;
            margin-bottom: 0.75rem;
            display: block;
            text-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .ascension-badge .badge-name {
            font-weight: 600;
            font-size: 1rem;
            margin-top: 0.5rem;
            display: block;
            color: var(--text-primary);
        }
        .ascension-badge .badge-duration {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Special style for the best tier */
        .ascension-badge.tier-quantum {
            border-color: var(--primary-color);
            background: linear-gradient(to bottom right, var(--bg-secondary), var(--bg-tertiary));
            animation: quantum-glow 3s infinite alternate;
        }
        @keyframes quantum-glow {
            from { box-shadow: 0 0 5px color-mix(in srgb, var(--primary-color) 20%, transparent); }
            to { box-shadow: 0 0 20px 5px color-mix(in srgb, var(--primary-color) 40%, transparent); }
        }
        .ascension-badge.tier-quantum .badge-name {
            color: var(--primary-color);
        }

        .ascension-features {
            text-align: left;
            margin: 2rem auto;
            max-width: 450px;
            padding: 1.5rem;
            background-color: var(--bg-primary);
            border-radius: var(--border-radius);
        }
        .ascension-features h5 { margin-top:0; margin-bottom: 1rem; }
        .ascension-features ul { list-style: none; padding: 0; }
        .ascension-features li { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem; }
        .ascension-features svg { color: #2ecc71; flex-shrink: 0; }

        .ascension-footer { margin-top: 1.5rem; font-size: 0.9rem; }
        .ascension-footer a { color: var(--text-secondary); text-decoration: none; border-bottom: 1px dotted var(--text-secondary); }
        .ascension-footer a:hover { color: var(--text-primary); border-bottom-color: var(--text-primary); }

        /* NEW: Styled Maybe Later Button */
        .ascension-footer-button {
            background-color: var(--bg-tertiary); /* Soft background */
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius-lg);
            font-weight: 500;
            transition: all 0.2s ease-in-out;
        }
        .ascension-footer-button:hover {
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-tertiary));
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        /* FIX #1: Ensure all modals are scrollable if content overflows */
        .modal-content {
            max-height: 90vh; /* Limit height to viewport */
            overflow-y: auto; /* Enable vertical scrolling */
        }

        /* FIX #2: Beautify Unlock Your Full Potential Section */
        .ascension-features {
            text-align: left;
            margin: 2rem auto;
            max-width: 450px;
            padding: 1.5rem;
            background-color: var(--bg-tertiary); /* Use a more prominent background */
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm); /* Subtle shadow */
            border: 1px solid var(--border-color);
        }
        .ascension-features h5 {
            margin-top:0;
            margin-bottom: 1rem;
            color: var(--primary-color); /* Highlight the title */
            font-size: 1.1em;
        }
        .ascension-features ul { list-style: none; padding: 0; }
        .ascension-features li {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
            font-size: 0.95rem;
        }
        .ascension-features svg { color: var(--success-color); flex-shrink: 0; } /* Use success color for checkmarks */
        #license-hub-container {
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 0;
            margin: 1rem 0;
        }
        .license-hub-grid {
            align-items: center;
        }
        #license-hub-status-badge {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        /* --- NEW: Polished Ascension Cards (v2) --- */
        .ascension-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1.5rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
        }
        .ascension-card:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: var(--primary-color);
            box-shadow: var(--shadow-lg);
        }
        .ascension-card-name {
            font-weight: 600;
            font-size: 1.05rem;
            color: var(--text-primary);
        }
        .ascension-card-duration {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        .ascension-card.is-current-tier {
            cursor: default;
            background-color: var(--bg-secondary);
            border-style: dashed;
        }
        .ascension-card.is-current-tier:hover {
            transform: none;
            box-shadow: none;
            border-color: var(--border-color);
        }
        .ascension-card.is-current-tier::after {
            content: 'CURRENTLY';
            position: absolute;
            top: 16px;
            right: -35px;
            transform: rotate(45deg);
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            font-size: 0.55rem;
            font-weight: 700;
            padding: 5px 32px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        /* --- NEW: Ascension Grid Layout (v2) --- */
        .ascension-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr); /* 6-column base for a 3+2 layout */
            gap: 1.25rem;
            margin: 2rem 0;
        }
        /* First 3 cards (Spark, Bronze, Silver) take 2 columns each, filling the first row */
        .ascension-grid .ascension-card:nth-child(-n+3) {
            grid-column: span 2;
        }
        /* Last 2 cards (Gold, Diamond) take 3 columns each, filling and centering on the second row */
        .ascension-grid .ascension-card:nth-child(n+4) {
            grid-column: span 3;
        }
        /* Media query for smaller screens to stack them nicely */
        @media (max-width: 680px) {
            .ascension-grid { grid-template-columns: 1fr; }
            .ascension-grid .ascension-card:nth-child(-n+3),
            .ascension-grid .ascension-card:nth-child(n+4) {
                grid-column: span 1; /* Each card takes the full row */
            }
        }

        /* --- NEW: Refined Maybe Later Button (v2) --- */
        .ascension-footer-button.witty-gradient-text {
            border: 2px solid var(--border-color);
            padding: 0.75rem 1.5rem;
            font-size: 1.1rem;
            font-weight: bold;
            transition: border-color 0.3s ease;
        }
        .ascension-footer-button.witty-gradient-text:hover {
            border-color: var(--primary-color);
        }
        /* Center the button */
        .ascension-modal .modal-buttons {
            justify-content: center;
        }

        
        /* --- THE ASTRAL CORE: MASTERPIECE EDITION BADGES (v2.0) --- */
        .badge-container { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; }
        .badge-label { font-weight: 500; font-size: 0.9rem; color: var(--text-secondary); }
        .badge-icon {
            width: 80px; height: 80px; display: flex; align-items: center; justify-content: center;
            position: relative; border-radius: 50%; overflow: hidden;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .badge-icon:hover {
            transform: scale(1.1) translateY(-5px);
            box-shadow: inset 0 1px 4px rgba(0,0,0,0.2), 0 8px 16px rgba(0,0,0,0.4);
        }
        .badge-icon .inner-icon {
            width: 62%; height: 62%; z-index: 1; display: flex; align-items: center; justify-content: center;
        }

        /* FIX: Specific rule to correctly size the small profile badge icon */
        #profile-badge .badge-icon {
            width: 100%;
            height: 100%;
            box-shadow: none; /* The outer container handles hover effects */
        }
        #profile-badge .inner-icon {
            width: 60%; /* This value provides the correct padding and centering */
            height: 60%;
        }
        .badge-icon .inner-icon svg {
            width: 100%;
            height: 100%;
        }

        /* --- Badge Icon Fills (Definitive Cross-Browser Fix) --- */
        [data-theme="light"] .astral.spark .inner-icon svg { fill: #6c757d; }
        [data-theme="light"] .astral.bronze .inner-icon svg { fill: #fff3e0; }
        [data-theme="light"] .astral.silver .inner-icon svg { fill: #ffffff; }
        [data-theme="light"] .astral.gold .inner-icon svg { fill: #424242; }
        [data-theme="light"] .astral.diamond .inner-icon svg { fill: #ffffff; }
        [data-theme="dark"] .astral.spark .inner-icon svg { fill: #a0aec0; }
        [data-theme="dark"] .astral.bronze .inner-icon svg { fill: #d7ccc8; }
        [data-theme="dark"] .astral.silver .inner-icon svg { fill: #eceff1; }
        [data-theme="dark"] .astral.gold .inner-icon svg { fill: #fffde7; }
        [data-theme="dark"] .astral.diamond .inner-icon svg { fill: #fff; }
        [data-theme="sepia"] .astral.spark .inner-icon svg { fill: #7a6a57; }
        [data-theme="sepia"] .astral.bronze .inner-icon svg { fill: #f5f5f5; }
        [data-theme="sepia"] .astral.silver .inner-icon svg { fill: #f5f5f5; }
        [data-theme="sepia"] .astral.gold .inner-icon svg { fill: #fbf0d9; }
        [data-theme="sepia"] .astral.diamond .inner-icon svg { fill: #fbf0d9; }

        /* Badge Animations & Theme Backgrounds (No changes here) */
        @keyframes subtle-glow { 0%, 100% { box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 0 10px 0px var(--glow-color); } 50% { box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 0 20px 5px var(--glow-color); } }
        @keyframes very-subtle-glow { 0%, 100% { box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 0 5px 0px var(--glow-color); } 50% { box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 0 10px 2px var(--glow-color); } }
        @keyframes icon-pulse { 0%, 100% { transform: scale(0.90); filter: drop-shadow(0 2px 3px rgba(0,0,0,0.25)) brightness(1); } 50% { transform: scale(1.15); filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4)) brightness(1.25); } }
        @keyframes rotate-veryslow { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes planetary-rotation { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        [data-theme="light"] .astral.spark { background: linear-gradient(145deg, #e9ecef, #dee2e6); color: #6c757d; }
        [data-theme="light"] .astral.bronze { background: linear-gradient(145deg, #d3a985, #b96f48); color: #fff3e0; }
        [data-theme="light"] .astral.silver { background: linear-gradient(145deg, #e0e0e0, #bdbdbd); color: #ffffff; --glow-color: rgba(33, 33, 33, 0.2); animation: very-subtle-glow 8s infinite ease-in-out; }
        [data-theme="light"] .astral.gold { background: linear-gradient(145deg, #fff176, #fbc02d); color: #424242; --glow-color: rgba(251, 192, 45, 0.3); animation: subtle-glow 7s infinite ease-in-out; }
        [data-theme="light"] .astral.diamond { background: linear-gradient(145deg, #81d4fa, #29b6f6); color: #ffffff; --glow-color: rgba(3, 155, 229, 0.5); animation: subtle-glow 6s infinite ease-in-out; }
        [data-theme="dark"] .astral.spark { background: radial-gradient(circle, #4a5568, #2d3748); color: #a0aec0; }
        [data-theme="dark"] .astral.bronze { background: radial-gradient(circle, #8d6e63, #4e342e); color: #d7ccc8; }
        [data-theme="dark"] .astral.silver { background: radial-gradient(circle, #78909c, #37474f); color: #eceff1; --glow-color: rgba(176, 190, 197, 0.3); animation: very-subtle-glow 8s infinite ease-in-out; }
        [data-theme="dark"] .astral.gold { background: radial-gradient(ellipse at center, #7f3d02, #ffb300, #f57f17); color: #fffde7; --glow-color: rgba(255, 236, 179, 0.35); animation: subtle-glow 7s infinite ease-in-out; }
        [data-theme="dark"] .astral.diamond { background: radial-gradient(ellipse at center, #01579b, #29b6f6, #000); color: #fff; --glow-color: rgba(128, 222, 234, 0.5); animation: subtle-glow 6s infinite ease-in-out; }
        [data-theme="sepia"] .astral.spark { background: radial-gradient(circle at 30% 30%, #fbf0d9, #e9dbbf); color: #7a6a57; }
        [data-theme="sepia"] .astral.bronze { background: radial-gradient(circle, #ab8669, #8c6d46); color: #f5f5f5; }
        [data-theme="sepia"] .astral.silver { background: radial-gradient(circle, #d2d0cb, #a8a399); color: #f5f5f5; --glow-color: rgba(215, 204, 182, 0.3); animation: very-subtle-glow 8s infinite ease-in-out; }
        [data-theme="sepia"] .astral.gold { background: radial-gradient(circle, #e6c589, #b08d4b); color: #fbf0d9; --glow-color: rgba(199, 159, 87, 0.4); animation: subtle-glow 7s infinite ease-in-out; }
        [data-theme="sepia"] .astral.diamond { background: radial-gradient(circle, #b8cdd9, #839aac); color: #fbf0d9; --glow-color: rgba(131, 154, 172, 0.4); animation: subtle-glow 6s infinite ease-in-out; }
        .astral.spark .inner-icon svg { filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2)); }
        [data-theme="sepia"] .astral.spark .inner-icon svg { filter: drop-shadow(0 1px 2px rgba(91,70,54,0.2)); }
        .astral.bronze .orbiting-dots { animation: planetary-rotation 20s infinite linear; transform-origin: center; }
        .astral.silver .inner-icon { animation: rotate-veryslow 90s infinite linear; }
        .astral.silver .inner-icon svg { filter: drop-shadow(0 0 5px rgba(236, 239, 241, 0.5)); }
        [data-theme="light"] .astral.silver .inner-icon svg { filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.7)); }
        [data-theme="sepia"] .astral.silver .inner-icon svg { filter: drop-shadow(0 0 6px rgba(251,240,217,0.6)); }
        .astral.gold .inner-icon { animation: icon-pulse 18s infinite ease-in-out; }
        .astral.diamond .inner-icon { animation: icon-pulse 18s infinite ease-in-out -3.5s; }


        /* NEW: Premium Flashcard Upsell Tile (v2.0 REDESIGN) */
        .premium-upsell-tile {
            background: rgba(var(--bg-secondary-rgb), 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid color-mix(in srgb, var(--primary-color) 20%, transparent);
            border-left: 5px solid var(--primary-color) !important;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1.25rem;
            text-align: center;
            transition: all 0.2s ease-in-out;
            aspect-ratio: 1.7 / 1; /* Maintain a card-like shape */
            min-height: 165px;
        }
        .premium-upsell-tile:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 0 20px 5px color-mix(in srgb, var(--primary-color) 20%, transparent);
            border-color: var(--primary-color);
        }
        .upsell-badge {
            align-self: center;
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            font-size: 0.8rem;
            font-weight: 600;
            padding: 4px 12px;
            border-radius: 16px;
        }
        .upsell-content h4 {
            margin: 1rem 0 0.5rem 0;
            font-size: 1.1rem;
            color: var(--text-primary);
        }
        .upsell-content p {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin: 0;
        }
        .upsell-progress-bar {
            height: 6px;
            background-color: var(--border-color);
            border-radius: 3px;
            margin: 0.75rem auto 0;
            overflow: hidden;
            width: 90%;
        }
        .upsell-progress {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 3px;
        }
        .upsell-cta {
            font-weight: 600;
            color: var(--primary-color);
            margin-top: 1rem;
            font-size: 0.95rem;
        }
        /* NEW: Library Premium Upsell Card */
        .library-premium-card {
            grid-column: 1 / -1; /* Make it span the full width */
            border-color: var(--primary-color) !important;
            background: linear-gradient(135deg, color-mix(in srgb, var(--primary-color) 5%, var(--bg-secondary)), var(--bg-secondary));
            cursor: pointer;
            /* FIX #4: Add rounded corners and transition for hover */
            border-radius: var(--border-radius);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        /* FIX #4: Add a beautiful hover effect */
        .library-premium-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 20px 5px color-mix(in srgb, var(--primary-color) 20%, transparent);
        }

        .premium-badge {
            background-color: var(--primary-color) !important;
            color: var(--text-on-primary) !important;
        }
        .premium-card-footer {
            flex-direction: column;
            align-items: stretch !important;
            gap: 0.75rem !important;
        }
        .premium-progress-bar {
            height: 6px;
            background-color: var(--border-color);
            border-radius: 3px;
            overflow: hidden;
            width: 100%;
        }
        .premium-progress {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 3px;
        }
        .premium-cta-text {
            font-weight: 600;
            color: var(--primary-color);
            text-align: right;
        }

        /* --- NEW: Audio Player Block --- */
        .nk-audio-player {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-left: 5px solid var(--primary-color);
            border-radius: var(--border-radius-lg);
            padding: 0.75rem 1rem;
            margin: 0.25em;
            box-shadow: var(--shadow-sm);
            user-select: none;
        }
        .audio-play-pause-btn {
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background-color: var(--primary-color);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        .audio-play-pause-btn:hover {
            transform: scale(1.05);
            background-color: var(--primary-color-hover);
        }
        /* Play icon (triangle) */
        .audio-play-pause-btn::before {
            content: '';
            position: absolute;
            top: 50%; left: 55%;
            transform: translate(-50%, -50%);
            border-style: solid;
            border-width: 8px 0 8px 14px;
            border-color: transparent transparent transparent var(--text-on-primary);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        /* Pause icon (bars) */
        .audio-play-pause-btn::after {
            content: '';
            position: absolute;
            top: 50%; left: 43%;
            transform: translate(-50%, -50%);
            width: 4px; /* Width of a single bar */
            height: 16px; /* Height of the bars */
            background-color: var(--text-on-primary);
            /* RATIONALE: This creates an identical second bar 6px to the right of the first one. */
            box-shadow: 6px 0 0 0 var(--text-on-primary);
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .audio-play-pause-btn.playing::before { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
        .audio-play-pause-btn.playing::after { opacity: 1; }

        .audio-progress-bar-container {
            flex-grow: 1;
        }
        .audio-progress-bar {
            width: 100%;
            cursor: pointer;
        }
        .audio-time-display {
            font-family: var(--font-body);
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
            min-width: 85px;
            text-align: center;
        }
        .nk-audio-player audio {
            display: none;
        }
        /* Style for the recording indicator */
        .recording-visualizer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px; /* Canvas size */
            height: 32px;
            opacity: 0.7;
            pointer-events: none; /* Make it non-interactive */
        }


        /* --- NEW: Reusable Gradient Text Style --- */
        .btn-gradient-text {
            background-size: 200% auto;
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            animation: witty-text-glow 8s linear infinite;
        }
        [data-theme="light"] .btn-gradient-text {
            background-image: linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488);
        }
        [data-theme="dark"] .btn-gradient-text {
            background-image: linear-gradient(90deg, #fde047, #6ee7b7, #f472b6, #fde047);
        }
        [data-theme="sepia"] .btn-gradient-text {
            background-image: linear-gradient(90deg, #b45309, #55a630, #92400e, #b45309);
        }


        /* --- REFINED: Transcribe Button Aesthetics --- */
        .nk-transcribe-container .btn.btn-secondary {
            font-weight: 600; /* Bolder for emphasis */
            border: 2.5px solid var(--primary-color);
            border-radius: 50% 20% / 10% 40%;
            padding: 0.6rem 1.2rem;
            background-color: var(--bg-tertiary); /* Theme-sensitive background */
            transition: all 0.2s ease-in-out;
        }
        .nk-transcribe-container .btn.btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow);
            border-color: var(--primary-color);
        }
        /* --- NEW: Toast Wave Animation --- */
        .toast-wave-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toast-wave-visualizer {
            display: flex;
            align-items: center;
            gap: 3px;
            height: 20px;
        }
        .toast-wave-visualizer .wave-bar {
            width: 4px;
            height: 100%;
            background-color: currentColor;
            border-radius: 2px;
            animation: toast-wave-dance 1.2s ease-in-out infinite;
        }
        .toast-wave-visualizer .wave-bar:nth-child(2) { animation-delay: -1.0s; }
        .toast-wave-visualizer .wave-bar:nth-child(3) { animation-delay: -0.8s; }
        .toast-wave-visualizer .wave-bar:nth-child(4) { animation-delay: -0.6s; }
        @keyframes toast-wave-dance {
            0%, 100% { transform: scaleY(0.2); }
            50% { transform: scaleY(1.0); }
        }

        /* --- NEW: PDF Attachment & Viewer Styles --- */
        .pdf-attachment-pill {
            display: inline-flex;
            align-items: stretch;
            vertical-align: middle;
            position: relative;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            margin: 0.2em 0.25em;
            max-width: calc(100% - 0.5em);
            overflow: hidden;
            transition: all 0.2s ease-in-out;
            background-color: var(--bg-tertiary) !important;
            background-image: none !important;
        }
        .pdf-attachment-pill::before {
            content: 'PDF';
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 0.5px;
            background-color: var(--danger-color);
            color: var(--text-on-primary);
            border-right: 1px solid var(--border-color);
        }
        .pdf-attachment-name {
            display: block; 
            padding: 6px 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            outline: none;
            min-width: 100px; 
            font-family: inherit;
            font-weight: 600;
            background-image: none !important;
        }
        body.read-mode .pdf-attachment-pill {
            cursor: pointer;
        }
        body.read-mode .pdf-attachment-pill:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow);
            transform: translateY(-1px);
        }
        body.write-mode .pdf-attachment-name {
            cursor: text;
            transition: background-color 0.2s ease;
        }
        body.write-mode .pdf-attachment-pill:hover .pdf-attachment-name {
            background-color: color-mix(in srgb, var(--primary-color) 8%, var(--bg-tertiary));
        }
        body.write-mode .pdf-attachment-name:focus {
            background-color: var(--bg-secondary);
            box-shadow: inset 0 0 0 2px var(--primary-color);
            white-space: normal;
            overflow: visible;
        }

        /* --- PDF Viewer Styles (v2 Professional Redesign) --- */
        #pdf-viewer-container {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 25000;
            background-color: var(--bg-primary); /* Changed for better base */
            display: none;
            flex-direction: column;
            animation: fadeIn 0.3s ease;
        }
        #pdf-viewer-container.visible {
            display: flex;
        }
        .pdf-viewer-header {
            flex-shrink: 0;
            display: flex;
            justify-content: space-between; /* This remains key */
            align-items: center;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background-color: rgba(var(--bg-secondary-rgb), 0.8);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            /* position: relative;  <-- This can be removed */
            z-index: 30;
        }
        .pdf-viewer-controls {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .pdf-viewer-title {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-primary);
            flex-grow: 1;         
            flex-shrink: 1;       
            min-width: 0;        
            text-align: center; 
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0 1rem; 
        }
        .pdf-page-indicator {
            font-variant-numeric: tabular-nums;
            font-weight: 500;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
        }
        #pdf-page-num {
            width: 45px;
            text-align: center;
            border: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            color: var(--text-primary);
            padding: 4px;
            margin: 0 6px;
            font-size: 0.9rem;
            font-family: var(--font-body);
        }
        #pdf-page-num:focus {
            outline: 2px solid var(--primary-color);
        }
        #pdf-page-num::-webkit-outer-spin-button, #pdf-page-num::-webkit-inner-spin-button {
            -webkit-appearance: none; margin: 0;
        }
        #pdf-page-num[type=number] { -moz-appearance: textfield; }

        .pdf-viewer-main {
            flex-grow: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }
        #pdf-thumbnails-bar {
            width: 150px;
            background-color: var(--bg-tertiary);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 12px;
            display: none;
            flex-direction: column;
            gap: 2px;
            z-index: 20;
        }
        .pdf-thumbnail {
            cursor: pointer;
            border: 3px solid transparent;
            border-radius: var(--border-radius);
            padding: 3px;
            transition: all 0.2s ease;
            text-align: center;
        }
        .pdf-thumbnail canvas {
            width: 100%; height: auto;
            border-radius: 4px;
            box-shadow: var(--shadow-sm);
        }
        .pdf-thumbnail:hover {
            border-color: var(--primary-color-hover);
            background-color: var(--bg-secondary);
        }
        .pdf-thumbnail.active {
            border-color: var(--primary-color);
            background-color: var(--bg-secondary);
        }
        .pdf-thumbnail span {
            font-size: 0.8rem; font-weight: 500;
            color: var(--text-secondary); margin-top: 4px; display: block;
        }
        .pdf-viewer-canvas-wrapper {
            flex-grow: 1;
            overflow: auto;
            display: grid;
            place-items: center;
            padding: 0.25rem; 
            padding-top: 0px;
        }

        .pdf-viewer-main.thumbnails-active #pdf-thumbnails-bar {
            display: flex;
        }
        .pdf-viewer-main.thumbnails-active .pdf-viewer-canvas-wrapper {
            margin-left: 10px; 
            transition: margin-left 0.3s ease-in-out;
        }
        /* --- THE CORE OF THE ALIGNMENT FIX --- */
        .pdf-page-container {
            position: relative;
            margin: 0 auto; 
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            line-height: 0;
        }
        #pdf-viewer-canvas {
            display: block;

        }
        #pdf-viewer-container.text-view-active #pdf-annotate-toggle,
        #pdf-viewer-container.text-view-active #pdf-annotation-toolbar {
            display: none !important;
        }

        /* --- DECOUPLED TEXT VIEW STYLES (v2) --- */
        #pdf-text-view-content {
            display: none; 
            width: 100%;
            padding: 2rem 1rem; /* Restored correct padding */
            font-family: var(--article-font-family);
            background-color: var(--bg-primary);
            color: var(--text-primary); 
        }

        #pdf-text-view-content p {
            margin-block-start: 0;
            margin-block-end: 0.5em; 
        }

        #pdf-text-view-content pre {
            font-family: inherit;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: inherit;
            text-align: left;
            margin: 0 auto;
            max-width: 80ch; /* Restored centering and readability */
            line-height: 1.7;
        }
        /* --- END OF TEXT VIEW STYLES --- */

        #pdf-viewer-container .btn-icon.active {
            background-color: var(--bg-tertiary); color: var(--primary-color);
        }
        body.pdf-viewer-active > header { display: none; }
        .pdf-more-menu-container {
            position: relative;
            display: inline-block;
        }
        .pdf-more-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            z-index: 26000;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            padding: 4px;
            display: none;
            flex-direction: column;
            gap: 4px;
            width: 180px;
        }
        .pdf-more-menu.visible { display: flex; animation: fadeIn 0.2s ease-out; }
        .pdf-more-menu .btn { width: 100%; justify-content: flex-start; }

        /* --- VIEW TOGGLING LOGIC --- */
        #pdf-viewer-container.text-view-active .pdf-page-container {
            display: none;
        }
        #pdf-viewer-container.text-view-active #pdf-text-view-content {
            display: block; 
        }

        /* --- NEW: Control Visibility Logic --- */
        /* Hide Text View specific controls by default */
        .text-view-only-btn {
            display: none;
        }
        /* Show them only when text view is active */
        #pdf-viewer-container.text-view-active .text-view-only-btn {
            display: inline-flex;
        }
        /* Hide standard zoom controls when in text view */
        #pdf-viewer-container.text-view-active #pdf-zoom-out,
        #pdf-viewer-container.text-view-active #pdf-zoom-percent,
        #pdf-viewer-container.text-view-active #pdf-zoom-in {
            display: none;
        }
        #pdf-viewer-container.pdf-fullscreen-active .pdf-viewer-header {
            display: none;
        }
        /* --- NEW: PDF Annotation Styles --- */
        .pdf-page-container {
            position: relative; /* CRITICAL for overlay positioning */
        }

        #annotation-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /* By default, clicks go through to the PDF below */
            z-index: 10; /* Ensures it's on top of the PDF canvas */
        }

        #pdf-viewer-container.annotation-active #annotation-layer {
            pointer-events: auto; /* When active, it captures mouse events for drawing */
            cursor: crosshair;
        }

        #pdf-annotation-toolbar .btn-icon.active {
            background-color: var(--bg-tertiary);
            color: var(--primary-color);
        }

        .pdf-color-palette {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 4px;
        }

        .pdf-color-pick {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .pdf-color-pick:hover {
            transform: scale(1.15);
        }

        .pdf-color-pick.active {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 60%, transparent);
            transform: scale(1.1);
        }

        #pdf-thickness-cycler svg {
            transition: transform 0.2s ease-in-out;
        }

        /* This rule standardizes all icons in both toolbars for a consistent look */
        #annotation-toolbar .btn-icon svg,
        #pdf-annotation-toolbar .btn-icon svg {
            width: 20px;
            height: 20px;
        }

        /* NEW: A smaller inner circle for the color cycler button for visual balance */
        .color-cycler-inner {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }
        /* --- NEW: PDF Viewer Mobile Responsiveness --- */
        body.mobile-view #pdf-viewer-header {
            flex-wrap: wrap;
            padding: 0.4rem 0.25rem;
            gap: 0.25rem;
        }

        body.mobile-view .pdf-viewer-title {
            order: -1; /* Move title to the top */
            width: 100%;
            text-align: center;
            padding-bottom: 0.5rem;
            font-size: 0.9rem;
            border-bottom: 1px solid var(--border-color);
            display:none;
        }

        body.mobile-view .pdf-viewer-main.thumbnails-active {
            flex-direction: column;
        }

        body.mobile-view #pdf-thumbnails-bar {
            width: 100%;
            height: 120px;
            flex-direction: row;
            overflow-x: auto;
            overflow-y: hidden;
            border-right: none;
            border-bottom: 1px solid var(--border-color);
        }

        body.mobile-view .pdf-thumbnail {
            min-width: 80px;
        }

        /* Hide less critical buttons on mobile main bar */
        body.mobile-view #pdf-thumbnails-toggle,
        body.mobile-view #pdf-fullscreen-toggle,
        body.mobile-view #pdf-viewer-header .control-divider {
            display: none;
        }
        .pdf-more-menu .mobile-only-btn {
            display: none;
        }

        body.mobile-view .pdf-more-menu .mobile-only-btn {
            display: flex; /* Show them in the menu on mobile */
        }
        .tutorial-btn {
            flex-shrink: 0;     
            white-space: nowrap; 
        }



   </style>
   
</head>
<body>

    <div id="the-line-container"><div id="the-line"></div></div>
    <div id="app-background"></div>
    <div id="text-measurer" style="position: absolute; left: -9999px; top: -9999px; visibility: hidden; pointer-events: none; padding: 10px 14px; font-family: var(--font-body); line-height: 1.5; word-wrap: break-word;"></div>

    <header>
        <div class="header-main-actions">
             <button class="btn-icon" aria-label="Go to Homepage" onclick="App.router.navigateTo('library')" title="Library">
                <svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 9v11a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9"/><path d="M9 22V12h6v10"/><path d="M2 10l10-7 10 7"/></svg>

            </button>
            <button class="btn-icon" id="todo-btn" onclick="App.hub.ui.showProductivityModal()" title="Tasks & Timer (Ctrl+K)">
                 <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5z"/><path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM2 2a1 1 0 0 0-1 1v11a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1H2z"/></svg>
                <span id="todo-badge" class="todo-badge" style="display: none;"></span>
            </button>
            
            
            <button class="btn-icon" id="flashcard-header-btn" onclick="App.router.navigateTo('flashcard')" title="Flashcards" aria-label="Go to flashcards">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><path d="M17 2v4"></path><path d="M7 2v4"></path><path d="M2 11h20"></path></svg>
            </button>
            <button class="btn-icon" id="stats-header-btn" onclick="App.router.navigateTo('stats-dashboard')" title="Statistics Dashboard" aria-label="Show statistics dashboard">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="9"></circle>
                    <path d="M12 3 v9 h9"></path>
                </svg>
            </button>
            <button class="btn-icon" id="visual-map-header-btn" onclick="App.router.navigateTo('visual-map')" title="Visual Map">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a10 10 0 1 0 10 10"/><path d="M12 18a6 6 0 1 0 0-12 6 6 0 0 0 0 12z"/><path d="M12 12a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></svg>

            </button>
            <button class="btn-icon" id="mindmap-header-btn" onclick="App.router.navigateTo('mindmap')" title="Mind Map">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="6" cy="12" r="3"></circle>
                    <circle cx="18" cy="7" r="2.5"></circle>
                    <circle cx="18" cy="17" r="2.5"></circle>
                    <path d="M9,12 C12,12 13,7 15.5,7"></path>
                    <path d="M9,12 C12,12 13,17 15.5,17"></path>
                </svg>
            </button>
        </div>
        <div class="header-actions">
            <button class="btn-icon" id="install-pwa-btn" title="Install App" aria-label="Install NoteKash App">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L6.354 8.146a.5.5 0 1 0-.708.708l2 2z"/></svg>
            </button>
            <button id="global-search-btn" class="btn-icon" title="Global Search (Ctrl+K)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
            </button>
            <button class="btn-icon" id="folder-btn" onclick="App.router.navigateTo('welcome')" title="Change Notes Folder (Alt+O)" aria-label="Change notes folder">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path d="M9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.826a2 2 0 0 1-1.991-1.819l-.637-7a1.99 1.99 0 0 1 .342-1.31L.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3zm-8.322.12C1.72 3.042 1.95 3 2.19 3h5.396l-.707-.707A1 1 0 0 0 6.172 2H2.5a1 1 0 0 0-1 .981l.006.139z"/></svg>
            </button>
            <button class="btn-icon" id="settings-btn" onclick="App.ui.showSettingsModal()" title="Settings" aria-label="Open settings">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311a1.464 1.464 0 0 1 0 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105 0l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.31-.17a1.464 1.464 0 0 1 2.105-.872l-.1-.34c.413-1.4 2.397-1.4 2.81 0l.1.34a1.464 1.464 0 0 1 2.105.872l.31.17c1.283.698-2.686-.705-1.987-1.987l-.169-.311a1.464 1.464 0 0 1 0-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105 0l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.31.17a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/></svg>
            </button>

            <button class="btn btn-primary" id="new-article-btn" onclick="App.events.createNewArticle()" title="New Article (Alt+Shift+N)" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>
            </button>
            <div id="profile-hub">
                <div id="profile-badge" title="Your Current Tier">
                    </div>
               <div id="profile-notification-card">
                    <div class="notification-header">
                        <span id="notification-badge-icon"></span>
                        <span id="notification-title"></span>
                    </div>
                    <p id="notification-message" class="notification-message"></p>
                    <a id="notification-link" href="#" onclick="event.preventDefault(); App.ui.closeProfileNotification(); App.ui.showLicenseModal();" style="display: none; text-decoration: none; color: inherit;">
                        <p id="notification-link-message" class="notification-message"></p>
                    </a>
                </div>
            </div>
            <button class="btn-icon mobile-header-more-btn" onclick="document.body.classList.toggle('mobile-header-expanded')" title="More actions" aria-label="More header actions">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </button>
        </div>
    </header>

    <main>
        <div id="welcome-view" class="view"></div>
        <div id="library-view" class="view"></div>
        <div id="article-view" class="view"></div>
        <div id="category-view" class="view"></div>
        <div id="tags-view" class="view"></div>
        <div id="flashcard-view" class="view"></div>
        <div id="stats-dashboard-view" class="view"></div>
       <div id="visual-map-view" class="view">
                <div id="visual-map-controls">
                    <div class="control-group">
                        <input type="search" class="search-input" id="graph-search-input" placeholder="Search nodes... (S)">
                        <button class="control-btn" id="find-next-btn" title="Find Next Result (Enter)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/><path d="M6 8.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1-.5-.5m0-2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5"/></svg></button>
                    </div>
                    <div class="control-group">
                        <button class="control-btn" id="filter-all-btn" title="Expand All Nodes"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg></button>
                        <button class="control-btn" id="filter-tags-btn" title="Collapse All to Tags"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12.586 2.586a2 2 0 0 0-2.828 0L2.172 10.172a2 2 0 0 0 0 2.828l7.414 7.414a2 2 0 0 0 2.828 0l7.414-7.414a2 2 0 0 0 0-2.828L12.586 2.586z"/><line x1="9" y1="9" x2="9.01" y2="9"/></svg></button>
                        <button class="control-btn" id="filter-orphans-btn" title="Show Orphan Notes"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg></button>
                        <button class="control-btn" id="cycle-category-btn" title="Toggle Categories (T)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg></button>
                    </div>
                    <div class="control-group premium-feature-locked">
                        <button class="control-btn" id="lasso-btn" title="Lasso Select Tool (L)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M15.1 4.2c-1-1.5-2.8-2.2-4.6-1.9-2.8.5-4.8 2.8-5 5.6-.2 2.3 1.1 4.5 3.1 5.5 2.1 1 4.5.4 6-1.1l2.4 2.4c.4.4 1 .4 1.4 0l.6-.6c.4-.4.4-1 0-1.4l-2.4-2.4c1.5-1.5 2.1-4 .9-6.1z"/><path d="M10.8 7.3c-.4.4-.4 1 0 1.4l4.2 4.2c.4.4 1 .4 1.4 0l.8-.8c.4-.4.4-1 0-1.4l-4.2-4.2c-.4-.4-1-.4-1.4 0l-.8.8z"/></svg></button>
                        <button class="control-btn" id="expand-selection-btn" title="Expand Selection" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg></button>
                        <button class="control-btn" id="collapse-selection-btn" title="Collapse Selection" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg></button>
                    </div>
                    <div class="control-group premium-feature-locked">
                        <button class="control-btn" id="random-color-btn" title="Cycle Colors (C)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg></button>
                        <button class="control-btn" id="revert-color-btn" title="Revert to Default Colors"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 13-3-3-3 3"/><path d="m12 10 3 3"/><path d="M10.002 6.43A6.5 6.5 0 0 0 8.5 20a6.5 6.5 0 0 0 13 0c0-2.83-1.8-5.23-4.29-6.13"/><path d="M4.24 10.32a6.5 6.5 0 0 0-1.74 6.18A6.5 6.5 0 0 0 8.5 20"/></svg></button>
                        <button class="control-btn" id="visual-map-layout-toggle" title="Toggle Layout"></button>
                    </div>
                    <div class="control-group premium-feature-locked">
                        <button class="control-btn" id="gather-nodes-btn" title="Gather All Nodes"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="14" x2="10" y2="14"></line><line x1="4" y1="10" x2="10" y2="10"></line><line x1="14" y1="4" x2="14" y2="10"></line><line x1="10" y1="4" x2="10" y2="10"></line><line x1="20" y1="10" x2="14" y2="10"></line><line x1="20" y1="14" x2="14" y2="14"></line><line x1="10" y1="20" x2="10" y2="14"></line><line x1="14" y1="20" x2="14" y2="14"></line></svg></button>
                    </div>
                    <div class="control-group premium-feature-locked">
                        <button class="control-btn" id="visual-map-snapshot-btn" title="Take Snapshot (P)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg></button>  
                        <button class="control-btn" id="toggle-snapshots-btn" title="View Snapshots"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg></button>
                        <button class="control-btn" id="delete-snapshots-btn" title="Delete Oldest Snapshots"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg></button>
                    </div>
                    <div class="control-group">
                        <button class="control-btn" id="zoom-in-btn" title="Zoom In (+, Spacebar)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
                        <button class="control-btn" id="zoom-out-btn" title="Zoom Out (-, Shift+Spacebar)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
                        <button class="control-btn" id="reset-view-btn" title="Reset View (R)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M2.5 2v6h6M21.5 22v-6h-6"/><path d="M22 11.5A10 10 0 0 0 3.2 7.2L2.5 8M2 12.5a10 10 0 0 0 18.8 4.2l.7-1.2"/></svg></button>
                    </div>
                </div>
                
                <div id="vm-focus-line" class="canvas-focus-line" title="Toggle Focus Mode (F)"></div>
                <div id="visual-map-container" tabindex="0"></div>
            </div>

            <div id="mindmap-view" class="view">
                 <div id="mindmap-controls">
                    <div class="control-group search-input-wrapper">
                        <input type="search" class="search-input" id="mindmap-search-input" placeholder="Search MindMaps...(S)">
                        <button class="control-btn" id="mindmap-find-next-btn" title="Find Next Result (Enter)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/><path d="M6 8.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1-.5-.5m0-2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5"/></svg></button>
                        <div class="search-results-list" id="mindmap-search-results" style="display: none;"></div>
                    </div>
                    <div class="control-group">
                        <button class="control-btn" id="mindmap-prev-btn" title="Previous Mind Map (J)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/></svg></button>
                        <button class="control-btn" id="mindmap-next-btn" title="Next Mind Map (K)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/></svg></button>
                    </div>
                     <div class="control-group premium-feature-locked">
                        <button id="mindmap-layout-toggle" class="control-btn" title="Toggle Layout"></button>
                        <button id="mindmap-expand-all" class="control-btn" title="Expand All"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg></button>
                        <button id="mindmap-collapse-all" class="control-btn" title="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg></button>
                    </div>
                     <div class="control-group premium-feature-locked">
                        <button class="control-btn" id="mindmap-rotate-colors" title="Rotate Colors (C)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg></button>
                    </div>
                    <div class="control-group premium-feature-locked">
                        <button class="control-btn" id="mindmap-snapshot-btn" title="Take Snapshot (P)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg></button>
                        <button class="control-btn" id="mindmap-toggle-snapshots-btn" title="View Snapshots"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg></button>
                        <button class="control-btn" id="mindmap-delete-snapshots-btn" title="Delete Oldest Snapshots"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg></button>
                    </div>
                    <div class="control-group">
                        <button class="control-btn" id="mindmap-zoom-in-btn" title="Zoom In (Space)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
                        <button class="control-btn" id="mindmap-zoom-out-btn" title="Zoom Out (Shift+Space)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
                        <button class="control-btn" id="mindmap-reset-view-btn" title="Reset View"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M2.5 2v6h6M21.5 22v-6h-6"/><path d="M22 11.5A10 10 0 0 0 3.2 7.2L2.5 8M2 12.5a10 10 0 0 0 18.8 4.2l.7-1.2"/></svg></button>
                    </div>
                    <div class="control-group">
                        <button class="control-btn" id="mindmap-gather-nodes-btn" title="Gather All Nodes"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="14" x2="10" y2="14"></line><line x1="4" y1="10" x2="10" y2="10"></line><line x1="14" y1="4" x2="14" y2="10"></line><line x1="10" y1="4" x2="10" y2="10"></line><line x1="20" y1="10" x2="14" y2="10"></line><line x1="20" y1="14" x2="14" y2="14"></line><line x1="10" y1="20" x2="10" y2="14"></line><line x1="14" y1="20" x2="14" y2="14"></line></svg></button>
                    </div>
                </div>
                <div id="mm-focus-line" class="canvas-focus-line" title="Toggle Focus Mode (F)"></div>
                <div id="mindmap-container" tabindex="0"></div>
            </div>
        </div>
    </main>

    <div id="annotation-toolbar" style="display:none;">
        <button class="btn-icon" onclick="App.events.navigateStageSlide(-1)" title="Previous Slide (â†)">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg>
        </button>
        <button class="btn-icon" onclick="App.events.navigateStageSlide(1)" title="Next Slide (â†’)">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" /></svg>
        </button>
        <div class="control-divider"></div>

        <button class="btn-icon tool-btn active" id="focus-tool-pen" onclick="App.annotationEngine.setTool('pen')" title="Pen Tool (P)"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" /></svg></button>
        <button class="btn-icon tool-btn" id="focus-tool-rect" onclick="App.annotationEngine.setTool('rect')" title="Rectangle Tool (R)"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 7.5A2.25 2.25 0 017.5 5.25h9a2.25 2.25 0 012.25 2.25v9a2.25 2.25 0 01-2.25 2.25h-9a2.25 2.25 0 01-2.25-2.25v-9z" /></svg></button>
        <button class="btn-icon tool-btn" id="focus-tool-eraser" onclick="App.annotationEngine.setTool('eraser')" title="Eraser Tool (E)"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M11.25 4.5l7.5 7.5-7.5 7.5" /><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg></button>
        <div class="control-divider"></div>
        <button id="focus-color-cycler" class="btn-icon" style="border-radius: 50%;" title="Cycle Color (C)" onclick="App.annotationEngine.cycleColor()"></button>
        <button id="focus-thickness-cycler" class="btn-icon" title="Cycle Thickness (T)" onclick="App.annotationEngine.cycleThickness()">
            <svg width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3" fill="currentColor"/></svg>
        </button>
        <div class="control-divider"></div>
        <button class="btn-icon" onclick="App.annotationEngine.undo()" title="Undo Last Annotation (U)">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>
        </button>
        <button class="btn-icon" onclick="App.annotationEngine.clearCurrentPage()" title="Clear Annotations (X)">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
        </button>
        <button class="btn-icon" onclick="App.annotationEngine.toggle('focus')" title="Exit Annotation Mode (D or Esc)">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
    </div>


    <div id="study-view-container"></div>
    <div id="article-controls" class="article-controls"></div>
    <button id="focus-mode-toggle" class="btn-icon" onclick="App.events.toggleFocusMode()" title="Exit Focus Mode (Esc)" aria-label="Toggle focus mode"></button>
    <div id="selection-toolbar" style="display:none; position:absolute; z-index:1001;"></div>
    <div id="image-toolbar" style="display:none; position:absolute; z-index:1001;"></div>

    <div id="context-menu-container"></div>
    <div id="toast-container"></div>
    <div id="modal-container"></div>
    <div id="zen-mode-container"></div>
    <input type="file" id="mobile-import-input" accept=".json" multiple style="display:none;">

    <div id="confetti-toast-container"></div>
    
    <script id="pomodoro-worker-script" type="text/js-worker">
        let timerId = null;
        let timeLeft = 0;

        self.onmessage = function(e) {
            const { command, newTimeLeft } = e.data;

            if (command === 'start') {
                if (timerId) clearInterval(timerId);
                timeLeft = newTimeLeft;
                timerId = setInterval(() => {
                    timeLeft--;
                    self.postMessage({ type: 'tick', timeLeft: timeLeft });
                    if (timeLeft <= 0) {
                        clearInterval(timerId);
                        timerId = null;
                    }
                }, 1000);
            } else if (command === 'pause') {
                if (timerId) {
                    clearInterval(timerId);
                    timerId = null;
                }
            } else if (command === 'stop') {
                if (timerId) {
                    clearInterval(timerId);
                    timerId = null;
                }
                timeLeft = 0;
            }
        };
    </script>
    <input type="file" id="background-image-input" accept="image/*" style="display: none;">
    <input type="file" id="import-files-input" accept=".zip,.notekash,.json" multiple style="display:none">
    <input type="file" id="pdf-import-input" accept=".pdf" style="display:none">
    <div id="pdf-viewer-container"></div>
   <script id="transcription-worker-script" type="text/js-worker">
        // **THE FIX**: This now uses the modern ES module import.
        // This is compatible with how the worker is created in runTranscription.
        import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1';

        let transcriber = null;

        self.addEventListener('message', async (event) => {
            const { audioData, modelName, playerId } = event.data;

            if (!transcriber) {
                try {
                    transcriber = await pipeline('automatic-speech-recognition', modelName);
                } catch (e) {
                    console.error("Failed to load transcription pipeline in worker", e);
                    self.postMessage({ status: 'error', data: 'Failed to load AI model.', playerId: playerId });
                    return;
                }
            }

             try {
                // THE FIX: Adding a stride creates overlapping audio chunks, which is crucial 
                // for maintaining context and preventing repetition in longer audio files.
                const output = await transcriber(audioData, {
                    chunk_length_s: 30,
                    stride_length_s: 5
                });
                self.postMessage({ status: 'complete', text: output.text, playerId: playerId });
            } catch (e) {
                console.error("Transcription failed in worker", e);
                self.postMessage({ status: 'error', data: 'Transcription failed.', playerId: playerId });
            }
        });
    </script>

    <script>
    /* ==========================================================================
       3. APPLICATION LOGIC (JAVASCRIPT v2 SUPERTAGS UPDATE)
       ==========================================================================
     *
     * DEVELOPER MAP (REFINED v2.0):
     * --------------------------------------------------------------------------
     * App        - Main application namespace.
     * .pwa       - PWA Service Worker and install prompt logic.
     * .config    - Static configuration.
     * .state     - Dynamic application state.
     * .settings  - Handles loading/saving of persistent settings via settings.json.
     * .init()    - Entry point.
     * .indexedDB - Handles storing the directory handle.
     * .fs        - Centralized file system operations for all JSON files.
     * .storage   - Handles all article-specific FS ops, including tombstone logic.
     * .dropbox   - Full Dropbox sync engine.
     * .router    - Manages navigation between views.
     * .ui        - Renders and updates the DOM.
     * .events    - User-triggered event handlers and listeners.
     * .services  - Business logic (exports, image processing, backup).
     * .util      - General-purpose helper functions.
     * .hub       - Encapsulated logic for the Productivity Hub (Tasks & Pomodoro).
     * .quiz      - Logic for the Flashcard Quiz Mode.
     * .visualMap - NEW: D3 Force-Directed Graph logic.
     * .mindMap   - NEW: D3 Hierarchical Tree logic.
     * .contentTools- NEW: Logic for [[...]] and ==...== syntax, suggestions.
     * --------------------------------------------------------------------------
     */
    
    // --- ICONS & HELPERS (FROM PROTOTAGS) ---
    const ICON_FORCE = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 4h-2.5a3.5 3.5 0 0 0-3.5 3.5V11"/><path d="M6 11h2.5a3.5 3.5 0 0 1 3.5 3.5V18"/><circle cx="6" cy="4" r="2"/><circle cx="18" cy="18" r="2"/></svg>`;
    const ICON_RADIAL = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m4.93 19.07 1.41-1.41"/><path d="m17.66 6.34 1.41-1.41"/></svg>`;
    const ICON_MINDMAP_FORCE = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h3M18 12h3M12 3v3M12 18v3"/><circle cx="12" cy="12" r="7"/><path d="M8.5 8.5c.66-.66 1.54-1.2 2.5-1.42"/><path d="M15.5 15.5c-.66.66-1.54 1.2-2.5 1.42"/><path d="M15.5 8.5c-.66-.66-1.54-1.2-2.5-1.42"/><path d="M8.5 15.5c.66.66 1.54 1.2 2.5 1.42"/></svg>`;
    const ICON_MINDMAP_RADIAL = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="2"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m4.93 19.07 1.41-1.41"/><path d="m17.66 6.34 1.41-1.41"/></svg>`;

    // --- SHARED MODULE: Color Manager (FROM PROTOTAGS) ---
    const ColorManager = {
        palettes: ['c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'c10', 'c11', 'c12', 'c13', 'c14', 'c15'],
        assignment: new Map(),
        seed: 1,
        _pseudoRandom() { let x = Math.sin(this.seed++) * 10000; return x - Math.floor(x); },
        getSchemeFor(id, index) {
            if (!this.assignment.has(id)) this.assignment.set(id, this.palettes[index % this.palettes.length]);
            return this.assignment.get(id);
        },
        rotateSchemes() {
            const shuffledPalettes = [...this.palettes];
            for (let i = shuffledPalettes.length - 1; i > 0; i--) {
                const j = Math.floor(this._pseudoRandom() * (i + 1));
                [shuffledPalettes[i], shuffledPalettes[j]] = [shuffledPalettes[j], shuffledPalettes[i]];
            }
            const currentIds = Array.from(this.assignment.keys());
            this.assignment.clear();
            currentIds.forEach((id, index) => this.assignment.set(id, shuffledPalettes[index % shuffledPalettes.length]));
        },
        clear() { this.assignment.clear(); }
    };

    const DUMMY_TUTORIAL_ARTICLE = {
        title: "Welcome to Your Second Brain âœ¨",
        isDummy: true,
        get category() {
            const userCategories = App.settings.get('userCategories') || [];
            const defaultCategory = userCategories.find(c => c.isDefault);
            return defaultCategory ? defaultCategory.name : 'General'; // Fallback just in case.
        },
        get content() {
            const randomQuote = App.util.getRandomMessage(App.util.powerQuotes);
            const randomDevMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
            const styledDivider = `<hr style="border: none; border-top: 2px solid var(--border-color); opacity: 0.9; width: 80%; margin: 0.25em auto;">`;

            // --- FIX: Updated all "color-name" classes to the new "color-number" system ---
            return `
                <div class="nk-text-tile color-6" style="display: flex; justify-content: center; text-align: center; padding: 0.35rem; margin: 0.5em 0 0.5em 0;">
                    <span class="power-quote-gradient" style="font-size: 1.2em; line-height: 1.4;"><b><i>"${randomQuote}"</i></b></span>
                </div>
                <p style="text-align: center;">Welcome to NoteKash! This isn't just a notepad; it's a powerful toolkit for thinking. This interactive note will show you what's possible. Let's begin.</p>
                
                ${styledDivider}

                <div style="display: flex; align-items: center; gap: 0.75rem; font-family: var(--font-body); margin-top: 2em; margin-bottom: 1em;">
                    <h2 style=" font-family: var(--article-font-family); margin: 0; font-size: 1.5em; display: flex; align-items: center; gap: 0.75rem;">ðŸ’¡ Never Lose a Fleeting Thought</h2>
                </div>
                <p>Your thoughts aren't flat, so your notes shouldn't be either. ::To Start new note click "+" Icon (top right)_r::. Now use simple shortcuts to bring them to life.</p>
                <div style="background-color: color-mix(in srgb, var(--primary-color) 5%, transparent); border-radius: var(--border-radius); padding: 0.1em 1.5em; margin: 1em 0;">
                    <blockquote>
                        You can type <kbd>&#61;&#61;double equals&#61;&#61;</kbd> for a <span class="highlight-1">quick highlight</span>, and <span class="text-blue"> even apply colored text</span> with<kbd>&#58;&#58;text color &#58;&#58;</kbd>. The most powerful feature? Weave a web of knowledge by creating a <span class="rendered-tag" data-tag="second-brain">[[SuperTag]]</span> when you type <kbd>&#91;&#91;double brackets&#93;&#93;</kbd>. </br>
                        Use shortcuts to speed up your workflow e.g (Cmd+1â€“9) for highlight, find rest in K-Manual.
                    </blockquote>
                </div>
                <ul>
                    <li>Start a line with <kbd>*</kbd> then <kbd>space</kbd> for bullet points. You can use 'â—‹','â¦¿','â– ','â€£','âœ¤','â—†','â—˜' as well.</li>
                </ul>

                <div style="display: flex; align-items: center; gap: 0.75rem; font-family: var(--font-body); margin-top: 2em; margin-bottom: 1em;">
                    <h2 style=" font-family: var(--article-font-family); margin: 0; font-size: 1.5em; display: flex; align-items: center; gap: 0.75rem;">ðŸ§  Build Lasting Knowledge</h2>
                </div>
                <p>Turn passive notes into an active learning system. Use our built-in tools to challenge your memory and solidify knowledge.</p>
                <div class="nk-accordion" data-state="open">
                    <div class="nk-accordion-trigger">
                        <span class="nk-accordion-title"><b>How do I practice Active Recall? (Click me)</b></span>
                        <svg class="nk-accordion-chevron" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"></polyline></svg>
                    </div>
                    <div class="nk-accordion-content">
                        <p>Use these cards for Q&A (also creates front/back flashcard), or Just type <kbd>&#123;&#123;c1::cloze deletion&#125;&#125;</kbd> to instantly create a {{c1::Cloze Flashcard}} on key terms.</p>
                    </div>
                </div>
                <p>You can also organize technical notes with clean code blocks.</p>
                <pre><code contenteditable="false" style="border-radius: var(--border-radius);">{\n  "idea": "Build a Second Brain",\n  "status": "in_progress",\n  "tags": ["productivity", "learning", "creativity"]\n}</code></pre>

                <div style="display: flex; align-items: center; gap: 0.75rem; font-family: var(--font-body); margin-top: 2em; margin-bottom: 1em;">
                    <h2 style=" font-family: var(--article-font-family); margin: 0; font-size: 1.5em; display: flex; align-items: center; gap: 0.75rem;">âš™ï¸ Create a Learning Engine</h2>
                </div>
                <div class="nk-text-tile color-ghost-1">
                    <div class="nk-text-tile-content" contenteditable="false" style="white-space: normal;">
                        <p style="margin: 0;">Transform your notes into our powerful, <b>Automated Learning Engine (ALE)</b>. As you write, <i>instantly create flashcards from text using '<kbd>{{c1::cloze}}</kbd>' syntax, from Q&A accordions, or from full MCQ blocks</i>. Our <b> intelligent Spaced Repetition System (SRS) </b>then schedules the perfect time for you to review each card, ensuring you learn efficiently and remember what mattersâ€”permanently. <i>Stop just taking notes; start building lasting knowledge.</i></p>
                    </div>
                </div>
                <div class="nk-mcq-block" contenteditable="false">
                    <div class="nk-mcq-question" contenteditable="false">What's the best way to see all of NoteKash's features without leaving the keyboard?</div>
                    <div class="nk-mcq-options">
                        <div class="nk-mcq-option" data-is-correct="false"><div class="nk-mcq-option-text">Memorizing complex shortcuts</div></div>
                        <div class="nk-mcq-option" data-is-correct="true"><div class="nk-mcq-option-text">Pressing the '/' key for the Command Palette</div></div>
                        <div class="nk-mcq-option" data-is-correct="false"><div class="nk-mcq-option-text">Searching through the settings menu</div></div>
                    </div>
                    <div class="nk-mcq-explanation" contenteditable="false"><p><b>Correct!</b> The <b>Command Palette</b> is your superpower in writing. Pressing <b>'/'</b> gives you instant access to insert Tables, Charts, Timelines, Flashcards, MCQs, Lists, Code blocks, Pdfs, Audio, Decktiles and Other Cool Features. You can also Link content, Manage content and even define words on the fly.</p></div>
                </div>

                <div style="display: flex; align-items: center; gap: 0.75rem; font-family: var(--font-body); margin-top: 2em; margin-bottom: 1em;">
                    <h2 style=" font-family: var(--article-font-family); margin: 0; font-size: 1.5em; display: flex; align-items: center; gap: 0.75rem;">ðŸ—ºï¸ See the Big Picture, Instantly</h2>
                </div>
                <p>As your Notes Grow, you need to see the Big Picture?. Our <b> Smart & Powerful, Automatic Learning Engine (ALE) </b> works in background to generate MindMaps and create VisualMaps from your Notes. Go to the <b>Visual Map</b> to see how your SuperTags connectâ€”you can even add **Sticky Notes** to your canvas to capture new ideas. Or, view your highlighted snippets in the <b>Mind Map</b>.</p>
                <div class="nk-timeline-block" contenteditable="false">
                    <div class="nk-timeline-entry"><div class="nk-timeline-content"><div class="nk-timeline-date">Phase 1</div><div class="nk-timeline-title">Capture Fleeting Ideas</div></div></div>
                    <div class="nk-timeline-entry"><div class="nk-timeline-content"><div class="nk-timeline-date">Phase 2</div><div class="nk-timeline-title">Form Connections & Insights</div></div></div>
                    <div class="nk-timeline-entry"><div class="nk-timeline-content"><div class="nk-timeline-date">Phase 3</div><div class="nk-timeline-title">Achieve Intuitive Clarity</div></div></div>
                </div>
                <div class="chart-container" contenteditable="false">
                    <canvas data-chart-config='{"type":"bar","data":{"labels":["Clarity","Connections","Recall"],"datasets":[{"data":[20,55,85]}]},"options":{"indexAxis":"x"}}' width="600" height="300" style="max-width: 100%; height: auto;"></canvas>
                </div>

                <div style="display: flex; align-items: center; gap: 0.75rem; font-family: var(--font-body); margin-top: 2em; margin-bottom: 1em;">
                    <h2 style=" font-family: var(--article-font-family); margin: 0; font-size: 1.5em; display: flex; align-items: center; gap: 0.75rem;">ðŸŽ¯ Reclaim Your Focus & Time</h2>
                </div>
                <p>NoteKash is also your focus partner. Use the **Productivity Hub** (<kbd>Ctrl+;</kbd>) to manage tasks, start a Pomodoro timer, or enter the immersive, full-screen **Zen Mode** for ultimate deep focus.</p>
                <div class="nk-textile-deck" contenteditable="false">
                    <div class="deck-layout-toggle" title="Toggle Layout"><i class="fa-solid fa-table-cells"></i></div>
                    <div class="nk-text-tile color-1" data-color="1"><span class="nk-text-tile-icon">ðŸŽ›</span><div class="nk-text-tile-content">Click to Hide</div></div>
                    <div class="nk-text-tile color-6" data-color="6"><span class="nk-text-tile-icon">ðŸŽ¯</span><div class="nk-text-tile-content">Integrated Task Management</div></div>
                    <div class="nk-text-tile color-3" data-color="3"><span class="nk-text-tile-icon">ðŸ…</span><div class="nk-text-tile-content">Pomodoro Focus Timer</div></div>
                    <div class="nk-text-tile color-4" data-color="4"><span class="nk-text-tile-icon">ðŸ</span><div class="nk-text-tile-content">Zen Mode</div></div>
                    <div class="nk-text-tile color-5" data-color="5"><span class="nk-text-tile-icon">ðŸŽ™ï¸</span><div class="nk-text-tile-content">Record & Transcribe Audio Notes</div></div>
                </div>
                
                <div class="nk-text-tile color-2" style="margin: 1.5em 0; display: flex; max-width: 100%;">
                    <span class="nk-text-tile-icon">ðŸ’¡</span>
                    <div class="nk-text-tile-content" contenteditable="false" style="white-space: normal;">
                        <b>Pro-Tip:</b> Super Search (<kbd>Ctrl+K</kbd>) is your command center. Use it to instantly <b>Create</b> notes on the fly using Syntax of <i>"note:[category]: Title >> Content"</i>, Create instant tasks using <i>"task:[category]: Task Name #priority" </i>, or Start pomodoro on Tasks or <b>Navigate</b> anywhere with commands like <i>%stats, %quiz, %new etc.</i> to track your learning streaks!
                    </div>
                </div>
                
                <p>  You can also Turn your notes into a captivating presentation == with <b>Stage Mode</b> ==g, reveal ideas one by one ==with <b>Cinematic Reveal</b>==c , or set the perfect mood from ==dozens of beautiful <b>Ambiance Themes</b>==. </br></p>
                <p> ::This is just a single note. Imagine the power of these features working in concert across your entire library. Explore the full tutorial to discover even more powerful tools._m:: </p>
                ${styledDivider}
                <div style="display: flex; align-items: center; gap: 0.75rem; font-family: var(--font-body); margin-top: 2em; margin-bottom: 1em;">
                    <h2 style="font-family: var(--article-font-family); margin: 0; font-size: 1.5em; display: flex; align-items: center; gap: 0.75rem;">âœ¨ Unlock Your AI Co-Pilot</h2>
                </div>
                <p>NoteKash AI isn't just a chatbot; with more than <b> 25+ AI Tools </b>, it's a <b> suite of powerful specialized tools </b> integrated directly into your workflow. Go beyond simple Q&A and let your AI co-pilot actively help you learn, create, and think faster.</p>
                <div class="nk-textile-deck" contenteditable="false">
                    <div class="deck-layout-toggle" title="Toggle Layout"><i class="fa-solid fa-table-cells"></i></div>
                    <div class="nk-text-tile color-1" data-color="1"><span class="nk-text-tile-icon">â“</span><div class="nk-text-tile-content"><b>KashAsk:</b> Ask AI Anything</div></div>
                    <div class="nk-text-tile color-9" data-color="9"><span class="nk-text-tile-icon">ðŸª„</span><div class="nk-text-tile-content"><b>KashCurate:</b> Auto-Beautify Notes</div></div>
                    <div class="nk-text-tile color-8" data-color="8"><span class="nk-text-tile-icon">ðŸ“œ</span><div class="nk-text-tile-content"><b>KashSummary:</b> Instant Summaries</div></div>
                    
                    <div class="nk-text-tile color-10" data-color="10"><span class="nk-text-tile-icon">ðŸ“‡</span><div class="nk-text-tile-content"><b>KashFlash:</b> Generate Flashcards</div></div>
                    <div class="nk-text-tile color-7" data-color="7"><span class="nk-text-tile-icon">ðŸ”‘</span><div class="nk-text-tile-content"><b>KashKeywords:</b> Extract Key Concepts</div></div>
                    <div class="nk-text-tile color-5" data-color="5"><span class="nk-text-tile-icon">ðŸ’¡</span><div class="nk-text-tile-content"><b>KashExplain:</b> Explain Complex Topics</div></div>
                    <div class="nk-text-tile color-4" data-color="4"><span class="nk-text-tile-icon">ðŸ§ </span><div class="nk-text-tile-content"><b>KashMnemonic:</b> Create Mnemonics</div></div>
                    <div class="nk-text-tile color-2" data-color="2"><span class="nk-text-tile-icon">âœï¸</span><div class="nk-text-tile-content"><b>KashScript:</b> Turn Notes into a Script</div></div>
                    <div class="nk-text-tile color-2" data-color="2"><span class="nk-text-tile-icon">ðŸ–</span><div class="nk-text-tile-content"><b>KashHighlight:</b> Automatic Highlighting</div></div>
                    <div class="nk-text-tile color-2" data-color="2"><span class="nk-text-tile-icon">ðŸ“</span><div class="nk-text-tile-content"><b>KashTags:</b> Automatic SuperTags creation</div></div>

                </div>
                <div class="nk-text-tile color-ghost-1" style="margin: 1.5em 0; display: flex; max-width: 100%;">
                    <span class="nk-text-tile-icon">ðŸš€</span>
                    <div class="nk-text-tile-content" contenteditable="false" style="white-space: normal;">
                        <b>AI Pro-Tip:</b> Simply type <kbd>/</kbd> in the editor to open the <b>Command Palette</b>. From there, you can access all the powerful 'Kash' AI commands like <kbd>kashsummary</kbd>, <kbd>kashcurate</kbd>, <kbd>kashdebate</kbd>, and many more to supercharge your notes. You can also use "kashask:" command on Global search.
                    </div>
                </div>
                <p style="text-align: center; font-size: 1.2em; line-height: 1.4; margin-top: 0.5em; margin-bottom: 0.5em;"><span class="power-quote-gradient"><b><i>Stop just writing notes. Start building knowledge with an AI partner that understands learning.</i></b></span></p>
                
                ${styledDivider}
                <div style="display: flex; align-items: center; gap: 0.75rem; font-family: var(--font-body); margin-top: 2em; margin-bottom: 1em;">
                    <h2 style="font-family: var(--article-font-family); margin: 0; font-size: 1.5em; display: flex; align-items: center; gap: 0.75rem;">ðŸ’Ž The NoteKash Difference</h2>
                </div>
                <p>Built for thinkers, learners, and creators who value speed, ownership, and a beautifully integrated workflow.</p>
                <div id="article-content" style="margin-top: 0.ã€‚ 5em;">
                    <table style="width: 100%; border-collapse: collapse; border-radius: var(--border-radius-lg); overflow: hidden; box-shadow: var(--shadow-sm); border: 1px solid var(--border-color);">
                        <thead>
                            <tr style="background-color: var(--bg-tertiary);">
                                <th style="padding: 12px 16px; text-align: left; font-size: 1.1em;">Feature</th>
                                <th style="padding: 12px 16px; text-align: center; font-size: 1.1em; background-color: color-mix(in srgb, var(--danger-color) 8%, transparent);">Most Note Apps</th>
                                <th style="padding: 12px 16px; text-align: center; font-size: 1.1em; background-color: color-mix(in srgb, var(--success-color) 8%, transparent);">NoteKash</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="border-top: 1px solid var(--border-color);">
                                <td style="padding: 12px 16px; font-weight: 500;">Data Ownership</td>
                                <td style="padding: 12px 16px; text-align: center;">â˜ï¸ Cloud-Only</td>
                                <td style="padding: 12px 16px; text-align: center; font-weight: 600; color: var(--primary-color);">ðŸ“‚ User Owned</td>
                            </tr>
                            <tr style="border-top: 1px solid var(--border-color); background-color: color-mix(in srgb, var(--border-color) 15%, transparent);">
                                <td style="padding: 12px 16px; font-weight: 500;">Pricing Model</td>
                                <td style="padding: 12px 16px; text-align: center;"><span class="nk-stat-badge" style="background-color: var(--bg-secondary);">ðŸ’³ Costly Monthly Subscriptions</span></td>
                                <td style="padding: 12px 16px; text-align: center;"><span class="nk-stat-badge" style="background-color: var(--bg-secondary); border-color: var(--primary-color); color: var(--primary-color);">ðŸ’µ Lowest Price with One Time Cost</span></td>
                            </tr>
                            <tr style="border-top: 1px solid var(--border-color);">
                                <td style="padding: 12px 16px; font-weight: 500;">Offline Access</td>
                                <td style="padding: 12px 16px; text-align: center;">ðŸ”´ Limited / None</td>
                                <td style="padding: 12px 16px; text-align: center;">ðŸŸ¢ Full Functionality</td>
                            </tr>
                            <tr style="border-top: 1px solid var(--border-color); background-color: color-mix(in srgb, var(--border-color) 15%, transparent);">
                                <td style="padding: 12px 16px; font-weight: 500;">Integrated Learning</td>
                                <td style="padding: 12px 16px; text-align: center;">ðŸ”´ Separate Apps Needed</td>
                                <td style="padding: 12px 16px; text-align: center;">ðŸŸ¢ Built-in SRS Flashcards</td>
                            </tr>
                            <tr style="border-top: 1px solid var(--border-color);">
                                <td style="padding: 12px 16px; font-weight: 500;">Visual Thinking</td>
                                <td style="padding: 12px 16px; text-align: center;">ðŸ”´ Basic Linking</td>
                                <td style="padding: 12px 16px; text-align: center;">ðŸŸ¢ Mind & Visual Maps</td>
                            </tr>
                            <tr style="border-top: 1px solid var(--border-color); background-color: color-mix(in srgb, var(--border-color) 15%, transparent);">
                                <td style="padding: 12px 16px; font-weight: 500;">Focus Tools</td>
                                <td style="padding: 12px 16px; text-align: center;">ðŸ”´ Minimal</td>
                                <td style="padding: 12px 16px; text-align: center;">ðŸŸ¢ Pomodoro, Zen Mode, Todo</td>
                            </tr>
                            <tr style="border-top: 1px solid var(--border-color); background-color: color-mix(in srgb, var(--border-color) 15%, transparent);">
                                <td style="padding: 12px 16px; font-weight: 500;">Note AI</td>
                                <td style="padding: 12px 16px; text-align: center;">ðŸ”´ Limited & Costly</td>
                                <td style="padding: 12px 16px; text-align: center;">ðŸŸ¢ Unlimited & Powerful</td>
                            </tr>
                            <tr style="border-top: 1px solid var(--border-color);">
                                <td style="padding: 12px 16px; font-weight: 500;">Speed & Performance</td>
                                <td style="padding: 12px 16px; text-align: center;">ðŸŒ Can be slow</td>
                                <td style="padding: 12px 16px; text-align: center;">âš¡ï¸ Blazing Fast</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p style="text-align: center; font-size: 1.2em; line-height: 1.4; margin-top: 0.5em; margin-bottom: 0.5em;"><span class="power-quote-gradient"><b><i>${randomDevMessage}</i></b></span></p>
            `;
        }
    };

    const App = {

        
        // ==========================================================================
        // NEW: ASCENSION & LICENSE MODULE
        // ==========================================================================
        license: {
            state: {
                tier: 'Spark', // Default free tier
                userName: '',
                isPremium: false,
                expiry: null,
                token: null
            },

            isPremium() {
                // ADDED: Explicit check for the developer key for robustness.
                if (this.state.token === 'testingnow') return true;

                if (!this.state.isPremium || !this.state.expiry) return false;
                // Check if the expiry date is in the future
                return new Date(this.state.expiry) > new Date();
            },


            async activate() {
                const nameInput = document.getElementById('license-name-input');
                const statusInput = document.getElementById('license-status-input');
                const keyInput = document.getElementById('license-key-input');
                const name = nameInput.value.trim();
                const status = statusInput.value.trim();
                const key = keyInput.value.trim();

                if (!name || !key) {
                    App.ui.showToast('Please enter both your name and license key.', 'warning');
                    return;
                }

                // Save status/bio locally regardless of activation success
                await App.settings.set('userBio', status);

                const validationUrl = '/.netlify/functions/validate';

                try {
                    const response = await fetch(validationUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, key })
                    });
                    const data = await response.json();
                    if (!response.ok) throw new Error(data.error || 'Activation failed.');

                    const token = data.token;
                    const payload = JSON.parse(atob(token.split('.')[1]));

                    this.state.token = token;
                    this.state.isPremium = payload.isPremium;
                    this.state.tier = payload.tier;
                    this.state.userName = payload.userName;
                    this.state.expiry = payload.expiry;

                    await App.settings.set('licenseToken', token);
                    App.ui.showToast(`Welcome, ${payload.tier} ${payload.userName}! Premium activated.`, 'success');
                    this.updateUIAfterStateChange();
                    App.ui.closeModal();

                } catch (error) {
                    App.ui.showToast(`Activation Error: ${error.message}`, 'error');
                    console.error('Activation Error:', error);
                }
            },

            revalidate() {
                if (this.isPremium()) {
                    const expiryDate = new Date(this.state.expiry).toLocaleDateString();
                    App.ui.showToast(`License for ${this.state.userName} is valid until ${expiryDate}.`, 'success');
                } else {
                    App.ui.showToast('No active license found to re-validate.', 'warning');
                }
            },

            delete() {
                App.ui.showConfirmationModal({
                    title: 'Delete License?',
                    message: 'Are you sure you want to delete your license and revert to the Spark (free) tier? All premium features will be locked.',
                    confirmText: 'Delete',
                    onConfirm: async () => {
                        await App.settings.set('licenseToken', null);
                        // Do NOT delete userBio, they might want to keep it.
                        this.state = { tier: 'Spark', userName: '', isPremium: false, expiry: null, token: null };
                        this.updateUIAfterStateChange();
                        App.ui.closeModal();
                        App.ui.showToast('License removed. You are now on the Spark tier.', 'info');
                    }
                });
            },

            async loadState() {

                const savedToken = App.settings.get('licenseToken');
                // NEW: Intercept the developer key before validation
                if (savedToken === 'testingnow') {
                this.state.token = 'testingnow';
                this.state.isPremium = true;
                this.state.tier = 'Diamond';
                this.state.userName = 'Developer';
                // Set an expiry date far in the future for testing purposes
                const futureDate = new Date();
                futureDate.setFullYear(futureDate.getFullYear() + 10);
                this.state.expiry = futureDate.toISOString();

                // Bypass the rest of the validation logic
                this.updateUIAfterStateChange();
                return;
                }

                if (savedToken) {
                    try {
                        const payload = JSON.parse(atob(savedToken.split('.')[1]));
                        if (new Date(payload.expiry) > new Date()) {
                            this.state.token = savedToken;
                            this.state.isPremium = payload.isPremium;
                            this.state.tier = payload.tier;
                            this.state.userName = payload.userName;
                            this.state.expiry = payload.expiry;
                        } else {
                        App.ui.showToast('Your premium license has expired.', 'warning');
                        await App.settings.set('licenseToken', null);
                        }
                    } catch (e) {
                        console.error("Error parsing license token:", e);
                        await App.settings.set('licenseToken', null);
                    }
                }
                this.updateUIAfterStateChange();
            },

            updateUIAfterStateChange() {
                const badgeInfo = { Spark: { icon: 'âœ¨', name: 'Spark', color: '#B0BEC5' }, Bronze: { icon: 'ðŸ¥‰', name: 'Bronze', color: '#CD7F32' }, Silver: { icon: 'ðŸ¥ˆ', name: 'Silver', color: '#C0C0C0' }, Gold: { icon: 'ðŸ¥‡', name: 'Gold', color: '#FFD700' }, Diamond: { icon: 'ðŸ’Ž', name: 'Diamond', color: '#B9F2FF' }};
                const currentTier = badgeInfo[this.state.tier] || badgeInfo.Spark;
                const isPremium = this.isPremium();

                const profileBadge = document.getElementById('profile-badge');
                if (profileBadge) {
                    // Replace the simple text content with our new rich HTML badge
                    profileBadge.innerHTML = App.util.getTierBadgeHTML(this.state.tier, 36);
                    profileBadge.title = `Your Current Tier: ${currentTier.name}`;
                }

                document.querySelectorAll('.premium-feature-locked').forEach(el => {
                    if (isPremium) {
                        el.classList.remove('premium-feature-locked');
                        if (el.dataset.originalTitle) {
                            el.title = el.dataset.originalTitle;
                        }
                    } else {
                        el.classList.add('premium-feature-locked');
                        if (!el.dataset.originalTitle) {
                            el.dataset.originalTitle = el.title;
                        }
                        el.title = 'This is a Premium feature. Upgrade to unlock.';
                    }
                });
                App.ui.updateHeaderState();
                const activeViewId = App.router.getActiveView();
                if (activeViewId === 'flashcard') App.ui.filterAndRenderFlashcards();
                if (activeViewId === 'library') App.ui.filterAndRenderArticles();
            },
        },
        // ==========================================================================
        // 3.1. CONFIGURATION
        // ==========================================================================
        config: {
            categories: ["General", "Geography", "History", "Society", "Polity", "Security", "Science", "Ecology", "Economy", "Essay", "Ethics", "Opinion", "Misc"],
            highlightClasses: ['highlight-1', 'highlight-2', 'highlight-3', 'highlight-4', 'highlight-5', 'highlight-6', 'highlight-7'],
            textClasses: ['text-red', 'text-green', 'text-blue', 'text-magenta'],
            colorCycle: ['highlight-1', 'highlight-2', 'highlight-3', 'highlight-4', 'highlight-5', 'highlight-6', 'highlight-7', 'text-red', 'text-green', 'text-blue', 'text-magenta'],
            sparkTierLimit: 365,
            sm2: {
                ratings: ['Again', 'Hard', 'Hold', 'Good', 'Easy'],
                colors: { 'Again': 'red', 'Hard': 'orange', 'Hold': 'purple', 'Good': 'skyblue', 'Easy': 'green'},
                leechThreshold: 5, // Mark a card as a leech after 5 lapses
                // DEPRECATED: These will no longer be used by the new algorithm, but we can keep them for now.
                baseIntervals: { 'Again': 600000, 'Hard': 3600000, 'Hold': 21600000, 'Good': 43200000, 'Easy': 172800000 },
                maxReviewCount: 7 
            },

            quiz: {
                cardCount: 10,
                scores: { 'Easy': 1.0, 'Good': 0.9, 'Hold': 0.7, 'Hard': 0.5, 'Again': 0.2 }
            },
            fonts: [
                // 11 Offline System Fonts (Free)
                { name: 'Arial', value: 'Arial, Helvetica, sans-serif' },
                { name: 'Cambria', value: 'Cambria, Cochin, Georgia, Times, "Times New Roman", serif' },
                { name: 'Courier New', value: "'Courier New', Courier, monospace" },
                { name: 'Garamond', value: 'Garamond, serif' },
                { name: 'Georgia', value: 'Georgia, serif' },
                { name: 'Helvetica', value: 'Helvetica, Arial, sans-serif' },
                { name: 'Monaco', value: 'Monaco, "Lucida Console", monospace' },
                { name: 'Palatino', value: 'Palatino, "Palatino Linotype", serif' },
                { name: 'Sans-Serif', value: 'sans-serif' },
                { name: 'Times New Roman', value: "'Times New Roman', Times, serif" },
                { name: 'Verdana', value: 'Verdana, Geneva, sans-serif' },
                // 38 Google Web Fonts (Premium)
                { name: 'Allura', value: 'Allura, cursive' },
                { name: 'Arvo', value: 'Arvo, serif' },
                { name: 'Bitter', value: 'Bitter, serif' },
                { name: 'Cabin', value: 'Cabin, sans-serif' },
                { name: 'Cabin Sketch', value: "'Cabin Sketch', cursive" },
                { name: 'Changa One', value: "'Changa One', cursive" },
                { name: 'Cinzel', value: 'Cinzel, serif' },
                { name: 'Crimson Text', value: "'Crimson Text', serif'" },
                { name: 'Dancing Script', value: "'Dancing Script', cursive" },
                { name: 'Exo 2', value: "'Exo 2', sans-serif" },
                { name: 'Fira Code', value: "'Fira Code', monospace" },
                { name: 'Great Vibes', value: "'Great Vibes', cursive" },
                { name: 'Inconsolata', value: 'Inconsolata, monospace' },
                { name: 'Jersey 20', value: "'Jersey 20', sans-serif" },
                { name: 'Josefin Sans', value: "'Josefin Sans', sans-serif" },
                { name: 'Kaushan Script', value: "'Kaushan Script', cursive" },
                { name: 'Lato', value: 'Lato, sans-serif' },
                { name: 'Libre Baskerville', value: "'Libre Baskerville', serif" },
                { name: 'Lobster', value: 'Lobster, cursive' },
                { name: 'Merriweather', value: 'Merriweather, serif' },
                { name: 'Metal Mania', value: "'Metal Mania', cursive" },
                { name: 'Montserrat', value: 'Montserrat, sans-serif' },
                { name: 'Pacifico', value: 'Pacifico, cursive' },
                { name: 'Parisienne', value: 'Parisienne, cursive' },
                { name: 'Patrick Hand', value: "'Patrick Hand', cursive" },
                { name: 'Playfair Display', value: "'Playfair Display', serif" },
                { name: 'Protest Revolution', value: "'Protest Revolution', sans-serif" },
                { name: 'Righteous', value: 'Righteous, cursive' },
                { name: 'Roboto', value: 'Roboto, sans-serif' },
                { name: 'Rochester', value: 'Rochester, cursive' },
                { name: 'Salsa', value: 'Salsa, cursive' },
                { name: 'Satisfy', value: 'Satisfy, cursive' },
                { name: 'Sofia', value: 'Sofia, cursive' },
                { name: 'Source Code Pro', value: "'Source Code Pro', monospace" },
                { name: 'Special Elite', value: "'Special Elite', cursive" },
                { name: 'Syne Mono', value: "'Syne Mono', monospace" },
                { name: 'Ubuntu', value: 'Ubuntu, sans-serif' },
                { name: 'Vollkorn', value: 'Vollkorn, serif' },
                { name: 'Zilla Slab', value: "'Zilla Slab', serif" },
            ],
            bulletCycle: ['default', 'bullet-square', 'bullet-triangle', 'bullet-empty-circle', 'bullet-hyphen'],
            themes: [ { id: 'light', name: 'Light' }, { id: 'dark', name: 'Dark' }, { id: 'sepia', name: 'Sepia' }, { id: 'custom', name: 'Create Theme' } ],
            sanitizer: {
                allowedTags: ['P', 'BR', 'B', 'I', 'U', 'STRONG', 'EM', 'SPAN', 'DIV', 'UL', 'OL', 'LI', 'A', 'BLOCKQUOTE', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HR', 'TABLE', 'THEAD', 'TBODY', 'TR', 'TH', 'TD', 'DEL', 'IMG', 'SUB', 'SUP', 'CODE', 'PRE', 'BUTTON', 'SVG', 'POLYLINE', 'MARK', 'CANVAS', 'AUDIO', 'INPUT'],
                allowedAttributes: {
                    '*': ['class', 'id', 'title', 'style'], 
                    'a': ['href', 'target', 'data-link-type', 'data-link-id', 'data-article-id'],
                    'span': ['data-tag-text', 'contenteditable', 'data-placeholder', 'data-tag', 'data-pdf-id', 'data-original-name'],
                    'mark': [],
                    'canvas': ['data-chart-config', 'width', 'height', 'style'],
                    'div': ['contenteditable', 'data-placeholder', 'data-state', 'data-checked', 'data-is-correct', 'data-answered', 'data-color', 'data-caption-theme', 'data-caption-align'],
                    'img': ['src', 'alt', 'width', 'height','style','data-original-width', 'data-original-height'],
                    'td': ['colspan', 'rowspan'],
                    'th': ['colspan', 'rowspan'],
                    'button': ['aria-expanded', 'aria-controls', 'class', 'aria-label'],
                    'svg': ['viewBox', 'class', 'width', 'height', 'fill', 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'],
                    'polyline': ['points'],
                    'audio': ['src', 'controls', 'preload'],
                    'input': ['type', 'value', 'min', 'max', 'step', 'class', 'style', 'title']
                }
            },
            image: {
                maxWidth: 1024,
                jpegQuality: 0.95,
                maxUploadSize: 30 * 1024 * 1024 // 30MB
            },
            stickyNoteColors: [
                'default', 'crimson', 'tangerine', 'sunflower', 'lime', 'forest', 'azure', 
                'indigo', 'amethyst', 'lavender', 'fuchsia', 'blush', 'terracotta', 
                'teal', 'slate', 'olive'
            ],

        },

        // ==========================================================================
        // 3.2. STATE
        // ==========================================================================
        state: {
            articles: [],
            isInitialLoadComplete: false,
            isHydrated: false,
            hydrationPromise: null,
            deletedRecords: [],
            activeArticleId: null,
            activeReaderTheme: 'default',
            currentMode: 'read',
            isFullscreen: false,
            directoryHandle: null,
            currentBulletIndex: 0,
            lastClickTime: 0,
            chartInstances: {},
            studySession: { isActive: false, isQuizMode: false, cards: [], currentIndex: 0, isRating: false },
            settings: {},
            libraryRender: {
                isRendering: false,
                currentIndex: 0,
                filteredArticles: [],
                searchTimeout: null
            },
            flashcardRender: {
                searchResults: [],
                selectedIndex: -1
            },
            selectedImageContainer: null,
            savedRange: null,
            pwa: { installPromptEvent: null },
            dropboxToken: null,
            dropboxUser: null,
            isDropboxReady: false,
            isSyncing: false,
            isArticleDirty: false,
            isPristineNewArticle: false,
            lastHeartKeyPressTime: 0,
            focusSession: {
                isActive: false,
                articles: [],
                currentIndex: 0,
                isStageMode: false,
                currentSlideIndex: 0,
                scrollStops: [],
                isCinematicActive: false,
                teleprompterActive: false,
                teleprompterSize: 30,
                teleprompterFontSize: 1.1, 
            },
            autosaveInterval: null,
            // New states from ProtoTags
            tags: {},
            visualMapState: { snapshots: [], stickyNotes: {} },
            mindMapState: { snapshots: [] },
            dataCache: { isBuilt: false, mindMapSnippets: {} },
            scrollToTagId: null,
            suggestionTimeout: null,
        },

        // ==========================================================================
        // 3.3. SETTINGS MANAGEMENT
        // ==========================================================================
        settings: {
            defaults: {
                lastStorageMode: null,
                hasSetViewPreference: false,
                mobileViewEnabled: false,
                userCategories: null,
                categoryLayout: 'list',
                categoryHighlightsVisible: true,
                libraryTitle: 'My Library', 
                categoryNameStyle: 'full',
                focusModeFontSize: '1.1rem', 
                theme: 'light',
                readerTheme: 'default',
                uiOpacity: 1.0,
                fontFamily: 'Georgia, serif',
                fontSize: '1.15rem',
                lineHeight: '1.7',
                backgroundImage: null,
                customThemeBase: 'light',
                flashcardSortBy: 'sm2',
                tagSortBy: 'alpha',
                colorCycleIndex: 0,
                showTagsOnTiles: true,
                categoryRenames: {},
                enableDropboxSync: false,
                dropboxToken: null,
                dropboxClientId: null,
                lastSyncTimestamp: null,
                pomodoroWork: 25,
                pomodoroBreak: 5,
                studySessionSize: 25,
                studyCardFontSize: '1.6rem',
                jpegQuality: 0.9,
                ocrThreshold: 128,
                audioBitrate: 32000,
                pdfTextViewFontSize: '1.1rem',
                pdfTextViewTheme: 'default',
                intervalModifier: 1.0,
            },
            async load() {
                const savedSettings = await App.fs.read('settings.json');
                App.state.settings = { ...this.defaults, ...savedSettings };

                if (!App.state.settings.userCategories || (Array.isArray(App.state.settings.userCategories) && typeof App.state.settings.userCategories[0] === 'string')) {
                    console.log("Initializing or migrating category format to objects...");
                    const categoryNames = App.state.settings.userCategories || App.config.categories; // Use saved names or default
                    const migratedCategories = categoryNames.map((name, index) => ({
                        name: name,
                        colorIndex: index % App.util.getCategoryColorCount(),
                        isDefault: name === 'General' // <-- This is the surgical addition
                    }));
                  
                    await this.set('userCategories', migratedCategories);
                }
                App.state.dropboxToken = App.state.settings.dropboxToken;
            },
            async save() {
                await App.fs.write('settings.json', App.state.settings);
            },
            get(key) {
                return App.state.settings[key];
            },
            async set(key, value) {
                App.state.settings[key] = value;
                await this.save();
            }
        },

        // ==========================================================================
        // 3.4. INITIALIZATION
        // ==========================================================================
        async _startFileSystemSession() {
            console.log("File system permission granted. Starting session...");
            
            const pendingRenamePlan = await App.fs.read('_category_rename_plan.json');
            if (pendingRenamePlan) {
                App.ui.showToast('Resuming interrupted category rename...', { type: 'warning', duration: 0 });
                await App.events.categories.executeRenamePlan(pendingRenamePlan);
            }

            const operationPlan = await App.fs.read('_category_operation_plan.json');
            if (operationPlan) {
                if (operationPlan.status === 'cancelled') {
                    // If the operation was cancelled, clean up the plan file and do nothing.
                    console.log("Cleaning up a previously cancelled category operation.");
                    await App.fs.write('_category_operation_plan.json', null);
                } else {
                    // If the plan is pending (or legacy without a status), execute it.
                    setTimeout(() => App.events.categories.executeOperationPlan(operationPlan), 500);
                }
            }
            await App.settings.load(); // Load settings FIRST

            const userCategories = App.settings.get('userCategories');
            if (!userCategories || (Array.isArray(userCategories) && (userCategories.length === 0 || typeof userCategories[0] === 'string' || userCategories[0].displayName === undefined))) {
                console.log("Performing one-time migration for user categories to add displayName...");
                
                const categoryNames = Array.isArray(userCategories) && userCategories.length > 0 && typeof userCategories[0] === 'string' 
                    ? userCategories 
                    : (userCategories || App.config.categories).map(c => c.name || c);
                
                const migratedCategories = categoryNames.map((name, index) => ({
                    name: name,
                    displayName: name, 
                    colorIndex: userCategories?.find?.(c => c.name === name)?.colorIndex ?? index % App.util.getCategoryColorCount(),
                    isDefault: name === 'General'
                }));

                await App.settings.set('userCategories', migratedCategories); // <<< THE FIX IS HERE
                console.log("Category migration complete.");
            }

            App.ui.applyTheme(App.settings.get('theme'), true); // Apply theme
            await App.loadInitialData(); // Load all other data
            App.router.navigateTo('library'); // Navigate to the library
        },

        async init() {

            if ('launchQueue' in window && 'files' in LaunchParams.prototype) {
                window.launchQueue.setConsumer(async (launchParams) => {
                    if (!launchParams.files || launchParams.files.length === 0) {
                        return;
                    }
                    const fileHandles = launchParams.files;
                    const files = await Promise.all(fileHandles.map(handle => handle.getFile()));
                    App.ui.showToast(`Importing ${files.length} shared note(s)...`, { type: 'info' });
                    App.services.backup.handleFileImport(files);
                });
            }

            if (window.pdfjsLib) {
                pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;
            }
            this.pwa.init();
            this.events.setupGlobalListeners();
            const mobileImportInput = document.getElementById('mobile-import-input');
            if (mobileImportInput) mobileImportInput.addEventListener('change', (e) => App.storage.handleMobileImport(e));

            try {
                const savedHandle = await this.indexedDB.getHandle('directory');

                if (savedHandle) {
                    App.state.directoryHandle = savedHandle;
                    App.state.storageMode = 'fileSystem';

                    const permissionStatus = await savedHandle.queryPermission({ mode: 'readwrite' });

                    if (permissionStatus === 'granted') {
                        // Permission is already granted, so we can start the session.
                        await this._startFileSystemSession();
                    } else {
                    
                        this.ui.applyTheme(App.settings.get('theme') || 'light', true);
                        this.router.navigateTo('welcome', { permissionState: permissionStatus });
                    }
                } else {
                    // This is the path for first-time users or browser storage users.
                    await App.settings.load();
                    this.ui.applyTheme(App.settings.get('theme'), true);

                    if (App.settings.get('lastStorageMode') === 'browser') {
                        App.state.storageMode = 'browser';
                        await this.loadInitialData();
                        App.router.navigateTo('library');
                    } else {
                        this.router.navigateTo('welcome', { permissionState: 'none' });
                    }
                }
            } catch (error) {
                console.error("Initialization error:", error);
                try { await App.settings.load(); } catch(e) {}
                this.ui.applyTheme(App.settings.get('theme') || 'light', true);
                this.router.navigateTo('welcome', { permissionState: 'none' });
            }
        },

        async loadInitialData() {
           
            console.log(`Loading data in '${App.state.storageMode}' mode.`);

            if (App.state.storageMode === 'fileSystem' && App.state.directoryHandle) {
                const indexFile = await App.fs.read('_index.json');
                if (indexFile && Array.isArray(indexFile)) {
                    App.state.articles = indexFile;
                } else {
                    await this.storage.load();
                    await this.storage.generateIndexFromState();
                }
            } else {
                const articlesFromDB = await App.browserStore.getAllArticles();
                App.state.articles = articlesFromDB;
                App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
            }

            App.state.activeReaderTheme = App.settings.get('readerTheme') || 'default';

            if (!this.settings.get('hasSetViewPreference')) {
                if (window.innerWidth <= 768) await this.settings.set('mobileViewEnabled', true);
                await this.settings.set('hasSetViewPreference', true);
            }

       
            this.ui.applyMobileView();
            this.ui.applyFontSettings();
            document.documentElement.style.setProperty('--ui-opacity', App.settings.get('uiOpacity'));
            const blurValue = parseFloat(App.settings.get('uiOpacity')) === 0 ? '0px' : '8px';
            document.documentElement.style.setProperty('--blur-intensity', blurValue);

            this.proactiveBackgroundLoader();
            App.state.isInitialLoadComplete = true;
        },

        async proactiveBackgroundLoader() {
            if (App.state.isHydrated) return;

            console.log("Starting proactive background load...");
            await App.license.loadState();
            let hydrationOccurred = false;

            if (App.state.directoryHandle && App.state.articles.length > 0 && App.state.articles[0].content === undefined) {
                console.log("Hydrating articles with full content in the background...");
                const { articles: fullArticles } = await this.storage.getAll();
                App.state.articles = fullArticles;
                App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                hydrationOccurred = true; // Mark that a data update happened.
                console.log("Article hydration complete.");
            }

            App.state.isHydrated = true;

            await this.hub.loadData();
            await this.quiz.loadStats();
            App.state.tags = await App.fs.read('tags.json') || {};
            App.state.visualMapState = await App.fs.read('visual-map-state.json') || { snapshots: [], stickyNotes: {} };
            App.state.mindMapState = await App.fs.read('mind-map-state.json') || { snapshots: [] };

            App.globalSearch.buildIndex();

            if (hydrationOccurred && App.router.getActiveView() === 'library') {
                console.log("Hydration complete, re-rendering library view to ensure consistency.");
                App.ui.filterAndRenderArticles();
            }

            App.ui.updateHeaderState();
            await this.dropbox.init();
            if (this.dropbox.isReady() && App.state.directoryHandle && this.settings.get('enableDropboxSync')) {
                this.dropbox.syncChanges(true);
            }

            await App.util.reconcileCategories();

            requestIdleCallback(() => App.contentTools.buildDataCache());
            console.log("Proactive background load complete.");
        },

        // ==========================================================================
        // 3.5. DATABASE (INDEXEDDB for Handle Persistence)
        // ==========================================================================
        indexedDB: {
            db: null, dbName: 'NoteKashFSDatabase_v2', storeName: 'fileSystemHandles',
            async openDB() {
                return new Promise((resolve, reject) => {
                    if (this.db) return resolve(this.db);
                    const request = indexedDB.open(this.dbName, 1);
                    request.onerror = () => reject("IndexedDB error: " + request.error);
                    request.onsuccess = (e) => { this.db = e.target.result; resolve(this.db); };
                    request.onupgradeneeded = (e) => e.target.result.createObjectStore(this.storeName);
                });
            },
            async setHandle(key, value) {
                const db = await this.openDB();
                const tx = db.transaction(this.storeName, 'readwrite');
                tx.objectStore(this.storeName).put(value, key);
                return new Promise(resolve => tx.oncomplete = resolve);
            },
            async getHandle(key) {
                const db = await this.openDB();
                return new Promise((resolve, reject) => {
                    const req = db.transaction(this.storeName, 'readonly').objectStore(this.storeName).get(key);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            }
        },


         // ==========================================================================
        // 3.5. BROWSER STORAGE ABSTRACTION (NEW & ROBUST)
        // ==========================================================================
        browserStore: {
            _dbPromise: null, 
            _dbName: 'NoteKash_BrowserStore_v1',
            _version: 1, 

            _getDB() {
                // This robust pattern ensures indexedDB.open is only called ONCE.
                // All subsequent calls will await the same initial connection promise, preventing deadlocks.
                if (!this._dbPromise) {
                    this._dbPromise = new Promise((resolve, reject) => {
                        const request = indexedDB.open(this._dbName, this._version);

                        request.onerror = (event) => {
                            console.error("IndexedDB connection error:", event.target.error);
                            reject("IndexedDB connection failed. Your browser might be in private mode or have storage disabled.");
                        };

                        request.onsuccess = (event) => {
                            resolve(event.target.result);
                        };

                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('articles')) {
                                db.createObjectStore('articles', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('files')) {
                                db.createObjectStore('files', { keyPath: 'fileName' });
                            }
                        };
                    });
                }
                return this._dbPromise;
            },

            async _getStore(storeName, mode) {
                const db = await this._getDB();
                return db.transaction(storeName, mode).objectStore(storeName);
            },

            // --- Article-specific methods ---
            async getArticle(id) {
                const store = await this._getStore('articles', 'readonly');
                return new Promise((resolve) => {
                    const request = store.get(id);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                });
            },

            async getAllArticles() {
                const store = await this._getStore('articles', 'readonly');
                return new Promise((resolve) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => resolve([]);
                });
            },

            async setArticle(article) {
                const store = await this._getStore('articles', 'readwrite');
                return new Promise((resolve, reject) => {
                    const request = store.put(article);
                    request.onsuccess = resolve;
                    request.onerror = (event) => {
                        console.error("Error setting article in IndexedDB:", event.target.error);
                        reject(event.target.error);
                    };
                });
            },

            async deleteArticle(articleId) {
                const store = await this._getStore('articles', 'readwrite');
                return new Promise((resolve) => {
                    store.delete(articleId).onsuccess = resolve;
                });
            },
            async getFileMetadata(fileName) {
                const store = await this._getStore('files', 'readonly');
                return new Promise((resolve) => {
                    const request = store.get(fileName);
                    request.onsuccess = () => resolve(request.result ? { lastModified: request.result.lastModified } : null);
                    request.onerror = () => resolve(null);
                });
            },
            // --- File-specific methods (for settings.json, etc.) ---
            async getFile(fileName) {
                const store = await this._getStore('files', 'readonly');
                return new Promise((resolve) => {
                    const request = store.get(fileName);
                    request.onsuccess = () => resolve(request.result ? request.result.data : null);
                    request.onerror = () => resolve(null);
                });
            },

            async setFile(fileName, data) {
                const store = await this._getStore('files', 'readwrite');
                const wrapper = {
                    fileName: fileName,
                    data: data,
                    lastModified: new Date().toISOString()
                };
                return new Promise((resolve, reject) => {
                    const request = store.put(wrapper);
                    request.onsuccess = resolve;
                    request.onerror = (event) => {
                        console.error("Error setting file in IndexedDB:", event.target.error);
                        reject(event.target.error);
                    };
                });
            },
        },

        // ==========================================================================
        // 3.6. FILE SYSTEM (FS) MODULE
        // ==========================================================================
        
        fs: {
            async read(fileName) {
                if (App.state.directoryHandle) {
                    try {
                        const fileHandle = await App.state.directoryHandle.getFileHandle(fileName);
                        const file = await fileHandle.getFile();
                        const text = await file.text();
                        if (!text) return null;
                        return JSON.parse(text);
                    } catch (err) {
                        if (err.name === 'NotFoundError') return null;
                        console.error(`Error reading or parsing ${fileName}:`, err);
                        App.ui.showToast(`Could not load ${fileName}. It may be corrupted.`, 'error');
                        return null;
                    }
                } else {
                    return App.browserStore.getFile(fileName);
                }
            },
            async write(fileName, data) {
                if (App.state.directoryHandle) {
                    try {
                        const fileHandle = await App.state.directoryHandle.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(JSON.stringify(data, null, 2));
                        await writable.close();
                    } catch (err) {
                        console.error(`Error writing to ${fileName}:`, err);
                        App.ui.showToast(`Error saving data to ${fileName}.`, 'error');
                    }
                } else {
                    await App.browserStore.setFile(fileName, data);
                }
            },
            async getFileMetadata(fileName) {
                if (App.state.storageMode === 'fileSystem' && App.state.directoryHandle) {
                    try {
                        const fileHandle = await App.state.directoryHandle.getFileHandle(fileName);
                        const file = await fileHandle.getFile();
                        return { lastModified: new Date(file.lastModified).toISOString() };
                    } catch (err) {
                        if (err.name === 'NotFoundError') return null; // File doesn't exist
                        console.error(`Error getting metadata for ${fileName}:`, err);
                        return null;
                    }
                } else if (App.state.storageMode === 'browser') {
                    return await App.browserStore.getFileMetadata(fileName);
                }
                return null;
            },
        },


        // ==========================================================================
        // 3.7. STORAGE ENGINE (File System + Tombstones)
        // ==========================================================================
        storage: {
            DELETED_RECORDS_FILENAME: '_deleted.json',

            async load() {
                // This function is now ONLY for File System mode. Browser mode is handled in loadInitialData.
                if (!App.state.directoryHandle) return;

                const { articles, failedCount, total } = await this.getAll();
                App.state.articles = articles;
                App.state.deletedRecords = await this.getDeletedRecords();
                App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));

                if(failedCount > 0) App.ui.showToast(`${failedCount} corrupt file(s) skipped.`, { type: 'warning' });
                if(total > 0) App.ui.showToast(`${articles.length} articles loaded.`, { type: 'success' });
            },

            async createArticle(data) {
                const newArticle = { id: 'art_' + crypto.randomUUID(), title: data.title || 'Untitled Article', content: data.content || '<p><br></p>', category: data.category || 'General', readCount: 0, readHistory: [], tags: [], flashcards: {}, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() };
                try {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = newArticle.content;
                    newArticle.wordCount = (tempDiv.textContent || "").trim().split(/\s+/).filter(Boolean).length;

                    if (App.state.directoryHandle) {
                        await App.fs.write(`${newArticle.id}.json`, newArticle); // Directly use App.fs
                        await this.generateIndexFromState();
                    } else {
                        await App.browserStore.setArticle(newArticle); // Use new browser store
                    }

                    App.state.articles.unshift(newArticle);
                    App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                    return newArticle;
                } catch (err) { console.error("Failed to create article:", err); App.ui.showToast("Error saving new article.", {type: 'error'}); return null; }
            },

            async updateArticle(id, updates) {
                const articleIndex = App.state.articles.findIndex(a => a.id === id);
                if (articleIndex === -1) return { success: false, error: 'Article not found in state.' };
                const updatedArticle = { ...App.state.articles[articleIndex], ...updates, updatedAt: new Date().toISOString() };
                try {
                    if (updatedArticle.content) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = updatedArticle.content;
                        updatedArticle.wordCount = (tempDiv.textContent || "").trim().split(/\s+/).filter(Boolean).length;
                    }

                    if (App.state.directoryHandle) {
                        await App.fs.write(`${updatedArticle.id}.json`, updatedArticle); // Directly use App.fs
                        await this.generateIndexFromState();
                    } else {
                        await App.browserStore.setArticle(updatedArticle); // Use new browser store
                    }

                    App.state.articles[articleIndex] = updatedArticle;
                    App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                    return { success: true, article: updatedArticle };
                } catch (err) {
                    console.error("Failed to update article:", err);
                    App.ui.showToast(`Save failed. Could not update the article.`, { type: 'error' });
                    return { success: false, error: err.message };
                }
            },

            async deleteArticle(id) {
                const articleInState = this.getArticle(id);
                if (!articleInState) return;
                App.state.articles = App.state.articles.filter(a => a.id !== id);
                try {
                    if (App.state.directoryHandle) {
                        await this.recordDeletion(id);
                        await App.state.directoryHandle.removeEntry(`${id}.json`).catch(e => { if (e.name !== 'NotFoundError') throw e; });
                        await this.generateIndexFromState();
                    } else {
                        await App.browserStore.deleteArticle(id); // Use new browser store
                    }
                } catch (err) { console.error("Failed to delete article:", err); App.ui.showToast("Error: Could not delete the article.", { type: 'error' }); }
            },

            async handleMobileImport(event) {
                const files = event.target.files;
                if (!files.length) return;
                const toast = App.ui.showToast(`Importing 0 / ${files.length} notes...`, { duration: 0 });
                let importedCount = 0;
                for (const file of files) {
                    if (file.name.endsWith('.json')) {
                        try {
                            const article = JSON.parse(await file.text());
                            if (article.id && article.title) {
                                await App.browserStore.setArticle(article);
                                importedCount++;
                                App.ui.updateToast(toast, `Importing ${importedCount} / ${files.length} notes...`);
                            }
                        } catch (e) { console.warn(`Skipping invalid file: ${file.name}`); }
                    }
                }
                App.ui.hideToast(toast);
                App.ui.showToast(`${importedCount} notes imported!`, 'success');

                // Set the correct state and trigger the main loading sequence for consistency.
                App.state.isInitialLoadComplete = false;
                App.state.isHydrated = false; // <-- THE FIX: Reset the hydration flag
                App.state.storageMode = 'browser';
                App.state.directoryHandle = null;

                await App.loadInitialData();
                App.router.navigateTo('library');
            },

            // --- The functions below are now ONLY used for File System mode ---
            async verifyPermission(handle) {
                if (await handle.queryPermission({ mode: 'readwrite' }) === 'granted') return true;
                if (await handle.requestPermission({ mode: 'readwrite' }) === 'granted') return true;
                return false;
            },
            async getAll() {
                if (!App.state.directoryHandle) return { articles: [], failedCount: 0, total: 0 };
                const entries = [];
                const dataFiles = ['settings.json', 'todos.json', 'pomodoro.json', 'quiz_stats.json', 'tags.json', 'visual-map-state.json', 'mind-map-state.json'];
                for await (const entry of App.state.directoryHandle.values()) {
                    if (entry.kind === 'file' && entry.name.endsWith('.json') && !entry.name.startsWith('_') && !dataFiles.includes(entry.name)) {
                        entries.push(entry);
                    }
                }
                const total = entries.length;
                if(total === 0) return { articles: [], failedCount: 0, total: 0 };
                const toastId = App.ui.showToast(`Loading 0 / ${total} articles...`, { type: 'info', duration: 120000 }); 
                const articles = []; let failedCount = 0; let count = 0;
                for (const entry of entries) {
                    try {
                        const file = await entry.getFile(); const content = await file.text(); const article = JSON.parse(content);
                        if (typeof article.id === 'string' && typeof article.title === 'string' && typeof article.content === 'string' && typeof article.category === 'string' && !isNaN(new Date(article.updatedAt))) {
                            articles.push(article);
                        } else { throw new Error('Invalid NoteKash article structure'); }
                    } catch (err) { console.error(`Skipping invalid or corrupt file ${entry.name}:`, err.message); App.ui.showToast(`Skipped corrupt file: ${entry.name}`, { type: 'warning' }); failedCount++; }
                    count++; App.ui.updateToast(toastId, `Loading ${count} / ${total} articles...`);
                }
                App.ui.hideToast(toastId); return { articles, failedCount, total };
            },
            async generateIndexFromState() {
                if (!App.state.directoryHandle) return;
                const tempDiv = document.createElement('div');
                const indexData = App.state.articles.map(article => {
                    let wordCount = article.wordCount;
                    if (typeof article.content === 'string') {
                        tempDiv.innerHTML = article.content;
                        wordCount = (tempDiv.textContent || "").trim().split(/\s+/).filter(Boolean).length;
                    }
                    return { id: article.id, title: article.title, category: article.category, tags: article.tags || [], readCount: article.readCount || 0, createdAt: article.createdAt, updatedAt: article.updatedAt, wordCount: wordCount || 0 };
                });
                await App.fs.write('_index.json', indexData);
                console.log(`Regenerated _index.json from state with ${indexData.length} articles.`);
            },
            async getDeletedRecords() { return await App.fs.read(this.DELETED_RECORDS_FILENAME) || []; },
            async saveDeletedRecords(records) { await App.fs.write(this.DELETED_RECORDS_FILENAME, records); },
            async recordDeletion(id) {
                const now = new Date().toISOString(); const records = await this.getDeletedRecords();
                if (!records.some(r => r.id === id)) { records.push({ id, deletedAt: now }); }
                await this.saveDeletedRecords(records); App.state.deletedRecords = records;
            },
            async _getAllArticlesFromCurrentStore() {
                if (App.state.storageMode === 'fileSystem' && App.state.directoryHandle) {
                    const { articles } = await this.getAll();
                    return articles;
                } else if (App.state.storageMode === 'browser') {
                    return await App.browserStore.getAllArticles();
                }
                return []; 
            },
            getArticle(id) { return App.state.articles.find(a => a.id === id); },
        },
                
        // ==========================================================================
        // 3.8. DROPBOX SYNC ENGINE
        // ==========================================================================
        dropbox: {
            SINGLETON_DATA_FILES: ['settings.json', 'todos.json', 'pomodoro.json', 'quiz_stats.json', 'tags.json', 'visual-map-state.json', 'mind-map-state.json'],
            async init() {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('code')) {
                    await this.handleRedirect();
                } else if (App.state.dropboxToken) {
                    await this.validateToken();
                }
            },
            async connect() {
                const clientId = App.settings.get('dropboxClientId');
                if (!clientId) { App.ui.showToast("Please set your Dropbox Client ID first.", { type: 'error' }); return; }
                const codeVerifier = this.generateCodeVerifier();
                sessionStorage.setItem('dropbox-code-verifier', codeVerifier);
                const codeChallenge = await this.generateCodeChallenge(codeVerifier);
                const authUrl = new URL('https://www.dropbox.com/oauth2/authorize');
                authUrl.searchParams.set('client_id', clientId);
                authUrl.searchParams.set('response_type', 'code');
               authUrl.searchParams.set('redirect_uri', 'https://notekash.com'); 
                authUrl.searchParams.set('code_challenge_method', 'S256');
                authUrl.searchParams.set('code_challenge', codeChallenge);
                window.location.href = authUrl.toString();
            },
            async handleRedirect() {
                const urlParams = new URLSearchParams(window.location.search);
                const authCode = urlParams.get('code');
                const codeVerifier = sessionStorage.getItem('dropbox-code-verifier');
                const clientId = App.settings.get('dropboxClientId');
                if (!authCode || !codeVerifier || !clientId) return;
                try {
                    const response = await fetch('https://api.dropboxapi.com/oauth2/token', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: new URLSearchParams({
                            code: authCode,
                            grant_type: 'authorization_code',
                            redirect_uri: 'https://notekash.com',
                            code_verifier: codeVerifier,
                            client_id: clientId,
                        })
                    });
                    if (!response.ok) throw new Error('Failed to get token');
                    const data = await response.json();
                    await App.settings.set('dropboxToken', data.access_token);
                    App.state.dropboxToken = data.access_token;
                    await this.validateToken();
                } catch (error) {
                    App.ui.showToast("Dropbox connection failed.", { type: 'error' });
                } finally {
                    window.history.replaceState({}, document.title, window.location.pathname);
                    sessionStorage.removeItem('dropbox-code-verifier');
                    App.ui.showSettingsModal();
                }
            },
            async validateToken() {
                try {
                    const user = await this.apiCall('users/get_current_account', null);
                    App.state.dropboxUser = user;
                    App.state.isDropboxReady = true;
                    App.ui.showToast(`Connected as ${user.name.display_name}.`, { type: 'success' });
                } catch (error) {
                    console.error("Token validation failed:", error);
                    this.disconnect();
                }
            },
            async disconnect() {
                await App.settings.set('dropboxToken', null);
                App.state.dropboxToken = null;
                App.state.dropboxUser = null; 
                App.state.isDropboxReady = false;
                App.ui.showToast("Disconnected from Dropbox.");
            },
            async apiCall(endpoint, body, options = {}) {
                if (!App.state.dropboxToken) { return Promise.reject("Not connected to Dropbox"); }
                const isUploadOrDownload = endpoint.includes('files/upload') || endpoint.includes('files/download');
                const apiUrl = isUploadOrDownload ? `https://content.dropboxapi.com/2/${endpoint}` : `https://api.dropboxapi.com/2/${endpoint}`;
                const headers = { 'Authorization': `Bearer ${App.state.dropboxToken}`, ...options.headers };
                const fetchOptions = { method: 'POST', headers };
                if (!isUploadOrDownload && body) { headers['Content-Type'] = 'application/json'; fetchOptions.body = JSON.stringify(body); }
                else if (isUploadOrDownload) { headers['Content-Type'] = 'application/octet-stream'; fetchOptions.body = body; }
                
                try {
                    const response = await fetch(apiUrl, fetchOptions);
                    if (!response.ok) {
                        if (response.status === 401) { this.disconnect(); App.ui.showToast("Dropbox connection expired.", { type: 'error' }); }
                        const errorJson = await response.json().catch(() => ({}));
                        if (errorJson.error_summary && errorJson.error_summary.includes('insufficient_space')) { App.ui.showToast("Your Dropbox is full.", { type: 'error' }); }
                        throw new Error(`API call failed: ${response.statusText}`);
                    }
                    if (options.isDownload) {
                        const content = await response.text();
                        return { content };
                    }
                    if (response.headers.get('content-length') === '0' || response.status === 204) return null;
                    return response.json();
                } catch (e) {
                     if (e instanceof TypeError) { App.ui.showToast("Network error. Sync paused.", { type: 'warning' }); }
                    throw e;
                }
            },

            async syncChanges(isSilent = false) {
                if (App.state.isSyncing) {
                    if (!isSilent) App.ui.showToast("Sync already in progress.", { type: 'warning' });
                    return;
                }
                if (!this.isReady()) {
                    console.warn("Dropbox sync called but not ready. Aborting.");
                    return;
                }

                App.state.isSyncing = true;
                if (document.getElementById('settings-modal-content')) App.ui.showSettingsModal();
                if (!isSilent) App.ui.showToast("Syncing...", { duration: 0 });

                try {
                    // STEP 1: GET LOCAL DATA (Unchanged for Articles)
                    const localArticles = await App.storage._getAllArticlesFromCurrentStore();
                    const localDeletedRecords = await App.storage.getDeletedRecords();

                    const localArticlesMap = new Map(localArticles.map(a => [a.id, a]));
                    const localDeletedMap = new Map(localDeletedRecords.map(r => [r.id, r]));

                    // STEP 2: GET REMOTE DATA & SEGREGATE
                    const remoteFiles = await this.listAllFiles();
                    let remoteDeletedRecords = [];
                    const remoteArticlesMap = new Map();
                    const remoteSingletonsMap = new Map(); // <-- NEW

                    for (const file of remoteFiles) {
                        const name = file.name;
                        if (name === App.storage.DELETED_RECORDS_FILENAME) {
                            const { content } = await this.apiCall('files/download', null, { headers: { 'Dropbox-API-Arg': JSON.stringify({ path: file.path_lower }) }, isDownload: true });
                            remoteDeletedRecords = content ? JSON.parse(content) : [];
                        } 
                        // NEW: Check if it's a singleton data file
                        else if (this.SINGLETON_DATA_FILES.includes(name)) {
                            remoteSingletonsMap.set(name, file);
                        }
                        // Check for articles
                        else if(name.endsWith('.json') && !name.startsWith('_') && name.startsWith('art_')) {
                            remoteArticlesMap.set(name.replace('.json', ''), file);
                        }
                    }

                    const remoteDeletedMap = new Map(remoteDeletedRecords.map(r => [r.id, r]));

                    // STEP 3: MERGE DELETION RECORDS 
                    const masterDeletedMap = new Map(localDeletedMap);
                    remoteDeletedMap.forEach((remoteRecord, id) => {
                        const localRecord = masterDeletedMap.get(id);
                        if (!localRecord || new Date(remoteRecord.deletedAt) > new Date(localRecord.deletedAt)) {
                            masterDeletedMap.set(id, remoteRecord);
                        }
                    });

                    // STEP 4: COMPARE & BUILD SYNC LISTS
                    const toUploadArticles = [], toDownloadArticles = [], toDeleteLocal = [], toDeleteRemotePaths = [];
                    const toUploadSingletons = [], toDownloadSingletons = []; // <-- NEW
                    const TOLERANCE_MS = 2000; // Dropbox timestamp tolerance

                    // 4a. Compare Articles
                    const allArticleIds = new Set([...localArticlesMap.keys(), ...remoteArticlesMap.keys()]);
                    for (const id of allArticleIds) {
                        if (masterDeletedMap.has(id)) continue; 
                        const local = localArticlesMap.get(id);
                        const remote = remoteArticlesMap.get(id);

                        if (local && !remote) { toUploadArticles.push(local); } 
                        else if (!local && remote) { toDownloadArticles.push(remote); } 
                        else if (local && remote) {
                            const localDate = new Date(local.updatedAt);
                            const remoteDate = new Date(remote.server_modified);
                            if (Math.abs(localDate.getTime() - remoteDate.getTime()) > TOLERANCE_MS) {
                                if (localDate > remoteDate) { toUploadArticles.push(local); } 
                                else { toDownloadArticles.push(remote); }
                            }
                        }
                    }

                    // 4b. Compare Deletion Lists 
                    masterDeletedMap.forEach(record => {
                        if (localArticlesMap.has(record.id)) toDeleteLocal.push(record.id);
                        if (remoteArticlesMap.has(record.id)) toDeleteRemotePaths.push({ path: `/${record.id}.json` });
                    });

                    // 4c. Compare Singleton Data Files (NEW)
                    for (const fileName of this.SINGLETON_DATA_FILES) {
                        const localMeta = await App.fs.getFileMetadata(fileName);
                        const remoteMeta = remoteSingletonsMap.get(fileName);

                        if (localMeta && !remoteMeta) {
                            // Local exists, remote doesn't -> UPLOAD
                            const localData = await App.fs.read(fileName);
                            if (localData) toUploadSingletons.push({ name: fileName, data: localData });
                        } 
                        else if (!localMeta && remoteMeta) {
                            // Remote exists, local doesn't -> DOWNLOAD
                            toDownloadSingletons.push(remoteMeta);
                        } 
                        else if (localMeta && remoteMeta) {
                            // Both exist -> COMPARE TIMESTAMPS
                            const localDate = new Date(localMeta.lastModified);
                            const remoteDate = new Date(remoteMeta.server_modified);

                            if (Math.abs(localDate.getTime() - remoteDate.getTime()) > TOLERANCE_MS) {
                                if (localDate > remoteDate) {
                                    // Local is newer -> UPLOAD
                                    const localData = await App.fs.read(fileName);
                                    if (localData) toUploadSingletons.push({ name: fileName, data: localData });
                                } else {
                                    // Remote is newer -> DOWNLOAD
                                    toDownloadSingletons.push(remoteMeta);
                                }
                            }
                        }
                    }

                    // STEP 5: EXECUTE SYNC OPERATIONS
                    // 5a. Article Uploads
                    const articleUploadPromises = toUploadArticles.map(article => 
                        this.apiCall('files/upload', JSON.stringify(article), { headers: { 'Dropbox-API-Arg': JSON.stringify({ path: `/${article.id}.json`, mode: 'overwrite' }) } })
                    );

                    // 5b. Singleton File Uploads (NEW)
                    const singletonUploadPromises = toUploadSingletons.map(file =>
                        this.apiCall('files/upload', JSON.stringify(file.data), { headers: { 'Dropbox-API-Arg': JSON.stringify({ path: `/${file.name}`, mode: 'overwrite' }) } })
                    );

                    // 5c. Article Downloads
                    const articleDownloadPromises = toDownloadArticles.map(async remoteMeta => {
                        const { content } = await this.downloadFile(remoteMeta);
                        if (content) {
                            const article = JSON.parse(content);
                            if (localArticlesMap.has(article.id)) {
                                await App.storage.updateArticle(article.id, article); 
                            } else {
                                await App.storage.createArticle(article);
                            }
                        }
                    });

                    // 5d. Singleton File Downloads (NEW)
                    const singletonDownloadPromises = toDownloadSingletons.map(async remoteMeta => {
                        const { content } = await this.downloadFile(remoteMeta);
                        if (content) {
                            const data = JSON.parse(content);
                            // App.fs.write will automatically use the right storage (FS or Browser)
                            await App.fs.write(remoteMeta.name, data);
                        }
                    });

                    // Execute all uploads and downloads in parallel
                    await Promise.allSettled([
                        ...articleUploadPromises, ...singletonUploadPromises,
                        ...articleDownloadPromises, ...singletonDownloadPromises
                    ]);

                    // 5e. Remote Deletions 
                    if (toDeleteRemotePaths.length > 0) {
                        await this.apiCall('files/delete_batch', { entries: toDeleteRemotePaths });
                    }

                    // 5f. Local Deletions 
                    for(const id of toDeleteLocal) {
                        await App.storage.deleteArticle(id); 
                    }

                    // 5g. Sync Deleted Records 
                    const finalDeletedRecords = Array.from(masterDeletedMap.values());
                    if (localDeletedMap.size !== finalDeletedRecords.length || remoteDeletedMap.size !== finalDeletedRecords.length) {
                        await App.storage.saveDeletedRecords(finalDeletedRecords);
                        await this.apiCall('files/upload', JSON.stringify(finalDeletedRecords), { headers: { 'Dropbox-API-Arg': JSON.stringify({ path: `/${App.storage.DELETED_RECORDS_FILENAME}`, mode: 'overwrite' }) } });
                    }

                    // STEP 6: FINALIZE & RELOAD UI
                    const articleChanges = toUploadArticles.length + toDownloadArticles.length + toDeleteLocal.length > 0;
                    const singletonChanges = toUploadSingletons.length + toDownloadSingletons.length > 0;

                    if (articleChanges) {
                        // Re-sort in-memory state and refresh library
                        App.state.articles.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                        await App.util.reconcileCategories(); // Re-check categories

                        const activeView = App.router.getActiveView();
                        if (activeView === 'library' || activeView === 'flashcard' || activeView === 'stats-dashboard' || activeView === 'visual-map' || activeView === 'mindmap' || activeView === 'category') {
                            App.router.navigateTo(activeView, App.router.getActiveViewData(), true);
                        }
                    }

                    if (singletonChanges) {
                        // A data file changed, which requires a soft-reload of state.
                        App.ui.showToast('App data (settings, tasks) synced. Reload recommended.', { type: 'info', duration: 10000 });
                    }

                    if (articleChanges || singletonChanges) {
                        if (!isSilent) App.ui.showToast('Sync Complete!', { type: 'success' }); 
                    } else if (!isSilent) {
                        App.ui.showToast("Everything is up to date.", { type: 'success' });
                    }

                    await App.settings.set('lastSyncTimestamp', new Date().toISOString());

                } catch (error) {
                    console.error("Sync Error:", error);
                    if (!isSilent) App.ui.showToast(`Sync failed: ${error.message}`, { type: 'error' });
                } finally {
                    App.state.isSyncing = false;
                    if (document.getElementById('settings-modal-content')) App.ui.showSettingsModal();
                }
            },

            async downloadFile(remoteMeta) {
                return await this.apiCall('files/download', null, { headers: { 'Dropbox-API-Arg': JSON.stringify({ path: remoteMeta.path_lower }) }, isDownload: true });
            },
            async listAllFiles() {
                if (!this.isReady()) return [];
                try {
                    let result = await this.apiCall('files/list_folder', { path: '' });
                    const allFiles = [...result.entries];
                    while (result.has_more) {
                        result = await this.apiCall('files/list_folder/continue', { cursor: result.cursor });
                        allFiles.push(...result.entries);
                    }
                    return allFiles.filter(f => f['.tag'] === 'file');
                } catch (err) {
                    if (err.message && err.message.includes("path/not_found")) return [];
                    else throw err;
                }
            },
            generateCodeVerifier() { const c='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01236789-._~';let r='';const v=new Uint8Array(128);crypto.getRandomValues(v);for(let i=0;i<v.length;i++)r+=c[v[i]%c.length];return r; },
            async generateCodeChallenge(v) { const d=new TextEncoder().encode(v);const h=await crypto.subtle.digest('SHA-256',d);return btoa(String.fromCharCode.apply(null,new Uint8Array(h))).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); },
            isReady: () => App.state.isDropboxReady,
        },
        
        // ==========================================================================
        // 3.9. ROUTER
        // ==========================================================================
        router: {
            navigateTo(viewId, data = null, isPopState = false) {
                
                document.getElementById('welcome-view')?.classList.remove('fading-out');
                document.body.classList.remove('canvas-focus-mode', 'mobile-header-expanded');

                // Manage browser history for a functional back button.
                if (!isPopState) {
                    const currentState = history.state || {};
                    // Prevent pushing the same page onto the history stack twice.
                    if (currentState.viewId !== viewId || JSON.stringify(currentState.data) !== JSON.stringify(data)) {
                        const url = `#${viewId}`;
                        history.pushState({ viewId, data }, '', url);
                    }
                }

                App.state.libraryRender.isRendering = false;
                clearTimeout(App.state.libraryRender.searchTimeout);
                App.events.unmountViewListeners();
                
                // --- NEW CO-PILOT LOGIC ---
                const coPilotViews = ['category', 'visual-map', 'mindmap'];
                const coPilotToggle = document.getElementById('kash-copilot-toggle');
                if (coPilotToggle) {
                    coPilotToggle.style.display = coPilotViews.includes(viewId) ? 'flex' : 'none';
                }
                if (App.coPilot.state.isOpen) {
                    App.coPilot.toggle(); // Automatically close the sidebar when navigating away
                }

                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                const view = document.getElementById(`${viewId}-view`);

                const mainEl = document.querySelector('main');
                const root = document.documentElement;
                const body = document.body;

                const isMap = viewId === 'visual-map' || viewId === 'mindmap';
                if (isMap) {
                    mainEl.style.height = '100vh';
                    mainEl.style.overflow = 'hidden';
                    root.style.overflow = 'hidden';
                    body.style.overflow = 'hidden';
                } else {
                    mainEl.style.height = '';
                    mainEl.style.overflow = '';
                    root.style.overflow = '';
                    body.style.overflow = '';
                }

                if (view) {
                    App.ui.renderView(viewId, data, view);
                    view.classList.add('active');
                }

                const articleControls = document.getElementById('article-controls');
                if (articleControls) {
                    articleControls.style.display = viewId === 'article' ? 'flex' : 'none';
                }

                if (viewId !== 'article') {
                    App.ui.updateTheLine(1);
                }

                App.ui.updateHeaderState();
                App.events.mountViewListeners(viewId);
            },
            getActiveView: () => document.querySelector('.view.active')?.id.replace('-view', ''),
        },

 


        // ==========================================================================
        // 3.10. UI RENDERING
        // ==========================================================================
        ui: {
           
            async renderView(viewId, data, view) {
                // First, handle special cases like maps that have a unique setup.
                if (viewId === 'visual-map' || viewId === 'mindmap') {
                    if (!view.hasChildNodes()) {
                        const mapType = viewId.split('-')[0];
                        const controlsId = `${mapType}-map-controls`;
                        const containerId = `${mapType}-map-container`;
                        const focusLineId = `${mapType === 'visual' ? 'vm' : 'mm'}-focus-line`;
                        const controlsPlaceholder = document.createElement('div');
                        controlsPlaceholder.id = controlsId;
                        const focusLinePlaceholder = document.createElement('div');
                        focusLinePlaceholder.id = focusLineId;
                        focusLinePlaceholder.className = 'canvas-focus-line';
                        focusLinePlaceholder.title = 'Toggle Focus Mode (Esc)';
                        const containerPlaceholder = document.createElement('div');
                        containerPlaceholder.id = containerId;
                        containerPlaceholder.tabIndex = 0;
                        view.appendChild(controlsPlaceholder);
                        view.appendChild(focusLinePlaceholder);
                        view.appendChild(containerPlaceholder);
                    }

                    if (viewId === 'visual-map') setTimeout(() => App.visualMap.init(), 50);
                    if (viewId === 'mindmap') setTimeout(() => App.mindMap.init(), 50);
                    return; 
                }

                // For all other views, proceed with the original, fast rendering logic.
                view.innerHTML = ''; // Clear the view first

                switch (viewId) {
                    case 'welcome': this.renderWelcomeView(view, data); break;
                    case 'library': this.renderLibraryView(view); break;
                    case 'article': await this.renderArticleView(view, data); break;
                    case 'category': this.renderCategoryView(view, data); break;
                    case 'tags': this.renderTagsView(view); break;
                    case 'flashcard': this.renderFlashcardView(view, data); break;
                    case 'stats-dashboard': this.renderStatsDashboardView(view, data); break;
                }
            },

            renderWelcomeView(container, data) {
                const { permissionState } = data || {};

                // RATIONALE: All icon definitions are moved here for consistency and easy access.
                const folderIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"></path></svg>`;
                const browserIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>`;
                const resumeIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"/><path d="m19 9-5 5-4-4-3 3"/></svg>`;

                const headerHTML = `
                    <div class="welcome-hero">
                        <h1 class="library-title">Note Kash</h1>
                        <p id="welcome-subtitle"></p>
                    </div>`;

                let choicesHTML = '';

                if (permissionState === 'prompt') {
                    // RATIONALE: Replaced the 2-column grid with a single-column flex container. This ensures the single "Resume" card is always perfectly centered on the screen, fixing the alignment issue.
                    choicesHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 1.5rem; margin-top: 3rem;">
                            <div class="welcome-card recommended" onclick="App.events.requestStoredPermission()" style="width: 100%; max-width: 420px;">
                                <div class="welcome-card-header">
                                    <div class="card-icon">${resumeIcon}</div>
                                    <h3 class="card-title">Resume Session</h3>
                                </div>
                                <p class="card-description">Grant access to your previously selected folder to continue where you left off.</p>
                            </div>
                            <div class="welcome-prompt-alternatives">
                                <a href="#" onclick="event.preventDefault(); App.events.selectDirectory(true)">Choose a New Folder</a>
                                <span>&bull;</span>
                                <a href="#" onclick="event.preventDefault(); App.events.useBrowserStorage()">Use Browser Instead</a>
                            </div>
                        </div>`;
                } else {
                    const isFPIsupported = 'showDirectoryPicker' in window;
                    const folderCardClass = isFPIsupported ? 'recommended' : 'disabled';
                    const folderCardTitle = isFPIsupported ? 'Best for privacy & data ownership.' : 'Your browser does not support this feature.';
                    const folderCardOnClick = isFPIsupported ? `App.events.selectDirectory()` : '';

                    choicesHTML = `
                        <div class="welcome-choices">
                            <div class="welcome-card ${folderCardClass}" onclick="${folderCardOnClick}" title="${folderCardTitle}">
                                <div class="welcome-card-header">
                                    <div class="card-icon">${folderIcon}</div>
                                    <h3 class="card-title">On My Device</h3>
                                </div>
                                <p class="card-description">Store notes privately on your device. Ideal for privacy, reliability & ownership.</p>
                            </div>
                            <div class="welcome-card" onclick="App.events.useBrowserStorage()" title="Easiest setup, works on all browsers.">
                                <div class="welcome-card-header">
                                    <div class="card-icon">${browserIcon}</div>
                                    <h3 class="card-title">In the Browser</h3>
                                </div>
                                <p class="card-description">Store notes inside your browser's database. No folder setup required.</p>
                            </div>
                        </div>`;
                }
                container.innerHTML = `<div class="welcome-container">${headerHTML}${choicesHTML}</div>`;

                const subtitleEl = document.getElementById('welcome-subtitle');
                if (subtitleEl) {
                    App.util.typewriter(subtitleEl, "Unleash the Power of Your Second Brain...", 65); // Speed up from 45ms to 40ms

                }

                if (permissionState === 'denied') {
                    container.querySelector('.welcome-hero p').insertAdjacentHTML('afterend', 
                        `<p style="color:var(--danger-color); font-weight: 500; margin-top: -0.5rem; margin-bottom: 1.5rem;">Access was denied. Please select a folder again or use the alternatives below.</p>`
                    );
                }
            },

            renderLibraryView(container) {
                const mainCategories = [
                    { name: 'Tags', action: 'tags', data: '' },
                    { name: 'Flashcards', action: 'flashcard', data: '' }
                ];

                const userCategoryObjects = App.settings.get('userCategories');
                const otherCategories = userCategoryObjects.map(catObj => ({
                    name: catObj.name,
                    colorIndex: catObj.colorIndex,
                    action: 'category',
                    data: `'${catObj.name}'`
                }));

                const nameStyle = App.settings.get('categoryNameStyle') || 'full';

                // --- NEW: Theme-aware icon selection logic ---
                const currentTheme = App.settings.get('theme');
                const customBase = App.settings.get('customThemeBase');
                let toggleIcon;

                switch (currentTheme) {
                    case 'sepia':
                        toggleIcon = 'ðŸŸ¤';
                        break;
                    case 'dark':
                        toggleIcon = 'ðŸŸ ';
                        break;
                    case 'custom':
                        // Use specific icons based on the custom theme's base
                        toggleIcon = (customBase === 'dark') ? 'ðŸŸ ' : 'ðŸŸ¢';
                        break;
                    case 'light':
                    default:
                        toggleIcon = 'ðŸŸ¢';
                        break;
                }

                const toggleButtonHTML = `
                    <button class="category-chip category-action-btn" id="category-name-toggle" title="Toggle Category Name Length" onclick="App.events.toggleCategoryNameStyle()">
                        ${toggleIcon}
                    </button>
                `;

                const allCategoryButtons = [...mainCategories, ...otherCategories];
                const libraryTitle = App.util.escapeHtml(App.settings.get('libraryTitle') || 'My Library');

                container.innerHTML = `
                    <div class="library-main">
                        <div class="library-header">
                            <a href="https://studyrecapped.com/general/the-official-notekash-guide-art-of-building-a-second-brain/" target="_blank" rel="noopener noreferrer"><h1 class="library-title">${libraryTitle}</h1></a>
                        </div>
                        <div class="search-and-filter-bar">
                            <div class="search-bar-container">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>
                                <input type="text" id="search-input" placeholder="Search by titles, snippets, '*category', read count e.g *law, 0 (unread)" aria-label="Search articles">
                            </div>
                            <select id="sort-filter" class="btn btn-secondary" aria-label="Sort articles by">
                                <option value="updatedAt">Sort by Newest</option>
                                <option value="createdAt">Sort by Oldest</option>
                                <option value="title">Sort by Title</option>
                                <option value="unread">Sort by Unread</option>
                                <option value="read">Sort by Read</option>
                                <option value="random">Sort by Random</option>
                            </select>
                        </div>
                        <div class="category-filters">
                            ${toggleButtonHTML}
                            ${allCategoryButtons.map(cat => {
                             
                                let className, style = '', buttonText, titleText;
                                titleText = (cat.name === 'Tags' || cat.name === 'Flashcards') ? cat.name : App.util.getCategoryDisplayName(cat.name);

                                if (cat.name === 'Tags') {
                                    className = 'category-chip category-action-btn action-secondary';
                                    buttonText = 'Tags';
                                } else if (cat.name === 'Flashcards') {
                                    className = 'category-chip category-action-btn action-primary';
                                    buttonText = 'Flash';
                                } else {
                                    className = 'category-chip';
                                    const backgroundColor = `var(--cat-color-${cat.colorIndex}-bg)`;
                                    const textColor = `var(--category-pill-text)`;
                                    style = `style="background-color: ${backgroundColor}; color: ${textColor};"`;
                                    buttonText = (nameStyle === 'full') ? titleText : titleText.substring(0, 4);
                                }

                                return `<button class="${className}" ${style} onclick="App.router.navigateTo('${cat.action}', ${cat.data})" title="${titleText}">${buttonText}</button>`;
                            }).join('')}

                            <button class="category-chip category-action-btn action-primary" onclick="App.router.navigateTo('category', 'All')">All</button>
                            
                        </div>
                        <hr style="width:100%; border-color: var(--border-color); margin: 0;">
                        <div id="article-grid-container">
                            <div class="article-grid" id="article-grid">
                                <div class="empty-state" style="grid-column: 1 / -1;"><div class="spin">${App.util.icons.cycle}</div><h3>Loading Library...</h3></div>
                            </div>
                        </div>
                    </div>`;

                setTimeout(() => App.ui.filterAndRenderArticles(), 50);
            },

           filterAndRenderArticles() {
                const grid = document.getElementById('article-grid');
                if (!grid) return;

                const searchTerm = document.getElementById('search-input')?.value || '';
                let articlesToDisplay = [...App.state.articles];
                let currentSearchTerm = searchTerm.trim();

                const sortBy = App.settings.get('librarySortBy') || 'updatedAt';
                switch (sortBy) {
                    case 'createdAt':
                        articlesToDisplay.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
                        break;
                    case 'title':
                        articlesToDisplay.sort((a, b) => a.title.localeCompare(b.title));
                        break;
                    case 'unread':
                        articlesToDisplay.sort((a, b) => (a.readCount || 0) - (b.readCount || 0));
                        break;
                    case 'read':
                        articlesToDisplay.sort((a, b) => (b.readCount || 0) - (a.readCount || 0));
                        break;
                    case 'random':
                        articlesToDisplay.sort(() => Math.random() - 0.5);
                        break;
                    case 'updatedAt':
                    default:
                        articlesToDisplay.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                        break;
                }

                const readCountMatch = currentSearchTerm.match(/^(\d+)\s*(.*)/);
                let readCountFilter = null;
                if (readCountMatch) {
                    readCountFilter = parseInt(readCountMatch[1], 10);
                    currentSearchTerm = readCountMatch[2].trim();
                    if (readCountFilter === 0) {
                        articlesToDisplay = articlesToDisplay.filter(a => !a.readCount || a.readCount === 0);
                    } else {
                        articlesToDisplay = articlesToDisplay.filter(a => a.readCount === readCountFilter);
                    }
                }

                const categoryMatch = currentSearchTerm.match(/^\*(\w*)\s*/);
                if (categoryMatch) {
                    const prefix = categoryMatch[1].toLowerCase();
                    const userCategories = App.settings.get('userCategories'); // Get the category objects

                    if (prefix && userCategories) { // Add a check for userCategories
                        const matchingCategoryNames = userCategories
                            .filter(catObj => // Filter the objects directly
                                catObj.name.toLowerCase().startsWith(prefix) ||
                                (App.util.getCategoryDisplayName(catObj.name) || '').toLowerCase().startsWith(prefix)
                            )
                            .map(catObj => catObj.name); // Then get the names

                        const matchingCategorySet = new Set(matchingCategoryNames);
                        if (matchingCategorySet.size > 0) {
                            articlesToDisplay = articlesToDisplay.filter(a => matchingCategorySet.has(a.category));
                        }
                    }
                    currentSearchTerm = currentSearchTerm.replace(/^\*(\w*)\s*/, '').trim();
                }

                if (currentSearchTerm) {
                    const searchableData = articlesToDisplay.map(article => ({
                        id: article.id,
                        title: article.title,
                        tags: (article.tags || []).join(' '),
                        snippets: App.util.extractSnippets(article, 'highlight').map(s => s.text)
                    }));

                    const fuse = new Fuse(searchableData, {
                        keys: [{ name: 'title', weight: 0.6 }, { name: 'tags', weight: 0.3 }, { name: 'snippets', weight: 0.1 }],
                        includeScore: true, threshold: 0.4
                    });
                    const results = fuse.search(currentSearchTerm);
                    const filteredIds = new Set(results.map(r => r.item.id));
                    articlesToDisplay = articlesToDisplay.filter(a => filteredIds.has(a.id));
                }

                let finalHTML = '';

                if (!App.license.isPremium()) {
                    const articlesUsed = App.state.articles.length;
                    const articleLimit = App.config.sparkTierLimit;
                    const percentageUsed = Math.min(100, Math.round((articlesUsed / articleLimit) * 100));

                    finalHTML += `
                        <div class="article-card library-premium-card" onclick="App.router.navigateTo('article', { articleObject: DUMMY_TUTORIAL_ARTICLE, mode: 'read' })" title="A message from the developer...">
                            <div class="card-category-badge premium-badge">âœ¨ Spark Tier</div>
                            <h3 class="card-title">You've used ${percentageUsed}% Quota (${articlesUsed} of ${articleLimit} notes)</h3>
                            <div class="card-footer premium-card-footer">
                                <div class="premium-progress-bar">
                                    <div class="premium-progress" style="width: ${percentageUsed}%;"></div>
                                </div>
                                <span class="premium-cta-text">Click to see what's possible â†’</span>
                            </div>
                        </div>`;
                }

                if (articlesToDisplay.length > 0) {
                    finalHTML += articlesToDisplay.map(article => this.getArticleCardHTML(article)).join('');
                } 
                else {
                    if (App.state.articles.length === 0) {
                        finalHTML += `<div class="empty-state" style="grid-column: 1 / -1;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><path d="M12 2a10 10 0 1 0 10 10"/><path d="M12 18a6 6 0 1 0 0-12 6 6 0 0 0 0 12z"/><path d="M12 12a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></svg>
                            <h3>Your Second Brain Awaits!</h3>
                            <p>Click the <strong>+</strong> button in the top right to create your first note.</p>
                        </div>`;
                    } else {
                        finalHTML += `<div class="empty-state" style="grid-column: 1 / -1;"><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg><h3>Ouch, No Results Found</h3><p>Try a different title, tag, or filter combination.</p></div>`;
                    }
                }
                grid.innerHTML = finalHTML;

                const visibleCards = Array.from(grid.querySelectorAll('.article-card:not(.library-premium-card)'));
                const shouldHighlight = !!currentSearchTerm || readCountFilter !== null || !!categoryMatch;
                visibleCards.forEach(card => card.classList.toggle('search-highlight-card', shouldHighlight));
                document.querySelectorAll('.search-selected-card').forEach(c => c.classList.remove('search-selected-card'));
                App.state.libraryRender.searchResults = visibleCards;
                App.state.libraryRender.selectedIndex = -1;
                if (shouldHighlight && visibleCards.length > 0) {
                    App.state.libraryRender.selectedIndex = 0;
                    visibleCards[0].classList.add('search-selected-card');
                    if(document.activeElement.id === 'sort-filter') {
                        visibleCards[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            },
            
            async startLibraryRender() {
                const grid = document.getElementById('article-grid');
                if (!grid) return;

                App.state.libraryRender.isRendering = true;
                App.state.libraryRender.currentIndex = 0;
                grid.innerHTML = '';
                window.scrollTo(0, 0);

                if (App.state.libraryRender.filteredArticles.length === 0) {
                    let emptyMessage = `<div class="empty-state" style="grid-column: 1 / -1;"><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg><h3>No Articles Found</h3><p>Try adjusting your search or create a new article.</p></div>`;
                    if (!App.state.directoryHandle) {
                        emptyMessage = `<div class="empty-state" style="grid-column:1/-1; text-align:center; padding: 4rem 1rem;"><p>Please select a folder to begin.</p></div>`
                    }
                    grid.innerHTML = emptyMessage;
                    App.state.libraryRender.isRendering = false;
                    return;
                }
                
                const fillViewport = async () => {
                    if (!App.state.libraryRender.isRendering) return;
                    let hasSpace = document.documentElement.scrollHeight <= document.documentElement.clientHeight;
                    while (hasSpace && App.state.libraryRender.currentIndex < App.state.libraryRender.filteredArticles.length) {
                        this.renderArticleBatch(15);
                        await new Promise(resolve => setTimeout(resolve, 50));
                        hasSpace = document.documentElement.scrollHeight <= document.documentElement.clientHeight;
                    }
                };
                
                await fillViewport();

                const renderRestInBackground = () => {
                    if (!App.state.libraryRender.isRendering || App.state.libraryRender.currentIndex >= App.state.libraryRender.filteredArticles.length) {
                        App.state.libraryRender.isRendering = false;
                        return;
                    }
                    this.renderArticleBatch(20);
                    requestIdleCallback(renderRestInBackground);
                };

                requestIdleCallback(renderRestInBackground);
            },


            renderArticleBatch(count) {
                const grid = document.getElementById('article-grid');
                if (!grid) return;

                const { filteredArticles, currentIndex } = App.state.libraryRender;
                const endIndex = Math.min(currentIndex + count, filteredArticles.length);
                
                let articlesHTML = '';
                for (let i = currentIndex; i < endIndex; i++) {
                    articlesHTML += this.getArticleCardHTML(filteredArticles[i]);
                }
                
                grid.insertAdjacentHTML('beforeend', articlesHTML);
                App.state.libraryRender.currentIndex = endIndex;
            },

            getArticleCardHTML(article) {
                // Find the category object to get its colorIndex
                const categoryObj = App.settings.get('userCategories').find(c => c.name === article.category) || { name: article.category, colorIndex: 0 };
                const backgroundColor = App.util.getCategoryColor(categoryObj.colorIndex);

                const readCount = article.readCount || 0;
                const progressColorVar = `var(${App.util.getReadProgressColorVar(readCount)})`;
                const borderStyle = `border-left-color: ${progressColorVar};`;
                
                const heartTitle = `Read ${readCount} time(s)`;
                let heartSVG;
                if (readCount === 0) {
                    heartSVG = `<svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z" fill="${progressColorVar}"/></svg>`;
                } else {
                    const masteryGlow = readCount >= 10 ? `filter: drop-shadow(0 0 5px ${progressColorVar});` : '';
                    heartSVG = `<svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" width="20" style="${masteryGlow}"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" fill="${progressColorVar}"/></svg>`;
                }

                const readCountBadgeHTML = `<div title="${heartTitle}" style="display: flex; align-items: center; justify-content: center; height: 24px; width: 24px;">${heartSVG}</div>`;
                const wordCountHTML = `<span class="card-word-count">${article.wordCount || 0} words</span>`;
                const date = new Date(article.updatedAt);
                const dateHTML = `<span class="card-date">${date.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' })}</span>`;
                
                // UPDATED: Note the inline style for background-color and removal of data-category
                return `<div class="article-card ui-card" tabindex="0" data-id="${article.id}" style="${borderStyle}" onclick="App.router.navigateTo('article', {id: '${article.id}', mode: 'read'})" onkeydown="if(event.key === 'Enter') this.click()">
                    <div class="card-header-info">
                        <div class="card-category-badge category-pill" style="background-color: ${backgroundColor};">${App.util.getCategoryDisplayName(categoryObj.name)}</div>
                        ${readCountBadgeHTML}
                    </div>
                    <h3 class="card-title">${article.title}</h3>
                    <div class="card-footer">${wordCountHTML}${dateHTML}</div>
                </div>`;
            },

        showAscensionModal() {
            const wittyMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
            const maybeLaterText = App.util.getRandomMessage(App.util.maybeLaterMessages);

            // --- FIX: "isCurrent" is now determined dynamically by checking the user's license state ---
            const badgeTiers = [
                { name: 'Spark', duration: 'Free Tier', isCurrent: App.license.state.tier === 'Spark' },
                { name: 'Bronze', duration: '3 Months', isCurrent: App.license.state.tier === 'Bronze' },
                { name: 'Silver', duration: '6 Months', isCurrent: App.license.state.tier === 'Silver' },
                { name: 'Gold', duration: '1 Year', isCurrent: App.license.state.tier === 'Gold' },
                { name: 'Diamond', duration: 'Lifetime', isCurrent: App.license.state.tier === 'Diamond' }
            ];

            const badgesHTML = badgeTiers.map(tier => `
                <div class="ascension-card ${tier.isCurrent ? 'is-current-tier' : ''}" 
                    style="border-radius: 24px; min-width: 160px;"
                    onclick="${tier.isCurrent ? '' : `App.ui.closeModal(); App.ui.showLicenseModal();`}">

                    ${App.util.getTierBadgeHTML(tier.name)}
                    <span class="ascension-card-name">${tier.name}</span>
                    <span class="ascension-card-duration">${tier.duration}</span>
                </div>
            `).join('');

            const mailtoLink = 'mailto:learningmarvel@gmail.com';

            const modalHTML = `
                <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                    <div class="modal-content ui-card ascension-modal" onclick="event.stopPropagation()">
                        <div id="ascension-witty-message" class="witty-gradient-text" style="font-size: 1.8rem; margin-bottom: 1rem;">${wittyMessage}</div>
                        <h4 class="witty-gradient-text" style="font-size: 1.2rem;">Choose Your Ascension</h4>
                        <div class="ascension-grid">${badgesHTML}</div>
                        <div class="ascension-features">
                            <h5>Unlock Your Full Potential:</h5>
                            <ul>
                                <li>${App.util.icons.saveAndRead} Unlimited Notes & Flashcards & Quiz</li>
                                <li>${App.util.icons.saveAndRead} Unlock all Advanced Pro Commands</li>
                                <li>${App.util.icons.saveAndRead} Unlimited Search Results & Power Search</li>
                                <li>${App.util.icons.saveAndRead} Unlimited MindMaps & VisualMaps </li>
                                <li>${App.util.icons.saveAndRead} Unlimited access to NoteKash AI</li>
                                <li>${App.util.icons.saveAndRead} Unlimited AI Audio Transcription </li>
                                <li>${App.util.icons.saveAndRead} Unlock Automatic Cloud Sync</li>
                                <li>${App.util.icons.saveAndRead} Unlock All Export Options (PDF,TSV ...)</li>
                                <li>${App.util.icons.saveAndRead} Customize your Fonts & Themes</li>
                                <li>${App.util.icons.saveAndRead} Remove Adverts & Join our Elite Group </li>
                                <li>${App.util.icons.saveAndRead} Get cool Premium Badge & Templates</li>
                                <li>${App.util.icons.saveAndRead} Get promised access to All Future Features...</li>
                            </ul>
                        </div>
                        <div class="ascension-footer">
                            <a href="${mailtoLink}">Prefer to Donate or Get a Discount? Contact me directly.</a>
                        </div>
                        <div class="modal-buttons" style="margin-top: 1.5rem;">
                            <button class="ascension-footer-button witty-gradient-text" onclick="App.ui.closeModal()">${maybeLaterText}</button>
                        </div>
                    </div>
                </div>`;
            document.getElementById('modal-container').innerHTML = modalHTML;
            const savedKey = App.settings.get('openRouterKey');
            const savedModel = App.settings.get('openRouterModel');
            if (savedKey) document.getElementById('openrouter-key-input').value = savedKey;
            if (savedModel) document.getElementById('openrouter-model-select').value = savedModel;
        },

        closeAscensionModal() {
            const modal = document.getElementById('ascension-modal-backdrop');
            if (modal) modal.style.display = 'none';
        },
        
        async renderArticleView(container, data) {
            const { id, mode, articleObject, scrollToSnippetId, overrideContent, restoredScrollTop, isPreviewing } = data; // Added isPreviewing
            let article = articleObject ? articleObject : App.storage.getArticle(id);

            if (!article) { App.router.navigateTo('library'); return; }

            // ... (keep the existing content loading logic here) ...
            if (article.content === undefined && !articleObject && !overrideContent) {
                const fullArticleData = await App.fs.read(`${article.id}.json`);
                if (fullArticleData) {
                    Object.assign(article, fullArticleData);
                } else {
                    App.ui.showToast(`Error: Could not load article content for ${article.title}.`, 'error');
                    App.router.navigateTo('library');
                    return;
                }
            }


            App.state.activeArticleId = article.id;
            App.state.currentMode = mode;
            document.body.classList.remove('read-mode', 'write-mode');
            document.body.classList.add(`${mode}-mode`);
            if (App.settings.get('theme') === 'custom') { document.body.classList.add('image-theme-active'); }
            App.ui.applyFontSettings();

            const finalContent = overrideContent ?? article.content;

            container.innerHTML = `<div class="article-view-wrapper">
                <div class="article-container ui-card">
                    <div class="article-tags-display"></div>
                    <input type="text" class="article-title-input" value="${App.util.escapeHtml(article.title)}" id="article-title" readonly>
                    <div class="article-metadata-bar">
                        <span id="word-count-display"></span>
                        <span id="creation-date-display"></span>
                    </div>
                    <hr class="title-divider">
                    <div id="article-content" spellcheck="false" data-placeholder="Start writing here..."></div>
                </div>
            </div>`;
            
            // --- FIX: Apply the preview class if we are in a preview state ---
            if (isPreviewing) {
                const articleContainer = container.querySelector('.article-container');
                if (articleContainer) {
                    articleContainer.classList.add('is-in-preview-mode');
                }
            }

            // ... (The rest of the function remains identical) ...
            this.updateArticleMetadata(finalContent, article.createdAt);
            this.renderArticleControls(article);
            this.updateArticleViewForMode({ ...article, content: finalContent });

            if (typeof restoredScrollTop === 'number') {
                setTimeout(() => {
                    const mainEl = document.querySelector('main');
                    if (mainEl) mainEl.scrollTop = restoredScrollTop;
                }, 50);
            }

            if (scrollToSnippetId) {
                setTimeout(() => {
                    let targetElement = document.getElementById(scrollToSnippetId);
                    // NEW: Check if it's a PDF pill
                    if (!targetElement && scrollToSnippetId.startsWith('pdf_')) {
                        targetElement = document.querySelector(`.pdf-attachment-pill[data-pdf-id="${scrollToSnippetId}"]`);
                    }
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        targetElement.style.transition = 'background-color 0.5s, box-shadow 0.5s, border-color 0.5s';
                        targetElement.style.boxShadow = `0 0 15px 5px var(--hl-1-border)`;
                        targetElement.style.borderColor = 'var(--hl-1-border)'; // For PDF pills
                        setTimeout(() => { targetElement.style.boxShadow = ''; targetElement.style.borderColor = ''; }, 2500);
                    }
                }, 100);
            }

            setTimeout(() => App.events.updateReadingProgress(), 100);
            const contentDiv = document.getElementById('article-content');
            if (contentDiv) {
                contentDiv.querySelectorAll('canvas[data-chart-config]').forEach(canvas => {
                    App.ui.renderChartOnCanvas(canvas);
                });
            }

            const wrapper = container.querySelector('.article-view-wrapper');
            const controls = document.getElementById('article-controls');
            if (wrapper && controls) {
                wrapper.appendChild(controls);
            }
            this.applyReaderTheme();

        },


        updateArticleMetadata(content = '', createdAt = '') {
            const wordCountEl = document.getElementById('word-count-display');
            const dateEl = document.getElementById('creation-date-display');

            if (wordCountEl) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                const text = tempDiv.textContent || tempDiv.innerText || "";
                const words = text.trim().split(/\s+/).filter(Boolean).length;
                wordCountEl.textContent = `${words} words`;
            }

            if (dateEl && createdAt) {
                const date = new Date(createdAt);
                const options = { year: 'numeric', month: 'long', day: 'numeric' };
                dateEl.textContent = `Created on ${date.toLocaleDateString(undefined, options)}`;
            }
        },
        
        updateArticleViewForMode(article) {
            const titleInput = document.getElementById('article-title');
            const contentDiv = document.getElementById('article-content');
            const tagsContainer = document.querySelector('.article-tags-display');
            const isWriteMode = App.state.currentMode === 'write';

            titleInput.readOnly = !isWriteMode;
            contentDiv.contentEditable = isWriteMode;

            if (isWriteMode) {
                contentDiv.innerHTML = article.content;
                const isEffectivelyEmpty = article.content.trim() === '' || article.content.trim() === '<p><br></p>';
                contentDiv.classList.toggle('is-empty', isEffectivelyEmpty);
                contentDiv.setAttribute('data-placeholder', "Start writing... Use [[tags]] for Visual Map, ==highlights== for Mind Map, or {{c1::cloze}} for flashcards.");

                // RATIONALE (WRITE MODE): A short timeout is necessary here. The browser needs a moment
                // to parse the raw HTML inside a contenteditable element before we can attach listeners.
                setTimeout(() => App.audio.initializePlayersIn(contentDiv), 50);

            } else {
                let parsedContent = App.util.parseShortcuts(article.content);
                let finalContent = App.util.renderClozeForDisplay(parsedContent);
                finalContent = finalContent.replaceAll(' contenteditable="true"', '');
                finalContent = finalContent.replaceAll(" contenteditable='true'", '');
                // If the article has attachments, verify and render them
                if (article.attachments) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = finalContent;
                    tempDiv.querySelectorAll('.pdf-attachment-pill[data-pdf-id]').forEach(pill => {
                        const attachment = article.attachments.find(a => a.id === pill.dataset.pdfId);
                        if (!attachment) {
                            pill.outerHTML = '[Invalid PDF Attachment]';
                        }
                    });
                    finalContent = tempDiv.innerHTML;
                }

                contentDiv.innerHTML = App.util.sanitizeHTML(finalContent);

                contentDiv.querySelectorAll('.nk-accordion').forEach(accordion => {
                    const hintEditor = accordion.querySelector('.nk-accordion-hint-editor');
                    if (hintEditor && (hintEditor.textContent.trim() || hintEditor.querySelector('.nk-accordion-hint-content')?.innerHTML.trim())) {
                        const hintBtn = accordion.querySelector('.nk-accordion-hint-btn');
                        if (hintBtn) hintBtn.style.display = 'flex';
                        hintEditor.style.display = 'none';
                    }
                });

                App.contentTools.autoSuggestTags(contentDiv);

                App.audio.initializePlayersIn(contentDiv);
            }

            const categoryObj = App.settings.get('userCategories').find(c => c.name === article.category) || { name: article.category, colorIndex: 0 };
            const categoryPillHTML = `<span class="category-pill" style="background-color: ${App.util.getCategoryColor(categoryObj.colorIndex)}; cursor: pointer;" onclick="App.router.navigateTo('category', '${article.category}')">${App.util.getCategoryDisplayName(categoryObj.name)}</span>`;

            const tagsHTML = (article.tags || []).map(tag => `<span class="tag-item" onclick="App.events.showTagModal('${tag}')">${App.state.tags[tag]?.displayName || tag}</span>`).join('');

            tagsContainer.innerHTML = isWriteMode ? tagsHTML : categoryPillHTML + tagsHTML;
        },

    
        renderArticleControls(article) {
            const controlsContainer = document.getElementById('article-controls');
            if (!controlsContainer) return;

            if (article.isDummy) {
                controlsContainer.innerHTML = `
                    <div class="controls-wrapper" style="display: flex; justify-content: center; gap: 1rem;">
                        <button class="btn btn-primary btn-gradient-text tutorial-btn" style="font-weight: 700; border: 2px solid transparent; border-radius: var(--border-radius-lg); background-image: linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488), linear-gradient(var(--bg-secondary), var(--bg-secondary)), linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488); background-origin: border-box; background-clip: text, padding-box, border-box;" onclick="window.open('https://studyrecapped.com/general/the-official-notekash-guide-art-of-building-a-second-brain/', '_blank')">
                            ðŸ“š Tutorial
                        </button>
                        <button class="btn btn-primary btn-gradient-text tutorial-btn" style="font-weight: 700; border: 2px solid transparent; border-radius: var(--border-radius-lg); background-image: linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488), linear-gradient(var(--bg-secondary), var(--bg-secondary)), linear-gradient(90deg, #0d9488, #581c87, #be185d, #0d9488); background-origin: border-box; background-clip: text, padding-box, border-box;" onclick="App.ui.showAscensionModal()">
                            ðŸ’Ž Unlock Pro
                        </button>
                    </div>
                `;
                return;
            }

            const readCount = article.readCount || 0;
            const progressColorVar = `var(${App.util.getReadProgressColorVar(readCount)})`;

            const newHeartButtonHTML = `
                <button class="btn-icon"
                        id="unified-heart-btn" 
                        title="Click to advance read count (S).. Double-click to reset (SS)." 
                        aria-label="Mark as finished or reset count">
                    <svg width="28" height="28" viewBox="0 0 24 24" style="transform: scale(1.35);">
                        <defs>
                            <filter id="heart-shadow" x="-50%" y="-50%" width="200%" height="200%">
                                <feDropShadow dx="0" dy="1" stdDeviation="1" flood-color="#000000" flood-opacity="0.2"/>
                            </filter>
                            <filter id="badge-shadow" x="-50%" y="-50%" width="200%" height="200%">
                                <feDropShadow dx="0.5" dy="1" stdDeviation="1.5" flood-color="#000000" flood-opacity="0.35"/>
                            </filter>
                        </defs>
                        <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" fill="${progressColorVar}" style="pointer-events: none;" filter="url(#heart-shadow)"></path>
                        ${readCount > 0 ? `
                        <g transform="translate(18, 6.5)" style="pointer-events: none;" filter="url(#badge-shadow)">
                            <circle r="5.5" fill="#f8f9fa" stroke="${progressColorVar}" stroke-width="1"></circle>
                            <text x="0" y="0.5" text-anchor="middle" dominant-baseline="central" fill="${progressColorVar}" font-size="8px" font-weight="bold" font-family="var(--font-body)">
                                ${readCount}
                            </text>
                        </g>
                        ` : ''}
                    </svg>
                </button>
            `;

            const categoryOptions = App.settings.get('userCategories').map(cat => 
                `<option value="${cat.name}" ${article.category === cat.name ? 'selected' : ''}>${App.util.getCategoryDisplayName(cat.name)}</option>`
            ).join('');

            // --- NEW DYNAMIC BUTTON LOGIC ---
            const textColors = ['text-red', 'text-green', 'text-blue', 'text-magenta', 'text-orange', 'text-teal', 'text-slate'];
            const currentTextColorIndex = App.settings.get('textColorCycleIndex') || 0;
            const colorToShowCssVar = `var(--${textColors[currentTextColorIndex]})`;
            const textColorButtonHTML = `
                <button class="btn-icon" onclick="App.events.cycleTextColorFormatting()" title="Cycle Text Color" aria-label="Cycle through text colors">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="10" fill="${colorToShowCssVar}" stroke="var(--border-color)" stroke-width="1.5"></circle>
                    </svg>
                </button>
            `;
            const shareButtonHTML = navigator.share ? `
                <button class="btn-icon" data-action="shareArticle" title="Share Article">
                   <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>
                </button>
            ` : '';   
            controlsContainer.innerHTML = `
                <div class="controls-wrapper read-mode-controls">
                    <button class="btn-icon" data-action="goToCategory" title="Go to Category View" aria-label="Go to category view">${App.util.icons.category}</button>
                    <button class="btn-icon btn-primary" data-action="switchToWrite" title="Edit Article (E)" aria-label="Edit article">${App.util.icons.edit}</button>
                    ${newHeartButtonHTML}
                    <div class="control-divider"></div>
                    <div class="control-group-popover">
                        <button class="btn-icon" id="export-popover-btn" title="Export Options" aria-label="Export options">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/></svg>
                        </button>
                        <div class="popover-menu">
                            <button class="btn-icon" data-action="copyHighlights" title="Copy Title & Highlights">${App.util.icons.copy}</button>
                            <button class="btn-icon" data-action="exportHtml" title="Export as HTML File">${App.util.icons.html}</button>
                            ${shareButtonHTML}
                            <button class="btn-icon" data-action="exportNoteKash" title="Export as .notekash File">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="control-divider"></div>
                    <button class="btn-icon" onclick="App.events.cycleReaderTheme()" oncontextmenu="event.preventDefault(); App.events.cycleReaderTheme(true)" ondblclick="event.preventDefault(); App.events.resetReaderTheme()" title="Cycle Ambiance (C, Right-click back, Double-click reset)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg>
                    </button>
                    <button class="btn-icon" data-action="toggleFocusMode" title="Fullscreen Read Mode (F)" aria-label="Toggle fullscreen read mode">${App.util.icons.eyeOpen}</button>
                </div>
                <div class="controls-wrapper write-mode-controls">
                    <button class="btn-icon" id="record-audio-btn" onclick="App.audio.toggleRecording()" title="Start/Stop Recording" aria-label="Start or stop audio recording">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0V3z"/><path d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5z"/></svg>
                    </button>
                    <button class="btn-icon" onclick="App.events.openCommandPaletteFromButton()" title="Open Command Palette (/)" aria-label="Open command palette">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M5.52.359A.5.5 0 0 1 6 0h4a.5.5 0 0 1 .474.658L8.694 6H12.5a.5.5 0 0 1 .395.807l-7 9a.5.5 0 0 1-.873-.454L6.823 9.5H3.5a.5.5 0 0 1-.48-.641l2.5-8.5z"/></svg>
                    </button>
                    ${textColorButtonHTML}
                    <button class="btn-icon" title="Manage Table" data-action="manageTable" aria-label="Insert or modify table">${App.util.icons.table}</button>
                    <button class="btn-icon" title="Insert Accordion Card" data-action="insertAccordion" aria-label="Insert accordion card"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 0A1.5 1.5 0 0 0 0 1.5v3A1.5 1.5 0 0 0 1.5 6h13A1.5 1.5 0 0 0 16 4.5v-3A1.5 1.5 0 0 0 14.5 0h-13zM1 4.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 .5.5v-3a.5.5 0 0 1-.5-.5h-13a.5.5 0 0 1-.5.5v3zm0 5A1.5 1.5 0 0 0 0 11v3a1.5 1.5 0 0 0 1.5 1.5h13A1.5 1.5 0 0 0 16 14v-3a1.5 1.5 0 0 0-1.5-1.5h-13zM1 14a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 .5.5v-3a.5.5 0 0 1-.5-.5h-13a.5.5 0 0 1-.5.5v3z"/></svg></button>
                    <div class="control-divider"></div>
                    <button class="btn-icon btn-primary" data-action="saveAndRead" title="Done Editing (Finish & Read)" aria-label="Save and switch to read mode">
                        <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 0 24 24" width="20px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"/></svg>
                    </button>
                    <select id="category-selector" class="btn btn-secondary" aria-label="Select article category">${categoryOptions}</select>
                    <button class="btn-icon" data-action="deleteArticle" title="Delete Article" aria-label="Delete article">${App.util.icons.trash}</button>
                    <div class="control-divider"></div>
                    <div class="list-toolbar-group" id="list-group">
                        <button class="btn-icon" title="List Styles" aria-label="List formatting options">${App.util.icons.list}</button>
                        <div class="list-popover">
                            <button class="btn-icon" title="Bulleted List" data-action="execCommand" data-value="insertUnorderedList" onmousedown="event.preventDefault()"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm-3 1a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/></svg></button>
                            <button class="btn-icon" title="Numbered List (1,2,3)" data-action="execCommand" data-value="insertOrderedList" onmousedown="event.preventDefault()"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 1.222V2.5h1V.5H.5v.722zM1.354 4.08V3.34h-.843v.74h.843zM1.354 5.21V4.47h-.843v.74h.843zm.353 1.63h-.843V6.1h.843v.74zm-.002 1.144h-.843v.74h.843v-.74zM1.354 9.17V8.43h-.843v.74h.843zm.353 1.63h-.843v-.74h.843v.74zm0 1.144h-.843v.74h.843v-.74z"/><path d="M5.5 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM5.5 7.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0 4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5z"/></svg></button>
                            <button class="btn-icon" title="Lettered List (a,b,c)" data-action="applyListStyle" data-value="ordered-alpha" onmousedown="event.preventDefault()"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M5.286 14H3.945L1.81 7.643h1.39l1.412 4.158h.053l1.412-4.158h1.39L5.286 14zM13.385 7.643h-1.39L10.58 4h1.42l1.385 3.643zM11.95 5.07c.053.15.1.32.14.51h.053c.04-.19.087-.36.14-.51L12.89 3.5h-1.8L11.95 5.07zM12 14a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5zm0-1a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z"/></svg></button>
                            <button class="btn-icon" title="Triangle Bullet" data-action="applyListStyle" data-value="bullet-triangle" onmousedown="event.preventDefault()"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="m13.142 8.285-9.428 5.443a.5.5 0 0 1-.715-.434V2.706a.5.5 0 0 1 .715-.434l9.428 5.443a.5.5 0 0 1 0 .868z"/></svg></button>
                            <button class="btn-icon" title="Circle Bullet" data-action="applyListStyle" data-value="bullet-empty-circle" onmousedown="event.preventDefault()"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/></svg></button>
                            <button class="btn-icon" title="Square Bullet" data-action="applyListStyle" data-value="bullet-square" onmousedown="event.preventDefault()">
                            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2z"/></svg></button>
                        </div>
                    </div>
                    <div class="format-toolbar-group" id="format-group">
                        <button class="btn-icon" title="Text Formatting" aria-label="Text formatting options">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M13 4v16"></path><path d="M17 4v16"></path><path d="M19 4H9.5a4.5 4.5 0 0 0 0 9H13"></path></svg>
                        </button>
                        <div class="format-popover" id="format-popover">
                            <button class="btn-icon" title="Bold (Cmd/Ctrl+B)" data-action="execCommand" data-value="bold" onmousedown="event.preventDefault()" aria-label="Bold text"><b>B</b></button>
                            <button class="btn-icon" title="Italic (Cmd/Ctrl+I)" data-action="execCommand" data-value="italic" onmousedown="event.preventDefault()" aria-label="Italicize text"><i>I</i></button>
                            <button class="btn-icon" title="Underline (Cmd/Ctrl+U)" data-action="execCommand" data-value="underline" onmousedown="event.preventDefault()" aria-label="Underline text"><u>U</u></button>
                        </div>
                    </div>
                    <button class="btn-icon" title="Insert Checkbox" data-action="insertCheckbox" aria-label="Insert checkbox">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/><path d="M10.97 4.97a.75.75 0 0 1 1.071 1.05l-3.992 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.235.235 0 0 1 .02-.022z"/></svg>
                    </button>
                    <button class="btn-icon" data-action="toggleFocusMode" title="Focus Mode" aria-label="Toggle focus mode">${App.util.icons.pen}</button>
                </div>
            `;
            if (App.audio.isRecording) {
                const recordBtn = controlsContainer.querySelector('#record-audio-btn');
                if (recordBtn) recordBtn.classList.add('is-recording');
            }
            const heartButton = controlsContainer.querySelector('#unified-heart-btn');
            if (heartButton) {
                let clickTimer = null;

                heartButton.addEventListener('click', () => {
                    clearTimeout(clickTimer);
                    clickTimer = setTimeout(() => {
                        App.events.finishArticle();
                    }, 450);
                });

                heartButton.addEventListener('dblclick', () => {
                    clearTimeout(clickTimer); 
                    App.events.resetReadCount(); 
                });
                heartButton.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
            }
        },
        
       renderCategoryView(container, data) {
            const category = typeof data === 'string' ? data : data.category;
            const articleIdToFocus = typeof data === 'object' ? data.articleId : null;
            const isAllCategory = category === 'All';
            const layoutMode = App.settings.get('categoryLayout') || 'list';
            const highlightsVisible = App.settings.get('categoryHighlightsVisible') !== false; // Default to true


            const sortBy = App.settings.get('categorySortBy') || 'updatedAt';
            
           const sortedArticles = App.services.export.getSortedArticlesForCategory(category);

            if (layoutMode === 'timeline') {
                if (sortBy === 'updatedAt') { // This corresponds to "Last Created"
                    sortedArticles.sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt)); // Descending
                } else { // For all other sorts (First Created, Read, Unread, Random), use ascending time.
                    sortedArticles.sort((a,b) => new Date(a.createdAt) - new Date(b.createdAt)); // Ascending
                }
            }
            
            const articlesWithHighlights = sortedArticles
                .map(article => {
                    let snippets = App.util.extractSnippets(article, 'highlight', true);
                    snippets = snippets.filter(s => !s.html.includes('class="rendered-tag"'));
                    return { ...article, snippets };
                })
                .filter(article => article.snippets.length > 0);

            let contentHtml;
            if (articlesWithHighlights.length > 0) {
                const buildSectionalCardHTML = (article) => {
                    const snippetHTML = article.snippets.map(s => `<div class="snippet" style="cursor: pointer;" onclick="App.router.navigateTo('article', {id: '${s.articleId}', mode: 'read', scrollToSnippetId: '${s.id}'})">${s.html}</div>`).join('');
                    return `<div class="sectional-card-header">
                                <h3 class="sectional-card-title" onclick="App.router.navigateTo('article', {id: '${article.id}', mode: 'read'})">${article.title}</h3>
                                <div class="category-controls-group">
                                    <button class="btn-icon" title="Enter Focus Mode" onclick="App.events.enterFocusMode('${article.id}')">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M20.25 20.25v-4.5m0 4.5h-4.5m4.5 0L15 15m-6-6l-6 6m6-6l6-6" /></svg>
                                    </button>
                                </div>
                            </div>
                            <div class="sectional-card-body">${snippetHTML}</div>`;
                };

                if (layoutMode === 'timeline') {
                    contentHtml = articlesWithHighlights.map((article, index) => {
                        const formattedDate = new Date(article.createdAt).toLocaleDateString(undefined, { day: 'numeric', month: 'short' });
                        return `<div class="timeline-entry" style="animation-delay: ${index * 70}ms;">
                                    <div class="timeline-marker">
                                        <div class="timeline-date">${formattedDate}</div>
                                    </div>
                                    <div class="sectional-card" id="summary-${article.id}">
                                        ${buildSectionalCardHTML(article)}
                                    </div>
                                </div>`;
                    }).join('');
                } else {
                    contentHtml = articlesWithHighlights.map(article => `<div class="sectional-card" id="summary-${article.id}">${buildSectionalCardHTML(article)}</div>`).join('');
                }
            } else {
                contentHtml = `<div class="empty-state" style="grid-column: 1 / -1;"><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg><h3>No Highlights in this Category</h3><p>Use ==highlights== in your notes to see them here.</p></div>`;
            }

            container.innerHTML = `
            <div class="category-view-container ${!highlightsVisible ? 'hide-snippet-colors' : ''} ${layoutMode === 'grid' ? 'grid-mode-active' : ''}">
                <div class="category-controls-hub">
                    <h2 style="margin:0;">${isAllCategory ? 'All Snippets' : `Category: ${App.util.getCategoryDisplayName(category)}`}</h2>
                    <div class="category-controls-group">
                        <button class="btn-icon" title="Focus Mode for entire Category" onclick="App.events.enterFocusModeForCategory('${category}')">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M20.25 20.25v-4.5m0 4.5h-4.5m4.5 0L15 15m-6-6l-6 6m6-6l6-6" /></svg>
                        </button>
                        <div class="layout-toggle-btn">
                            <button class="btn-icon ${layoutMode === 'list' ? 'active' : ''}" id="layout-btn-list" title="List View"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" /></svg></button>
                            <button class="btn-icon ${layoutMode === 'grid' ? 'active' : ''}" id="layout-btn-grid" title="Grid View"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6A2.25 2.25 0 016 3.75h2.25A2.25 2.25 0 0110.5 6v2.25a2.25 2.25 0 01-2.25 2.25H6A2.25 2.25 0 013.75 8.25V6zM3.75 15.75A2.25 2.25 0 016 13.5h2.25a2.25 2.25 0 012.25 2.25V18a2.25 2.25 0 01-2.25 2.25H6A2.25 2.25 0 013.75 18v-2.25zM13.5 6A2.25 2.25 0 0115.75 3.75h2.25A2.25 2.25 0 0120.25 6v2.25a2.25 2.25 0 01-2.25 2.25H15.75A2.25 2.25 0 0113.5 8.25V6zM13.5 15.75A2.25 2.25 0 0115.75 13.5h2.25a2.25 2.25 0 012.25 2.25V18a2.25 2.25 0 01-2.25 2.25H15.75A2.25 2.25 0 0113.5 18v-2.25z" /></svg></button>
                            <button class="btn-icon ${layoutMode === 'timeline' ? 'active' : ''}" id="layout-btn-timeline" title="Timeline View"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25H12" /></svg></button>
                        </div>
                        <select id="category-sort-filter" class="btn btn-secondary" aria-label="Sort snippets by">
                            <option value="updatedAt">Last Created</option>
                            <option value="createdAt">First Created</option>
                            <option value="read">Read</option>
                            <option value="unread">Unread</option>
                            <option value="random">Random</option>
                        </select>
                        <div class="toggle-switch" id="highlight-toggle" title="Toggle Highlight Colors"></div>
                        <div class="export-dropdown-container">
                            <button class="btn btn-primary" onclick="this.nextElementSibling.classList.toggle('show'); event.stopPropagation();">Export</button>
                            <div class="export-dropdown-menu">
                                <button class="btn btn-secondary" onclick="App.services.export.copyCategoryContent('${category}')">Copy Text</button>
                                <button class="btn btn-secondary" onclick="App.services.export.copyCategoryContentAsMarkdown('${category}')">Copy MD</button>
                                <button class="btn btn-secondary ${!App.license.isPremium() ? 'premium-feature-locked' : ''}" onclick="if(App.license.isPremium()) App.services.export.categoryAsText('${category}'); else App.ui.showAscensionModal();">.TXT</button>
                                <button class="btn btn-secondary ${!App.license.isPremium() ? 'premium-feature-locked' : ''}" onclick="if(App.license.isPremium()) App.services.export.exportCategoryAsHtml('${category}'); else App.ui.showAscensionModal();">.HTML</button>
                                <button class="btn btn-secondary ${!App.license.isPremium() ? 'premium-feature-locked' : ''}" onclick="if(App.license.isPremium()) App.services.export.categoryAsPdf('${category}'); else App.ui.showAscensionModal();">.PDF</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="sectional-card-container ${layoutMode === 'timeline' ? 'is-timeline' : ''}">${contentHtml}</div>
            </div>`;
            
            document.getElementById('category-sort-filter').value = sortBy;
            document.getElementById('category-sort-filter').addEventListener('change', (e) => App.events.changeCategorySort(e, category));
            
            const highlightToggle = document.getElementById('highlight-toggle');
            highlightToggle.addEventListener('click', App.events.toggleCategoryHighlights);
            const isHiding = container.classList.contains('hide-snippet-colors');
            highlightToggle.classList.toggle('active', !isHiding);
            
            document.getElementById('layout-btn-list').addEventListener('click', () => App.events.setCategoryLayout('list'));
            document.getElementById('layout-btn-grid').addEventListener('click', () => App.events.setCategoryLayout('grid'));
            document.getElementById('layout-btn-timeline').addEventListener('click', () => App.events.setCategoryLayout('timeline'));
            
            document.addEventListener('click', (e) => {
                const dropdown = document.querySelector('.export-dropdown-menu');
                if (dropdown && dropdown.classList.contains('show') && !e.target.closest('.export-dropdown-container')) {
                    dropdown.classList.remove('show');
                }
            }, { once: true });

            if (articleIdToFocus) {
                setTimeout(() => {
                    const targetCard = document.getElementById(`summary-${articleIdToFocus}`);
                    if (targetCard) {
                        targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        targetCard.style.transition = 'box-shadow 0.5s ease-in-out';
                        targetCard.style.boxShadow = `0 0 20px 5px var(--primary-color)`;
                        setTimeout(() => { targetCard.style.boxShadow = ''; }, 2500);
                    }
                }, 100);
            }
        },

        renderTagsView(container) {
            const sortBy = App.settings.get('tagSortBy');
            
            container.innerHTML = `
                <div class="tags-view-container ui-card">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 24px; flex-wrap: wrap; gap: 1rem;">
                        <div class="search-bar-container" style="flex-basis: 300px; flex-grow: 1;">
                            <svg xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>
                            <input type="text" id="tag-search-input" placeholder="Search tags..." aria-label="Search tags">
                        </div>
                        <select id="tag-sort-filter" class="btn btn-secondary" aria-label="Sort tags by">
                            <option value="alpha" ${sortBy === 'alpha' ? 'selected' : ''}>Alphabetical</option>
                            <option value="date-new" ${sortBy === 'date-new' ? 'selected' : ''}>Newest</option>
                            <option value="date-old" ${sortBy === 'date-old' ? 'selected' : ''}>Oldest</option>
                            <option value="random" ${sortBy === 'random' ? 'selected' : ''}>Random</option>
                        </select>
                    </div>
                    <div id="tag-cloud-container"></div>
                </div>`;
            App.events.filterAndRenderTags();
        },

        renderFlashcardView(container) {
            const category = App.settings.get('flashcardCategory') || 'All';
            const sortBy = App.settings.get('flashcardSortBy');
            
            const nameStyle = App.settings.get('categoryNameStyle') || 'full';

            const userCategories = App.settings.get('userCategories');
            const allCategoryNames = ['All', ...userCategories.map(c => c.name)];

            const categoryChips = allCategoryNames.map(catName => {
                const isActive = category === catName;
                let buttonText;
                    const fullDisplayName = App.util.getCategoryDisplayName(catName);
                    if (catName === 'All') {
                        buttonText = 'All';
                    } else {
                        buttonText = (nameStyle === 'full') ? fullDisplayName : fullDisplayName.substring(0, 4);
                    }
                  
                const titleText = (catName === 'All') ? 'All' : fullDisplayName;
                const categoryObj = userCategories.find(c => c.name === catName);
                const colorIndex = categoryObj ? categoryObj.colorIndex : 0;

                const style = catName === 'All' 
                        ? '' 
                        : `style="background-color: var(--cat-color-${colorIndex}-bg); color: var(--category-pill-text);"`;

                    return `<button class="btn category-chip ${isActive ? 'active' : ''}" ${style} onclick="App.events.changeFlashcardCategory('${catName}')" title="${titleText}">${buttonText}</button>`;
                }).join('');

                container.innerHTML = `
                <div class="flashcard-view-header">
                    <div style="display: flex; align-items: stretch; gap: 0.75rem; flex-wrap: wrap; width: 100%;">
                        <div style="display: flex; align-items: stretch; ">
                            <button class="btn btn-primary" onclick="App.events.study.start()">Study Session</button>
                        </div>
                        <button class="btn btn-secondary" onclick="App.events.study.start({ mode: 'allDue' })" title="Study ALL due cards without a limit">S-Due Cards</button>
                        <button class="btn btn-secondary" onclick="App.events.study.start({ mode: 'mcqOnly' })" title="Study only Multiple-Choice Questions from this deck">S-MCQ</button>
                        <button class="btn btn-primary btn-quiz" onclick="App.quiz.start()">Recall Quiz</button>
                        <button class="btn btn-primary btn-quiz" onclick="App.quiz.start({ mode: 'mcq' })">MCQ Quiz</button>
                        <button class="btn btn-danger" onclick="App.events.resetFilteredFlashcardsConfirmation()" title="Reset progress for all cards in the current filter">Reset</button>
                        <button class="btn-icon" onclick="App.ui.showFlashcardSettingsModal()" title="Flashcard Settings">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311a1.464 1.464 0 0 1 0 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105 0l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.31-.17a1.464 1.464 0 0 1 2.105-.872l-.1-.34c.413-1.4 2.397-1.4 2.81 0l.1.34a1.464 1.464 0 0 1 2.105.872l.31.17c1.283.698-2.686-.705-1.987-1.987l-.169-.311a1.464 1.464 0 0 1 0-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105 0l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.31.17a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/></svg>
                        </button>
                    </div>
                    <div class="category-filters" style="width: 100%;">${categoryChips}</div>
                </div>
                <div style="display:flex; gap: 1rem; align-items:center; margin-bottom: 1.5rem;">
                    <div class="search-bar-container">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>
                        <input type="text" id="flashcard-search-input" placeholder="Search flashcards (Press 'S' to focus)..." aria-label="Search flashcards">
                    </div>
                    <select id="flashcard-sort" class="btn btn-secondary" aria-label="Sort flashcards by">
                        <option value="sm2" ${sortBy === 'sm2' ? 'selected' : ''}>Sort by SRS</option>
                        <option value="mcq" ${sortBy === 'mcq' ? 'selected' : ''}>Sort by MCQ</option>
                        <option value="random" ${sortBy === 'random' ? 'selected' : ''}>Sort by Random</option>
                        <option value="createdAt-desc" ${sortBy === 'createdAt-desc' ? 'selected' : ''}>Sort by Newest</option>
                        <option value="createdAt-asc" ${sortBy === 'createdAt-asc' ? 'selected' : ''}>Sort by Oldest</option>
                        <option value="read" ${sortBy === 'read' ? 'selected' : ''}>Sort by Read</option>
                        <option value="unread" ${sortBy === 'unread' ? 'selected' : ''}>Sort by Unread</option>
                        <option value="leeches" ${sortBy === 'leeches' ? 'selected' : ''}>Sort by Leeches</option>
                    </select>
                    <div class="export-dropdown-container">
                        <button class="btn btn-primary" onclick="this.nextElementSibling.classList.toggle('show'); event.stopPropagation();">Export</button>
                        <div class="export-dropdown-menu">
                            <div class="${!App.license.isPremium() ? 'premium-feature-locked' : ''}" style="width:100%;">
                                <button class="btn btn-secondary" style="width:100%;" onclick="if(App.license.isPremium()) App.services.export.exportFlashcardsAsTxt(); else { App.ui.showAscensionModal(); this.parentElement.parentElement.classList.remove('show'); }">.TXT</button>
                            </div>
                            <div class="${!App.license.isPremium() ? 'premium-feature-locked' : ''}" style="width:100%;">
                                <button class="btn btn-secondary" style="width:100%;" onclick="if(App.license.isPremium()) App.services.export.exportFlashcardsAsTsv(); else { App.ui.showAscensionModal(); this.parentElement.parentElement.classList.remove('show'); }">.TSV (Anki)</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flashcard-grid" id="flashcard-grid"></div>
            `;
            this.filterAndRenderFlashcards();
        },

        
        filterAndRenderFlashcards() {
            const grid = document.getElementById('flashcard-grid');
            if (!grid) return;

            const searchTerm = document.getElementById('flashcard-search-input')?.value || '';
            let filteredFlashcards = App.util.getSortedFlashcardsForDisplay(searchTerm);
            
            const isPremium = App.license.isPremium();
            const flashcardLimit = App.config.sparkTierLimit;
            const totalFlashcards = App.util.getAllFlashcards().length;

            if (!isPremium) {
                // If the user is not premium, ALWAYS add the upsell tile first.
                filteredFlashcards.unshift({
                    type: 'premium-upsell-tile',
                    used: totalFlashcards,
                    limit: flashcardLimit
                });

                // Then, slice the array of actual flashcards to enforce the limit.
                filteredFlashcards = filteredFlashcards.slice(0, flashcardLimit + 1); // +1 to keep the upsell tile
            }

            if (filteredFlashcards.length === 0) {
                grid.innerHTML = `<div class="empty-state" style="grid-column: 1 / -1;"><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1"><path stroke-linecap="round" stroke-linejoin="round" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z" /></svg><h3>No Flashcards Found</h3><p>Create flashcards using {{c1::your text}} or accordions in an article.</p></div>`;
            } else {
                grid.innerHTML = filteredFlashcards.map(this.getFlashcardTileHTML).join('');
            }

            const visibleCards = Array.from(grid.querySelectorAll('.flashcard-tile'));
            const isSearching = searchTerm.trim() !== '';

            visibleCards.forEach(card => card.classList.toggle('search-highlight-card', isSearching));
            document.querySelectorAll('.flashcard-tile.search-selected-card').forEach(c => c.classList.remove('search-selected-card'));
            
            App.state.flashcardRender.searchResults = isSearching ? visibleCards : [];
            App.state.flashcardRender.selectedIndex = -1;

            if (isSearching && visibleCards.length > 0) {
                App.state.flashcardRender.selectedIndex = 0;
                visibleCards[0].classList.add('search-selected-card');
            }
        },


        getFlashcardTileHTML(flashcard) {
            if (flashcard.type === 'premium-upsell-tile') {
                const actualUsed = flashcard.used;
                const limit = flashcard.limit;
                const displayUsed = Math.min(actualUsed, limit);
                const percentageUsed = Math.min(100, Math.round((actualUsed / limit) * 100));

                return `
                    <div class="flashcard-tile premium-upsell-tile" onclick="App.ui.showAscensionModal()">
                        <div class="upsell-badge">âœ¨ Spark Tier</div>
                        <div class="upsell-content">
                            <h4>Unlock Unlimited Cards</h4>
                            <p>Quota used: <strong>${percentageUsed}%</strong> <i> (${displayUsed} of ${limit} flashcards) </i>. Go Premium to Go Unlimited!</p>
                            <div class="upsell-progress-bar">
                                <div class="upsell-progress" style="width: ${percentageUsed}%;"></div>
                            </div>
                        </div>
                        <div class="upsell-cta">Go Premium</div>
                    </div>`;
            }

            const color = App.util.sm2.getRatingColor(flashcard.rating);
            let cardFront, cardBack;
            
            // âœ¨ NEW: Leech indicator logic.
            const leechIndicator = (flashcard.lapses || 0) >= App.config.sm2.leechThreshold 
                ? '<span title="Leech Card: This card is difficult for you. Consider rephrasing it." style="cursor: help;">ðŸ©¸</span> ' 
                : '';

            if (flashcard.type === 'collapsible') {
                const reversibleIndicator = flashcard.isReversed ? `<span class="reversible-indicator" title="Reversible Card (Answer Side)">${App.util.icons.reversible}</span>` : '';
                cardFront = leechIndicator + flashcard.frontText + reversibleIndicator;
                cardBack = flashcard.backText;
            } else if (flashcard.type === 'mcq') {
                cardFront = leechIndicator + flashcard.question;
                const correctOption = flashcard.options.find(opt => opt.isCorrect);
                const answerText = correctOption ? correctOption.text : 'N/A';
                let explanationHTML = '';
                if (flashcard.explanation) {
                    explanationHTML = `<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color); font-size: 0.85em; color: var(--text-secondary);">${flashcard.explanation}</div>`;
                }
                cardBack = `<p><b>Correct:</b> ${answerText}</p>${explanationHTML}`;
            } else { // Default to legacy cloze
                const parsedFullText = App.util.parseShortcuts(flashcard.fullText);
                cardFront = leechIndicator + parsedFullText.replace(/{{c\d+::(.*?)}}/g, '<strong class="cloze-hidden">[â€¦â€¦?]</strong>');
                cardBack = parsedFullText.replace(/{{c\d+::(.*?)}}/g, '<span class="cloze-revealed-wrapper"><strong class="cloze-revealed">$1</strong></span>');
            }

            let reviewInfo = 'New Card';
            if (flashcard.nextReviewDue) {
                const nextDate = new Date(flashcard.nextReviewDue);
                const now = new Date();
                const options = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
                if (nextDate > now) {
                    reviewInfo = `Next: ${nextDate.toLocaleString('en-GB', options)}`;
                } else {
                    reviewInfo = 'Review Due!';
                }
            }

            return `
                <div class="flashcard-tile" style="border-left-color: ${color};" 
                    onclick="this.classList.toggle('is-flipped')" 
                    oncontextmenu="App.events.flashcardContextMenu(event, '${flashcard.id}')"
                    title="Click to flip, right-click for options">
                    <div class="flashcard-tile-flipper">
                        <div class="flashcard-tile-face flashcard-tile-front">
                            <div class="flashcard-tile-content">${cardFront}</div>
                            <div class="flashcard-tile-footer">
                                <button class="btn-icon" title="Go to Source Article" onclick="event.stopPropagation(); App.router.navigateTo('article', {id: '${flashcard.articleId}', mode: 'read'})">${App.util.icons.article}</button>
                                <button class="btn-icon" title="Delete Card" onclick="event.stopPropagation(); App.events.deleteFlashcardConfirmation('${flashcard.id}')">${App.util.icons.trash}</button>
                                <button class="btn-icon" title="Reset Card Progress" onclick="event.stopPropagation(); App.events.resetFlashcard('${flashcard.id}')">${App.util.icons.reset}</button>
                                <button class="btn-icon" title="Review 1 Day Earlier" onclick="event.stopPropagation(); App.events.nudgeReviewDate('${flashcard.id}', -1)">${App.util.icons.minus}</button>
                                <button class="btn-icon" title="Review 1 Day Later" onclick="event.stopPropagation(); App.events.nudgeReviewDate('${flashcard.id}', 1)">${App.util.icons.plus}</button>
                            </div>
                        </div>
                        <div class="flashcard-tile-face flashcard-tile-back">
                            <div class="flashcard-tile-content">${cardBack}</div>
                            <div class="flashcard-tile-footer" style="justify-content:flex-end;">
                                <small>${reviewInfo}</small>
                            </div>
                        </div>
                    </div>
                </div>`;
        },

        renderStudyView(session) {
            const container = document.getElementById('study-view-container');
            document.documentElement.style.setProperty('--study-card-font-size', App.settings.get('studyCardFontSize') || '1.6rem');
            if (!session.isActive || session.cards.length === 0) {
                container.innerHTML = '';
                document.body.classList.remove('study-mode-active', 'read-mode');
                return;
            }
            document.body.classList.add('study-mode-active', 'read-mode');

            const card = session.cards[session.currentIndex];
            const borderColor = App.util.sm2.getRatingColor(card.rating);
            let cardFront, cardBack, contentBoxClass = '';

            let controlsHTML = '';
            const isFirstCard = session.currentIndex === 0;
            const isLastCard = session.currentIndex === session.cards.length - 1;

            const prevButtonIcon = `<button class="btn-icon-nav" onclick="App.events.study.prev()" ${isFirstCard ? 'disabled' : ''} title="Previous Card (â†)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg>
            </button>`;
            const nextButtonIcon = `<button class="btn-icon-nav" onclick="App.events.study.next()" ${isLastCard ? 'disabled' : ''} title="Next Card (â†’)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" /></svg>
            </button>`;
            const exitButtonIcon = `<button class="btn-icon-nav btn-exit-study" onclick="App.events.study.exit()" title="Exit Session (Esc)">${App.util.icons.close}</button>`;
            const currentFontSize = App.settings.get('studyCardFontSize') || '1.6rem';
            const fontSizeButton = `<button class="btn-icon-nav" onclick="App.events.study.toggleFontSize(this)" title="Cycle Font Size">
                <span style="font-weight: 700; font-size: 1rem;">${currentFontSize.replace('rem','')}</span>
            </button>`;
            const themeButtonIcon = `<button class="btn-icon-nav" title="Cycle Ambiance (C, Right-click to go back)" oncontextmenu="event.preventDefault(); App.events.study.cycleStudyTheme(true);" onclick="App.events.study.cycleStudyTheme()">${App.util.icons.theme}</button>`;

            if (session.quizType === 'mcq') {
                controlsHTML = `
                    <div class="study-nav-and-ratings">
                        ${prevButtonIcon}
                        ${themeButtonIcon}
                        ${nextButtonIcon}
                    </div>
                    <div class="mcq-controls-right-group">
                        ${fontSizeButton}
                        ${exitButtonIcon}
                    </div>
                `;
            } else { 
                // New layout for SRS with corrected grouping
                controlsHTML = `
                    <div class="study-nav-and-ratings">
                        ${prevButtonIcon}
                        ${themeButtonIcon}
                        ${nextButtonIcon}
                    </div>
                    <div class="srs-rating-group">
                        <button class="btn btn-study-rating btn-again" onclick="App.events.study.rate('Again')">Again</button>
                        <button class="btn btn-study-rating btn-hard" onclick="App.events.study.rate('Hard')">Hard</button>
                        <button class="btn btn-study-rating btn-hold" onclick="App.events.study.rate('Hold')" title="Snooze this card until tomorrow">Bury</button>
                        <button class="btn btn-study-rating btn-good" onclick="App.events.study.rate('Good')">Good</button>
                        <button class="btn btn-study-rating btn-easy" onclick="App.events.study.rate('Easy')">Easy</button>
                    </div>
                    <div class="mcq-controls-right-group">
                        ${fontSizeButton}
                        ${exitButtonIcon}
                    </div>
                `;
            }

            if (card.type === 'collapsible') {
                const reversibleIndicator = card.isReversed ? `<span class="reversible-indicator" title="Reversible Card (Answer Side)">${App.util.icons.reversible}</span>` : '';
                const hintArea = card.hint ? `<div class="study-hint-container"><button class="btn btn-secondary study-hint-btn">Show Hint</button><div class="study-hint-content" style="display: none;">${card.hint}</div></div>` : '';
                cardFront = card.frontText + reversibleIndicator + hintArea;
                cardBack = card.backText;
            } else if (card.type === 'mcq') {
                contentBoxClass = 'mcq-type';
                const optionsHtml = card.options.map(opt => `<div class="nk-mcq-option" data-is-correct="${opt.isCorrect}">${opt.text}</div>`).join('');
                cardFront = `<div class="nk-mcq-block" data-quiz-mode="${session.quizType}"><div class="nk-mcq-question">${card.question}</div><div class="nk-mcq-options">${optionsHtml}</div></div>`;
                const correctOption = card.options.find(opt => opt.isCorrect);
                let answerHTML = `<strong>Answer:</strong> <span style="color: var(--success-color);">${correctOption ? correctOption.text : 'N/A'}</span>`;
                if (card.explanation) {
                    answerHTML += `<hr style="margin: 1rem 0;"><div style="font-size: 0.8em; color: var(--text-secondary);">${card.explanation}</div>`;
                }
                cardBack = `<div><div><strong>Question:</strong> ${card.question}</div><hr style="margin: 1.5rem 0;"><div>${answerHTML}</div></div>`;
            } else {
                const parsedFullText = App.util.parseShortcuts(card.fullText);
                cardFront = parsedFullText.replace(/{{c\d+::(.*?)}}/g, '<strong class="cloze-hidden">[â€¦â€¦?]</strong>');
                cardBack = parsedFullText.replace(/{{c\d+::(.*?)}}/g, '<span class="cloze-revealed-wrapper"><strong class="cloze-revealed">$1</strong></span>');
            }

            const activeTheme = session.activeTheme || 'default';
            const activeThemeClass = activeTheme !== 'default' ? `ambiance-${activeTheme}` : '';
            const globalTheme = App.settings.get('theme');
            let backgroundStyle = (activeTheme === 'default' && globalTheme === 'custom' && App.settings.get('backgroundImage')) 
                ? `background-image: url(${App.settings.get('backgroundImage')});` 
                : '';

            container.innerHTML = `<div class="study-view ${activeThemeClass}" role="dialog" aria-modal="true" aria-label="Study Session">
                <div class="study-background" style="${backgroundStyle}"></div>
                <div class="study-content-container">
                    <div class="study-card" onclick="if (this.querySelector('.nk-mcq-block') && !this.querySelector('.nk-mcq-block[data-answered=true]')) return; this.classList.toggle('is-flipped')" tabindex="0" aria-label="Flashcard, press Space to flip">
                        <div class="study-card-face study-card-front"><div class="study-card-content-box ${contentBoxClass}" style="border-color: ${borderColor};">${cardFront}</div></div>
                        <div class="study-card-face study-card-back"><div class="study-card-content-box" style="border-color: ${borderColor};">${cardBack}</div></div>
                    </div>
                </div>
                <div class="study-controls-container">
                    <div class="study-progress-wrapper">
                        <progress id="study-progress-bar" class="study-progress-bar" value="${session.currentIndex + 1}" max="${session.cards.length}"></progress>
                        <div class="study-progress-counter">${session.currentIndex + 1} / ${session.cards.length}</div>
                    </div>
                    <div class="study-controls">${controlsHTML}</div>
                </div>
            </div>`;

            // FIX #1: Add manual wheel event listener to enable scrolling on long flashcards.
            const studyViewOverlay = container.querySelector('.study-view');
            if (studyViewOverlay) {
                studyViewOverlay.addEventListener('wheel', (e) => {
                    const studyCard = studyViewOverlay.querySelector('.study-card');
                    if (!studyCard) return;

                    const isFlipped = studyCard.classList.contains('is-flipped');
                    const activeFaceSelector = isFlipped ? '.study-card-back' : '.study-card-front';
                    const contentBox = studyViewOverlay.querySelector(`${activeFaceSelector} .study-card-content-box`);

                    if (contentBox && contentBox.scrollHeight > contentBox.clientHeight) {
                        e.preventDefault();
                        contentBox.scrollTop += e.deltaY;
                    }
                }, { passive: false });
            }

            if (card.type === 'mcq') { container.querySelector('.study-card-front .study-card-content-box')?.addEventListener('click', (e) => App.events.handleMcqAnswer(e, true)); }
            if (card.type === 'collapsible' && card.hint) { const hintBtn = container.querySelector('.study-hint-btn'); if (hintBtn) { hintBtn.addEventListener('click', (e) => { e.stopPropagation(); const hintContent = hintBtn.nextElementSibling; const isHidden = hintContent.style.display === 'none'; hintContent.style.display = isHidden ? 'block' : 'none'; hintBtn.textContent = isHidden ? 'Hide Hint' : 'Show Hint'; }); } }
            
            const studyCardEl = container.querySelector('.study-card');
            if (studyCardEl && card.type !== 'mcq') {
                App.events.study.setupCardGestures(studyCardEl);
            }
            
            const keyboardHandler = session.quizType === 'mcq' ? App.quiz.handleKeyboard : App.events.study.handleKeyboard;
            document.addEventListener('keydown', keyboardHandler.bind(App.quiz), { once: true });
            App.util.trapFocus(container.querySelector('.study-view'));
        },

        renderStatsDashboardView(container, data) {
            const today = new Date();
            const selectedMonth = data?.month !== undefined ? data.month : today.getMonth();
            const selectedYear = data?.year !== undefined ? data.year : today.getFullYear();

            container.innerHTML = `
                <div class="stats-dashboard-view">
                    <div class="stats-header">
                        <h1 class="library-title">Stats Dashboard</h1>
                    </div>
                    <div id="stats-content-area"></div>
                </div>
            `;
            this.renderStatsContent(document.getElementById('stats-content-area'), selectedMonth, selectedYear);

            const readingData = App.util.getReadingChartData(selectedMonth, selectedYear);
            const flashcardData = App.util.getFlashcardChartData(selectedMonth, selectedYear);
            
            const baseColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
            const baseColorRgb = App.util.colorToRgb(baseColor);
            const chartFillColor = baseColorRgb ? `rgba(${baseColorRgb.join(',')}, 0.2)` : '#cccccc';

            const readCtx = document.getElementById('readingActivityChart')?.getContext('2d');
            if(readCtx) {
                if (App.state.chartInstances.reading) App.state.chartInstances.reading.destroy();
                App.state.chartInstances.reading = new Chart(readCtx, {
                    type: 'line', data: { labels: readingData.labels, datasets: [{ label: `Articles Completed`, data: readingData.data, borderColor: baseColor, borderWidth: 2, tension: 0.4, fill: true, backgroundColor: chartFillColor }] },
                    options: { scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } } }
                });
            }

            const flashCtx = document.getElementById('flashcardActivityChart')?.getContext('2d');
            if(flashCtx) {
                if (App.state.chartInstances.flashcard) App.state.chartInstances.flashcard.destroy();
                App.state.chartInstances.flashcard = new Chart(flashCtx, {
                    type: 'bar', data: { labels: flashcardData.labels, datasets: [{ label: `Flashcards Reviewed`, data: flashcardData.data, backgroundColor: baseColor }] },
                    options: { scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } } }
                });
            }
            // âœ¨ NEW & CORRECTED: Render Flashcard Forecast Chart
            const forecastCtx = document.getElementById('flashcardForecastChart')?.getContext('2d');
            if(forecastCtx) {
                if (App.state.chartInstances.forecast) App.state.chartInstances.forecast.destroy();
                const forecastData = App.util.getFlashcardForecastData();
                App.state.chartInstances.forecast = new Chart(forecastCtx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({ length: 30 }, (_, i) => `+${i}d`),
                        datasets: [{
                            label: 'Cards Due',
                            data: forecastData,
                            backgroundColor: chartFillColor, // Uses the correctly defined color from the parent function
                            borderColor: baseColor,        // Uses the correctly defined color from the parent function
                            borderWidth: 1
                        }]
                    },
                    options: {
                        scales: { y: { beginAtZero: true, ticks: { stepSize: 5 } } },
                        plugins: { legend: { display: false } }
                    }
                });
            }

            // âœ¨ NEW & CORRECTED: Render Card Ease Distribution Chart
            const easeCtx = document.getElementById('cardEaseDistributionChart')?.getContext('2d');
            if(easeCtx) {
                if (App.state.chartInstances.ease) App.state.chartInstances.ease.destroy();
                const easeData = App.util.getCardEaseDistributionData();
                App.state.chartInstances.ease = new Chart(easeCtx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Leech', 'Hard', 'Normal', 'Easy', 'New'],
                        datasets: [{
                            label: 'Card Distribution',
                            data: [easeData.Leech, easeData.Hard, easeData.Normal, easeData.Easy, easeData.New],
                            // âœ¨ FIX: Get the computed color values directly to fix the display bug
                            backgroundColor: [
                                getComputedStyle(document.documentElement).getPropertyValue('--danger-color').trim(),      // Leech
                                getComputedStyle(document.documentElement).getPropertyValue('--warning-color').trim(),     // Hard
                                getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(),     // Normal
                                getComputedStyle(document.documentElement).getPropertyValue('--success-color').trim(),     // Easy
                                getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim()   // New
                            ],
                            borderColor: getComputedStyle(document.documentElement).getPropertyValue('--bg-primary').trim(),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            }
                        }
                    }
                });
            }
            const monthSelect = document.getElementById('stats-month-select');
            const yearSelect = document.getElementById('stats-year-select');

            const updateView = () => {
                const newMonth = parseInt(monthSelect.value);
                const newYear = parseInt(yearSelect.value);
                App.router.navigateTo('stats-dashboard', { month: newMonth, year: newYear });
            };

            monthSelect?.addEventListener('change', updateView);
            yearSelect?.addEventListener('change', updateView);
        },
  


        renderStatsContent(container, currentMonth, currentYear) {
            const readingStats = App.util.getReadingStats();
            const hubStats = App.hub.util.getDashboardStats();
            const flashcardStats = App.util.getFlashcardStats();
            const quizStats = App.quiz.getStats();
            const dailyStreak = App.util.calculateQuizStreak();
            const weekCompletionData = App.util.getWeekCompletionData();
            const todayFlashcards = App.util.getFlashcardStatsForPeriod('today').reviewed;
            const yesterdayFlashcards = App.util.getFlashcardStatsForPeriod('yesterday').reviewed;
            const todayArticles = App.util.getReadingStatsForPeriod('today').read;
            const yesterdayArticles = App.util.getReadingStatsForPeriod('yesterday').read;
            const today = new Date();
            const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();

            let heatmapHtml = '';
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(Date.UTC(currentYear, currentMonth, day));
                const dateStr = date.toISOString().slice(0, 10);
                const seconds = hubStats.pomodoro.dailyTotals[dateStr] || 0;
                const formattedDate = date.toLocaleDateString(undefined, { day: 'numeric', month: 'short', timeZone: 'UTC' });
                const formattedTime = App.hub.util.formatSecondsToDecimalHours(seconds);
                let level = 0; const hours = seconds / 3600;
                if (hours >= 8) level = 6; else if (hours >= 6) level = 5; else if (hours >= 4.5) level = 4;
                else if (hours >= 3) level = 3; else if (hours >= 1.5) level = 2; else if (hours >= 0.25) level = 1;
                heatmapHtml += `<div class="heatmap-day level-${level}" title="${formattedDate}\n${formattedTime} focused"></div>`;
            }
            const dayOfWeek = new Date(currentYear, currentMonth, 1).getDay();
            const startOffset = (dayOfWeek === 0 ? 6 : dayOfWeek - 1);
            heatmapHtml = Array(startOffset).fill('<div class="heatmap-day empty"></div>').join('') + heatmapHtml;
            const totalCells = startOffset + daysInMonth;
            const remainingCells = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
            heatmapHtml += Array(remainingCells).fill('<div class="heatmap-day empty"></div>').join('');

            const categoryTimeMap = new Map(hubStats.pomodoro.categories);
            const categoryTilesHTML = App.settings.get('userCategories').map(cat => {
                const seconds = categoryTimeMap.get(cat.name) || 0;
                // NEW: Apply dynamic background color
                const backgroundColor = App.util.getCategoryColor(cat.colorIndex);
                return `<div class="category-card"><div class="category-card-info"><div class="category-pill" style="background-color: ${backgroundColor};">${App.util.getCategoryDisplayName(cat.name)}</div></div><div class="category-card-value">${App.hub.util.formatSecondsToDecimalHours(seconds)}</div></div>`
            }).join('');

            const { firstYear, firstMonth } = App.util.getAppStartDate();
            const yearOptions = [];
            for (let y = today.getFullYear(); y >= firstYear; y--) {
                yearOptions.push(`<option value="${y}" ${y === currentYear ? 'selected' : ''}>${y}</option>`);
            }
            const monthOptions = Array.from({length: 12}, (_, i) => {
                const date = new Date(currentYear, i);
                const isDisabled = currentYear === firstYear && i < firstMonth;
                return `<option value="${i}" ${i === currentMonth ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}>${date.toLocaleString('default', { month: 'long' })}</option>`;
            }).join('');

            const weeklyCalendarHTML = weekCompletionData.map(day => `
                <div class="week-day ${day.isCompleted ? 'completed' : ''} ${day.isToday ? 'today' : ''}">
                    <span class="day-letter">${day.dayLetter}</span>
                    <span class="date-number">${day.dateNumber}</span>
                </div>
            `).join('');

            container.innerHTML = `
                <div class="stats-section-title">Cards Quiz Stats</div>
                <div class="quiz-stats-container">
                    <div class="streak-container">
                        <div class="streak-display daily" title="${dailyStreak > 0 ? `You're on a ${dailyStreak}-day streak!` : 'Complete a quiz today to start a streak!'}">
                            <div class="streak-value">${dailyStreak}</div>
                            <div class="streak-label">Day Streak ðŸ”¥</div>
                        </div>
                        <div class="weekly-streak-calendar" title="Your quiz activity for the current week.">
                            ${weeklyCalendarHTML}
                        </div>
                    </div>
                    <div class="sub-stats-grid">
                        <div class="stat-card"><div class="stat-card-value">${quizStats.lastScore.toFixed(1)}</div><div class="stat-card-label">Last Score</div></div>
                        <div class="stat-card"><div class="stat-card-value">${quizStats.bestScore.toFixed(1)}</div><div class="stat-card-label">Best Score</div></div>
                        <div class="stat-card"><div class="stat-card-value">${quizStats.avgScore.toFixed(2)}</div><div class="stat-card-label">Avg. Score</div></div>
                        <div class="stat-card"><div class="stat-card-value">${quizStats.totalScore.toFixed(1)}/${quizStats.totalQuizzes * 10}</div><div class="stat-card-label">Total Score</div></div>
                    </div>
                </div>
                <div class="stats-section-title">Focus Calendar</div>
                <div class="heatmap-container"><div class="heatmap-header"><b>${monthNames[currentMonth]} ${currentYear}</b></div><div class="heatmap-grid">${heatmapHtml}</div></div>
                <div class="stats-section-title">Pomodoro Focus Stats</div>
                <div class="stats-grid">
                    <div class="stat-card"><div class="stat-card-value">${App.hub.util.formatSecondsToDecimalHours(hubStats.pomodoro.today)}</div><div class="stat-card-label">Today</div></div>
                    <div class="stat-card"><div class="stat-card-value">${App.hub.util.formatSecondsToDecimalHours(hubStats.pomodoro.yesterday)}</div><div class="stat-card-label">Yesterday</div></div>
                    <div class="stat-card"><div class="stat-card-value">${App.hub.util.formatSecondsToDecimalHours(hubStats.pomodoro.average)}</div><div class="stat-card-label">Daily Average</div></div>
                    <div class="stat-card"><div class="stat-card-value">${App.hub.util.formatSecondsToDecimalHours(hubStats.pomodoro.best)}</div><div class="stat-card-label">Best Day</div></div>
                </div>
                <div class="stats-section-title">Time by Note Category</div>
                <div class="category-grid">${categoryTilesHTML.length > 0 ? categoryTilesHTML : `<p style="text-align:center; color: var(--text-secondary);">No focused time recorded yet.</p>`}</div>
                <div class="stats-section-title">Task Stats</div>
                <div class="stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));">
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.total}</div><div class="stat-card-label">Total Tasks</div></div>
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.completed}</div><div class="stat-card-label">Completed</div></div>
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.completedToday}</div><div class="stat-card-label">Done Today</div></div>
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.completedYesterday}</div><div class="stat-card-label">Done Yesterday</div></div>
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.backlog}</div><div class="stat-card-label">Backlog</div></div>
                    <div class="stat-card"><div class="stat-card-value">${hubStats.tasks.upcoming}</div><div class="stat-card-label">Upcoming</div></div>
                </div>
                <div class="stats-section-title">Flashcard Spaced Repetition</div>
                <div class="stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));">
                    <div class="stat-card"><div class="stat-card-value">${flashcardStats.total}</div><div class="stat-card-label">Total Cards</div></div>
                    <div class="stat-card"><div class="stat-card-value">${flashcardStats.due}</div><div class="stat-card-label">To Study</div></div>
                    ${App.config.sm2.ratings.map(r => `<div class="stat-card"><div class="stat-card-value">${flashcardStats.ratings[r] || 0}</div><div class="stat-card-label">${r}</div></div>`).join('')}
                    <div class="stat-card"><div class="stat-card-value">${flashcardStats.ratings['New'] || 0}</div><div class="stat-card-label">New Cards</div></div>
                    <div class="stat-card"><div class="stat-card-value">${yesterdayFlashcards}</div><div class="stat-card-label">Yesterday</div></div>
                    <div class="stat-card"><div class="stat-card-value" style="color:var(--success-color);">${todayFlashcards}</div><div class="stat-card-label">Today</div></div>
                </div>
                <div style="margin-top: 2rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
                    <div><canvas id="flashcardActivityChart" style="margin-top: 1rem;"></canvas></div>
                </div>
                <div style="margin-top: 2rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
                    <div>
                        <h4 style="text-align: center;">Upcoming Reviews (Next 30 Days)</h4>
                        <canvas id="flashcardForecastChart"></canvas>
                    </div>
                </div>
                <div style="margin-top: 2rem;">
                    <h4 style="text-align: center;">Card Difficulty Distribution</h4>
                    <div style="max-width: 400px; margin: 0 auto;">
                        <canvas id="cardEaseDistributionChart"></canvas>
                    </div>
                </div>
                <div class="stats-section-title">Reading Stats</div>
                <div class="stats-grid" style="grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));">
                    <div class="stat-card"><div class="stat-card-value">${readingStats.total}</div><div class="stat-card-label">Total Articles</div></div>
                    <div class="stat-card"><div class="stat-card-value">${readingStats.completed}</div><div class="stat-card-label">Completed</div></div>
                    <div class="stat-card"><div class="stat-card-value">${readingStats.unread}</div><div class="stat-card-label">Unread</div></div>
                    ${Object.entries(readingStats.stages).map(([stage, count]) => `<div class="stat-card"><div class="stat-card-value">${count}</div><div class="stat-card-label">Read ${stage}${stage === '5' ? '+' : ''}x</div></div>`).join('')}
                    <div class="stat-card"><div class="stat-card-value">${yesterdayArticles}</div><div class="stat-card-label">Yesterday</div></div>
                    <div class="stat-card"><div class="stat-card-value" style="color:var(--success-color);">${todayArticles}</div><div class="stat-card-label">Today</div></div>
                </div>
                <div style="margin-top: 2rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">
                    <div><canvas id="readingActivityChart" style="margin-top: 1rem;"></canvas></div>
                </div>
                <div class="stats-section-title" style="margin-top: 3rem; text-align:center; border:none;">View Historical Data</div>
                <div style="display:flex; justify-content:center; gap: 1rem; margin-top: -0.5rem;">
                    <select id="stats-month-select" class="btn btn-secondary">${monthOptions}</select>
                    <select id="stats-year-select" class="btn btn-secondary">${yearOptions.join('')}</select>
                </div>
            `;
        },

        renderFocusMode() {
            const session = App.state.focusSession;
            if (!session.isActive) {
                // Hide Co-Pilot when exiting Focus Mode
                const coPilotToggle = document.getElementById('kash-copilot-toggle');
                if (coPilotToggle) coPilotToggle.style.display = 'none';
                return;
            }

            // --- NEW: Show Co-Pilot when entering Focus Mode ---
            const coPilotToggle = document.getElementById('kash-copilot-toggle');
            if (coPilotToggle) coPilotToggle.style.display = 'flex';


            let overlay = document.getElementById('focus-mode-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'focus-mode-overlay';
                document.body.appendChild(overlay);
            }

            overlay.className = `focus-mode-overlay ${session.isStageMode ? 'stage-mode-active' : ''} ${session.activeTheme && session.activeTheme !== 'default' ? 'ambiance-' + session.activeTheme : ''}`;
            if (session.isCinematicActive) {
                overlay.classList.add('cinematic-active');
            }

            const highlightsVisible = App.settings.get('categoryHighlightsVisible') !== false;
            const currentArticle = session.articles[session.currentIndex];
            const fontSize = App.settings.get('focusModeFontSize') || '1.1rem';

            const contentHTML = currentArticle.snippets.map(item => {
                if (item.type === 'mcq' || item.type === 'timeline' || item.type === 'chart' || item.type === 'accordion') {
                    let finalHtml = item.html.replace(/contenteditable="true"/g, 'contenteditable="false"');
                    
                    if (item.type === 'mcq') finalHtml = finalHtml.replace('class="nk-mcq-block"', 'class="nk-mcq-block" tabindex="0"');
                    if (item.type === 'timeline') finalHtml = finalHtml.replace('class="nk-timeline-block"', 'class="nk-timeline-block" tabindex="0"');
                    if (item.type === 'chart') finalHtml = finalHtml.replace('class="chart-container"', 'class="chart-container" tabindex="0"');
                    if (item.type === 'accordion') {
                        const accordionWithTabindex = finalHtml.replace('class="nk-accordion"', 'class="nk-accordion" tabindex="0"');
                        finalHtml = `<div>${accordionWithTabindex}</div>`;
                    }
                    return finalHtml;
                } else {
                    return `<div class="snippet" tabindex="0" onclick="App.events.toggleSnippetVisibility(event)">${item.html}</div>`;
                }
            }).join('');

            overlay.innerHTML = `
                <div id="blackout-screen"></div> <div id="whiteboard-screen"></div> 
                <div class="laser-pointer" id="laser-pointer" style="display: none;"></div>
                <div class="focus-mode-content" tabindex="-1">
                    <h1 class="focus-mode-title" onclick="App.events.exitFocusMode(); App.router.navigateTo('article', {id: '${currentArticle.id}', mode: 'read'})">${currentArticle.title}</h1>
                    <div class="focus-mode-body ${!highlightsVisible ? 'hide-snippet-colors' : ''}" style="--focus-mode-font-size: ${fontSize};">
                        <canvas id="annotation-canvas"></canvas> 
                        ${contentHTML}
                    </div>
                </div>
                <div class="focus-mode-controls" id="focus-controls-container"></div>`;
        
            overlay.querySelectorAll('canvas[data-chart-config]').forEach(canvas => {
                App.ui.renderChartOnCanvas(canvas);
            });

            if (session.isStageMode) {
                setTimeout(() => {
                    const bodyEl = overlay.querySelector('.focus-mode-body');
                    if (bodyEl) {
                        session.scrollStops = this._calculateScrollStops(bodyEl);
                        bodyEl.scrollTo({ top: session.scrollStops[session.currentSlideIndex], behavior: 'auto' });

                        const observer = new IntersectionObserver((entries) => {
                            entries.forEach(entry => {
                                const isVisible = entry.isIntersecting;
                                entry.target.classList.toggle('is-visible', isVisible);
                                if (isVisible && session.isCinematicActive && !entry.target.querySelector('img')) {
                                    App.events.typewriter.setup(entry.target);
                                } else if (!isVisible && entry.target === App.events.typewriter.currentSnippet) {
                                    App.events.typewriter.reset();
                                }
                            });
                        }, { root: bodyEl, threshold: 0.8 });
                    
                        bodyEl.querySelectorAll('.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-accordion').forEach(el => observer.observe(el));
                    }
                    this.renderFocusModeControls();
                }, 100);
            } else {
                this.renderFocusModeControls();
            }

            overlay.addEventListener('click', App.events.handleContentClick);
            const bodyEl = overlay.querySelector('.focus-mode-body');
            if (bodyEl) {
                const canvas = overlay.querySelector('#annotation-canvas');
                canvas.width = bodyEl.offsetWidth;
                canvas.height = bodyEl.scrollHeight;
                bodyEl.addEventListener('scroll', () => { if(App.annotationEngine.state.isActive && App.annotationEngine.state.context === 'focus') App.annotationEngine.redrawPageAnnotations(); });
                bodyEl.addEventListener('mouseover', App.events.handleSpotlight);
                bodyEl.addEventListener('mouseout', App.events.handleSpotlight);
            }
            overlay.querySelector('.focus-mode-content').focus();
        },

         renderFocusModeControls() {
            const session = App.state.focusSession;
            const container = document.getElementById('focus-controls-container');
            if (!container) return;

            const isPremium = App.license.isPremium();
            const premiumLockClass = App.license.isPremium() ? '' : 'premium-feature-locked';

            let controlsHTML = '';
            const isStageMode = session.isStageMode;
            const highlightsVisible = App.settings.get('categoryHighlightsVisible') !== false;
            const themeIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg>`;
            const stageModeToggleIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM8 17H6v-2h2v2zm4 0h-2v-2h2v2zm4 0h-2v-2h2v2z"/></svg>`;
            const highlighterIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="1.8" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 012.829-5.185l7.423-2.119a2.25 2.25 0 001.624-1.624l2.119-7.423a4.5 4.5 0 015.185-2.829l2.846.813L15.904 9.813a2.25 2.25 0 00-1.624 1.624l-2.119 7.423z" /><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 16.5h2.25a2.25 2.25 0 002.25-2.25V6.75" /></svg>`;

            if (isStageMode) {
                const slideCount = session.scrollStops ? session.scrollStops.length : 0;
                const progressDots = Array.from({ length: slideCount }, (_, i) => 
                    `<div class="progress-dot ${i === session.currentSlideIndex ? 'active' : ''}" onclick="App.state.focusSession.currentSlideIndex=${i}; App.events.navigateStageSlide(0);"></div>`
                ).join('');

                container.className = 'stage-mode-controls';

                const cinematicIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m2 6 3 3 3-3 3 3 3-3 3 3 3-3"/><path d="M2 12l3 3 3-3 3 3 3-3 3 3 3-3"/><path d="M2 18l3 3 3-3 3 3 3-3 3 3 3-3"/></svg>`;
                const cinematicActive = session.isCinematicActive;
                
                const cinematicOnClick = isPremium ? "App.events.presentation.toggleCinematicMotion(this)" : "App.ui.showToast('Cinematic Reveal is a Premium feature.', 'info')";
                const annotationOnClick = isPremium ? "App.annotationEngine.toggle('focus')" : "App.ui.showToast('Live Annotation is a Premium feature.', 'info')";
                const exportOnClick = isPremium ? "App.events.exportCurrentSlide()" : "App.ui.showToast('Copying slides is a Premium feature.', 'info')";


                container.className = 'stage-mode-controls';
                controlsHTML = `
                    <button class="btn-icon" onclick="App.events.navigateStageSlide(-1)" title="Previous Slide (â†)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg></button>
                    <div class="stage-progress-indicator" title="Jump to slide">${progressDots}</div>
                    <button class="btn-icon" onclick="App.events.navigateStageSlide(1)" title="Next Slide (â†’)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" /></svg></button>
                    <div class="control-divider"></div>

                    <button class="btn-icon" id="teleprompter-toggle-btn" onclick="App.events.presentation.toggleTeleprompter()" title="Toggle Teleprompter (i)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M6 3h8a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zM4 2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h1v-1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h1V2H4z"/><path d="M7 5.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/></svg>
                    </button>
                    <button class="btn-icon ${highlightsVisible ? 'active' : ''}" onclick="App.events.toggleStageModeHighlights(this)" title="Toggle Highlight Colors (H)">${highlighterIcon}</button>

                    <div class="${premiumLockClass}">
                        <button class="btn-icon ${cinematicActive ? 'active' : ''}" onclick="${cinematicOnClick}" title="Toggle Cinematic Reveal">${cinematicIcon}</button>
                    </div>
                <div class="${premiumLockClass}">
                        <button class="btn-icon annotation-btn" onclick="${annotationOnClick}" title="Toggle Annotation (D)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" /></svg>
                        </button>
                    </div>
                    <div class="${premiumLockClass}">
                        <button class="btn-icon" onclick="${exportOnClick}" title="Copy Slide Image (P)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.774 48.774 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" /><path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z" /></svg>
                        </button>
                    </div>
                    <button class="btn-icon" id="laser-pointer-toggle" title="Toggle Laser Pointer (L)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.042 21.672L13.684 16.6m0 0l-2.51 2.225.569-9.47 5.227 7.917-3.286-.672zM12 2.25a8.25 8.25 0 00-8.25 8.25c0 1.721.576 3.322 1.568 4.675A8.25 8.25 0 0012 21.75a8.25 8.25 0 008.25-8.25c0-4.556-3.694-8.25-8.25-8.25z" /></svg></button>
                    <button class="btn-icon" onclick="App.events.toggleStageMode()" title="Exit Stage Mode (Esc)">${stageModeToggleIcon}</button>
                `;
            } else { // Standard Focus Mode
                const fontSize = App.settings.get('focusModeFontSize') || '1.1rem';
                const isControlsHidden = document.querySelector('.focus-mode-overlay')?.classList.contains('controls-hidden');
                const stageModeToggleIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 17.25v1.007a3 3 0 01-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0115 18.257V17.25m6-12V15a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 15V5.25A2.25 2.25 0 015.25 3h13.5A2.25 2.25 0 0121 5.25z" /></svg>`;
                container.className = 'focus-mode-controls';
                controlsHTML = `
                    <button id="focus-mode-immersive-toggle" class="btn-icon immersive-toggle-btn" onclick="App.events.toggleFocusModeControls()" title="${isControlsHidden ? 'Show Controls' : 'Hide Controls'}">${isControlsHidden ? App.util.icons.eyeOpen : App.util.icons.eyeClosed}</button>    
                    <button class="btn-icon" onclick="App.events.toggleStageMode()" title="Enter Stage Mode">${stageModeToggleIcon}</button>
                    <button class="btn-icon" onclick="App.events.presentation.cycleAmbiance()" oncontextmenu="event.preventDefault(); App.events.presentation.cycleAmbiance(true);" title="Cycle Ambiance (C, Right-click to go back)">${themeIcon}</button>

                    <button id="focus-font-size-btn" class="btn-icon" onclick="App.events.toggleFocusModeFontSize(this)" title="Cycle Font Size (F)"><span style="font-weight: 700; font-size: 1rem;">${fontSize.replace('rem','')}</span></button>
                    <button class="btn-icon ${highlightsVisible ? 'active' : ''}" onclick="App.events.toggleFocusModeHighlights(this)" title="Toggle Highlight Colors (s)">${highlighterIcon}</button>
                    <button class="btn-icon" onclick="App.events.navigateFocusMode(-1)" title="Previous Article (â†)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg></button>
                    <button class="btn-icon" onclick="App.events.navigateFocusMode(1)" title="Next Article (â†’)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" /></svg></button>
                    <button class="btn-icon btn-danger" onclick="App.events.exitFocusMode()" title="Exit Focus Mode (Esc)">${App.util.icons.close}</button>
                    
                `;
            }
            container.innerHTML = controlsHTML;
            const laserToggle = document.getElementById('laser-pointer-toggle');
            if (laserToggle) {
                laserToggle.onclick = App.events.toggleLaserPointer;
                laserToggle.classList.toggle('active', document.querySelector('.focus-mode-overlay.laser-active') !== null);
            }
        },

       _calculateScrollStops(bodyEl) {
            
            const elements = Array.from(bodyEl.querySelectorAll('.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-accordion'));

            if (elements.length === 0) return [0];

            const containerHeight = bodyEl.clientHeight;
            const scrollStops = [];
            let currentPageElements = [];
            let currentPageHeight = 0;
            const verticalMargin = 16;

            elements.forEach((el) => {
                const elHeight = el.offsetHeight;
                if (elHeight > containerHeight) {
                    if (currentPageElements.length > 0) { scrollStops.push(currentPageElements[0].offsetTop); }
                    scrollStops.push(el.offsetTop);
                    currentPageElements = []; currentPageHeight = 0; return;
                }
                if (currentPageHeight + elHeight + (currentPageElements.length > 0 ? verticalMargin : 0) > containerHeight) {
                    scrollStops.push(currentPageElements[0].offsetTop);
                    currentPageElements = [el]; currentPageHeight = elHeight;
                } else {
                    currentPageElements.push(el);
                    currentPageHeight += elHeight + (currentPageElements.length > 1 ? verticalMargin : 0);
                }
            });

            if (currentPageElements.length > 0) { scrollStops.push(currentPageElements[0].offsetTop); }
            if (scrollStops.length > 0) { scrollStops[0] = 0; }

            return scrollStops.length > 0 ? scrollStops : [0];
        },

        migrationScreen: {
            state: { isCancelled: false },

            show(title = "Migrating Data") {
                this.state.isCancelled = false; // Reset cancellation state on every new operation
                const overlay = document.createElement('div');
                overlay.id = 'migration-overlay';
                overlay.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(var(--bg-primary-rgb), 0.8); backdrop-filter: blur(4px);
                    z-index: 100000; display: flex; align-items: center; justify-content: center;
                    animation: fadeIn 0.3s;
                `;

                const dynamicStyles = `
                    <style>
                        @keyframes migration-card-glow {
                            from { box-shadow: 0 0 8px -4px var(--primary-color); border-color: var(--primary-color); }
                            to { box-shadow: 0 0 20px 2px color-mix(in srgb, var(--primary-color) 40%, transparent); border-color: color-mix(in srgb, var(--primary-color) 70%, transparent); }
                        }
                        @keyframes gradient-pan {
                            0% { background-position: 0% 50%; }
                            50% { background-position: 100% 50%; }
                            100% { background-position: 0% 50%; }
                        }
                        .migration-card-glowing {
                            border: 1.5px solid var(--primary-color);
                            animation: migration-card-glow 2.5s infinite alternate ease-in-out;
                        }
                        .migration-title-gradient {
                            background: linear-gradient(45deg, #FF8C42, #FFD05A, #00A896, #A2E869, #05A387);
                            background-size: 250% 250%;
                            -webkit-background-clip: text;
                            background-clip: text;
                            -webkit-text-fill-color: transparent;
                            animation: gradient-pan 10s ease infinite;
                        }
                        .migration-cancel-btn-styled {
                            background-color: transparent;
                            border: 1px solid var(--border-color);
                            color: var(--text-secondary);
                            transition: all 0.2s ease-in-out;
                        }
                        .migration-cancel-btn-styled:hover {
                            background-color: color-mix(in srgb, var(--danger-color) 10%, transparent);
                            border-color: var(--danger-color);
                            color: var(--danger-color);
                            transform: translateY(-1px);
                        }
                        .migration-progress-gradient {
                            background: linear-gradient(90deg, var(--pomo-color-1), var(--pomo-color-3), var(--pomo-color-5), var(--pomo-color-7), var(--pomo-color-9));
                        }
                    </style>
                `;

                overlay.innerHTML = `
                    ${dynamicStyles}
                    <div class="ui-card migration-card-glowing" style="width: 90%; max-width: 450px; padding: 2rem; text-align: center; display: flex; flex-direction: column; gap: 1rem;">
                        <div id="migration-spinner" class="spin" style="font-size: 2rem; color: var(--primary-color); margin: 0 auto;">
                            ${App.util.icons.cycle}
                        </div>
                        
                        <h2 id="migration-title" class="migration-title-gradient" style="font-family: var(--font-display); font-size: 1.75rem; margin: -0.5rem 0 0 0;">${title}</h2>
                        
                        <p id="migration-status" style="color: var(--text-secondary); min-height: 1.5em;"></p>
                        
                        <div style="width: 100%; background: var(--bg-tertiary); border-radius: 8px; overflow: hidden; margin-top: 0.5rem;">
                            <div id="migration-progress-bar" class="migration-progress-gradient" style="width: 0%; height: 8px; transition: width 0.3s ease;"></div>
                        </div>

                        <button id="migration-cancel-btn" class="btn migration-cancel-btn-styled" style="margin-top: 1.5rem; width: 50%; align-self: center;">Cancel</button>
                    </div>
                `;
                document.body.appendChild(overlay);

                document.getElementById('migration-cancel-btn').onclick = async () => {
                    this.state.isCancelled = true;
                    App.ui.showToast('Operation cancelled by user.', 'warning');
                    
                    // Update the plan file to reflect the cancellation
                    try {
                        const plan = await App.fs.read('_category_operation_plan.json');
                        if (plan) {
                            plan.status = 'cancelled';
                            await App.fs.write('_category_operation_plan.json', plan);
                        }
                    } catch (e) {
                        console.error("Could not update operation plan to 'cancelled':", e);
                    }

                    this.hide();
                };
            },

            update(progress, statusText) {
                const bar = document.getElementById('migration-progress-bar');
                const status = document.getElementById('migration-status');
                if (bar) bar.style.width = `${progress}%`;
                if (status) status.textContent = statusText;
            },

            hide() {
                const overlay = document.getElementById('migration-overlay');
                if (overlay) overlay.remove();
            }
        },


        applyTheme(theme, isInitialLoad = false) {
            const isCustom = theme === 'custom';
            const baseTheme = App.settings.get('customThemeBase');
            document.documentElement.setAttribute('data-theme', isCustom ? baseTheme : theme);

            const bgImage = App.settings.get('backgroundImage');
            const hasBgImage = isCustom && !!bgImage;
            document.body.classList.toggle('image-theme-active', hasBgImage);
            document.getElementById('app-background').style.backgroundImage = hasBgImage ? `url(${bgImage})` : 'none';

            const opacity = App.settings.get('uiOpacity');
            document.documentElement.style.setProperty('--ui-opacity', opacity);
            const blurIntensity = parseFloat(opacity) === 0 ? '0px' : '8px';
            document.documentElement.style.setProperty('--blur-intensity', blurIntensity);
            document.documentElement.classList.toggle('zero-opacity-active', parseFloat(opacity) === 0);

            if (!isInitialLoad) {
                App.settings.set('theme', theme);
            }

            setTimeout(() => {
                const primaryBg = getComputedStyle(document.documentElement).getPropertyValue('--bg-primary').trim();
                const secondaryBg = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary').trim();
                const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
                const primaryRgb = App.util.colorToRgb(primaryBg);
                const secondaryRgb = App.util.colorToRgb(secondaryBg);
                const primaryColorRgb = App.util.colorToRgb(primaryColor);
                if(primaryRgb) document.documentElement.style.setProperty('--bg-primary-rgb', primaryRgb.join(','));
                if(secondaryRgb) document.documentElement.style.setProperty('--bg-secondary-rgb', secondaryRgb.join(','));
                if(primaryColorRgb) document.documentElement.style.setProperty('--primary-color-rgb', primaryColorRgb.join(','));

                const activeView = App.router.getActiveView();
                if (activeView === 'library') {
                    const toggleButton = document.getElementById('category-name-toggle');
                    if (toggleButton) {
                        let newIcon;
                        switch (theme) {
                            case 'sepia': newIcon = 'ðŸŸ¤'; break;
                            case 'dark': newIcon = 'ðŸŸ '; break;
                            case 'custom':
                                const customBase = App.settings.get('customThemeBase');
                                newIcon = (customBase === 'dark') ? 'ðŸŸ ' : 'ðŸŸ¢';
                                break;
                            case 'light': default: newIcon = 'ðŸŸ¢'; break;
                        }
                        toggleButton.innerHTML = newIcon;
                    }
                }

                const currentAactiveView = App.router.getActiveView();
                if (currentAactiveView === 'article') {
                    const contentDiv = document.getElementById('article-content');
                    if (contentDiv) {
                        contentDiv.querySelectorAll('canvas[data-chart-config]').forEach(canvas => App.ui.renderChartOnCanvas(canvas));
                    }
                } else if (currentActiveView === 'stats-dashboard') {
                    const viewContainer = document.getElementById('stats-dashboard-view');
                    const monthSelect = document.getElementById('stats-month-select');
                    const yearSelect = document.getElementById('stats-year-select');
                    if (viewContainer && monthSelect && yearSelect) {
                        const currentMonth = parseInt(monthSelect.value);
                        const currentYear = parseInt(yearSelect.value);
                        App.ui.renderStatsDashboardView(viewContainer, { month: currentMonth, year: currentYear });
                    }
                }
            }, 50);
        },

        applyMobileView() {
            const enabled = App.settings.get('mobileViewEnabled');
            document.body.classList.toggle('mobile-view', enabled);

            const toggleSwitch = document.getElementById('mobile-view-toggle');
            const labelContainer = document.getElementById('mobile-view-label-container');

            if (toggleSwitch) {
                toggleSwitch.classList.toggle('active', enabled);
            }
            if (labelContainer) {
                // NEW: More intuitive labels
                const label = enabled ? 'Switch to Desktop View' : 'Switch to Mobile View';
                const description = enabled ? 'For utilizing full power of App' : 'Optimized for small screens & touch.';
                labelContainer.innerHTML = `<b>${label}</b><small>${description}</small>`;
            }
        },

        applyFontSettings() {
            const family = App.settings.get('fontFamily');
            const size = App.settings.get('fontSize');
            const lineHeight = App.settings.get('lineHeight');
            document.documentElement.style.setProperty('--article-font-family', family);
            document.documentElement.style.setProperty('--article-font-size', size);
            document.documentElement.style.setProperty('--article-line-height', lineHeight);
        },

         updateHeaderState() {
            const newArticleBtn = document.getElementById('new-article-btn');
            if (!newArticleBtn) return;

            if (App.state.storageMode === 'fileSystem' && !App.state.directoryHandle) {
                newArticleBtn.disabled = true;
                newArticleBtn.classList.remove('limit-reached');
                newArticleBtn.title = 'Select a folder to begin';
                return;
            }

            newArticleBtn.disabled = false;
            const isPremium = App.license.isPremium();
            const articleLimit = App.config.sparkTierLimit;
            const articlesUsed = App.state.articles.length;
            const canCreateArticle = isPremium || articlesUsed < articleLimit;

            newArticleBtn.classList.toggle('limit-reached', !canCreateArticle);

            if (!canCreateArticle) {
                newArticleBtn.title = `Spark plan limit of ${articleLimit} notes reached. Go Premium for unlimited notes.`;
                newArticleBtn.onclick = () => App.ui.showAscensionModal();
            } else {
                newArticleBtn.title = 'New Article (Alt+Shift+N)';
                newArticleBtn.onclick = () => App.events.createNewArticle();
            }
        },

        applyReaderTheme() {
            const wrapper = document.querySelector('.article-view-wrapper');
            if (!wrapper) return;
            const theme = App.state.activeReaderTheme;
            wrapper.className = wrapper.className.replace(/\bambiance-\S+/g, '').trim();

            if (theme !== 'default') {
                wrapper.classList.add(`ambiance-${theme}`);
            }
        },
        applyStudyTheme() {
            const studyView = document.querySelector('.study-view');
            if (!studyView) return;
            const theme = App.state.studySession.activeTheme;

            studyView.className = studyView.className.replace(/\bambiance-\S+/g, '').trim();

            if (theme !== 'default') {
                studyView.classList.add(`ambiance-${theme}`);
            }
        },

        showSelectionToolbar(range) {
            const toolbar = document.getElementById('selection-toolbar');

           
            const icons = {
                drag: `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="5" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="12" cy="19" r="1"/></svg>`,
                palette: `<svg viewBox="0 0 24 24" width="23" height="23" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg>`,
                tag: `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="9" x2="20" y2="9"/><line x1="4" y1="15" x2="20" y2="15"/><line x1="10" y1="3" x2="8" y2="21"/><line x1="16" y1="3" x2="14" y2="21"/></svg>`,
                cloze: `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"/><path d="M2 12h20"/><path d="M17 2v5"/><path d="M7 2v5"/></svg>`,
                aiMagic: `<svg viewBox="0 0 24 24" width="20" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v2.35M10.15 6.344l-1.493-1.493M6.344 10.15l-2.187-2.187M3 12h2.35M6.344 13.85l-2.187 2.187M10.15 17.656l-1.493 1.493M12 21v-2.35M13.85 17.656l1.493 1.493M17.656 13.85l2.187 2.187M21 12h-2.35M17.656 10.15l2.187-2.187M13.85 6.344l1.493-1.493"/><circle cx="12" cy="12" r="2.35"/></svg>`,

                clear: `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 12.5h10.5M11 12.5a5 5 0 0 1-5-5V4.5"/><path d="M4 4.5h10.5"/><path d="M4 19.5h10.5"/><path d="m18 10-2-2 2-2"/><path d="m21 17-2-2 2-2"/></svg>`,
                orientation: `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M4 6h16M4 12h16M4 18h16"/></svg>`
            };
            
            
            const highlightButtons = App.config.highlightClasses.slice(0, 6).map((cls, i) =>
                `<button class="btn-icon highlight-btn" 
                    style="background-color:var(--${cls.replace('highlight-','hl-')}-bg); border:1px solid var(--${cls.replace('highlight-','hl-')}-border);" 
                    title="Highlight (Cmd+Shift+${i+2})" onmousedown="event.preventDefault(); App.events.applyFormatting('class', '${cls}')"></button>`
            ).join('');

      
            toolbar.innerHTML = `
                <div class="toolbar-wrapper">
                    <div class="toolbar-drag-handle" title="Drag Toolbar">${icons.drag}</div>
                    <button id="ai-magic-btn" class="btn-icon" title="AI Magic âœ¨ (Ctrl+J)">${icons.aiMagic}</button>
                    <div class="control-divider"></div>
                    <button class="btn-icon" title="Cycle Colors" onmousedown="event.preventDefault(); App.events.cycleColorFormatting()">${icons.palette}</button>
                    ${highlightButtons}
                    <div class="control-divider"></div>
                    <button class="btn-icon" title="Create Tag [[...]]" onmousedown="event.preventDefault(); App.contentTools.tagSelection()">${icons.tag}</button>
                    <button class="btn-icon" title="Create Cloze Flashcard" onmousedown="event.preventDefault(); App.events.applyFormatting('cloze')">${icons.cloze}</button>  
                    <button class="btn-icon" title="Remove Formatting" onmousedown="event.preventDefault(); App.events.removeFormatting()">${icons.clear}</button>
                    <button class="btn-icon" id="toolbar-orientation-toggle" title="Toggle Layout">${icons.orientation}</button>
                </div>
            `;

           
            const rect = range.getBoundingClientRect();
            toolbar.style.display = 'block';
            const isMobileView = document.body.classList.contains('mobile-view');
            let topPos, leftPos;
            if (isMobileView) {
                topPos = rect.bottom + window.scrollY + 8;
                leftPos = rect.left + window.scrollX + rect.width / 2 - toolbar.offsetWidth / 2;
            } else {
                topPos = rect.top + window.scrollY - toolbar.offsetHeight - 8;
                leftPos = rect.left + window.scrollX + rect.width / 2 - toolbar.offsetWidth / 2;
            }
            const wrapper = toolbar.querySelector('.toolbar-wrapper');
            const dragHandle = toolbar.querySelector('.toolbar-drag-handle');
            const toggleBtn = document.getElementById('toolbar-orientation-toggle');
            let state = { x: leftPos, y: topPos, orientation: 'horizontal' };
            if (!isMobileView) {
                try {
                    const savedState = JSON.parse(localStorage.getItem('noteKashToolbarState'));
                    if (savedState) {
                        state.orientation = savedState.orientation ?? 'horizontal';
                        const toolbarWidth = toolbar.offsetWidth, toolbarHeight = toolbar.offsetHeight, margin = 10, headerHeight = 48;
                        if (savedState.x > margin && savedState.x + toolbarWidth < window.innerWidth - margin && savedState.y > headerHeight && savedState.y + toolbarHeight < window.innerHeight - margin) {
                            state.x = savedState.x; state.y = savedState.y;
                        }
                    }
                } catch(e) { console.warn("Could not parse toolbar state."); }
            }
            toolbar.style.left = `${state.x < 5 ? 5 : state.x}px`;
            toolbar.style.top = `${state.y}px`;
            if (state.orientation === 'vertical') {
                wrapper.classList.add('vertical');
                toggleBtn.querySelector('svg').style.transform = 'rotate(90deg)';
            }
            const saveState = () => {
                const currentRect = toolbar.getBoundingClientRect();
                localStorage.setItem('noteKashToolbarState', JSON.stringify({
                    x: currentRect.left + window.scrollX, y: currentRect.top + window.scrollY,
                    orientation: wrapper.classList.contains('vertical') ? 'vertical' : 'horizontal'
                }));
            };

            document.getElementById('ai-magic-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                App.ui.hideSelectionToolbar();
                App.ui.aiMagicModal.open();
            });

            toggleBtn.addEventListener('click', (e) => {
                e.preventDefault();
                wrapper.classList.toggle('vertical');
                toggleBtn.querySelector('svg').style.transform = wrapper.classList.contains('vertical') ? 'rotate(90deg)' : 'rotate(0deg)';
                saveState();
            });

            let offsetX, offsetY;
            const move = (e) => { const newX = (e.touches ? e.touches[0].clientX : e.clientX) - offsetX; const newY = (e.touches ? e.touches[0].clientY : e.clientY) - offsetY; toolbar.style.left = `${newX}px`; toolbar.style.top = `${newY}px`; };
            const up = () => { document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); document.removeEventListener('touchmove', move); document.removeEventListener('touchend', up); saveState(); };
            const down = (e) => { e.preventDefault(); const r = toolbar.getBoundingClientRect(); offsetX = (e.touches ? e.touches[0].clientX : e.clientX) - r.left; offsetY = (e.touches ? e.touches[0].clientY : e.clientY) - r.top; document.addEventListener('mousemove', move); document.addEventListener('mouseup', up); document.addEventListener('touchmove', move); document.addEventListener('touchend', up); };
            dragHandle.addEventListener('mousedown', down);
            dragHandle.addEventListener('touchstart', down, { passive: false });
        },


        hideSelectionToolbar() { document.getElementById('selection-toolbar').style.display = 'none'; },
        
        
        showImageToolbar(imageContainer) {
            const toolbar = document.getElementById('image-toolbar');
            const isHighlighted = imageContainer.classList.contains('highlighted-image');
            const isWriteMode = App.state.currentMode === 'write';

            const toolsPopover = `
                <div class="list-toolbar-group" id="image-tools-group">
                    <button class="btn-icon" title="More Image Tools" aria-label="More image tools">
                        <i class="fa-solid fa-ellipsis-vertical"></i>
                    </button>
                    <div class="list-popover">
                        <button class="btn-icon ${!App.license.isPremium() ? 'premium-feature-locked' : ''}" title="Extract Text from Image (OCR)" onmousedown="event.preventDefault(); if (App.license.isPremium()) App.services.image.runOCR(); else App.ui.showAscensionModal();">
                            <i class="fa-solid fa-file-pen"></i>
                        </button>
                        <button class="btn-icon" title="Copy Image" onmousedown="event.preventDefault(); App.services.image.copy(App.state.selectedImageContainer);">${App.util.icons.copy}</button>
                        <button class="btn-icon" title="Reset Size" onmousedown="event.preventDefault(); App.events.handleImageAlignment('reset-size');">${App.util.icons.reset}</button>
                        ${isWriteMode ? `<button class="btn-icon" title="Delete Image" onmousedown="event.preventDefault(); App.services.image.delete(App.state.selectedImageContainer);">${App.util.icons.trash}</button>` : ''}
                    </div>
                </div>
            `;

            const toolbarButtons = `
                <button class="btn-icon" title="Align Left" onmousedown="event.preventDefault(); App.events.handleImageAlignment('align-left');">${App.util.icons.alignLeft}</button>
                <button class="btn-icon" title="Align Center" onmousedown="event.preventDefault(); App.events.handleImageAlignment('align-center');">${App.util.icons.alignCenter}</button>
                <button class="btn-icon" title="Align Right" onmousedown="event.preventDefault(); App.events.handleImageAlignment('align-right');">${App.util.icons.alignRight}</button>
                <div class="control-divider"></div>
                <button class="btn-icon" title="Highlight Image" onmousedown="event.preventDefault(); App.events.highlightImage();" style="color: ${isHighlighted ? 'var(--primary-color)' : 'inherit'}">${isHighlighted ? App.util.icons.star : App.util.icons.starOutline}</button>
                <button class="btn-icon" title="View Fullscreen" onmousedown="event.preventDefault(); App.ui.imageLightbox.open(App.state.selectedImageContainer);">${App.util.icons.expand}</button>
                ${isWriteMode ? `<button class="btn-icon" title="Add/Edit Caption" onmousedown="event.preventDefault(); App.events.addImageCaption();">${App.util.icons.caption}</button>` : ''}
                <div class="control-divider"></div>
                ${toolsPopover}
            `;

            toolbar.innerHTML = `<div class="toolbar-wrapper">${toolbarButtons}</div>`;
            const rect = imageContainer.getBoundingClientRect();
            toolbar.style.display = 'block';
            toolbar.style.left = `${rect.left + window.scrollX + rect.width / 2 - toolbar.offsetWidth / 2}px`;
            toolbar.style.top = `${rect.top + window.scrollY - toolbar.offsetHeight - 8}px`;
        },
        
        

        hideImageToolbar() { document.getElementById('image-toolbar').style.display = 'none'; },

        aiMagicModal: {
            state: {
                isOpen: false,
                savedRange: null,
                commands: [],
                filteredCommands: [],
                selectedIndex: 0,
                fuse: null,
            },
            
            init() {
                this._handleKeyDown = this._handleKeyDown.bind(this);
            },

            open() {
                if (this.state.isOpen) return;

                const selection = window.getSelection();
                this.state.savedRange = (selection && !selection.isCollapsed && selection.rangeCount > 0)
                    ? selection.getRangeAt(0).cloneRange()
                    : null;

                this.state.isOpen = true;
                this.state.commands = this._getCommands();
                this.state.fuse = new Fuse(this.state.commands.filter(c => c.type !== 'separator'), { keys: ['title', 'desc', 'id'], threshold: 0.4 });
                this.state.filteredCommands = this.state.commands;
                this.state.selectedIndex = -1;

                const modalHTML = `
                    <div class="ai-magic-backdrop">
                        <div class="ai-magic-modal">
                            <div class="ai-magic-header">
                                <h3 class="ai-magic-title witty-gradient-text">NoteKash AI Co-Pilot</h3>
                                <div class="ai-magic-prompt-container">
                                    <input type="text" id="ai-magic-prompt-input" placeholder="Search or Ask AI anything ..." autocomplete="off">
                                    <button id="ai-magic-prompt-send" class="btn-icon btn-primary" title="Ask AI">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
                                            <path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div id="ai-magic-command-list"></div>
                        </div>
                    </div>`;
                
                document.getElementById('modal-container').innerHTML = modalHTML;

                // THE FIX: Add the event listener ONLY when the modal opens.
                document.addEventListener('keydown', this._handleKeyDown, true);
                
                this._renderCommands();
                this._addListeners();
                document.getElementById('ai-magic-prompt-input').focus();
            },

            close() {
                if (!this.state.isOpen) return;
                this.state.isOpen = false;
                this.state.savedRange = null;
                document.getElementById('modal-container').innerHTML = '';
                
                document.removeEventListener('keydown', this._handleKeyDown, true);
            },

            _showUpsellCard() {
                const commandListEl = document.getElementById('ai-magic-command-list');
                if (!commandListEl) return;
                const promptContainer = document.querySelector('.ai-magic-prompt-container');
                if (promptContainer) promptContainer.style.display = 'none';

                const wittyMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
                const diamondBadgeHTML = App.util.getTierBadgeHTML('Diamond');

                const upsellHTML = `
                    <div class="ai-upsell-card">
                        ${diamondBadgeHTML}
                        <h4>Unlock Your Thinking Partner</h4>
                        <p>Go Premium to use all 25+ specialized AI tools. Turn raw notes into structured knowledge, get instant insights, and write faster than ever before.</p>
                        <button class="btn btn-primary" onclick="App.ui.showAscensionModal(); App.ui.aiMagicModal.close();">Unlock Full AI Power</button>
                        <p class="witty-gradient-text"><em>"${wittyMessage}"</em></p>
                    </div>
                `;

                commandListEl.innerHTML = upsellHTML;
            },

            _getCommands() {
                const hasSelection = !!this.state.savedRange;
                const allCommands = [
                    // Selection Commands
                    { id: 'kashwriting', title: 'Improve Writing', desc: 'Refine the selected text', icon: 'fa-solid fa-wand-sparkles', action: () => App.events.ai.executeImproveWriting(), selection: true },
                    { id: 'kashgrammar', title: 'Fix Grammar', desc: 'Correct spelling and Grammar ', icon: 'fa-solid fa-pen-nib', action: () => App.events.ai.executeFixGrammar(), selection: true },
                    { id: 'kashexplain', title: 'Explain This', desc: 'Explain the selected concept', icon: 'fa-solid fa-lightbulb', action: () => App.events.ai.executeKashExplain(), selection: true },
                    { id: 'kashflash', title: 'Generate Flashcard', desc: 'Create a cloze from selection', icon: 'fa-solid fa-clone', action: () => App.events.ai.executeKashFlash(), selection: true },
                    { id: 'kashmnemonic', title: 'Create Mnemonic', desc: 'Generate a memory aid', icon: 'fa-solid fa-brain', action: () => App.events.ai.executeKashMnemonic(), selection: true },
                    { id: 'convertMcq', title: 'Convert to MCQ', desc: 'Turn selection into an MCQ block', icon: 'fa-solid fa-list-check', action: () => App.commandPalette.convertSelectionToMcq(), selection: true },
                    { id: 'kashtranslate', title: 'Translate...', desc: 'Translate selection to another language', icon: 'fa-solid fa-earth-americas', action: () => { const lang = prompt('Translate to language:'); if(lang) App.events.ai.executeKashTranslate(lang); }, selection: true },
                    { id: 'kashlist', title: 'Convert to List', desc: 'Restructure selection as a list', icon: 'fa-solid fa-list-ul', action: () => App.events.ai.executeKashListify(), selection: true },
                    { id: 'kashtable', title: 'Convert to Table', desc: 'Restructure selection into a table', icon: 'fa-solid fa-table-cells', action: () => App.events.ai.executeKashTable(), selection: true },

                    // Article-wide Commands
                    { id: 'kashexpand', title: 'Continue Writing', desc: 'Let AI continue from your cursor', icon: 'fa-solid fa-pen-fancy', action: () => App.events.ai.executeKashExpand() },
                    { id: 'kashsummary', title: 'Summarize Article', desc: 'Generate a summary of the entire note', icon: 'fa-solid fa-file-lines', action: () => App.events.ai.executeKashSummary() },
                    { id: 'kashcurate', title: 'Curate & Beautify', desc: 'Let AI structure and format the note', icon: 'fa-solid fa-wand-magic-sparkles', action: () => App.events.ai.executeKashCurate() },
                    { id: 'kashaccordion', title: 'Generate Q&A', desc: 'Create Q&A accordions from the note', icon: 'fa-solid fa-clipboard-question', action: () => App.events.ai.executeKashAccordion() },
                    { id: 'kashmcq', title: 'Generate MCQs', desc: 'Create multiple-choice questions', icon: 'fa-solid fa-list-check', action: () => App.events.ai.executeKashMcqGenerator() },
                    { id: 'kashhighlight', title: 'Auto-Highlight', desc: 'Highlight key parts of the note', icon: 'fa-solid fa-highlighter', action: () => App.events.ai.executeKashHighlight() },
                    { id: 'kashtags', title: 'Auto-Tag', desc: 'Automatically generate and apply tags', icon: 'fa-solid fa-tags', action: () => App.events.ai.executeKashTags() },
                    { id: 'kashkeywords', title: 'Extract Key Concepts', desc: 'Pull out main ideas into a Deck', icon: 'fa-solid fa-key', action: () => App.events.ai.executeKashKeywords() },
                    { id: 'kashtimeline', title: 'Create Timeline', desc: 'Generate a timeline from the note', icon: 'fa-solid fa-timeline', action: () => App.events.ai.executeKashTimeline() },

                    // --- NEWLY ADDED COMMANDS ---
                    { id: 'kashcraft', title: 'KashCraft Analysis', desc: 'Transform note into a structured analysis', icon: 'fa-solid fa-graduation-cap', action: () => App.events.ai.executeKashCraft() },
                    { id: 'kashextract', title: 'Extract Topic...', desc: 'Extract a specific topic from the note', icon: 'fa-solid fa-magnifying-glass-chart', action: () => { const topic = prompt('What topic do you want to extract? (e.g., key arguments, dates)'); if (topic) App.events.ai.executeKashExtract(topic); } },
                    { id: 'kashlink', title: 'Create & Link Note...', desc: 'Generate a new note on a topic and link it', icon: 'fa-solid fa-link', action: () => { const topic = prompt('What topic for the new note?'); if (topic) App.events.ai.executeKashLink(topic); } },
                    { id: 'kashlong', title: 'Detailed Summary', desc: 'Generate a long, detailed summary of the note', icon: 'fa-solid fa-file-export', action: () => App.events.ai.executeKashLong() },
                    { id: 'kashoutline', title: 'Generate Outline...', desc: 'Create an outline for a new topic', icon: 'fa-solid fa-list-ol', action: () => { const topic = prompt('What topic do you want an outline for?'); if (topic) App.events.ai.executeKashOutline(topic); } },
                    // --- END OF NEW COMMANDS ---

                    { id: 'kashsplit', title: 'Split Note', desc: 'Intelligently split this note into two', icon: 'fa-solid fa-scissors', action: () => App.events.ai.executeKashSplit() },
                    { id: 'kashquote', title: 'Find a Quote', desc: 'Add a relevant quote to your note', icon: 'fa-solid fa-quote-left', action: () => App.events.ai.executeKashQuote() },
                    { id: 'kashstory', title: 'Write a Story', desc: 'Turn the note into a memorable story', icon: 'fa-solid fa-book-open', action: () => App.events.ai.executeKashStory() },
                    { id: 'kashscript', title: 'Write a Script', desc: 'Generate a short video script', icon: 'fa-solid fa-clapperboard', action: () => App.events.ai.executeKashScript() },
                    { id: 'kashcomedy', title: 'Make it Funny', desc: 'Turn the note into a comedy routine', icon: 'fa-solid fa-masks-theater', action: () => App.events.ai.executeKashComedy() },
                    { id: 'kashquestion', title: 'Generate Questions', desc: 'Create study questions from the note', icon: 'fa-solid fa-circle-question', action: () => App.events.ai.executeKashQuestion() },
                    { id: 'kashdebate', title: 'Create a Debate', desc: 'Generate a pros and cons table', icon: 'fa-solid fa-scale-balanced', action: () => App.events.ai.executeKashDebate() },
                ];
                
                const selectionCommands = allCommands.filter(cmd => cmd.selection);
                const articleCommands = allCommands.filter(cmd => !cmd.selection);

                if (hasSelection) {
                    return [...selectionCommands, { type: 'separator' }, ...articleCommands];
                }
                return articleCommands;
            },

            _renderCommands() {
                const listEl = document.getElementById('ai-magic-command-list');
                if (!listEl) return;

             
                const numColumns = Math.floor(listEl.offsetWidth / 195); // Approx width of a tile + gap
                const isCompact = this.state.filteredCommands.length < numColumns && this.state.filteredCommands.length > 0;
                listEl.classList.toggle('compact-grid', isCompact);

                const html = this.state.filteredCommands.map((cmd, index) => {
                    if (cmd.type === 'separator') {
                        return '<div class="ai-magic-separator"></div>';
                    }
                    const isSelected = this.state.selectedIndex === index; // Check against visual index
                    
                    const itemHTML = `
                        <div class="ai-magic-command-item ${isSelected ? 'selected' : ''}" data-visual-index="${index}" title="${cmd.desc}">
                            <i class="command-icon ${cmd.icon}"></i>
                            <div class="command-text">
                                <div class="command-title">${cmd.title}</div>
                            </div>
                        </div>
                    `;
                    return itemHTML;
                }).join('');

                listEl.innerHTML = html;
            },

            _addListeners() {
                const backdrop = document.querySelector('.ai-magic-backdrop');
                const searchInput = document.getElementById('ai-magic-prompt-input');
                const sendBtn = document.getElementById('ai-magic-prompt-send');
                const commandList = document.getElementById('ai-magic-command-list');

                backdrop.addEventListener('click', (e) => { if (e.target === backdrop) this.close(); });
                
                const handlePrompt = async () => {
                    if (!App.license.isPremium()) {
                        this._showUpsellCard();
                        return; 
                    }
                    const query = searchInput.value.trim();
                    if(query) {
                        // --- SURGICAL FIX #2 STARTS HERE ---
                        const commandListEl = document.getElementById('ai-magic-command-list');
                        if (commandListEl) {
                            commandListEl.innerHTML = `
                            <div class="copilot-empty-state" style="justify-content: center; text-align: center; padding: 2rem;">
                                <div class="spin" style="font-size: 2.5rem; color: var(--primary-color);">${App.util.icons.cycle}</div>
                                <h4 class="witty-gradient-text" style="margin-top: 1rem;">Your Second Brain is thinking...</h4>
                            </div>`;
                        }
                        // --- SURGICAL FIX #2 ENDS HERE ---

                        if (this.state.savedRange) {
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(this.state.savedRange);
                        }
                        const selection = window.getSelection();
                        const context = (selection && !selection.isCollapsed) ? selection.toString() : document.getElementById('article-content').innerText;
                        const fullPrompt = `Based on the following context:\n\n---\n${context}\n---\n\nAnswer this question: ${query}`;
                        
                        await App.events.ai.executeKashAsk(fullPrompt);
                        this.close();
                    }
                };

                sendBtn.addEventListener('click', handlePrompt);
                searchInput.addEventListener('input', () => {
                    const query = searchInput.value;
                    if (query) {
                        this.state.filteredCommands = this.state.fuse.search(query).map(r => r.item);
                    } else {
                        this.state.filteredCommands = this._getCommands();
                    }
                    this.state.selectedIndex = -1;
                    this._renderCommands();
                });

                commandList.addEventListener('click', (e) => {
                    const itemEl = e.target.closest('.ai-magic-command-item');
                    if (itemEl) {
                        if (!App.license.isPremium()) {
                            e.preventDefault();
                            e.stopPropagation();
                            this._showUpsellCard();
                            return; 
                        }
                        this.state.selectedIndex = parseInt(itemEl.dataset.visualIndex, 10);
                        this._executeSelected();
                    }
                });
            },

            _handleKeyDown(e) {
                // CORRECTED: The internal reference must also use the correct name.
                if (!App.ui.aiMagicModal.state.isOpen) return;
                if (e.key === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    this.close();
                    return;
                }
                const items = Array.from(document.querySelectorAll('.ai-magic-command-item'));
                if (items.length === 0 && e.key !== 'Enter') return;
                const isInputFocused = document.activeElement.id === 'ai-magic-prompt-input';
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (isInputFocused) {
                        document.getElementById('ai-magic-prompt-send').click();
                    } else {
                        this._executeSelected();
                    }
                    return;
                }
                // Arrow key navigation logic remains the same.
                if (e.key === 'ArrowUp' && this.state.selectedIndex !== -1) {
                    e.preventDefault();
                    const numColumns = getComputedStyle(document.getElementById('ai-magic-command-list')).gridTemplateColumns.split(' ').length;
                    const newIndex = this.state.selectedIndex - numColumns;
                    if (newIndex < 0) {
                        this.state.selectedIndex = -1;
                        document.getElementById('ai-magic-prompt-input').focus();
                        this._updateSelection();
                    } else {
                        this.state.selectedIndex = newIndex;
                        this._updateSelection();
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const numColumns = getComputedStyle(document.getElementById('ai-magic-command-list')).gridTemplateColumns.split(' ').length;
                    if (isInputFocused) {
                        this.state.selectedIndex = 0;
                    } else {
                        this.state.selectedIndex = Math.min(this.state.selectedIndex + numColumns, items.length - 1);
                    }
                    this._updateSelection();
                } else if (e.key === 'ArrowLeft' && !isInputFocused) {
                    e.preventDefault();
                    this.state.selectedIndex = Math.max(0, this.state.selectedIndex - 1);
                    this._updateSelection();
                } else if (e.key === 'ArrowRight' && !isInputFocused) {
                    e.preventDefault();
                    this.state.selectedIndex = Math.min(this.state.selectedIndex + 1, items.length - 1);
                    this._updateSelection();
                }
            },

            _updateSelection() {
                const items = document.querySelectorAll('.ai-magic-command-item');
                items.forEach((item) => {
                    const visualIndex = parseInt(item.dataset.visualIndex, 10);
                    const isSelected = visualIndex === this.state.selectedIndex;
                    item.classList.toggle('selected', isSelected);
                    if (isSelected) {
                        item.scrollIntoView({ block: 'nearest' });
                    }
                });
            },

            _executeSelected() {
                const command = this.state.filteredCommands[this.state.selectedIndex];
                if (command && command.action) {
                    if (this.state.savedRange) {
                        const selection = window.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(this.state.savedRange);
                    }
                    command.action();
                    this.close();
                }
            }
        },


        imageLightbox: {
            state: {
                scale: 1,
                isDragging: false,
                startPos: { x: 0, y: 0 },
                translatePos: { x: 0, y: 0 }
            },

            open(imageContainer) {
                if (!imageContainer) return;
                const img = imageContainer.querySelector('img');
                if (!img) return;

                this.state = { scale: 1, isDragging: false, startPos: { x: 0, y: 0 }, translatePos: { x: 0, y: 0 } };

                const lightboxHTML = `
                    <div id="image-lightbox-overlay" class="modal-backdrop" style="z-index: 25000; background-color: rgba(0,0,0,0.8);">
                        <div class="lightbox-image-wrapper">
                            <img src="${img.src}" class="lightbox-image" alt="Lightbox image">
                        </div>
                        <div class="lightbox-controls">
                            <button class="btn-icon" id="lightbox-zoom-in" title="Zoom In (+)">${App.util.icons.zoomIn}</button>
                            <button class="btn-icon" id="lightbox-zoom-out" title="Zoom Out (-)">${App.util.icons.zoomOut}</button>
                            <button class="btn-icon" id="lightbox-reset" title="Reset View (R)">${App.util.icons.reset}</button>
                            <button class="btn-icon" id="lightbox-close" title="Close (Esc)">${App.util.icons.close}</button>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', lightboxHTML);
                this.addListeners();
            },
            showAiContextMenu(range) {
                this.hideContextMenu(); // Ensure no other context menus are open
                const rect = range.getBoundingClientRect();
                const x = rect.left + window.scrollX;
                const y = rect.top + window.scrollY - 38; // Position it just above the selection

                const menuHtml = `
                    <button onclick="App.events.ai.executeImproveWriting()">Improve Writing</button>
                    <button onclick="App.events.ai.executeFixGrammar()">Fix Grammar & Spelling</button>
                `;

                this.showContextMenu(x, y, menuHtml);
            },
            close() {
                const overlay = document.getElementById('image-lightbox-overlay');
                if (overlay) overlay.remove();
                document.removeEventListener('keydown', this.handleKeyDown);
            },

            addListeners() {
                const overlay = document.getElementById('image-lightbox-overlay');
                const imageWrapper = overlay.querySelector('.lightbox-image-wrapper');

                document.getElementById('lightbox-zoom-in').addEventListener('click', () => this.zoom(1));
                document.getElementById('lightbox-zoom-out').addEventListener('click', () => this.zoom(-1));
                document.getElementById('lightbox-reset').addEventListener('click', () => this.reset());
                document.getElementById('lightbox-close').addEventListener('click', () => this.close());

                overlay.addEventListener('click', (e) => { if (e.target === overlay) this.close(); });

                imageWrapper.addEventListener('mousedown', (e) => this.startPan(e));
                imageWrapper.addEventListener('mousemove', (e) => this.pan(e));
                imageWrapper.addEventListener('mouseup', () => this.endPan());
                imageWrapper.addEventListener('mouseleave', () => this.endPan());
                imageWrapper.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.zoom(e.deltaY > 0 ? -1 : 1);
                }, { passive: false });

                document.addEventListener('keydown', this.handleKeyDown.bind(this));
            },

            updateTransform() {
                const wrapper = document.querySelector('.lightbox-image-wrapper');
                if (wrapper) {
                    wrapper.style.transform = `translate(${this.state.translatePos.x}px, ${this.state.translatePos.y}px) scale(${this.state.scale})`;
                }
            },

            zoom(direction) {
                const zoomFactor = 1.2;
                this.state.scale *= (direction > 0) ? zoomFactor : (1 / zoomFactor);
                this.state.scale = Math.max(0.5, Math.min(this.state.scale, 8)); // Clamp zoom level

                if (this.state.scale <= 1) this.reset();
                else this.updateTransform();
            },

            reset() {
                this.state.scale = 1;
                this.state.translatePos = { x: 0, y: 0 };
                this.updateTransform();
            },

            startPan(e) {
                if (this.state.scale <= 1) return;
                e.preventDefault();
                this.state.isDragging = true;
                this.state.startPos = { x: e.clientX - this.state.translatePos.x, y: e.clientY - this.state.translatePos.y };
                const wrapper = document.querySelector('.lightbox-image-wrapper');
                if (wrapper) wrapper.style.cursor = 'grabbing';
            },

            pan(e) {
                if (!this.state.isDragging) return;
                this.state.translatePos.x = e.clientX - this.state.startPos.x;
                this.state.translatePos.y = e.clientY - this.state.startPos.y;
                this.updateTransform();
            },

            endPan() {
                this.state.isDragging = false;
                const wrapper = document.querySelector('.lightbox-image-wrapper');
                if (wrapper) wrapper.style.cursor = 'grab';
            },

            handleKeyDown(e) {
                    switch(e.key) {
                        case 'Escape': this.close(); break;
                        case '+': case '=': this.zoom(1); break;
                        case '-': this.zoom(-1); break;
                        case 'r': case '0': this.reset(); break;
                    }
                }
            },
            showContextMenu(x, y, menuHtml) {
                this.hideContextMenu();
                const container = document.getElementById('context-menu-container');
                container.innerHTML = `<div class="context-menu" style="left: ${x}px; top: ${y}px;">${menuHtml}</div>`;
            },
            hideContextMenu() { document.getElementById('context-menu-container').innerHTML = ''; },
            
            showToast(message, options = {}) {
                if (typeof options === 'string') { options = { type: options }; }
                const { type = 'info', duration = 4000, action = null } = options;

                const container = document.getElementById('toast-container');
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.id = `toast-${crypto.randomUUID()}`; // Assign a unique ID for updating

                // Intelligently handle HTML content vs. plain text.
                if (/<[a-z][\s\S]*>/i.test(message)) {
                    toast.innerHTML = message;
                } else {
                    const messageSpan = document.createElement('span');
                    messageSpan.textContent = message;
                    toast.appendChild(messageSpan);
                }

                if (action && action.label && action.callback) {
                    const actionButton = document.createElement('button');
                    actionButton.className = 'btn btn-secondary';
                    actionButton.textContent = action.label;
                    actionButton.onclick = () => { action.callback(); this.hideToast(toast); };
                    actionButton.style.marginLeft = 'auto';
                    toast.appendChild(actionButton);
                }

                container.appendChild(toast);
                setTimeout(() => toast.classList.add('show'), 100);

                if (duration > 0) {
                    setTimeout(() => {
                        this.hideToast(toast);
                    }, duration);
                }
                return toast; 
            },

        
            updateToast(toastIdOrEl, message) {
                const toast = (typeof toastIdOrEl === 'string') ? document.getElementById(toastIdOrEl) : toastIdOrEl;
                if(toast) {
                    const messageHolder = toast.querySelector('span') || toast;
                    if (/<[a-z][\s\S]*>/i.test(message)) {
                        messageHolder.innerHTML = message;
                    } else {
                        messageHolder.textContent = message;
                    }
                }
            },

            hideToast(toastIdOrEl) {
                const toast = (typeof toastIdOrEl === 'string') ? document.getElementById(toastIdOrEl) : toastIdOrEl;
                if (toast) {
                    toast.classList.remove('show');
                    setTimeout(() => toast.remove(), 400);
                }
            },

            showSettingsModal() {
                const isPremium = App.license.isPremium();
                
                const navItems = [
                    { id: 'profile', icon: 'fa-user-circle', label: 'Profile & License', action: 'showLicenseModal', isLocked: false },
                    { id: 'appearance', icon: 'fa-palette', label: 'Appearance Model', action: 'showAppearanceModal', isLocked: false },
                    { id: 'categories', icon: 'fa-folder-tree', label: 'Category Manager', action: 'showCategoryManagerModal', isLocked: false },
                    { id: 'storage', icon: 'fa-database', label: 'Storage & Sync', action: 'showStorageModal', isLocked: false },
                    { id: 'audio', icon: 'fa-microphone-lines', label: 'Audio & Scribe', action: 'showAudioSettingsModal', isLocked: false },
                    { id: 'ai', icon: 'fa-wand-magic-sparkles', label: 'NoteKash AI', action: 'showAiSettingsModal', isLocked: !isPremium },
                    { id: 'shortcuts', icon: 'fa-keyboard', label: 'Shortcut Manual', action: 'showShortcutsModal', isLocked: false },
                ];

                const navItemsHTML = navItems.map(item => `
                    <a class="settings-nav-item ${item.isLocked ? 'locked' : ''}" 
                       onclick="if (!this.classList.contains('locked')) { App.ui.closeModal(); App.ui.${item.action}(); } else { App.ui.showAscensionModal(); }"
                       style="justify-content: flex-start;">
                        <i class="fa-solid ${item.icon}" style="width: 24px;"></i> 
                        <span>${item.label}</span>
                    </a>
                `).join('');

                const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div class="modal-content ui-card" style="max-width: 420px;" onclick="event.stopPropagation()">
                            <h3 style="text-align: center;">Settings</h3>
                            <nav class="settings-nav" style="border: none; padding: 0.5rem;">
                                ${navItemsHTML}
                            </nav>
                            <div class="modal-buttons">
                                <button class="btn btn-primary" onclick="App.ui.closeModal()">Close</button>
                            </div>
                        </div>
                    </div>`;
                
                document.getElementById('modal-container').innerHTML = modalHTML;
            },

            showAiSettingsModal() {
                const hasOpenRouterKey = !!App.settings.get('openRouterKey');
                const hasGeminiKey = !!App.settings.get('geminiKey');
                const selectedProvider = App.settings.get('aiProvider') || 'openrouter';
                const selectedModel = App.settings.get('openRouterModel') || 'mistralai/mistral-7b-instruct:free';

                const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div id="ai-settings-modal-content" class="modal-content ui-card" onclick="event.stopPropagation()">
                            <h3>AI Provider Settings</h3>

                            <div class="settings-section">
                                <h4>Bring Your Own Key (BYOK)</h4>
                                <div class="settings-grid">
                                    <label for="ai-provider-select">Provider</label>
                                    <select id="ai-provider-select" class="btn btn-secondary">
                                        <option value="openrouter" ${selectedProvider === 'openrouter' ? 'selected' : ''}>OpenRouter</option>
                                        <option value="gemini" ${selectedProvider === 'gemini' ? 'selected' : ''}>Google Gemini</option>
                                    </select>

                                    <div id="openrouter-fields" style="display: ${selectedProvider === 'openrouter' ? 'contents' : 'none'};">
                                        <label for="openrouter-key-input">OpenRouter Key</label>
                                        <input type="password" id="openrouter-key-input" class="text-input" placeholder="${hasOpenRouterKey ? 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢' : 'sk-or-...'}">

                                        <label for="openrouter-model-input">Preferred Model</label>
                                        <div>
                                            <input type="text" id="openrouter-model-input" class="text-input" value="${selectedModel}" placeholder="e.g., openai/gpt-4o">
                                            <small style="display: block; margin-top: 4px; color: var(--text-secondary);">Enter exact model name from OpenRouter whose API key is in use.</small>
                                        </div>
                                    </div>

                                    <div id="gemini-fields" style="display: ${selectedProvider === 'gemini' ? 'contents' : 'none'};">
                                        <label for="gemini-key-input">Gemini API Key</label>
                                        <input type="password" id="gemini-key-input" class="text-input" placeholder="${hasGeminiKey ? 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢' : 'AIzaSy...'}">
                                    </div>
                                </div>
                            </div>

                            <div class="modal-buttons">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back</button>
                                <button class="btn btn-primary" onclick="App.events.ai.saveAiSettings()">Save</button>
                            </div>
                        </div>
                    </div>`;

                document.getElementById('modal-container').innerHTML = modalHTML;

                // Populate existing keys
                const savedOpenRouterKey = App.settings.get('openRouterKey');
                const savedGeminiKey = App.settings.get('geminiKey');
                if (savedOpenRouterKey) document.getElementById('openrouter-key-input').value = savedOpenRouterKey;
                if (savedGeminiKey) document.getElementById('gemini-key-input').value = savedGeminiKey;

                // Add event listener to toggle fields
                document.getElementById('ai-provider-select').addEventListener('change', (e) => {
                    const isGemini = e.target.value === 'gemini';
                    document.getElementById('openrouter-fields').style.display = isGemini ? 'none' : 'contents';
                    document.getElementById('gemini-fields').style.display = isGemini ? 'contents' : 'none';
                });
            },

            showAudioSettingsModal() {
                const currentBitrate = App.settings.get('audioBitrate');

                const bitrateOptions = [
                    { value: 16000, label: 'Mini (To Save Space)' },
                    { value: 32000, label: 'Low (Voice Memo)' },
                    { value: 64000, label: 'Medium (Podcast - Recommended)' },
                    { value: 128000, label: 'High (Music)' }
                ].map(opt => `<option value="${opt.value}" ${currentBitrate === opt.value ? 'selected' : ''}>${opt.label}</option>`).join('');

                const models = [
                    { id: 'tiny', name: 'Smooth', size: '75 MB' }, { id: 'base', name: 'Good', size: '142 MB' },
                    { id: 'small', name: 'Better', size: '466 MB' }, { id: 'medium', name: 'Excellent', size: '1.42 GB' }
                ];
                const modelsHTML = models.map(model => `
                    <div class="settings-item">
                        <div class="settings-label"><b>${model.name} Model</b><small>${model.size} download</small></div>
                        <button class="btn btn-secondary" id="download-model-${model.id}" onclick="App.audio.downloadTranscriptionModel('Xenova/whisper-${model.id}')">Download</button>
                    </div>
                `).join('');

                const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div id="audio-settings-modal-content" class="modal-content ui-card" onclick="event.stopPropagation()">
                            <h3>Audio & Transcription</h3>

                            <div class="settings-section">
                                <h4>Audio Configuration</h4>
                                <div class="settings-grid">
                                    <label for="audio-bitrate-select">Recording Quality</label>
                                    <select id="audio-bitrate-select" class="btn btn-secondary" onchange="App.settings.set('audioBitrate', parseInt(this.value, 10))">${bitrateOptions}</select>
                                </div>
                                <div id="ascension-witty-message" class="witty-gradient-text" style="text-align: left; margin-top: 1rem; font-size: 1.1em;">Premium Offline Transcription</div>
                                <div class="settings-label" style="padding: 2px 0;">
                                    <small>Download a model to enable offline, private audio transcription.</small>
                                </div>
                                ${modelsHTML}
                                <div class="settings-item" style="margin-top: 1rem;">
                                    <div class="settings-label"><b>Current Status</b><small id="transcription-model-status">No model downloaded.</small></div>
                                    <button class="btn btn-danger" id="delete-models-btn" style="display:none;" onclick="App.audio.deleteTranscriptionModels()">Delete Models</button>
                                </div>
                            </div>

                            <div class="modal-buttons">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back</button>
                                <button class="btn btn-primary" onclick="App.ui.closeModal()">Done</button>
                            </div>
                        </div>
                    </div>`;

                document.getElementById('modal-container').innerHTML = modalHTML;
                App.audio.updateModelStatusUI();
            },

            showAppearanceModal() {
                const currentTheme = App.settings.get('theme');
                const themeOptions = App.config.themes.map(t => {
                    const isPremium = t.id === 'custom';
                    const isDisabled = isPremium && !App.license.isPremium();
                    return `<option value="${t.id}" ${currentTheme === t.id ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}>${t.name}${isDisabled ? ' ðŸ‘‘' : ''}</option>`;
                }).join('');

                const currentFont = App.settings.get('fontFamily');
                const fontOptions = App.config.fonts.map(font => {
                    const freeFonts = ['Arial, Helvetica, sans-serif', 'Cambria, Cochin, Georgia, Times, "Times New Roman", serif', "'Courier New', Courier, monospace", 'Garamond, serif', 'Georgia, serif', 'Helvetica, Arial, sans-serif', 'Monaco, "Lucida Console", monospace', 'Palatino, "Palatino Linotype", serif', 'sans-serif', "'Times New Roman', Times, serif", 'Verdana, Geneva, sans-serif'];
                    const isPremium = !freeFonts.includes(font.value);
                    const isDisabled = isPremium && !App.license.isPremium();
                    return `<option value="${font.value}" ${currentFont === font.value ? 'selected' : ''} ${isDisabled ? 'disabled' : ''}>${font.name}${isDisabled ? ' ðŸ‘‘' : ''}</option>`;
                }).join('');

                const currentSize = parseFloat(App.settings.get('fontSize'));
                const currentLineHeight = App.settings.get('lineHeight');
                const currentOpacity = App.settings.get('uiOpacity');
                const ocrThreshold = App.settings.get('ocrThreshold') || 128;
                const customThemeBase = App.settings.get('customThemeBase');
                const isMobileViewEnabled = App.settings.get('mobileViewEnabled');
                const mobileViewLabel = isMobileViewEnabled ? 'Switch to Desktop View' : 'Switch to Mobile View';
                const mobileViewDescription = isMobileViewEnabled ? 'For utilizing the full power of the app.' : 'Optimized for small screens & touch.';
                const libraryTitle = App.settings.get('libraryTitle') || 'My Library';

                const captionThemes = [
                    { id: 'sharp-light', name: 'Sharp Light (Default)' },
                    { id: 'sharp-dark', name: 'Sharp Dark' },
                    { id: 'forest', name: 'Forest Green Text' },
                    { id: 'navy', name: 'Navy Blue Text' },
                    { id: 'maroon', name: 'Maroon Text' },
                    { id: 'chocolate', name: 'Chocolate Text' },
                    { id: 'charcoal', name: 'Charcoal Text' },
                    { id: 'sunbeam', name: 'Sunbeam Yellow' },
                    { id: 'aqua', name: 'Aqua Blue' },
                    { id: 'lime', name: 'Lime Green' },
                    { id: 'rose', name: 'Rose Pink' },
                    { id: 'lavender', name: 'Lavender' },
                    { id: 'soft-glow', name: 'Soft Glow' },
                    { id: 'letterpress', name: 'Letterpress (Carved)' },
                    { id: 'gold-leaf', name: 'Gold Leaf (Glow)' }
                ];
                const currentCaptionTheme = App.settings.get('captionTheme') || 'sharp-light';
                const captionThemeOptions = captionThemes.map(t => `<option value="${t.id}" ${currentCaptionTheme === t.id ? 'selected' : ''}>${t.name}</option>`).join('');
                
                const captionAlignments = [
                    { id: 'bottom', name: 'Bottom' }, { id: 'middle', name: 'Middle' }, { id: 'top', name: 'Top' }
                ];
                const currentCaptionAlign = App.settings.get('captionAlign') || 'bottom';
                const captionAlignOptions = captionAlignments.map(a => `<option value="${a.id}" ${currentCaptionAlign === a.id ? 'selected' : ''}>${a.name}</option>`).join('');


                const modalHTML = `
                <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                    <div class="modal-content ui-card" style="max-width: 600px;" onclick="event.stopPropagation()">
                        <h3 style="text-align: center;">Appearance</h3>
                        
                        <div class="settings-section">
                            <h4><i class="fa-solid fa-swatchbook"></i> Theme & Layout</h4>
                            <div class="settings-grid">
                                <label for="theme-select">Theme</label>
                                <select id="theme-select" class="btn btn-secondary">${themeOptions}</select>

                                <label for="library-title-input">Library Title</label>
                                <input type="text" id="library-title-input" class="text-input" value="${App.util.escapeHtml(libraryTitle)}" placeholder="e.g., My Knowledge Garden">
                            </div>
                        </div>

                        <div id="custom-theme-controls" style="display: ${currentTheme === 'custom' ? 'block' : 'none'};" class="settings-section">
                            <h4><i class="fa-solid fa-image"></i> Custom Background</h4>
                            <div class="settings-grid">
                                <label for="custom-theme-base">UI Base</label>
                                <select id="custom-theme-base" class="btn btn-secondary">
                                    <option value="light" ${customThemeBase === 'light' ? 'selected' : ''}>Light UI</option>
                                    <option value="dark" ${customThemeBase === 'dark' ? 'selected' : ''}>Dark UI</option>
                                </select>
                                <div class="control-span" style="grid-column: 1 / -1;">
                                    <button id="change-bg-btn" class="btn btn-secondary" style="width:100%">Change Background Image</button>
                                </div>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h4><i class="fa-solid fa-font"></i> Typography</h4>
                            <div class="settings-grid">
                                <label for="font-family-select">Font Family</label>
                                <select id="font-family-select" class="btn btn-secondary">${fontOptions}</select>
                                
                                <div class="settings-label" title="Controls the default text size within notes."><b>Font Size</b></div>
                                <div class="slider-control-wrapper"><input type="range" id="font-size-slider" min="0.8" max="2.2" step="0.05" value="${currentSize}"><span id="font-size-value">${currentSize.toFixed(2)}rem</span></div>

                                <div class="settings-label" title="Adjusts the vertical spacing between lines of text for better readability."><b>Line Spacing</b></div>
                                <div class="slider-control-wrapper"><input type="range" id="line-height-slider" min="1.4" max="2.2" step="0.05" value="${currentLineHeight}"><span id="line-height-value">${currentLineHeight}</span></div>
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <h4><i class="fa-solid fa-closed-captioning"></i> Image Caption Style</h4>
                            <div class="settings-grid">
                                <label for="caption-theme-select">Caption Color</label>
                                <select id="caption-theme-select" class="btn btn-secondary">${captionThemeOptions}</select>

                                <label for="caption-align-select">Caption Position</label>
                                <select id="caption-align-select" class="btn btn-secondary">${captionAlignOptions}</select>
                            </div>
                        </div>

                        <div class="settings-section">
                             <h4><i class="fa-solid fa-sliders"></i> UI & Image Settings</h4>
                             <div class="settings-grid">
                                <div class="settings-label" title="Adjusts the transparency of UI elements like modals and toolbars. Set to 0% for a fully transparent look."><b>UI Opacity</b></div>
                                <div class="slider-control-wrapper"><input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="${currentOpacity}"><span id="opacity-value">${Math.round(currentOpacity * 100)}%</span></div>

                                <div class="settings-label" title="Controls the compression level for pasted or dropped images. Lower quality means smaller file sizes."><b>Import Image Quality</b></div>
                                <div class="slider-control-wrapper"><input type="range" id="image-quality-slider" min="0.1" max="1" step="0.05" value="${App.settings.get('jpegQuality')}"><span id="image-quality-value">${Math.round(App.settings.get('jpegQuality') * 100)}%</span></div>
                                
                                <div class="settings-label" title="Adjusts the black/white contrast for OCR. Higher values work for light text on dark backgrounds; lower values for dark text on light backgrounds."><b>OCR Contrast</b></div>
                                <div class="slider-control-wrapper"><input type="range" id="ocr-threshold-slider" min="50" max="200" step="1" value="${ocrThreshold}"><span id="ocr-threshold-value">${ocrThreshold}</span></div>
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <h4><i class="fa-solid fa-mobile-screen-button"></i> View Mode</h4>
                            <div class="settings-item">
                                <div class="settings-label" id="mobile-view-label-container"><b>${mobileViewLabel}</b><small>${mobileViewDescription}</small></div>
                                <div id="mobile-view-toggle" class="toggle-switch ${isMobileViewEnabled ? 'active' : ''}"></div>
                            </div>
                        </div>

                        <div class="modal-buttons">
                            <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back to Settings</button>
                        </div>
                    </div>
                </div>`;
                
                document.getElementById('modal-container').innerHTML = modalHTML;
                document.getElementById('theme-select').addEventListener('change', (e) => App.events.handleThemeChange(e.target.value));
                document.getElementById('library-title-input').addEventListener('input', App.events.changeLibraryTitle);
                document.getElementById('font-family-select').addEventListener('input', App.events.changeFontFamily);
                document.getElementById('font-size-slider').addEventListener('input', App.events.changeFontSize);
                document.getElementById('line-height-slider').addEventListener('input', App.events.changeLineHeight);
                document.getElementById('custom-theme-base').addEventListener('input', App.events.handleCustomThemeBaseChange);
                document.getElementById('opacity-slider').addEventListener('input', App.events.changeUiOpacity);
                document.getElementById('mobile-view-toggle').addEventListener('click', App.events.toggleMobileView);
                document.getElementById('image-quality-slider').addEventListener('input', App.events.changeImageQuality);
                document.getElementById('ocr-threshold-slider').addEventListener('input', App.events.changeOcrThreshold);
                document.getElementById('change-bg-btn').addEventListener('click', () => App.events.triggerBgImageUpload());
            
                document.getElementById('caption-theme-select').addEventListener('change', (e) => App.settings.set('captionTheme', e.target.value));
                document.getElementById('caption-align-select').addEventListener('change', (e) => App.settings.set('captionAlign', e.target.value));
            },

            showFlashcardSettingsModal() {
                const currentFim = App.settings.get('intervalModifier');
                const currentSessionSize = App.settings.get('studySessionSize');

                this.showConfirmationModal({
                    title: 'Flashcard Settings âš™ï¸',
                    message: `
                        <div class="settings-grid" style="gap: 1.5rem;">
                            <div class="control-span" title="Set the number of cards to study in a standard session.">
                                <label for="session-size-input" style="flex-grow: 1;">Study Session Size</label>
                                <input type="number" id="session-size-input" class="text-input" value="${currentSessionSize}" min="1" style="width: 80px; text-align: center;">
                            </div>
                            <div class="control-span" title="Adjust the speed of all review intervals. >100% is longer, <100% is shorter.">
                                <label for="interval-modifier-slider">Spaced Recall Controller</label>
                                <input type="range" id="interval-modifier-slider" min="0.3" max="2.5" step="0.05" value="${currentFim}">
                                <span id="interval-modifier-value" style="min-width: 50px; text-align: right;">${Math.round(currentFim * 100)}%</span>
                            </div>
                        </div>
                    `,
                    confirmText: 'Done',
                    showCancel: false,
                    onConfirm: () => {}, // The button will just close the modal
                    modalClass: 'flashcard-settings-modal'
                });

                // Add live event listeners for the new controls
                document.getElementById('session-size-input').addEventListener('change', (e) => {
                    const newLimit = parseInt(e.target.value, 10);
                    if (newLimit > 0) {
                        App.settings.set('studySessionSize', newLimit);
                    }
                });

                document.getElementById('interval-modifier-slider').addEventListener('input', (e) => {
                    const modifier = parseFloat(e.target.value);
                    document.getElementById('interval-modifier-value').textContent = `${Math.round(modifier * 100)}%`;
                    App.settings.set('intervalModifier', modifier);
                });
            },

            showChartModal() {
                App.state.savedRange = window.getSelection().getRangeAt(0).cloneRange(); // Save cursor position

                this.showConfirmationModal({
                    title: 'Create Chart',
                    message: `
                        <div class="settings-grid" style="gap: 1rem;">
                            <label for="chart-type-select">Chart Type</label>
                            <select id="chart-type-select" class="btn btn-secondary">
                                <option value="bar">Bar Chart</option>
                                <option value="bar-vertical">Bar (Vertical)</option>
                                <option value="line">Line Chart</option>
                                <option value="doughnut">Doughnut Chart</option>
                            </select>
                            <label for="chart-data-input" style="align-self: start; padding-top: 8px;">Data</label>
                            <textarea id="chart-data-input" class="text-input" rows="6" placeholder="Enter data, one item per line.\nFormat: Label,Value\n\nExample:\nApples,12\nOranges,9\nBananas,5"></textarea>
                        </div>
                    `,
                    confirmText: 'Insert Chart',
                    onConfirm: () => App.ui.insertChartFromModal(),
                    modalClass: 'chart-modal'
                });
                App.util.trapFocus(document.querySelector('.chart-modal'));
                setTimeout(() => {
                    const dataInput = document.getElementById('chart-data-input');
                    if (dataInput) {
                        dataInput.focus();
                        dataInput.select();
                    }
                }, 50);
            },


            async insertChartFromModal() {
                if (!window.Chart) {
                    App.ui.showToast("Chart library is not available.", { type: 'error' });
                    return;
                }

                const typeInput = document.getElementById('chart-type-select').value;
                const dataText = document.getElementById('chart-data-input').value;
                const lines = dataText.trim().split('\n').filter(line => line.includes(','));

                if (lines.length === 0) {
                    App.ui.showToast("Invalid data format.", { type: 'error' });
                    return;
                }

                const labels = lines.map(line => line.split(',')[0].trim());
                const data = lines.map(line => parseFloat(line.split(',')[1].trim()));

                if (data.some(isNaN)) {
                    App.ui.showToast("Data contains non-numeric values.", { type: 'error' });
                    return;
                }

                
                let chartType;
                switch (typeInput) {
                    case 'line':
                        chartType = 'line';
                        break;
                    case 'doughnut':
                        chartType = 'doughnut';
                        break;
                    case 'bar':
                    case 'bar-vertical':
                    default:
                        chartType = 'bar';
                        break;
                }


               
                const chartConfig = {
                  
                    type: chartType,
                    data: {
                        labels: labels,
                        datasets: [{
                            data: data
                        }]
                    },
                    options: {
                       
                        indexAxis: typeInput === 'bar-vertical' ? 'y' : 'x',
                     }
                };

                const canvasId = `chart-${crypto.randomUUID()}`;
                const chartConfigString = App.util.escapeHtml(JSON.stringify(chartConfig));

                const html = `<div class="chart-container" contenteditable="false"><canvas id="${canvasId}" data-chart-config="${chartConfigString}" width="600" height="400" style="max-width: 100%; height: auto;"></canvas></div>`;

                App.util.restoreSelection();
                App.util.insertGuardianBlock(`<p>${html}</p>`); // Use the helper

                setTimeout(() => {
                    const newCanvas = document.getElementById(canvasId);
                    if (newCanvas) {
                        App.ui.renderChartOnCanvas(newCanvas);
                    }
                    App.state.isArticleDirty = true; // Ensure autosave picks up the change
                }, 100);
            },

            updateSettingsUIState() {
                const modalContent = document.querySelector('.modal-content');
                if (!modalContent) return;
                const themeSelect = modalContent.querySelector('#theme-select');
                if (!themeSelect) return;
                const currentTheme = themeSelect.value;
                modalContent.classList.toggle('is-custom-theme', currentTheme === 'custom');
            },

            showCategoryManagerModal() {
                const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div id="category-manager-modal" class="modal-content ui-card" style="max-width: 500px;" onclick="event.stopPropagation()">
                            <h3>Manage Categories</h3>
                            <div id="category-list-container" style="max-height: 50vh; overflow-y: auto; margin: 1.5rem 0; display: flex; flex-direction: column; gap: 0.75rem;">
                                </div>
                            <div class="settings-section" style="padding-top: 1rem; margin-top: 1rem;">
                                <h4 style="margin-top: 0;">Add New Category</h4>
                                <div style="display: flex; gap: 0.75rem;">
                                    <input type="text" id="new-category-name" class="text-input" placeholder="Enter new category name...">
                                    <button class="btn btn-primary" id="add-category-btn">Add</button>
                                </div>
                            </div>
                            <div class="modal-buttons">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back to Settings</button>
                            </div>
                        </div>
                    </div>`;

                document.getElementById('modal-container').innerHTML = modalHTML;
                App.events.categories.refreshManager();

                document.getElementById('add-category-btn').onclick = () => {
                    const input = document.getElementById('new-category-name');
                    if (input.value) {
                        App.events.categories.add(input.value);
                        input.value = '';
                    }
                };
                document.getElementById('new-category-name').onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        document.getElementById('add-category-btn').click();
                    }
                };
            },


            async showStorageModal() {
                // --- 1. GET CURRENT STATE ---
                const isPremium = App.license.isPremium();
                const clientId = App.settings.get('dropboxClientId') || '';
                const isConnected = App.state.isDropboxReady;
                const hasKey = !!clientId.trim();
                const syncEnabled = App.settings.get('enableDropboxSync');
                const lastSyncTime = App.util.formatTimestamp(App.settings.get('lastSyncTimestamp'));

                // --- 2. BUILD THE CLOUD SYNC SECTION HTML ---

                // This class locks the entire section if the user is not premium.
                const premiumLockClass = !isPremium ? 'premium-feature-locked' : '';
                let cloudSyncHTML = '';

                if (!isPremium) {
                    // --- STATE A: SPARK (FREE) USER ---
                    // Show a clear upsell message.
                    cloudSyncHTML = `
                        <div class="premium-cta-text" style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: var(--border-radius-lg);">
                            Cloud Sync is a Premium feature.
                            <button class="btn btn-primary" style="margin-top: 0.75rem;" onclick="App.ui.showAscensionModal()">Unlock All Features</button>
                        </div>
                    `;
                } else {
                    // --- STATE B-E: PREMIUM USER ---
                    // The user is Premium, so we show the step-by-step setup.

                    // STEP 1: API Key Input (Always visible for premium users)
                    const step1_ApiKeyHTML = `
                        <div class="settings-item">
                            <div class="settings-label">
                                <b>Step 1: Set Your API Key</b>
                                <small>Get this from your Dropbox App Console.</small>
                            </div>
                        </div>
                        <div style="display:flex; gap: 8px; align-items: stretch; margin-top: -0.5rem; margin-bottom: 1rem;">
                            <input type="password" id="dropbox-client-id-input" class="text-input" placeholder="Paste your App Key (Client ID) here" value="${clientId}">
                            <button class="btn btn-secondary" onclick="${hasKey ? 'App.events.removeDropboxClientId()' : 'App.events.saveDropboxClientId()'}">${hasKey ? 'Remove' : 'Save'}</button>
                        </div>
                    `;

                    // STEP 2: Connect Button (Enabled only if key is saved)
                    const step2_ConnectHTML = `
                        <div class="settings-item">
                            <div class="settings-label">
                                <b>Step 2: Connect to Dropbox</b>
                                <small>${isConnected ? `Connected as ${App.state.dropboxUser.email}` : 'Please save an API key and connect.'}</small>
                            </div>
                            ${isConnected ? 
                                `<button class="btn btn-danger" onclick="App.dropbox.disconnect(); App.ui.showStorageModal();">Disconnect</button>` : 
                                `<button class="btn btn-primary" onclick="App.dropbox.connect()" ${!hasKey ? 'disabled' : ''}>Connect</button>`
                            }
                        </div>
                    `;

                    // STEP 3: Enable Toggle (Enabled only if connected)
                    const step3_EnableHTML = `
                        <div class="settings-item" style="${!isConnected ? 'opacity: 0.5; pointer-events: none;' : ''}">
                            <div class="settings-label">
                                <b>Step 3: Enable Sync</b>
                                <small>${!isConnected ? 'You must be connected to enable sync.' : 'Turn on automatic syncing.'}</small>
                            </div>
                            <div id="sync-toggle" class="toggle-switch ${syncEnabled ? 'active' : ''} ${!isConnected ? 'is-disabled' : ''}"></div>
                        </div>
                    `;

                    // STEP 4: Manual Sync Button (Visible only if enabled)
                    const step4_ManualSyncHTML = (isConnected && syncEnabled) ? `
                        <div class="settings-item">
                            <div class="settings-label">
                                <b>Manual Sync</b>
                                <small>Last sync: ${lastSyncTime}</small>
                            </div>
                            <button id="sync-now-btn" class="btn btn-primary" onclick="App.dropbox.syncChanges()" ${!App.state.directoryHandle && App.state.storageMode !== 'browser' ? 'disabled' : ''} title="${!App.state.directoryHandle && App.state.storageMode !== 'browser' ? 'Please select a folder or use browser storage first.' : 'Sync Now'}">
                                ${App.state.isSyncing ? `<i class="fa-solid fa-arrows-rotate spin"></i> Syncing...` : 'Sync Now'}
                            </button>
                        </div>
                    ` : '';

                    // HELP GUIDE: Separate from the inputs, always available at the bottom.
                    const helpGuideHTML = `
                        <div class="settings-item" style="margin-top: 1rem; border-top: 1px solid var(--border-color); padding-top: 1rem;">
                            <div class="settings-label">
                                <b>Need help?</b>
                                <small>Follow these steps to get your API key.</small>
                            </div>
                            <button class="btn btn-secondary" onclick="document.getElementById('dropbox-guide-content').style.display = document.getElementById('dropbox-guide-content').style.display === 'block' ? 'none' : 'block';">
                                Show Setup Guide
                            </button>
                        </div>
                        <div class="guide-content" id="dropbox-guide-content" style="display: none;">
                            <h3>1. Create Dropbox App</h3>
                            <ol>
                                <li>Go to the <a href="https://www.dropbox.com/developers/apps" target="_blank" rel="noopener noreferrer">Dropbox App Console</a> and click <strong>Create app</strong>.</li>
                                <li>Select <strong>Scoped access</strong> &rarr; <strong>App folder</strong>. Name your app (e.g., "NoteKashSync").</li>
                                <li>In <strong>Permissions</strong>, check <code>files.content.read</code> and <code>files.content.write</code>. Click Submit. (you can allow more items as well)</li>
                                <li>In <strong>Settings</strong>, find "Redirect URIs" and add this exact URL: <code>https://notekash.com</code> or you can copy from "web address" as well. </li> 
                                <li>Copy the <strong>App key (Client ID)</strong> from this page.</li>
                            </ol>
                            <h3>2. Save Your Key</h3>
                            <p>Paste the <strong>App key (Client ID)</strong> into the "Step 1" input box above and click <strong>Save</strong> then click <strong> Connect </strong> and you have sucessfully connected the <strong> powerful Automatic Multi Device Sync </strong>.</p>
                        </div>
                    `;

                    // Combine all parts for the premium user
                    cloudSyncHTML = step1_ApiKeyHTML + step2_ConnectHTML + step3_EnableHTML + step4_ManualSyncHTML + helpGuideHTML;
                }

                // --- 3. ASSEMBLE THE FINAL MODAL ---
                const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div class="modal-content ui-card" style="max-width: 550px;" onclick="event.stopPropagation()">
                            <h3 style="text-align: center;">Storage & Sync</h3>

                            <div class="settings-section">
                                <h4><i class="fa-solid fa-folder-open"></i> Local Storage</h4>
                                <div class="settings-item">
                                    <div class="settings-label"><b>Notes Folder</b><small>${App.state.directoryHandle ? `Using folder: '${App.state.directoryHandle.name}'` : 'Using Browser Storage.'}</small></div>
                                    <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.router.navigateTo('welcome');">Change</button>
                                </div>
                                <div class="settings-item">
                                    <div class="settings-label"><b>Backup</b><small>Save or Restore your Note or All Data files.</small></div>
                                    <div style="display:flex; gap: 8px;">
                                        <button class="btn btn-secondary" onclick="App.events.triggerZipImport()">Import</button>
                                        <button class="btn btn-secondary" onclick="App.services.backup.exportToZip()">Export</button>
                                    </div>
                                </div>
                            </div>

                            <div classs="settings-section ${premiumLockClass}">
                                <h4><i class="fa-brands fa-dropbox"></i> Cloud Sync</h4>
                                ${cloudSyncHTML}
                            </div>

                            <div class="modal-buttons">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back to Settings</button>
                            </div>
                        </div>
                    </div>`;

                document.getElementById('modal-container').innerHTML = modalHTML;

                // --- 4. RE-ATTACH LISTENERS ---
                const syncToggle = document.getElementById('sync-toggle');
                if (syncToggle && !syncToggle.classList.contains('is-disabled')) {
                    syncToggle.addEventListener('click', App.events.handleSyncToggle);
                }
            },


            showShortcutsModal() {
                const cmdKey = App.util.getCommandKey();
                this.showConfirmationModal({
                    title: 'Keyboard Shortcuts & Manual',
                    message: `<div class="shortcut-modal-content" style="font-size: 0.9rem; max-height: 70vh; overflow-y: auto;">
                        <h4>Global & Navigation</h4>
                        <ul>
                            <li><b>New Article:</b> <kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>N</kbd></li>
                            <li><b>Open Productivity Hub:</b> <kbd>${cmdKey}</kbd> + <kbd>K</kbd></li>
                            <li><b>Open/Change Notes Folder:</b> <kbd>Alt</kbd> + <kbd>O</kbd></li>
                            <li><b>Close Modal / Exit View:</b> <kbd>Esc</kbd></li>
                        </ul><hr>
                        
                        <h4>Task Window (Productivity Hub)</h4>
                        <p>These shortcuts work when you are not typing in an input field.</p>
                        <ul style="list-style: none; padding-left: 0;">
                            <li style="font-weight: bold; margin-bottom: 4px;"><u>Timer Controls</u></li>
                            <ul style="padding-left: 20px; margin-top: 4px;">
                                <li><b>Play / Pause Timer:</b> <kbd>S</kbd></li>
                                <li><b>Stop / Reset Timer:</b> <kbd>A</kbd></li>
                                <li><b>Timer Settings:</b> <kbd>T</kbd></li>
                                <li><b>Toggle Zen Mode:</b> <kbd>Z</kbd></li>
                            </ul>
                            <li style="font-weight: bold; margin-top: 1rem; margin-bottom: 4px;"><u>Task Composer</u></li>
                            <ul style="padding-left: 20px; margin-top: 4px;">
                                <li><b>Focus Date Input:</b> <kbd>D</kbd></li>
                                <li><b>Select Category:</b> <kbd>G</kbd></li>
                                <li><b>Cycle Priority:</b> <kbd>F</kbd></li>
                                <li><b>Increment Pomo Goal:</b> <kbd>C</kbd></li>
                                <li><b>Reset Pomo Goal:</b> <kbd>X</kbd></li>
                                <li><b>Add Task:</b> <kbd>Enter</kbd></li>
                            </ul>
                            <li style="font-weight: bold; margin-top: 1rem; margin-bottom: 4px;"><u>Quick Start Timer</u></li>
                            <ul style="padding-left: 20px; margin-top: 4px;">
                                <li><b>Start Timer for 1st Task:</b> <kbd>Q</kbd></li>
                                <li><b>Start Timer for 2nd Task:</b> <kbd>W</kbd></li>
                                <li><b>Start Timer for 3rd Task:</b> <kbd>E</kbd></li>
                                <li><b>Start Timer for 4th Task:</b> <kbd>R</kbd></li>
                            </ul>
                        </ul><hr>
                    
                        <h4>Library & Search Bar</h4>
                        <ul>
                            <li><b>Focus Search Box:</b> Press <kbd>S</kbd> (in Library or Flashcard view)</li>
                            <li><b>Filter by Category:</b> <kbd>*sci</kbd> (filters for 'Science')</li>
                            <li><b>Quick Commands (type in search and press Enter):</b>
                                <ul style="margin-top: 0.5rem; list-style-type: 'â†’ '; padding-left: 20px;">
                                    <li><kbd>%new</kbd> or <kbd>%+</kbd> &mdash; Create a new article</li>
                                    <li><kbd>%flash</kbd> &mdash; Go to Flashcards</li>
                                    <li><kbd>%study</kbd> &mdash; Start a study session</li>
                                    <li><kbd>!task</kbd> &mdash; Open Productivity Hub</li>
                                    <li><kbd>!stats</kbd> &mdash; Open Stats Dashboard</li>
                                    <li><kbd>!quiz</kbd> &mdash; Start a new Quiz</li>
                                </ul>
                            </li>
                        </ul><hr>
                        <h4>Write Mode: Formatting Shortcuts</h4>
                        <ul>
                            <li><b>Save Article:</b> <kbd>${cmdKey}</kbd> + <kbd>S</kbd></li>
                            <li><b>Insert Accordion/Flashcard:</b> <kbd>${cmdKey}</kbd> + <kbd>J</kbd></li>
                            <li><b>Bold / Italic / Underline:</b> <kbd>${cmdKey}</kbd> + <kbd>B</kbd> / <kbd>I</kbd> / <kbd>U</kbd></li>
                            <li><b>Create Cloze Flashcard:</b> Select text + <kbd>${cmdKey}</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></li>
                            <li><b>Create Visual Tag [[...]]:</b> <kbd>${cmdKey}</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></li>
                            <li><b>Cycle All Highlights/Colors:</b> Select text + <kbd>${cmdKey}</kbd> + <kbd>Shift</kbd> + <kbd>1</kbd></li>
                            <li><b>Specific Highlights:</b> Select text + <kbd>${cmdKey}</kbd> + <kbd>Shift</kbd> + <kbd>2</kbd> through <kbd>7</kbd></li>
                            <li><b>Color Text (Green/Red/Blue/Magenta):</b> Select text + <kbd>${cmdKey}</kbd> + <kbd>Shift</kbd> + <kbd>8</kbd> / <kbd>9</kbd> / <kbd>0</kbd> / <kbd>-</kbd></li>
                        </ul><hr>
                        <h4>Write Mode: Markdown-Style Shortcuts</h4>
                        <p>Type these at the start of a new line, then press space.</p>
                        <ul>
                            <li><b>Visual Tag:</b> <kbd>[[Your Tag]]</kbd></li>
                            <li><b>Bulleted List:</b> <kbd>*</kbd> or <kbd>-</kbd> + <kbd>Space</kbd></li>
                            <li><b>Numbered List:</b> <kbd>1.</kbd> + <kbd>Space</kbd></li>
                            <li><b>Blockquote:</b> <kbd>&gt;</kbd> + <kbd>Space</kbd></li>
                            <li><b>Heading:</b> <kbd>##</kbd> + <kbd>Space</kbd></li>
                            <li><b>Horizontal Line:</b> <kbd>---</kbd> + <kbd>Enter</kbd></li>
                            <li><b>Custom Highlights:</b>
                                <ul style="margin-top: 0.5rem; list-style-type: 'â†’ '; padding-left: 20px;">
                                    <li><kbd>==text==</kbd> for <span class="highlight-1">Yellow</span></li>
                                    <li><kbd>==text==g</kbd> for <span class="highlight-2">Green</span></li>
                                    <li><kbd>==text==b</kbd> for <span class="highlight-3">Blue</span></li>
                                    <li><kbd>==text==r</kbd> for <span class="highlight-4">Red</span></li>
                                    <li><kbd>==text==p</kbd> for <span class="highlight-5">Purple</span></li>
                                    <li><kbd>==text==c</kbd> for <span class="highlight-6">Cyan</span></li>
                                    <li><kbd>==text==m</kbd> for <span class="highlight-7">Magenta</span> (Rendered Tag style)</li>
                                </ul>
                            </li>
                            <li><b>Color Text:</b>
                                <ul style="margin-top: 0.5rem; list-style-type: 'â†’ '; padding-left: 20px;">
                                    <li><kbd>::text_r::</kbd> for <span class="text-red">Red Text</span></li>
                                    <li><kbd>::text_g::</kbd> for <span class="text-green">Green Text</span></li>
                                    <li><kbd>::text_b::</kbd> for <span class="text-blue">Blue Text</span></li>
                                    <li><kbd>::text_m::</kbd> for <span class="text-magenta">Magenta Text</span></li>
                                </ul>
                            </li>
                        </ul><hr>
                        <h4>Visual Map View</h4>
                        <p>These shortcuts work when the search bar is not focused.</p>
                        <ul>
                            <li><b>Focus Search:</b> <kbd>S</kbd></li>
                            <li><b>Save Snapshot & Export Image:</b> <kbd>F</kbd></li>
                            <li><b>Zoom:</b> <kbd>Spacebar</kbd> / <kbd>Shift</kbd>+<kbd>Spacebar</kbd> or <kbd>+</kbd> / <kbd>-</kbd></li>
                            <li><b>Pan View:</b> <kbd>Arrow Keys</kbd></li>
                            <li><b>Reset View:</b> <kbd>R</kbd></li>
                            <li><b>Toggle Lasso Tool:</b> <kbd>L</kbd></li>
                            <li><b>Cycle Category Focus:</b> <kbd>C</kbd></li>
                            <li><b>Exit Focus Mode / Clear Search:</b> <kbd>Esc</kbd></li>
                        </ul><hr>
                        <h4>Mind Map View</h4>
                        <p>These shortcuts work when the search bar is not focused.</p>
                        <ul>
                            <li><b>Focus Search:</b> <kbd>S</kbd></li>
                            <li><b>Save Snapshot & Export Image:</b> <kbd>F</kbd></li>
                            <li><b>Next / Previous Map:</b> <kbd>K</kbd> / <kbd>J</kbd></li>
                            <li><b>Zoom:</b> <kbd>Spacebar</kbd> / <kbd>Shift</kbd>+<kbd>Spacebar</kbd></li>
                            <li><b>Exit Focus Mode / Clear Search:</b> <kbd>Esc</kbd></li>
                        </ul><hr>
                        <h4>Study & Quiz Mode</h4>
                        <ul>
                            <li><b>Flip Card:</b> <kbd>Spacebar</kbd></li>
                            <li><b>Previous / Next Card:</b> <kbd>â†</kbd> / <kbd>â†’</kbd></li>
                            <li><b>Rate Again/Hard/Hold/Good/Easy:</b> <kbd>A</kbd> / <kbd>4</kbd> / <kbd>3</kbd> / <kbd>2</kbd> / <kbd>1</kbd></li>
                        </ul>
                    </div>`, 
                    confirmText: 'Close', showCancel: false
                });
            },

            showAudioConfigModal() {
                const currentBitrate = App.settings.get('audioBitrate');
                // ADDED: New "Mini" option with a 16000 bitrate
                const bitrateOptions = [
                    { value: 16000, label: 'Mini (To Save Space)' },
                    { value: 32000, label: 'Low (Voice Memo - Smallest File)' },
                    { value: 64000, label: 'Medium (Podcast - Recommended)' },
                    { value: 128000, label: 'High (Music - Largest File)' }
                ].map(opt => `<option value="${opt.value}" ${currentBitrate === opt.value ? 'selected' : ''}>${opt.label}</option>`).join('');

                const models = [
                    { id: 'tiny', name: 'Smooth', size: '75 MB' },
                    { id: 'base', name: 'Good', size: '142 MB' },
                    { id: 'small', name: 'Better', size: '466 MB' },
                    { id: 'medium', name: 'Excellent', size: '1.42 GB' }
                ];
                // ... (The rest of the function remains exactly the same) ...
                const modelsHTML = models.map(model => `
                    <div class="settings-item">
                        <div class="settings-label">
                            <b>${model.name} Model</b>
                            <small>${model.size} download</small>
                        </div>
                        <button class="btn btn-secondary" id="download-model-${model.id}" onclick="App.audio.downloadTranscriptionModel('Xenova/whisper-${model.id}')">Download</button>
                    </div>
                `).join('');

                const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div id="audio-config-modal" class="modal-content ui-card" onclick="event.stopPropagation()">
                            <h3>Audio Configuration</h3>
                            <div class="settings-section">
                                <h4>Recording Quality</h4>
                                <div class="settings-grid">
                                    <label for="audio-bitrate-select">Audio Quality</label>
                                    <select id="audio-bitrate-select" class="btn btn-secondary">${bitrateOptions}</select>
                                </div>
                            </div>
                            <div class="settings-section">
                                <div id="ascension-witty-message" class="witty-gradient-text">Only for Premium Users</div>
                                <h4>Audio Transcription (by AI Model)</h4>
                                <div class="settings-label" style="padding: 2px 0;">
                                    <small>Download a model to enable offline, private audio transcription. Larger models are more accurate but require more storage and processing power.</small>
                                </div>
                                ${modelsHTML}
                                <div class="settings-item" style="margin-top: 1rem;">
                                    <div class="settings-label">
                                        <b>Current Status</b>
                                        <small id="transcription-model-status">No model downloaded.</small>
                                    </div>
                                    <button class="btn btn-danger" id="delete-models-btn" style="display:none;" onclick="App.audio.deleteTranscriptionModels()">Delete</button>
                                </div>
                            </div>
                            <div class="modal-buttons" style="margin-top: 1.5rem;">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back</button>
                            </div>
                        </div>
                    </div>`;

                document.getElementById('modal-container').innerHTML = modalHTML;
                document.getElementById('audio-bitrate-select').addEventListener('change', (e) => App.settings.set('audioBitrate', parseInt(e.target.value, 10)));
                App.audio.updateModelStatusUI(); 
            },

            showLicenseModal() {
                const isPremium = App.license.isPremium();
                const tierName = App.license.state.tier || 'Spark';
                const userName = App.license.state.userName || '';
                const userBio = App.settings.get('userBio') || '';

                let licenseViewHTML;

                if (isPremium) {
                    const expiryDate = new Date(App.license.state.expiry).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                    licenseViewHTML = `
                        <div class="settings-section">
                            <h4 class="witty-gradient-text" style="text-align:center; font-size: 1.2em;">You are in the ${tierName} League!</h4>
                            <p style="text-align:center; color: var(--text-secondary);">Enjoy unlimited features until <strong>${expiryDate}</strong>.</p>
                        </div>
                        <div class="modal-buttons" style="margin-top: 1.5rem; justify-content: space-between;">
                            <button class="btn btn-danger" onclick="App.license.delete()">Downgrade to Spark</button>
                            <button class="btn btn-secondary" onclick="App.license.revalidate()">Re-validate License</button>
                        </div>`;
                } else {
                    licenseViewHTML = `
                        <div class="settings-section">
                             <div class="license-form-grid">
                                <label for="license-name-input">Your Name</label>
                                <input type="text" id="license-name-input" class="text-input" value="${userName}" placeholder="e.g., Alex Doe">

                                <label for="license-status-input">Your Bio</label>
                                <textarea id="license-status-input" class="text-input" rows="2" placeholder="A short bio... (e.g., Lifelong Learner)">${userBio}</textarea>

                                <label for="license-tier-select">Desired Tier</label>
                                <select id="license-tier-select" class="btn btn-secondary">
                                    <option value="bronze">Bronze (3 Months)</option>
                                    <option value="silver">Silver (6 Months)</option>
                                    <option value="gold">Gold (1 Year)</option>
                                    <option value="diamond">Diamond (Lifetime)</option>
                                </select>

                                <label for="license-key-input">License Key</label>
                                <input type="text" id="license-key-input" class="text-input" placeholder="Paste your unique license key here">
                            </div>
                            <div class="modal-buttons" style="margin-top: 1.5rem; justify-content: space-between;">
                                <button class="btn btn-secondary" onclick="App.events.generateLicenseRequestEmail()">Get a License Key</button>
                                <button class="btn btn-primary" onclick="App.license.activate()">Activate License</button>
                            </div>
                        </div>`;
                }

                const modalHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div id="license-modal-content" class="modal-content ui-card" style="max-width: 550px;" onclick="event.stopPropagation()">
                            <h3 style="text-align:center;">Profile & License</h3>
                            <div class="license-header-info" style="margin-top: 1rem;">
                                ${App.util.getTierBadgeHTML(tierName)}
                            </div>
                            ${licenseViewHTML}
                            <div class="modal-buttons" style="margin-top: 1.5rem; border-top: 1px solid var(--border-color); padding-top: 1rem;">
                                <button class="btn btn-secondary" onclick="App.ui.closeModal(); App.ui.showSettingsModal();">Back to Settings</button>
                            </div>
                        </div>
                    </div>`;
                document.getElementById('modal-container').innerHTML = modalHTML;
            },

            showQuizResultModal(score, total) {
                // RATIONALE: The original score-based feedback logic is preserved.
                let feedbackQuote = "";
                const percentage = (score / total) * 100;
                if (percentage > 80) feedbackQuote = "Perfection! Are you even human?";
                else if (percentage > 65) feedbackQuote = "Excellent grind! You're on fire.";
                else if (percentage > 50) feedbackQuote = "Strong effort! Stay consistent.";
                else if (percentage > 30) feedbackQuote = "Good Start! Keep Studying.";
                else feedbackQuote = "Too low, Time to Bleed.";

                // RATIONALE: The Power Quote is now fetched as an *additional* message.
                const powerQuote = App.util.getPowerQuote();

                const modalHTML = `
                    <div class="modal-backdrop" onclick="App.ui.closeModal()">
                        <div class="modal-content ui-card quiz-result-card" onclick="event.stopPropagation()">
                            <h3>Quiz Complete!</h3>
                            <div class="quiz-score-display">${score.toFixed(1)} / ${total}</div>
                            <p class="quiz-motivational-quote">"${feedbackQuote}"</p>

                            <p class="power-quote-gradient" style="font-size: 1.2rem; margin-top: 1rem;">
                                &ldquo;${powerQuote}&rdquo;
                            </p>

                            <div class="modal-buttons" style="margin-top: 1.5rem;">
                                <button class="btn btn-primary" onclick="App.ui.closeModal()">Awesome!</button>
                            </div>
                        </div>
                    </div>`;
                document.getElementById('modal-container').innerHTML = modalHTML;
            },

            showCustomModal({ title, message, buttons = [] }) {
                const modalContainer = document.getElementById('modal-container');
                const buttonsHTML = buttons.map((btn, index) => 
                    `<button class="btn ${btn.className || 'btn-secondary'}" id="custom-modal-btn-${index}">${btn.text}</button>`
                ).join('');

                modalContainer.innerHTML = `
                    <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                        <div class="modal-content ui-card">
                            <h3>${title}</h3>
                            <div>${message}</div>
                            <div class="modal-buttons">${buttonsHTML}</div>
                        </div>
                    </div>`;
                
                buttons.forEach((btn, index) => {
                    document.getElementById(`custom-modal-btn-${index}`).onclick = () => {
                        if (btn.onClick) btn.onClick();
                    };
                });
            },

            showConfirmationModal({ title, message, onConfirm, confirmText = 'Confirm', showCancel = true, modalClass = '', onCancel }) {
                const modalContainer = document.getElementById('modal-container');
                modalContainer.innerHTML = `
                    <div class="modal-backdrop">
                        <div class="modal-content ui-card ${modalClass}" role="dialog" aria-modal="true" aria-labelledby="modal-title">
                            <h3 id="modal-title">${title}</h3>
                            <div>${message}</div>
                            <div class="modal-buttons">
                                ${showCancel ? `<button class="btn btn-secondary" id="modal-cancel">Cancel</button>` : ''}
                                <button class="btn ${confirmText === 'Delete' || confirmText === 'Reset' || confirmText === 'Overwrite' || confirmText === 'Remove' ? 'btn-danger' : 'btn-primary'}" id="modal-confirm">${confirmText}</button>
                            </div>
                        </div>
                    </div>`;
                const modal = modalContainer.querySelector('.modal-content');
                const backdrop = modalContainer.querySelector('.modal-backdrop');
                const confirmBtn = modalContainer.querySelector('#modal-confirm');
                const cancelBtn = modalContainer.querySelector('#modal-cancel');

                const closeModalAction = () => { if(onCancel) onCancel(); this.closeModal(); };
                
                backdrop.addEventListener('click', (e) => { if (e.target === backdrop) { closeModalAction(); }});
                confirmBtn.addEventListener('click', () => { if (onConfirm) onConfirm(); this.closeModal(); });
                
                if (cancelBtn) cancelBtn.addEventListener('click', closeModalAction);
                App.util.trapFocus(modal);
            },

            showTemplateHubModal() {
                const preDefinedTemplates = [
                    { id: 'cornell-notes', icon: 'ðŸŽ“', title: 'Cornell Notes 2.0', desc: 'A robust system for structured note-taking and review.' },
                    { id: 'vocab-card', icon: 'ðŸ“š', title: 'Vocabulary Card', desc: 'Build your lexicon with structured vocabulary cards.' },
                    { id: 'upsc-analysis', icon: 'ðŸ—ž', title: 'UPSC Analysis', desc: 'For Current Affairs & syllabus linkage.' },
                    { id: 'meeting-agenda', icon: 'ðŸ¤', title: 'Meeting Agenda', desc: 'A clean, professional structure for any meeting.' },
                    { id: 'daily-planner', icon: 'ðŸ“…', title: 'Daily Planner', desc: 'Organize your day with tasks and priorities.' },
                    { id: 'smart-goals', icon: 'ðŸŽ¯', title: 'SMART Goals', desc: 'Define Specific, Measurable, Relevant goals.' },
                    { id: 'kwl-chart', icon: 'ðŸ§ ', title: 'KWL Chart', desc: 'Track what you Know, Want, and Learned.' },
                    { id: 'pros-cons', icon: 'â€¼ï¸', title: 'Pros & Cons', desc: 'A balanced matrix for informed decisions.' },
                    { id: 'swot-analysis', icon: 'âš–ï¸', title: 'SWOT Analysis', desc: 'Analyze Strengths, Weaknesses, Opportunities, Threats.' },
                    { id: 'content-planner', icon: 'ðŸš€', title: 'Content Planner', desc: 'A simple Kanban board to track your ideas.' }
                ];

                const cardsHTML = preDefinedTemplates.map(t => `
                    <div class="template-hub-card" onclick="App.events.ai.executeKashTemplate('${t.id}')">
                        <div class="template-card-icon">${t.icon}</div>
                        <div class="template-card-text">
                            <h3 class="template-card-title">${t.title}</h3>
                            <p class="template-card-desc">${t.desc}</p>
                        </div>
                    </div>
                `).join('');

                const isPremium = App.license.isPremium();
                const premiumLockClass = isPremium ? '' : 'premium-feature-locked';

                const modalHTML = `
                <style>
                    .template-hub-card {
                        background-color: var(--bg-secondary);
                        padding: 1rem;
                        border: 1px solid var(--border-color);
                        border-radius: var(--border-radius-lg);
                        display: flex;
                        align-items: flex-start;
                        gap: 1rem;
                        cursor: pointer;
                        transition: all 0.2s ease-in-out;
                    }
                    .template-hub-card:hover {
                        transform: translateY(-4px);
                        border-color: var(--primary-color);
                        box-shadow: 0 0 15px 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
                    }
                    .template-card-icon {
                        width: 40px;
                        height: 40px;
                        flex-shrink: 0;
                        background-color: var(--bg-tertiary);
                        border-radius: 10px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 1.5rem;
                        color: var(--text-primary);
                    }
                    .template-card-text { flex-grow: 1; }
                    .template-card-title {
                        font-size: 1rem;
                        font-weight: 600;
                        margin: 0 0 0.25rem 0;
                        color: var(--text-primary);
                    }
                    .template-card-desc {
                        font-size: 0.85rem;
                        color: var(--text-secondary);
                        line-height: 1.4;
                        margin: 0;
                    }
                </style>
                <div class="modal-backdrop" onclick="if(event.target === this) App.ui.closeModal()">
                    <div class="modal-content ui-card" style="max-width: 900px;" onclick="event.stopPropagation()">
                        <button class="modal-close-btn" onclick="App.ui.closeModal()">&times;</button>
                        <div style="text-align: center;">
                            <h3 class="witty-gradient-text" style="font-size: 1.8rem;">Template Hub</h3>
                            <p style="color: var(--text-secondary);">Choose a pre-made template or ask AI to create a custom one for you.</p>
                        </div>
                        
                        <div class="settings-section ${premiumLockClass}">
                            <h4><i class="fa-solid fa-wand-magic-sparkles" style="color: var(--primary-color);"></i> Create with AI</h4>
                            <div style="display: flex; gap: 0.75rem;">
                                <input type="text" id="custom-template-prompt" class="text-input" placeholder="e.g., a simple weekly meal planner...">
                                <button class="btn btn-primary" id="generate-custom-template-btn">Generate</button>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h4><i class="fa-solid fa-star" style="color: var(--primary-color);"></i> Curated Templates</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1rem; margin-top: 1rem;">
                                ${cardsHTML}
                            </div>
                        </div>
                    </div>
                </div>`;

                document.getElementById('modal-container').innerHTML = modalHTML;
                
                const customInput = document.getElementById('custom-template-prompt');
                const generateBtn = document.getElementById('generate-custom-template-btn');

                const generateAction = () => {
                    const prompt = customInput.value.trim();
                    if (prompt) {
                        if (isPremium) {
                            App.events.ai.executeKashTemplate(prompt);
                        } else {
                            App.ui.showAscensionModal();
                        }
                    } else {
                        App.ui.showToast("Please describe the template you want.", "warning");
                    }
                };

                generateBtn.addEventListener('click', generateAction);
                customInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        generateAction();
                    }
                });
            },

            toggleProfileNotification() {
                const notificationCard = document.getElementById('profile-notification-card');
                const profileBadge = document.getElementById('profile-badge');

                if (!notificationCard || !profileBadge) return;

                if (notificationCard.style.display === 'flex') {
                    this.closeProfileNotification();
                } else {
                    this.renderProfileNotification();
                    notificationCard.style.display = 'flex';
                    profileBadge.classList.add('active'); // Indicate active state
                    // Add a global listener to close when clicking outside
                    setTimeout(() => { // Small delay to prevent immediate close if click initiated toggle
                        document.addEventListener('click', this.closeProfileNotificationOutside, { once: true });
                    }, 100);
                }
            },

            closeProfileNotification() {
                const notificationCard = document.getElementById('profile-notification-card');
                const profileBadge = document.getElementById('profile-badge');
                if (notificationCard) {
                    notificationCard.style.display = 'none';
                }
                if (profileBadge) {
                    profileBadge.classList.remove('active');
                }
                document.removeEventListener('click', App.ui.closeProfileNotificationOutside);
            },

            closeProfileNotificationOutside(event) {
                const profileHub = document.getElementById('profile-hub');
                if (profileHub && !profileHub.contains(event.target)) {
                    App.ui.closeProfileNotification();
                } else {
                    // Re-add listener if click was inside profile hub but not on card itself
                    document.addEventListener('click', App.ui.closeProfileNotificationOutside, { once: true });
                }
            },

            renderProfileNotification() {
                const tierName = App.license.state.tier || 'Spark';
                const isPremium = App.license.isPremium();
                const userName = App.license.state.userName || 'Valued User';

                const notificationBadgeIcon = document.getElementById('notification-badge-icon');
                const notificationTitle = document.getElementById('notification-title');
                const notificationMessage = document.getElementById('notification-message');
                const notificationLink = document.getElementById('notification-link');
                const notificationLinkMessage = document.getElementById('notification-link-message');

                const powerQuote = App.util.getPowerQuote();

                if (notificationBadgeIcon) {
                    notificationBadgeIcon.innerHTML = App.util.getTierBadgeHTML(tierName);
                    const badgeIconEl = notificationBadgeIcon.querySelector('.badge-icon');
                    if (badgeIconEl) {
                        badgeIconEl.style.width = '48px';
                        badgeIconEl.style.height = '48px';
                    }
                }
                
                if (isPremium) {
                    // RATIONALE (FIX #3): Use the new utility to generate a dynamic, appreciative title.
                    if (notificationTitle) {
                        notificationTitle.innerHTML = App.util.getAppreciationMessage(userName, tierName);
                    }
                    // RATIONALE (FIX #1): The power quote is now placed INSIDE the clickable link, replacing the static text.
                    if (notificationLinkMessage) {
                        notificationLinkMessage.className = 'notification-message power-quote-gradient';
                        notificationLinkMessage.innerHTML = `&ldquo;${powerQuote}&rdquo;`;
                    }
                    notificationLink.style.display = 'block';
                    notificationMessage.style.display = 'none'; // Hide the non-clickable <p>
                } else {
                    // This is the original, correct behavior for Spark users.
                    if (notificationTitle) {
                        notificationTitle.innerHTML = `You are in the <strong>Spark League</strong>`;
                    }
                    if (notificationMessage) {
                        notificationMessage.className = 'notification-message power-quote-gradient';
                        notificationMessage.innerHTML = `&ldquo;${powerQuote}&rdquo;`;
                        notificationMessage.style.display = 'block';
                    }
                    notificationLink.style.display = 'none';
                }
            },

            closeModal() {
                Object.values(App.state.chartInstances).forEach(chart => chart?.destroy());
                App.state.chartInstances = {};
                document.removeEventListener('keydown', App.events.handleProductivityHubKeyDown, true);
                if (App.ui.aiMagicModal.state.isOpen) {
                    App.ui.aiMagicModal.close();
                }

                document.getElementById('modal-container').innerHTML = ''; 
            },

            updateTheLine(progress) {
                    const line = document.getElementById('the-line');
                    if (line) {
                        line.style.transform = `scaleX(${progress})`;
                    }
            },

            async showLibraryLoadingScreenAndLoadData() {
                 await App.loadInitialData();
                App.router.navigateTo('library');
            },

            
            renderChartOnCanvas(canvas) {
                if (!canvas || !canvas.dataset.chartConfig) return;

                try {
                    // 1. Get the theme-agnostic config we saved earlier.
                    const config = JSON.parse(canvas.dataset.chartConfig);

                    // 2. Get fresh styling information based on the CURRENT theme.
                    const themeColors = App.util.getChartColors();
                    const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-primary');
                    const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color');
                    const secondaryBg = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');

                    // 3. Dynamically apply all styling to the config object in memory.
                    if (config.type === 'line') {
                        // --- FIX: Add specific styling for Line charts ---
                        // RATIONALE: Line charts need a colored 'borderColor' for the line itself
                        // and a semi-transparent 'backgroundColor' for the area fill.
                        const primaryColor = themeColors[0] || '#0d9488';
                        const primaryRgb = App.util.colorToRgb(primaryColor);
                        
                        config.data.datasets[0].borderColor = primaryColor;
                        config.data.datasets[0].backgroundColor = primaryRgb ? `rgba(${primaryRgb.join(',')}, 0.2)` : '#0d948833';
                        config.data.datasets[0].fill = true; // Creates the modern "area chart" look.
                        config.data.datasets[0].tension = 0.4; // Adds a nice curve to the line.
                        config.data.datasets[0].pointBackgroundColor = primaryColor; // Ensure points are visible
                        config.data.datasets[0].pointBorderColor = secondaryBg; // Give points a nice border
                        config.data.datasets[0].pointBorderWidth = 2;
                        
                    } else {
                        // This is the existing logic for Bar and Doughnut charts
                        config.data.datasets[0].backgroundColor = themeColors;
                        config.data.datasets[0].borderColor = secondaryBg;
                        config.data.datasets[0].borderWidth = config.type === 'doughnut' ? 4 : 1;
                        config.data.datasets[0].borderRadius = config.type === 'bar' ? 6 : 0;
                    }

                    config.options = {
                        ...config.options, // Keep structural options like indexAxis
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: config.type === 'doughnut', // Only show legend for doughnut charts
                                position: 'right',
                                labels: { color: textColor }
                            }
                        },
                        scales: (config.type !== 'doughnut') ? {
                            x: { ticks: { color: textColor }, grid: { color: gridColor } },
                            y: { ticks: { color: textColor }, grid: { color: gridColor } }
                        } : {}
                    };
                    
                    // 4. If a chart instance already exists on this canvas, destroy it first.
                    if (Chart.getChart(canvas)) {
                        Chart.getChart(canvas).destroy();
                    }

                    // 5. Create the new Chart.js instance with the freshly styled config.
                    new Chart(canvas.getContext('2d'), config);

                } catch (e) {
                    console.error("Failed to render chart from data attribute:", e);
                    canvas.parentElement.innerHTML = '<p style="color:var(--danger-color);">[Chart data is corrupted]</p>';
                }
            },


            updateStudyProgressUI() {
                const s = App.state.studySession;
                const progressBar = document.getElementById('study-progress-bar');
                let progress = 0;
                if (s.isActive && s.cards.length > 0) {
                    progress = (s.currentIndex + 1) / s.cards.length;
                } else {
                    progress = 1;
                }

                this.updateTheLine(progress);
                if(progressBar) {
                    progressBar.value = s.currentIndex + 1;
                    progressBar.max = s.cards.length;
                }
            }
        },
        
        // ==========================================================================
        // 3.11. PWA LOGIC
        // ==========================================================================
        pwa: {
            init() {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('./service-worker.js').then(reg => {
                        console.log('Service Worker registered successfully.');
                        reg.addEventListener('updatefound', () => {
                            const newWorker = reg.installing;
                            console.log('New service worker found, installing.');
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('New service worker installed, ready for activation.');
                                    this.showUpdatePrompt(newWorker);
                                }
                            });
                        });
                    }).catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });

                    navigator.serviceWorker.addEventListener('controllerchange', () => {
                        window.location.reload();
                    });
                }
            },
            handleInstallPrompt(e) {
                e.preventDefault();
                App.state.pwa.installPromptEvent = e;
                const installBtn = document.getElementById('install-pwa-btn');
                if (installBtn) {
                    installBtn.style.display = 'inline-flex';
                }
            },
            showUpdatePrompt(worker) {
                 App.ui.showToast('A new version is available!', {
                    type: 'info',
                    duration: 10000,
                    action: {
                        label: 'Reload',
                        callback: () => {
                            worker.postMessage({ type: 'SKIP_WAITING' });
                        }
                    }
                });
            }
        },
    

        // ==========================================================================
        // 3.12. EVENT HANDLERS
        // ==========================================================================
        events: {
            
            transitionToLibrary(loadFunction) {
                const welcomeView = document.getElementById('welcome-view');
                if (welcomeView && welcomeView.classList.contains('active')) {
                    welcomeView.classList.add('fading-out');
                    setTimeout(() => {
                        loadFunction();
                    }, 350); 
                } else {
                    loadFunction();
                }
            },

            useBrowserStorage() {
                this.transitionToLibrary(async () => {
                    // Clear all previous state
                    await App.settings.set('lastStorageMode', 'browser');
                    App.state.isInitialLoadComplete = false;
                    App.state.isHydrated = false;
                    App.state.articles = [];

                    App.state.storageMode = 'browser';
                    App.state.directoryHandle = null;
                    await App.indexedDB.setHandle('directory', null);

                    await App.settings.load();
        
                    App.ui.applyTheme(App.settings.get('theme'));
                    await App.loadInitialData();
                    App.router.navigateTo('library');
                });
            },


            handlePopState(event) {
                if (event.state) {
                    App.router.navigateTo(event.state.viewId, event.state.data, true);
                }
            },
            changeLibraryTitle(event) {
                let newTitle = event.target.value.trim();
                if (!newTitle) {
                    newTitle = 'My Library'; // Fallback to default if empty
                }
                App.settings.set('libraryTitle', newTitle);
                
                // Live update the title if the library view is active
                const libraryTitleEl = document.querySelector('#library-view .library-title');
                if (libraryTitleEl) {
                    libraryTitleEl.textContent = newTitle;
                }
            },
            changeLibrarySort(event) {
                App.settings.set('librarySortBy', event.target.value);
                App.ui.filterAndRenderArticles();
            },

            cycleReaderTheme(goBack = false) { 
                const themes = App.events.presentation.themes;
                const currentIndex = themes.indexOf(App.state.activeReaderTheme);
                const nextIndex = goBack 
                    ? (currentIndex - 1 + themes.length) % themes.length 
                    : (currentIndex + 1) % themes.length;
                const newTheme = themes[nextIndex];

                App.state.activeReaderTheme = newTheme;
                App.settings.set('readerTheme', newTheme); // Remember the choice
                App.ui.applyReaderTheme();

                const themeName = newTheme.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                App.ui.showToast(`${themeName} Theme`, { type: 'info', duration: 1500 });
            },
            resetReaderTheme() {
                App.state.activeReaderTheme = 'default';
                App.settings.set('readerTheme', 'default');
                App.ui.applyReaderTheme();
                App.ui.showToast('Theme reset to default', { type: 'success', duration: 2000 });
            },

            
            handleGlobalClickInterceptor(event) {
                const lockedElement = event.target.closest('.premium-feature-locked');
                
                if (lockedElement && event.target.closest('.stage-mode-controls')) return;
                if (lockedElement && !App.license.isPremium()) {
                    event.preventDefault();
                    event.stopPropagation();
                    App.ui.showAscensionModal();
                }
            },

            generateLicenseRequestEmail() {
                const name = document.getElementById('license-name-input')?.value || '[Name not provided]';
                const status = document.getElementById('license-status-input')?.value || '[Status not provided]';
                const tierSelect = document.getElementById('license-tier-select');
                const tier = tierSelect.options[tierSelect.selectedIndex].text;

                const subject = `NoteKash License Key Request - ${tier}`;
                const body = `Hi there,\n\nMyself, ${name} am applying for a license key.\n\nStatus/Bio: ${status}\n\nKindly provide me with a License Key for the ${tier}.\n\nThank you!`;

                const mailtoLink = `mailto:learningmarvel@gmail.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                
                window.location.href = mailtoLink;
            },

            // New function to handle the command palette button click
            openCommandPaletteFromButton() {
                const contentDiv = document.getElementById('article-content');
                if (!contentDiv) return;

                // Re-focus the editor to ensure we have an active cursor position.
                contentDiv.focus();

                // Use a tiny delay to allow the browser to process the focus event.
                setTimeout(() => {
                    const selection = window.getSelection();
                    const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
                    App.commandPalette.open(range);
                }, 10);
            },

            handleSyncToggle() {
                if (!App.license.isPremium()) {
                    App.ui.showAscensionModal();
                    return;
                }
                const syncEnabled = App.settings.get('enableDropboxSync');
                App.settings.set('enableDropboxSync', !syncEnabled);
                App.ui.showStorageModal();
                if (!syncEnabled && App.dropbox.isReady()) {
                    App.dropbox.syncChanges(true);
                }
            },


            handleProductivityHubKeyDown(e) {
                const modal = document.getElementById('productivity-modal');
                if (!modal) {
                    document.removeEventListener('keydown', App.events.handleProductivityHubKeyDown, true);
                    return;
                }

                if (e.key === 'Enter') {
                    const titleInput = document.getElementById('composer-title-input');
                    if (titleInput && titleInput.value.trim() !== '' && !document.getElementById('pomodoro-settings-popup')) {
                        e.preventDefault();
                        e.stopPropagation();
                        App.hub.tasks.add();
                        return;
                    }
                }

                const activeEl = document.activeElement;
                const isTyping = activeEl && (
                    (activeEl.tagName === 'INPUT' && activeEl.type !== 'checkbox') ||
                    activeEl.tagName === 'SELECT' ||
                    activeEl.tagName === 'TEXTAREA'
                );

                if (isTyping) return;

                let shortcutHandled = false;
                const startTaskTimer = (index) => {
                    const startButtons = document.querySelectorAll('.task-item [data-action="start-pomodoro"]');
                    startButtons[index]?.click();
                };

                switch (e.key.toLowerCase()) {
                    case 'a': modal.querySelector('.pomodoro-controls button[title="Stop & Reset"]')?.click(); shortcutHandled = true; break;
                    case 's': modal.querySelector('.pomodoro-controls button[title*="Play"], .pomodoro-controls button[title*="Pause"]')?.click(); shortcutHandled = true; break;
                    case 't': App.hub.ui.showPomodoroSettings(); shortcutHandled = true; break;
                    case 'z': App.hub.pomodoro.toggleZenMode(); shortcutHandled = true; break;
                    case 'd': document.getElementById('composer-date-input')?.focus(); shortcutHandled = true; break;
                    case 'g': document.getElementById('category-select')?.focus(); shortcutHandled = true; break;
                    case 'f': document.getElementById('priority-btn')?.click(); shortcutHandled = true; break;
                    case 'c': document.getElementById('pomo-goal-btn')?.click(); shortcutHandled = true; break;
                    case 'x': const pomoBtn = document.getElementById('pomo-goal-btn'); if (pomoBtn) { pomoBtn.dispatchEvent(new MouseEvent('contextmenu', { bubbles: true, cancelable: true, view: window })); } shortcutHandled = true; break;
                    case 'q': startTaskTimer(0); shortcutHandled = true; break;
                    case 'w': startTaskTimer(1); shortcutHandled = true; break;
                    case 'e': startTaskTimer(2); shortcutHandled = true; break;
                    case 'r': startTaskTimer(3); shortcutHandled = true; break;
                }

                if (shortcutHandled) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            },
            
            setupGlobalListeners() {
                document.body.addEventListener('click', this.handleGlobalClickInterceptor, true);
                document.getElementById('profile-badge')?.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent immediate closing by closeProfileNotificationOutside
                    App.ui.toggleProfileNotification();
                });
                // Listen for the browser's back/forward button events.
                window.addEventListener('popstate', this.handlePopState);

                document.addEventListener('mousedown', (e) => {
                    if (!e.target.closest('#selection-toolbar')) App.ui.hideSelectionToolbar();
                    if (!e.target.closest('#image-toolbar')) App.ui.hideImageToolbar();
                    if (!e.target.closest('.context-menu')) App.ui.hideContextMenu();
                });

                document.addEventListener('click', (e) => {
                    // Specifically check for backlink clicks within the article content in read mode
                    const link = e.target.closest('#article-content a[data-link-type]');
                    if (link && App.state.currentMode === 'read') {
                        e.preventDefault();
                        e.stopPropagation(); // Stop other click events
                        const { linkType, linkId, articleId } = link.dataset;
                        if (linkType === 'article') {
                            App.router.navigateTo('article', { id: linkId, mode: 'read' });
                        } else if (linkType === 'snippet') {
                            App.router.navigateTo('article', { id: articleId, mode: 'read', scrollToSnippetId: linkId });
                        }
                    }
                });

                document.addEventListener('keydown', this.handleGlobalKeyDown);
                window.addEventListener('pagehide', () => { App.hub.data.saveTasks(); App.hub.data.savePomodoroStats(); App.quiz.saveStats(); App.settings.save(); });
                window.addEventListener('beforeinstallprompt', App.pwa.handleInstallPrompt);
                document.getElementById('install-pwa-btn')?.addEventListener('click', this.installPwa);

                const header = document.querySelector('header');
                if (header) {
                    header.addEventListener('click', (e) => {
                        // This logic is only for mobile view
                        if (!document.body.classList.contains('mobile-view')) {
                            return;
                        }
                        // Check if the hub is open and the click was on a header button that ISN'T the hub button itself
                        if (document.getElementById('productivity-modal') && e.target.closest('button') && !e.target.closest('#todo-btn')) {
                            App.hub.ui.closeModal();
                        }
                    });
                }
            },
           
            // Located in App.events
            mountViewListeners(viewId) {
                const setupDebouncedSearch = (inputId, filterFunction) => {
                    const input = document.getElementById(inputId);
                    if (input) {
                        input.addEventListener('input', () => {
                            clearTimeout(App.state.libraryRender.searchTimeout);
                            App.state.libraryRender.searchTimeout = setTimeout(() => {
                                filterFunction.call(App.ui);
                            }, 200);
                        });
                    }
                };

                switch (viewId) {
                    case 'library':
                        const grid = document.getElementById('article-grid');
                        if(grid) grid.innerHTML = App.state.articles.map(article => App.ui.getArticleCardHTML(article)).join('');

                        setupDebouncedSearch('search-input', App.ui.filterAndRenderArticles);
                        document.getElementById('sort-filter')?.addEventListener('change', (e) => App.events.changeLibrarySort(e));

                        document.getElementById('search-input')?.addEventListener('keydown', (e) => {
                            const { searchResults, selectedIndex } = App.state.libraryRender;
                            if (!searchResults || searchResults.length === 0) return;
                            let newIndex = selectedIndex;
                            let handled = false;
                            if (e.key === 'ArrowDown' || e.key === 'ArrowRight') { newIndex = (selectedIndex + 1) % searchResults.length; handled = true; } 
                            else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') { newIndex = (selectedIndex - 1 + searchResults.length) % searchResults.length; handled = true; } 
                            else if (e.key === 'Enter') { e.preventDefault(); const selectedCard = searchResults[selectedIndex]; if (selectedCard) selectedCard.click(); return; }
                            if (handled) { e.preventDefault(); if (selectedIndex > -1) searchResults[selectedIndex].classList.remove('search-selected-card'); searchResults[newIndex].classList.add('search-selected-card'); searchResults[newIndex].scrollIntoView({ behavior: 'smooth', block: 'center' }); App.state.libraryRender.selectedIndex = newIndex; }
                        });
                        break;
                    case 'article':
                        document.getElementById('article-controls').addEventListener('mousedown', this.handleArticleControlsClick);
                        const mainEl = document.querySelector('main');
                        if (mainEl) mainEl.addEventListener('scroll', App.events.updateReadingProgress, { passive: true });
                        const contentDiv = document.getElementById('article-content');

                        contentDiv.addEventListener('click', this.handleContentClick); 
                        const exportBtn = document.getElementById('export-popover-btn');
                        if (exportBtn) {
                            const popoverGroup = exportBtn.parentElement;

                            const closePopover = (e) => {
                                if (!popoverGroup.contains(e.target)) {
                                    popoverGroup.classList.remove('popover-active');
                                    document.removeEventListener('click', closePopover);
                                }
                            };

                            exportBtn.addEventListener('click', (e) => {
                                e.stopPropagation(); 
                                const isActive = popoverGroup.classList.toggle('popover-active');
                                if (isActive) {
                                    document.addEventListener('click', closePopover);
                                }
                            });
                        }

                        if (App.state.currentMode === 'write') {
                            const titleInput = document.getElementById('article-title');
                            const setDirty = () => { App.state.isArticleDirty = true; };
                            let audioInitTimeout;
                            contentDiv.addEventListener('input', () => {
                                setDirty();
                                contentDiv.classList.remove('is-empty');
                                clearTimeout(audioInitTimeout);
                                audioInitTimeout = setTimeout(() => {
                                    App.audio.initializePlayersIn(contentDiv);
                                }, 500); // 500ms delay after last input
                            });
                            titleInput.addEventListener('input', setDirty);
                            App.state.autosaveInterval = setInterval(() => { if (App.state.isArticleDirty) App.events.saveArticle({ isAutosave: true }); }, 15000);
                            const guardianCallback = () => { if (contentDiv.childElementCount === 0 || (contentDiv.childElementCount === 1 && contentDiv.firstElementChild.tagName === 'BR')) { contentDiv.innerHTML = '<p><br></p>'; }};
                            App.state.guardianObserver = new MutationObserver(guardianCallback);
                            App.state.guardianObserver.observe(contentDiv, { childList: true });
                            guardianCallback();
                            contentDiv.addEventListener('mouseup', App.events.handleSelection);

                            contentDiv.addEventListener('focusin', (e) => {
                                // When typing in mobile view, ensure the cursor is not hidden by the keyboard
                                if (document.body.classList.contains('mobile-view')) {
                                    setTimeout(() => {
                                        e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    }, 300); // A small delay allows the keyboard to animate in
                                }
                            });
                            contentDiv.addEventListener('paste', App.events.handlePaste);
                            contentDiv.addEventListener('keydown', (e) => {
                                const trigger = document.activeElement.closest('.nk-accordion-trigger');
                                if ((e.key === 'Enter' || e.key === ' ') && trigger && !document.activeElement.isContentEditable) {
                                    e.preventDefault();
                                    trigger.click();
                                    return;
                                }
                                App.events.handleWriterShortcuts(e);
                            });
                            contentDiv.addEventListener('focusin', App.events.handleFocusIn);
                            contentDiv.addEventListener('dragover', App.events.handleDragOver);
                            contentDiv.addEventListener('dragleave', App.events.handleDragLeave);
                            contentDiv.addEventListener('drop', App.events.handleImageDrop);
                        }
                        break;
                    case 'tags':
                        setupDebouncedSearch('tag-search-input', App.events.filterAndRenderTags);
                        document.getElementById('tag-sort-filter')?.addEventListener('change', App.events.changeTagSort);
                        break;
                    case 'flashcard':
                        document.getElementById('flashcard-sort')?.addEventListener('change', App.events.changeFlashcardSort);
                        setupDebouncedSearch('flashcard-search-input', App.ui.filterAndRenderFlashcards);
                        document.getElementById('flashcard-search-input')?.addEventListener('keydown', (e) => {
                            const { searchResults, selectedIndex } = App.state.flashcardRender;
                            if (!searchResults || searchResults.length === 0) return;
                            let newIndex = selectedIndex;
                            let handled = false;
                            if (e.key === 'ArrowDown' || e.key === 'ArrowRight') { newIndex = (selectedIndex + 1) % searchResults.length; handled = true; } 
                            else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') { newIndex = (selectedIndex - 1 + searchResults.length) % searchResults.length; handled = true; } 
                            else if (e.key === 'Enter') { e.preventDefault(); const selectedCard = searchResults[selectedIndex]; if (selectedCard) selectedCard.click(); return; }
                            if (handled) { e.preventDefault(); if (selectedIndex > -1) searchResults[selectedIndex].classList.remove('search-selected-card'); searchResults[newIndex].classList.add('search-selected-card'); searchResults[newIndex].scrollIntoView({ behavior: 'smooth', block: 'center' }); App.state.flashcardRender.selectedIndex = newIndex; }
                        });
                        break;
                }
            },


            typewriter: {
                intervalId: null,
        
                start(element) {
                    this.reset(); // Stop any previous typewriter effect
                    if (!element) return;

                    const words = element.querySelectorAll('.reveal-word');
                    if (words.length === 0) return; // Nothing to type

                    let wordIndex = 0;
                    this.intervalId = setInterval(() => {
                        if (wordIndex < words.length) {
                            words[wordIndex].classList.add('visible');
                            wordIndex++;
                        } else {
                            this.reset(); // Effect finished, clear the timer
                        }
                    }, 50); // Adjust typing speed here (milliseconds)
                },

                // This function clears any active typewriter timer
                reset() {
                    if (this.intervalId) {
                        clearInterval(this.intervalId);
                        this.intervalId = null;
                    }
                }
            },

            presentation: {
                themes: [
                    'default',
                    'lime-ink', 'goldenrod-pad', 'mint-chip', 'aqua-sky', 'peach-sorbet', 'powder-snow',
                    'terminal', 'crimson-night', 'royal-indigo', 'emerald-tablet', 'obsidian-ruby', 'blueprint', 'midnight-sun',
                    'evergreen', 'clay-sky', 'sandstone-agave', 'stone-moss', 'mahogany', 'riverbed','matrix',
                    'rosewater', 'azure-depth', 'olive-grove', 'sterling', 'greyscale'
                ],
                currentThemeIndex: 0,
                currentSnippetIndex: -1,
                 _revealFirstVisibleSnippet() {
                    const overlay = document.getElementById('focus-mode-overlay');
                    if (!overlay) return;

                    const allItems = Array.from(overlay.querySelectorAll('.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-accordion'));

                    const visibleItems = allItems.filter(el => el.classList.contains('is-visible'));

                    if (visibleItems.length > 0) {
                        const firstItemOnNewSlide = visibleItems[0];
                        // Un-reveal everything first
                        allItems.forEach(item => item.classList.remove('is-revealing', 'spotlight-key-focus'));
                        // Reveal just the first one on the new slide
                        firstItemOnNewSlide.classList.add('is-revealing', 'spotlight-key-focus');
                        App.events.typewriter.start(firstItemOnNewSlide);
                    }
                },

                cycleAmbiance(goBack = false) {
                    const session = App.state.focusSession;
                    if (!session.isActive) return;

                    const overlay = document.getElementById('focus-mode-overlay');
                    if (!overlay) return;

                    const currentIndex = this.themes.indexOf(session.activeTheme);
                    const nextIndex = goBack
                        ? (currentIndex - 1 + this.themes.length) % this.themes.length
                        : (currentIndex + 1) % this.themes.length;
                    const newTheme = this.themes[nextIndex];

                    // Manually remove any old theme classes
                    overlay.className = overlay.className.replace(/\bambiance-\S+/g, '').trim();
                    
                    if (newTheme !== 'default') {
                        overlay.classList.add(`ambiance-${newTheme}`);
                    }
                    
                    session.activeTheme = newTheme;

                    const themeName = newTheme.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    App.ui.showToast(`${themeName}`, { type: 'info', duration: 1500 });
                },

                // This function now correctly resets the theme using direct, reliable logic.
                resetAmbiance() {
                    const session = App.state.focusSession;
                    if (!session.isActive) return;

                    const overlay = document.getElementById('focus-mode-overlay');
                    if (!overlay) return;

                    overlay.className = overlay.className.replace(/\bambiance-\S+/g, '').trim();
                    session.activeTheme = 'default';

                    App.ui.showToast('Theme reset to default', { type: 'success', duration: 2000 });
                },

                toggleCinematicMotion(buttonEl) {
                    const session = App.state.focusSession;
                    if (!session.isActive) return;
                    session.isCinematicActive = !session.isCinematicActive;
                    const overlay = document.getElementById('focus-mode-overlay');
                    overlay?.classList.toggle('cinematic-active', session.isCinematicActive);
                    if (buttonEl) buttonEl.classList.toggle('active', session.isCinematicActive);
                    const currentSlideSnippets = session.isStageMode 
                        ? Array.from(overlay.querySelectorAll('.snippet.is-visible, .nk-mcq-block.is-visible'))
                        : Array.from(overlay.querySelectorAll('.snippet, .nk-mcq-block'));

                    // Reliability Polish: Clear any old spotlights when toggling
                    overlay.querySelectorAll('.spotlight-key-focus').forEach(el => el.classList.remove('spotlight-key-focus'));

                    if (session.isCinematicActive) {
                        currentSlideSnippets.forEach(s => s.classList.remove('is-revealing'));
                        this.currentSnippetIndex = -1;
                        this.navigateCinematicSnippet(1, true); // Reveal first snippet without scrolling
                        App.ui.showToast('Cinematic Reveal Enabled', { type: 'info' });
                    } else {
                        currentSlideSnippets.forEach(s => s.classList.add('is-revealing'));
                        App.events.typewriter.reset();
                        App.ui.showToast('Cinematic Reveal Disabled', { type: 'info' });
                    }
                },

                navigateCinematic(direction) {
                    const overlay = document.getElementById('focus-mode-overlay');
                    
                    const snippets = Array.from(overlay.querySelectorAll('.snippet.is-visible, .nk-mcq-block.is-visible, .nk-accordion.is-visible'));

                    if (snippets.length === 0) return;

                    // Clear any previous spotlight
                    overlay.querySelectorAll('.spotlight-key-focus').forEach(el => el.classList.remove('spotlight-key-focus'));

                    let newIndex = this.currentSnippetIndex + direction;
                    
                    // Clamp the new index to be within the valid range of snippets
                    newIndex = Math.max(0, Math.min(snippets.length - 1, newIndex));

                    const targetSnippet = snippets[newIndex];

                    if (targetSnippet) {
                        snippets.forEach(s => s.classList.remove('is-revealing'));
                        targetSnippet.classList.add('is-revealing');
                        
                        // Add the spotlight effect to the newly revealed snippet
                        targetSnippet.classList.add('spotlight-key-focus');
                        targetSnippet.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        // Apply the typewriter effect
                        App.events.typewriter.start(targetSnippet);
                    }
                    
                    this.currentSnippetIndex = newIndex;
                },


                _handleTeleprompterDragStart(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const resizer = document.getElementById('teleprompter-resizer');
                    if (resizer) resizer.classList.add('is-resizing');

                    document.addEventListener('mousemove', App.events.presentation._handleTeleprompterDrag);
                    document.addEventListener('mouseup', App.events.presentation._handleTeleprompterDragEnd);
                    document.addEventListener('touchmove', App.events.presentation._handleTeleprompterDrag, { passive: false });
                    document.addEventListener('touchend', App.events.presentation._handleTeleprompterDragEnd);
                },

                _handleTeleprompterDrag(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const session = App.state.focusSession;
                    if (!session.teleprompterActive) return;

                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                    const sidebar = document.getElementById('teleprompter-sidebar');
                    const content = document.querySelector('.focus-mode-overlay.teleprompter-active .focus-mode-content');
                    if (!sidebar || !content) return;

                    let newPercentage = 30;

                    if (document.body.classList.contains('mobile-view')) {
                        // Mobile: Vertical resize (based on height)
                        const headerHeight = document.querySelector('header')?.offsetHeight || 48;
                        const newHeight = clientY - headerHeight;
                        newPercentage = (newHeight / window.innerHeight) * 100;
                        newPercentage = Math.max(15, Math.min(85, newPercentage)); // Clamp between 15% and 85% height
                        
                        sidebar.style.height = `${100 - newPercentage}%`;
                        content.style.height = `${newPercentage}%`;
                    } else {
                        // Desktop: Horizontal resize (based on width)
                        newPercentage = (clientX / window.innerWidth) * 100;
                        newPercentage = Math.max(15, Math.min(60, newPercentage)); // Clamp between 15% and 60% width

                        sidebar.style.width = `${newPercentage}%`;
                        content.style.width = `${100 - newPercentage}%`;
                    }

                    session.teleprompterSize = newPercentage;
                    
                    // Recalculate stage mode layout *after* the DOM has updated
                    requestAnimationFrame(() => {
                        const bodyEl = document.querySelector('.focus-mode-body');
                        if (bodyEl && session.isStageMode) {
                            session.scrollStops = App.ui._calculateScrollStops(bodyEl);
                        }
                    });
                },

                _handleTeleprompterDragEnd(e) {
                    const resizer = document.getElementById('teleprompter-resizer');
                    if (resizer) resizer.classList.remove('is-resizing');

                    document.removeEventListener('mousemove', App.events.presentation._handleTeleprompterDrag);
                    document.removeEventListener('mouseup', App.events.presentation._handleTeleprompterDragEnd);
                    document.removeEventListener('touchmove', App.events.presentation._handleTeleprompterDrag);
                    document.removeEventListener('touchend', App.events.presentation._handleTeleprompterDragEnd);

                    // Final recalculation to ensure scroll stops are perfect
                    const session = App.state.focusSession;
                    const bodyEl = document.querySelector('.focus-mode-body');
                    if (bodyEl && session.isStageMode) {
                        session.scrollStops = App.ui._calculateScrollStops(bodyEl);
                    }
                },

                adjustTeleprompterFont(delta) {
                    const session = App.state.focusSession;
                    const sidebar = document.getElementById('teleprompter-sidebar');
                    if (!session.isActive || !session.teleprompterActive || !sidebar) return;
                    const currentSizeString = getComputedStyle(sidebar).getPropertyValue('--teleprompter-font-size') || '1.1rem';
            
                    let currentSizeNum = parseFloat(currentSizeString);
                    if (isNaN(currentSizeNum)) {
                        currentSizeNum = 1.1;
                    }
                    let newSize = currentSizeNum + delta;
                    newSize = Math.max(0.5, Math.min(3.0, newSize)); // Clamp size

                    session.teleprompterFontSize = newSize; // Store the new number
                    sidebar.style.setProperty('--teleprompter-font-size', `${newSize}rem`);
                },

                toggleTeleprompter() {
                    const session = App.state.focusSession;
                    if (!session.isActive) return;

                    session.teleprompterActive = !session.teleprompterActive;
                    const overlay = document.getElementById('focus-mode-overlay');
                    const toggleBtn = document.getElementById('teleprompter-toggle-btn');
                    const contentEl = overlay.querySelector('.focus-mode-content');

                    overlay.classList.toggle('teleprompter-active', session.teleprompterActive);
                    if (toggleBtn) {
                        toggleBtn.classList.toggle('active', session.teleprompterActive);
                    }

                    let sidebar = document.getElementById('teleprompter-sidebar');

                    if (session.teleprompterActive) {
                        if (!sidebar) {
                            sidebar = document.createElement('div');
                            sidebar.id = 'teleprompter-sidebar';
                            overlay.insertBefore(sidebar, contentEl);
                        }
                        
                        const size = session.teleprompterSize || 30;
                        const contentSize = 100 - size;

                        if (document.body.classList.contains('mobile-view')) {
                            // Mobile: Apply height
                            sidebar.style.height = `${contentSize}%`; // Teleprompter is on bottom
                            contentEl.style.height = `${size}%`;     // Content is on top
                        } else {
                            // Desktop: Apply width
                            sidebar.style.width = `${size}%`;
                            contentEl.style.width = `${contentSize}%`;
                        }

                        sidebar.style.setProperty('--teleprompter-font-size', `${session.teleprompterFontSize}rem`);
                        
                        const article = App.storage.getArticle(session.articles[session.currentIndex].id);
                       if (article && article.content) {
                            let parsedContent = App.util.parseShortcuts(article.content);
                            let teleprompterFriendlyContent = App.util._transformMcqsForTeleprompter(parsedContent);
                            teleprompterFriendlyContent = App.util._transformAccordionsForTeleprompter(teleprompterFriendlyContent);
                            let finalContentHTML = App.util.sanitizeForTeleprompter(teleprompterFriendlyContent);

                            sidebar.innerHTML = finalContentHTML;
                        } else {
                            sidebar.innerHTML = "<p>Could not load article content.</p>";
                        }
                        
                        const controlsHTML = `
                            <div id="teleprompter-controls">
                                <button class="btn-icon" id="tp-font-dec" onclick="App.events.presentation.adjustTeleprompterFont(-0.1)" title="Decrease Font Size (-)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M1 8a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13A.5.5 0 0 1 1 8z"/></svg>
                                </button>
                                <button class="btn-icon" id="tp-font-inc" onclick="App.events.presentation.adjustTeleprompterFont(0.1)" title="Increase Font Size (+)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>
                                </button>
                            </div>
                        `;
                        sidebar.insertAdjacentHTML('afterbegin', controlsHTML);
                        
                        const resizer = document.createElement('div');
                        resizer.id = 'teleprompter-resizer';
                        sidebar.appendChild(resizer); // Append to sidebar for correct positioning
                        
                        resizer.addEventListener('mousedown', App.events.presentation._handleTeleprompterDragStart);
                        resizer.addEventListener('touchstart', App.events.presentation._handleTeleprompterDragStart, { passive: false });

                        App.ui.showToast('Teleprompter On', 'info');

                    } else {
                        if (sidebar) {
                            sidebar.remove(); // This removes the sidebar and its child resizer
                        }
                        if (document.body.classList.contains('mobile-view')) {
                            contentEl.style.height = '100%';
                        } else {
                            contentEl.style.width = '100%';
                        }

                        App.ui.showToast('Teleprompter Off', 'info');
                    }

                    setTimeout(() => {
                        const bodyEl = overlay.querySelector('.focus-mode-body');
                        if (bodyEl) {
                            session.scrollStops = App.ui._calculateScrollStops(bodyEl);
                            bodyEl.scrollTo({ top: session.scrollStops[session.currentSlideIndex], behavior: 'auto' });
                        }
                    }, 100);
                },
            },



            unmountViewListeners() {
            
                const oldContentDiv = document.getElementById('article-content');
                if (oldContentDiv) {
                    const newContentDiv = oldContentDiv.cloneNode(true);
                    oldContentDiv.parentNode.replaceChild(newContentDiv, oldContentDiv);
                }
            

                const mainEl = document.querySelector('main');
                if (mainEl) {
                    mainEl.removeEventListener('scroll', App.events.updateReadingProgress);
                }

                const controls = document.getElementById('article-controls');
                if (controls && controls.parentElement !== document.body) {
                    document.body.appendChild(controls);
                }

                if (App.state.autosaveInterval) {
                    clearInterval(App.state.autosaveInterval);
                    App.state.autosaveInterval = null;
                    App.state.isArticleDirty = false;
                }
                if (App.state.guardianObserver) {
                    App.state.guardianObserver.disconnect();
                    App.state.guardianObserver = null;
                }

                
                if(App.visualMap && App.visualMap.destroy) App.visualMap.destroy();
                if(App.mindMap && App.mindMap.destroy) App.mindMap.destroy();
            },

            async installPwa() {
                const promptEvent = App.state.pwa.installPromptEvent;
                if (!promptEvent) return;
                
                promptEvent.prompt();
                const { outcome } = await promptEvent.userChoice;
                console.log(`User response to the install prompt: ${outcome}`);
                
                App.state.pwa.installPromptEvent = null;
                const installBtn = document.getElementById('install-pwa-btn');
                if (installBtn) {
                    installBtn.style.display = 'none';
                }
            },

            toggleCategoryNameStyle() {
                const currentStyle = App.settings.get('categoryNameStyle') || 'full';
                const newStyle = currentStyle === 'full' ? 'short' : 'full';
                App.settings.set('categoryNameStyle', newStyle);
                // Re-render the library view to apply the change instantly
                App.router.navigateTo('library');
            },

            handleGlobalKeyDown(e) {
                if (e.key === 'Escape' && App.commandPalette.state.isPreviewActive) {
                    e.preventDefault();
                    e.stopPropagation();
                    App.commandPalette.close(); // This triggers our robust _restoreEditor logic
                    return;
                }

                const cmdKey = App.util.getCommandKey() === 'Cmd' ? e.metaKey : e.ctrlKey;
                const isModalOpen = document.getElementById('modal-container').hasChildNodes();
                const target = e.target;
                const isEditable = target.isContentEditable || ['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName);
                
                if (cmdKey && e.key === ';') {
                    e.preventDefault();
                    App.hub.ui.showProductivityModal();
                    return;
                }
                if (e.key.toLowerCase() === 'h' && App.router.getActiveView() === 'category' && !isEditable) {
                    e.preventDefault();
                    App.events.toggleCategoryHighlights();
                    return;
                }
                if (e.key === 'Enter' && !isEditable) {
                    const welcomeView = document.getElementById('welcome-view');
                    if (welcomeView && welcomeView.classList.contains('active')) {
                        e.preventDefault();
                        const resumeBtn = document.getElementById('resume-btn');
                        if (resumeBtn) resumeBtn.click();
                        else document.getElementById('select-folder-btn')?.click();
                    }
                }

                if (e.key === 'Escape') {
                    if (document.body.classList.contains('canvas-focus-mode')) {
                        App.events.toggleCanvasFocusMode();
                        e.preventDefault();
                        return;
                    }
                    
                    const activeViewId = App.router.getActiveView();
                    if (isModalOpen) App.ui.closeModal();
                    else if(document.querySelector('.zen-mode-overlay')) App.hub.pomodoro.toggleZenMode();
                    else if (App.state.isFullscreen) App.events.toggleFocusMode();
                    else if (App.state.studySession.isActive) App.events.study.exit();
                    else if (activeViewId && activeViewId !== 'library') App.router.navigateTo('library');
                }
                if (e.altKey && e.key.toLowerCase() === 'a') {
                    e.preventDefault();
                    const coPilotToggle = document.getElementById('kash-copilot-toggle');
                    if (coPilotToggle && coPilotToggle.style.display !== 'none') {
                        App.coPilot.toggle();
                    }
                    return;
                }
                // ... (The rest of the function remains identical) ...
                if (cmdKey && e.key.toLowerCase() === 'k') { e.preventDefault(); App.globalSearch.openSearch(); }
                if (e.altKey && e.shiftKey && e.key.toLowerCase() === 'n') { e.preventDefault(); if(!document.getElementById('new-article-btn').disabled) App.events.createNewArticle(); }
                if (cmdKey && e.key.toLowerCase() === 's') { if (App.state.currentMode === 'write') { e.preventDefault(); App.events.saveArticle(false); } }
                if (e.altKey && e.key.toLowerCase() === 'o' && !cmdKey && !e.shiftKey) { const isWelcomeActive = document.getElementById('welcome-view')?.classList.contains('active'); const isLibraryActive = document.getElementById('library-view')?.classList.contains('active'); if (isWelcomeActive || isLibraryActive) { e.preventDefault(); App.events.selectDirectory(true); } }
                if (e.key.toLowerCase() === 's' && !cmdKey && !e.altKey && !e.shiftKey && !isEditable) {
                    const isLibraryActive = document.getElementById('library-view')?.classList.contains('active');
                    const isFlashcardActive = document.getElementById('flashcard-view')?.classList.contains('active');
                    if (isLibraryActive) { e.preventDefault(); document.getElementById('search-input')?.focus(); document.getElementById('search-input')?.select(); } 
                    else if (isFlashcardActive) { e.preventDefault(); document.getElementById('flashcard-search-input')?.focus(); document.getElementById('flashcard-search-input')?.select(); }
                }
                if (App.state.currentMode === 'read' && document.getElementById('article-view')?.classList.contains('active') && !document.body.classList.contains('pdf-viewer-active')) {
                    if (e.key.toLowerCase() === 'f' && !cmdKey && !e.altKey && !e.shiftKey && !isEditable) {
                        e.preventDefault(); 
                        App.events.toggleFocusMode(); 
                    }
                    if (e.key.toLowerCase() === 'c' && !cmdKey && !e.altKey && !e.shiftKey && !isEditable) {
                        e.preventDefault();
                        App.events.cycleReaderTheme();
                    }
                    if (e.key.toLowerCase() === 'e' && !cmdKey && !e.altKey && !e.shiftKey && !isEditable) {                        e.preventDefault();
                        App.events.switchToMode('write');
                    }
                    if (e.key.toLowerCase() === 's' && !cmdKey && !e.altKey && !e.shiftKey && !isEditable) {
                        e.preventDefault();
                        const now = new Date().getTime();
                        if (now - App.state.lastHeartKeyPressTime < 400) { // Double-press detected
                            App.events.resetReadCount();
                            App.state.lastHeartKeyPressTime = 0; // Reset timer to prevent triple-press issues
                        } else { // Single-press
                            App.events.finishArticle();
                            App.state.lastHeartKeyPressTime = now;
                        }
                    }
                }
                if (App.state.studySession.isActive) App.events.study.handleKeyboard(e);
            },

            async selectDirectory(isChange = false) {
                if ('showDirectoryPicker' in window) {
                    try {
                        const handle = await window.showDirectoryPicker();
                        const hasPermission = await App.storage.verifyPermission(handle);

                        if (hasPermission) {
                            const migrationResult = await App.services.migration.browserToFolder(handle);
                            
                            if (migrationResult === 'error' || migrationResult === 'cancelled') {
                                return; 
                            }

                         
                            this.transitionToLibrary(async () => {
                                App.state.isInitialLoadComplete = false;
                                App.state.isHydrated = false;
                                App.state.articles = [];

                                await App.settings.set('lastStorageMode', 'fileSystem');
                                App.state.directoryHandle = handle;
                                await App.indexedDB.setHandle('directory', handle);
                                await App.util.requestDurableStorage();
                                App.state.storageMode = 'fileSystem';

                                await App.settings.load();
                                App.ui.applyTheme(App.settings.get('theme'));
                                
                                await App.loadInitialData(); 
                                App.router.navigateTo('library');

                                App.ui.showToast(`Switched to Folder Mode: '${handle.name}' selected.`, { type: 'success' });
                            });
                        } else {
                            throw new Error("Permission was denied after selection.");
                        }
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            App.ui.showToast('Could not access the selected directory.', { type: 'error' });
                        }
                    }
                } else {
                    App.ui.showToast('Select your note files to import.', 'info');
                    document.getElementById('mobile-import-input').click();
                }
            },

            async requestStoredPermission() {
                if (!App.state.directoryHandle) { 
                    App.ui.showToast("No folder handle found. Please select a new folder.", {type: 'error'});
                    App.router.navigateTo('welcome', { permissionState: 'none' }); 
                    return; 
                }
                try {
                    const permission = await App.state.directoryHandle.requestPermission({ mode: 'readwrite' });
                    if (permission === 'granted') {
                        // THE FIX: Simply reload the page. The app will then start
                        // up on the known-good 'granted' permission path.
                        window.location.reload();
                    } else {
                        App.ui.showToast("Permission was denied. Please select the folder again.", {type: 'error'});
                        App.router.navigateTo('welcome', { permissionState: 'denied' });
                    }
                } catch (err) { 
                    if (err.name !== 'AbortError') {
                        console.error("Error requesting permission:", err); 
                        App.ui.showToast("Could not get permission for the folder.", {type: 'error'}); 
                    }
                }
            },
            async createNewArticle() {
                if (!App.license.isPremium() && App.state.articles.length >= App.config.sparkTierLimit) {
                    App.ui.showAscensionModal();
                    App.ui.showToast('Note limit reached. Go Premium for unlimited notes.', 'warning');
                    return;
                }
                // Create a temporary, in-memory article object without saving a file.
                const tempArticle = {
                    id: 'temp_new_article', // A special, temporary ID
                    title: 'Untitled Article',
                    content: '<p><br></p>',
                    category: (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name,
                    readCount: 0,
                    readHistory: [],
                    tags: [],
                    flashcards: {},
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                // Navigate to the editor, passing the temporary object directly.
                App.router.navigateTo('article', { articleObject: tempArticle, mode: 'write' });
            },

            switchToMode(mode) { App.router.navigateTo('article', { id: App.state.activeArticleId, mode }); },
           
            toggleCanvasFocusMode() {
                document.body.classList.toggle('canvas-focus-mode');
                // Give the browser a moment to apply CSS changes before resizing
                setTimeout(() => {
                    const activeViewId = App.router.getActiveView();
                    if (activeViewId === 'visual-map' && App.visualMap.triggerResize) {
                        App.visualMap.triggerResize();
                    } else if (activeViewId === 'mindmap' && App.mindMap.triggerResize) {
                        App.mindMap.triggerResize();
                    }
                }, 100);
            },

           async saveArticle(options = {}) {
                const { content: newContent, switchToRead = false, isAutosave = false } = options;
                const id = App.state.activeArticleId;
                if (!id) return;

                const titleInput = document.getElementById('article-title');
                const contentDiv = document.getElementById('article-content');
                if (!titleInput || !contentDiv) {
                    if (!isAutosave) App.ui.showToast("Save failed. Editor not found.", { type: 'error' });
                    return;
                }

                const title = titleInput.value.trim();
                let content = newContent ?? contentDiv.innerHTML.trim();
                content = App.util.parseShortcuts(content);
                content = App.contentTools.updateDataTagsInContent(content);

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;

                // --- THIS IS THE FIX (PART 1) ---
                // We get the most recent version of the article from the app's memory.
                // This ensures we have the latest attachment data, including any new PDF highlights.
                const articleInMemory = App.storage.getArticle(id) || {};
                let attachments = articleInMemory.attachments || [];
                let attachmentsUpdated = false;

                tempDiv.querySelectorAll('.pdf-attachment-pill[data-pdf-id]').forEach(pill => {
                    const attachmentId = pill.dataset.pdfId;
                    const nameSpan = pill.querySelector('.pdf-attachment-name');
                    const newName = nameSpan ? nameSpan.textContent.trim() : '';

                    const attachmentIndex = attachments.findIndex(att => att.id === attachmentId);

                    if (attachmentIndex > -1 && newName) {
                        const originalName = attachments[attachmentIndex].name;
                        const extension = originalName.slice(originalName.lastIndexOf('.'));
                        const newFullName = `${newName}${extension}`;

                        if (originalName !== newFullName) {
                            attachments[attachmentIndex].name = newFullName;
                            attachmentsUpdated = true;
                        }
                    }
                });

                const seenIds = new Set();
                const snippetSelector = '[class*="highlight-"], [class*="text-"]';
                tempDiv.querySelectorAll(snippetSelector).forEach(el => {
                    if (!el.id || seenIds.has(el.id)) {
                        el.id = `snip-${crypto.randomUUID().slice(0, 12)}`;
                    }
                    seenIds.add(el.id);
                });
                tempDiv.querySelectorAll('.rendered-tag').forEach(el => {
                    if (!el.id || seenIds.has(el.id)) {
                        el.id = `tag-snip-${crypto.randomUUID().slice(0, 12)}`;
                    }
                    seenIds.add(el.id);
                });

                content = tempDiv.innerHTML;

                const isContentEmpty = content === '' || content === '<p><br></p>' || contentDiv.textContent.trim() === '';
                if (!title && isContentEmpty) {
                    if (!isAutosave) { App.ui.showToast("Cannot save an empty article.", { type: 'warning' }); }
                    return;
                }

                const defaultCategoryName = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                const category = document.getElementById('category-selector')?.value || defaultCategoryName;

                const handleSaveSuccess = async (savedArticle) => {
                    App.state.isArticleDirty = false;
                    await App.contentTools.updateTagsIndex();
                    App.contentTools.buildDataCache();
                    App.commandPalette.state.fuse.links = null;

                    App.ui.updateArticleMetadata(content, savedArticle.createdAt);
                    if (switchToRead) { this.switchToMode('read'); }
                    if (App.dropbox.isReady() && App.settings.get('enableDropboxSync')) {
                        App.dropbox.syncChanges(true);
                    } else if (!isAutosave) {
                        App.ui.showToast('Saved!', { type: 'success' });
                    }
                };

                if (id === 'temp_new_article') {
                    const articleData = { title, content, category, attachments };
                    const newArticle = await App.storage.createArticle(articleData);
                    if (newArticle) {
                        App.state.activeArticleId = newArticle.id;
                        await handleSaveSuccess(newArticle);
                    }
                } else {
                    const article = App.storage.getArticle(id);
                    const existingFlashcards = article.flashcards || {};
                    const newFlashcards = App.util.extractFlashcards(content, id, category, existingFlashcards);
                    const newTags = App.contentTools.extractTagsFromHTML(content);

                    // --- THIS IS THE FIX (PART 2) ---
                    // The `attachments` array is now ALWAYS included in the update payload,
                    // ensuring PDF highlights are saved every time.
                    const updates = { title, content, category, flashcards: newFlashcards, tags: newTags, attachments: attachments };

                    const result = await App.storage.updateArticle(id, updates);
                    if (result.success) {
                        await handleSaveSuccess(result.article);
                    }
                }
            },

            async finishArticle() {
                const id = App.state.activeArticleId;
                if (!id) return;

                const articleIndex = App.state.articles.findIndex(a => a.id === id);
                if (articleIndex === -1) return;
                const article = App.state.articles[articleIndex];
                const newCount = (article.readCount || 0) + 1;
                const newHistory = [...(article.readHistory || []), new Date().toISOString()];
                const updatedArticle = { ...article, readCount: newCount, readHistory: newHistory };
                App.state.articles[articleIndex] = updatedArticle;
                App.ui.renderArticleControls(updatedArticle);
                setTimeout(() => {
                    const heartButton = document.querySelector('.read-mode-controls [data-action="finishArticle"]');
                    if (heartButton) {
                        heartButton.classList.add('done-btn-animated');
                        heartButton.addEventListener('animationend', () => {
                            heartButton.classList.remove('done-btn-animated');
                        }, { once: true });
                    }
                }, 50);
                await App.storage.updateArticle(id, { readCount: newCount, readHistory: newHistory });
            },

            async resetReadCount() {
                await App.storage.updateArticle(App.state.activeArticleId, { readCount: 0, readHistory: [] });
                App.ui.showToast("Article progress reset.");
                App.ui.renderArticleControls(App.storage.getArticle(App.state.activeArticleId));
            },

           deleteArticleWithConfirmation() {
                const id = App.state.activeArticleId;
                const article = App.storage.getArticle(id);
                App.ui.showConfirmationModal({
                    title: 'Delete Article',
                    message: `Are you sure you want to delete "${article.title}"? This will be deleted from your folder and synced.`,
                    confirmText: 'Delete',
                    onConfirm: async () => {
                        await App.storage.deleteArticle(id);
                        App.ui.showToast('Article deleted.');

                        App.commandPalette.state.fuse.links = null; 

                        App.router.navigateTo('library');
                        if (App.dropbox.isReady() && App.settings.get('enableDropboxSync')) {
                            App.dropbox.syncChanges(true);
                        }
                    }
                });
            },

            insertAccordionCard() {
                const cardId = 'acc_' + crypto.randomUUID();
                const contentId = 'acc-content-' + cardId;
                const cardHTML = `
                    <div class="nk-accordion" data-state="closed" data-id="${cardId}" data-reversible="false">
                        <div class="nk-accordion-trigger" role="button" tabindex="0" aria-expanded="false" aria-controls="${contentId}">
                            <span class="nk-accordion-title" contenteditable="true" data-placeholder="Question..."></span>
                            <div class="nk-accordion-controls">
                                <button class="nk-accordion-control-btn nk-accordion-hint-btn" title="Add/Edit Hint">${App.util.icons.hint}</button>
                                <button class="nk-accordion-control-btn nk-accordion-reversible-toggle" title="Make Reversible">${App.util.icons.reversible}</button>
                                <svg class="nk-accordion-chevron" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"></polyline></svg>
                            </div>
                        </div>
                        <div id="${contentId}" class="nk-accordion-content" contenteditable="true" data-placeholder="Answer..."><p><br></p></div>
                    </div>`;
                App.util.insertGuardianBlock(cardHTML); // Use the helper
            },

            handleSearchCommand(e) {
                if(e.key !== 'Enter') return;
                const command = e.target.value.trim().toLowerCase();
                
                let commandExecuted = false;
                
                if (command.startsWith('!')) {
                    e.preventDefault();
                    const action = command.substring(1);
                    switch(action) {
                        case 'task': App.hub.ui.showProductivityModal(); commandExecuted = true; break;
                        case 'stats': App.router.navigateTo('stats-dashboard'); commandExecuted = true; break;
                        case 'quiz': App.quiz.start(); commandExecuted = true; break;
                    }
                }
                else if (command.startsWith('%')) {
                    e.preventDefault();
                    const action = command.substring(1);

                    if (action === '+' || action === 'new') { App.events.createNewArticle(); commandExecuted = true; } 
                    else if (action === 'study') { App.events.study.start(); commandExecuted = true; }
                    else if (action === 'flash' || action === 'flashcards') { App.router.navigateTo('flashcard'); commandExecuted = true; }
                    else {
                        const foundCategory = App.settings.get('userCategories').find(c => c.toLowerCase() === action || App.util.getCategoryDisplayName(c).toLowerCase() === action);
                        if (foundCategory) { App.router.navigateTo('category', foundCategory); commandExecuted = true; }
                    }
                }
                
                if(commandExecuted) e.target.value = '';
            },

             handlePaste(e) {
                e.preventDefault();
                const clipboardData = e.clipboardData || window.clipboardData;

                // Priority 1: Handle image files from clipboard (e.g., screenshots)
                const imageFile = Array.from(clipboardData.items).find(item => item.kind === 'file' && item.type.startsWith('image/'));
                if (imageFile) {
                    App.services.image.processAndInsert(imageFile.getAsFile());
                    return;
                }

                // Priority 2: Handle HTML content (often for rich text or images from web)
                const pastedHTML = clipboardData.getData('text/html');
                if (pastedHTML) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = App.util.sanitizeHTML(pastedHTML);
                    
                    App.util.cleanPastedStyles(tempDiv);
                    // Re-ID accordions to prevent duplicate IDs when pasting within the same note
                    tempDiv.querySelectorAll('.nk-accordion').forEach(accordion => {
                        const newId = 'acc_' + crypto.randomUUID();
                        const oldContentId = accordion.querySelector('.nk-accordion-trigger')?.getAttribute('aria-controls');
                        const newContentId = 'acc-content-' + newId;
                        accordion.dataset.id = newId;
                        const trigger = accordion.querySelector('.nk-accordion-trigger');
                        if(trigger) trigger.setAttribute('aria-controls', newContentId);
                        const content = tempDiv.querySelector(`#${oldContentId}`);
                        if(content) content.id = newContentId;
                    });

                    const finalHtml = tempDiv.innerHTML;
                    document.execCommand('insertHTML', false, finalHtml);
                    App.state.isArticleDirty = true;
                    return;
                }

                // Priority 3: Handle plain text (the fallback)
                const pastedText = clipboardData.getData('text/plain');
                if (pastedText) {
                    // A more conservative threshold to ensure a smooth experience even on mid-range devices.
                    const PASTE_THRESHOLD = 8000; 
                    if (pastedText.length > PASTE_THRESHOLD) {
                        // Use the new, robust asynchronous helper for large text to prevent freezing
                        this._insertLargeTextInChunks(pastedText);
                    } else {
                        // For short text, insert directly for instant feedback
                        document.execCommand('insertHTML', false, App.util.textToHtml(pastedText));
                    }
                    App.state.isArticleDirty = true;
                    return;
                }
            },


            _insertLargeTextInChunks(text) {
                const originalLength = text.length;
                const toast = App.ui.showToast('Pasting large content... 0%', { type: 'info', duration: 0 });
                let remainingText = text;

                function processNextChunk() {
                    // Base case: If all text is processed, finalize and exit.
                    if (remainingText.length === 0) {
                        App.ui.hideToast(toast);
                        App.ui.showToast('Paste complete!', { type: 'success' });
                        App.state.isArticleDirty = true;
                        return;
                    }

                    // Update UI with progress using the now-functional updateToast.
                    const progress = Math.round(((originalLength - remainingText.length) / originalLength) * 100);
                    App.ui.updateToast(toast, `Pasting large content... ${progress}%`);

                    // --- THE ROBUST HYBRID CHUNKING LOGIC ---
                    const chunkSize = 8000; // Define a safe, fixed chunk size that will never freeze the UI.
                    let chunk = remainingText.substring(0, chunkSize);
                    
                    // To preserve formatting, we look for the last newline *within* our safe chunk.
                    let lastNewline = chunk.lastIndexOf('\n');

                    // If a newline is found (and we're not at the very end of the text), we split there.
                    // This keeps paragraphs intact.
                    if (lastNewline > 0 && remainingText.length > chunkSize) {
                        chunk = chunk.substring(0, lastNewline + 1);
                    }
                    // If no newline is found, we just use the fixed-size chunk. This is our failsafe.
                    
                    const htmlChunk = App.util.textToHtml(chunk);
                    if (htmlChunk.trim() !== '') {
                        document.execCommand('insertHTML', false, htmlChunk);
                    }

                    // Remove the processed chunk from the remaining text.
                    remainingText = remainingText.substring(chunk.length);

                    // Yield control back to the UI thread before processing the next chunk.
                    // This is the key to preventing the "Page Unresponsive" error.
                    setTimeout(processNextChunk, 0);
                }

                // Start the process
                processNextChunk();
            },

            handleDragOver(e) { e.preventDefault(); e.stopPropagation(); e.target.closest('#article-content').classList.add('drag-over'); },
            handleDragLeave(e) { e.preventDefault(); e.stopPropagation(); e.target.closest('#article-content').classList.remove('drag-over'); },
            
            async handleImageDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                e.target.closest('#article-content').classList.remove('drag-over');
            
                // This part handles files dragged from your local computer and works correctly.
                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    for (const file of files) {
                        if (file.type.startsWith('image/')) {
                            App.services.image.processAndInsert(file);
                        }
                    }
                    return; // Exit after handling local files
                }
            
                // --- NEW ROBUST LOGIC for images dragged from other websites ---
                const html = e.dataTransfer.getData('text/html');
                if (html) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    const img = tempDiv.querySelector('img');
            
                    if (img && img.src) {
                        // Case 1: The image source is a data URL (very common).
                        if (img.src.startsWith('data:')) {
                            const blob = App.util.dataURLtoBlob(img.src);
                            if (blob) {
                                App.services.image.processAndInsert(blob);
                            } else {
                                App.ui.showToast('Could not read dragged image data.', { type: 'error' });
                            }
                        }
                        // Case 2: The image source is a regular web URL.
                        else {
                            try {
                                App.ui.showToast('Downloading image...', { type: 'info' });
                                const response = await fetch(img.src);
                                if (!response.ok) throw new Error('Network response was not ok.');
                                const blob = await response.blob();
                                App.services.image.processAndInsert(blob);
                                App.ui.showToast('Image inserted!', { type: 'success' });
                            } catch (error) {
                                console.error('Error fetching dragged image:', error);
                                App.ui.showToast('Website blocked action (Copy/Download Image and Paste ðŸ˜¼)', { type: 'error' });
                            }
                        }
                    }
                }
            },

            handleFocusIn(e) {
                const target = e.target;
                const imageContainer = target.closest('.image-container');
                if (!imageContainer) App.events.deselectImage();
            },

           async handleContentClick(e) {
                const target = e.target;
                const isWriteMode = App.state.currentMode === 'write';

                // --- NEW LOGIC FOR FOCUS/STAGE MODE ACCORDIONS ---
                const focusOverlay = target.closest('.focus-mode-overlay');
                if (focusOverlay) {
                    const accordionTrigger = target.closest('.nk-accordion-trigger');
                    if (accordionTrigger) {
                        e.preventDefault();
                        e.stopPropagation();
                        const accordion = accordionTrigger.closest('.nk-accordion');
                        if (accordion) {
                            const isOpening = accordion.dataset.state === 'closed';
                            accordion.dataset.state = isOpening ? 'open' : 'closed';
                            accordionTrigger.setAttribute('aria-expanded', String(isOpening));
                        }
                        return; // Stop further processing in this case
                    }
                    // --- END NEW LOGIC ---

                    const session = App.state.focusSession;
                    if (session.isCinematicActive && session.isStageMode) {
                        const wordRevealed = App.events.typewriter.revealNext();
                        if (wordRevealed) {
                            e.preventDefault();
                            e.stopPropagation();
                            return;
                        }
                    }

                    const mcqBlock = target.closest('.nk-mcq-block');
                    if (mcqBlock) {
                        App.events.handleMcqAnswer(e, false);
                    }
                    return; 
                }
                
                if (!isWriteMode) {
                    const imageContainer = e.target.closest('.image-container');
                    if (imageContainer) {
                        App.events.selectImage(imageContainer);
                        e.stopPropagation();
                    } else if (App.state.selectedImageContainer && !e.target.closest('#image-toolbar')) {
                        App.events.deselectImage();
                    }
                }
                
                const pdfPill = target.closest('.pdf-attachment-pill');
                if (pdfPill && !isWriteMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    const attachmentId = pdfPill.dataset.pdfId;
                    if (attachmentId) {
                        App.pdf.viewer.open(attachmentId);
                    }
                    return;
                }
                
                const audioPlayer = target.closest('.nk-audio-player');
                const transcribeBtn = target.closest('.nk-transcribe-container .btn');

                if (audioPlayer) {
                    e.preventDefault(); 
                    const playPauseBtn = target.closest('.audio-play-pause-btn');
                    const progressBar = target.closest('.audio-progress-bar');
                    const speedBtn = target.closest('.audio-speed-btn');

                    if (playPauseBtn) {
                        App.audio.handlePlayPause(playPauseBtn);
                    } else if (progressBar) {
                        const audio = audioPlayer.querySelector('audio');
                        if (audio) audio.currentTime = progressBar.value;
                    } else if (speedBtn) {
                        App.audio.handleSpeedChange(speedBtn);
                    }
                    return;
                } else if (transcribeBtn) {
                   e.preventDefault();
                    if (App.license.isPremium()) {
                        App.audio.transcribeAudioBlock(transcribeBtn);
                    } else {
                        App.ui.showAscensionModal();
                    }
                    return;
                }
                
                const addTileBtn = target.closest('.deck-add-tile-btn');
                if (addTileBtn) {
                    e.preventDefault();
                    const solidColors = App.commandPalette.state.textileColors.filter(c => !isNaN(c));
                    const randomColor = solidColors[Math.floor(Math.random() * solidColors.length)];
                    const newTileHTML = `
                    <div class="nk-text-tile color-${randomColor}" contenteditable="false" data-color="${randomColor}">
                        <span class="nk-text-tile-icon"></span>
                        <div class="nk-text-tile-color-cycler" title="Cycle Color"><i class="fa-solid fa-palette fa-xs"></i></div>
                        <div class="nk-text-tile-content" contenteditable="true" data-placeholder="New tile..."></div>
                    </div>`;
                    addTileBtn.insertAdjacentHTML('beforebegin', newTileHTML);
                    App.state.isArticleDirty = true;
                    return;
                }
                const layoutToggleBtn = target.closest('.deck-layout-toggle');
                if (layoutToggleBtn) {
                    e.preventDefault();
                    const deck = layoutToggleBtn.closest('.nk-textile-deck');
                    deck.classList.toggle('layout-stack');
                    const isStack = deck.classList.contains('layout-stack');
                    layoutToggleBtn.innerHTML = isStack ? '<i class="fa-solid fa-grip"></i>' : '<i class="fa-solid fa-table-cells"></i>';
                    layoutToggleBtn.title = isStack ? 'Switch to Grid' : 'Switch to Stack';
                    if (isWriteMode) App.state.isArticleDirty = true;
                    return;
                }

                const textTile = target.closest('.nk-text-tile');
                if (textTile) {
                    if (App.state.currentMode === 'read') {
                        e.preventDefault();
                        textTile.classList.toggle('faded');
                    } else if (isWriteMode) {
                        const colorCycler = target.closest('.nk-text-tile-color-cycler');
                        if (colorCycler) {
                            e.preventDefault();
                            const colors = App.commandPalette.state.textileColors;
                            const currentColor = textTile.dataset.color || '1';
                            const currentIndex = colors.indexOf(currentColor);
                            const nextColor = colors[(currentIndex + 1) % colors.length];
                            textTile.classList.remove(`color-${currentColor}`);
                            textTile.classList.add(`color-${nextColor}`);
                            textTile.dataset.color = nextColor;
                            App.state.isArticleDirty = true;
                        }
                    }
                    return;
                }
                const mcqBlock = target.closest('.nk-mcq-block');
                if (mcqBlock) {
                    if (App.state.currentMode === 'read') {
                        App.events.handleMcqAnswer(e, false);
                    }
                    else if (App.state.currentMode === 'write') {
                        const addBtn = target.closest('.nk-mcq-add-option');
                        if (addBtn) {
                            e.preventDefault();
                            const optionsContainer = mcqBlock.querySelector('.nk-mcq-options');
                            if (optionsContainer.children.length >= 6) {
                                App.ui.showToast("Maximum of 6 options reached.", { type: 'warning' });
                                return;
                            }
                            const newOption = document.createElement('div');
                            newOption.className = 'nk-mcq-option';
                            newOption.dataset.isCorrect = 'false';
                            newOption.innerHTML = `<div class="nk-mcq-option-radio"></div><div class="nk-mcq-option-text" contenteditable="true" data-placeholder="New Option"></div><button class="nk-mcq-delete-option" title="Delete Option">&times;</button>`;
                            optionsContainer.appendChild(newOption);
                            App.state.isArticleDirty = true;
                        } else {
                            const optionDiv = target.closest('.nk-mcq-option');
                            if (optionDiv) {
                                e.preventDefault();
                                const deleteBtn = target.closest('.nk-mcq-delete-option');
                                const radioBtn = target.closest('.nk-mcq-option-radio');
                                if (deleteBtn) {
                                    if (mcqBlock.querySelectorAll('.nk-mcq-option').length > 2) {
                                        optionDiv.remove();
                                        App.state.isArticleDirty = true;
                                    } else {
                                        App.ui.showToast("An MCQ must have at least two options.", { type: 'warning' });
                                    }
                                } else if (radioBtn) {
                                    mcqBlock.querySelectorAll('.nk-mcq-option').forEach(opt => opt.dataset.isCorrect = 'false');
                                    optionDiv.dataset.isCorrect = 'true';
                                    App.state.isArticleDirty = true;
                                }
                            }
                        }
                    }
                    return;
                }
                const accordionTrigger = target.closest('.nk-accordion-trigger');
                const tagSuggestion = target.closest('.tag-suggestion');
                const checkboxBox = target.closest('.nk-checkbox-box');
                const timelineAddButton = target.closest('.nk-timeline-add button');
                if (accordionTrigger) {
                    const accordion = accordionTrigger.closest('.nk-accordion');
                    const reversibleToggle = target.closest('.nk-accordion-reversible-toggle');
                    const hintBtn = target.closest('.nk-accordion-hint-btn');
                    if (reversibleToggle && isWriteMode) {
                        e.preventDefault();
                        const isReversible = accordion.dataset.reversible === 'true';
                        accordion.dataset.reversible = String(!isReversible);
                        reversibleToggle.classList.toggle('active', !isReversible);
                        App.state.isArticleDirty = true;
                    } else if (hintBtn) {
                        e.preventDefault();
                        let hintEditor = accordion.querySelector('.nk-accordion-hint-editor');
                        if (hintEditor) {
                            const isHidden = hintEditor.style.display === 'none';
                            hintEditor.style.display = isHidden ? 'block' : 'none';
                        } else if (isWriteMode) {
                            hintEditor = document.createElement('div');
                            hintEditor.className = 'nk-accordion-hint-editor';
                            const hintContent = document.createElement('div');
                            hintContent.className = 'nk-accordion-hint-content';
                            hintContent.contentEditable = true;
                            hintContent.dataset.placeholder = 'Type your hint here...';
                            hintEditor.appendChild(hintContent);
                            accordion.appendChild(hintEditor);
                            hintContent.focus();
                        }
                        if(isWriteMode) App.state.isArticleDirty = true;
                    } else {
                        accordion.dataset.state = accordion.dataset.state === 'closed' ? 'open' : 'closed';
                        accordionTrigger.setAttribute('aria-expanded', accordion.dataset.state !== 'closed');
                    }
                    return;
                }
                if (tagSuggestion) {
                    clearTimeout(App.state.suggestionTimeout);
                    App.contentTools.tagSelection(tagSuggestion);
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv) return;
                    const newContent = contentDiv.innerHTML;
                    await App.events.saveArticle({ content: newContent });
                    App.contentTools.autoSuggestTags(contentDiv);
                    return;
                }
                if (checkboxBox && App.state.currentMode === 'write') {
                    const wrapper = checkboxBox.closest('.nk-checkbox-wrapper');
                    if (wrapper) {
                        wrapper.setAttribute('data-checked', String(wrapper.getAttribute('data-checked') !== 'true'));
                        App.state.isArticleDirty = true;
                    }
                    return;
                }
                if (timelineAddButton) {
                   const timelineBlock = timelineAddButton.closest('.nk-timeline-block');
                    if (timelineBlock) {
                        const newEntry = document.createElement('div');
                        newEntry.className = 'nk-timeline-entry';
                        newEntry.innerHTML = `<div class="nk-timeline-content"><div class="nk-timeline-date" contenteditable="true">New Date...</div><div class="nk-timeline-title" contenteditable="true">New Event...</div></div>`;
                        timelineBlock.querySelector('.nk-timeline-add').insertAdjacentElement('beforebegin', newEntry);
                        const newDateEl = newEntry.querySelector('.nk-timeline-date');
                        if (newDateEl) { App.util.placeCursor(newDateEl); window.getSelection().selectAllChildren(newDateEl); }
                    }
                    return;
                }
                if (target.tagName === 'IMG') {
                    const container = target.closest('.image-container');
                    if (container) App.events.selectImage(container);
                } else if (!target.closest('.image-container')) {
                    App.events.deselectImage();
                }
            },

            handleSelection() {
                // Use a small timeout to let the browser finalize the selection
                setTimeout(() => {
                    const selection = window.getSelection();
                    if (!selection || selection.isCollapsed || selection.rangeCount === 0) {
                        // If selection is lost or collapsed, hide all toolbars
                        App.ui.hideSelectionToolbar();
                        App.ui.aiMagic.hide();
                        return;
                    }

                    const range = selection.getRangeAt(0);
                    const container = range.commonAncestorContainer;
                    const parentElement = container.nodeType === 3 ? container.parentNode : container;

                    // Ensure the selection is within our main editor
                    const editor = document.getElementById('article-content');
                    if (!editor || !editor.contains(parentElement) || !editor.isContentEditable) {
                        return;
                    }

                    // Check if the selection is purely whitespace
                    if (selection.toString().trim() === '') {
                        App.ui.hideSelectionToolbar();
                        App.ui.aiMagic.hide();
                        return;
                    }

                    // Show the standard formatting toolbar
                    App.ui.showSelectionToolbar(range);

                    // Show our new AI Magic Toolbox
                    App.ui.aiMagic.show(range);

                }, 10);
            },

            applyFormatting(type, value) {
                const selection = window.getSelection();
                if (!selection || !selection.rangeCount || selection.isCollapsed) return false; // Return false on failure
                let range = selection.getRangeAt(0);
                const container = range.commonAncestorContainer;
                const parentElement = container.nodeType === 3 ? container.parentNode : container;

                if (parentElement.closest('#pdf-text-view-content')) {
                    const text = selection.toString().trim();
                    if (text && type === 'class' && value.startsWith('highlight-')) {
                        App.pdf.highlights.add(text, value);
                    }
                    return true; // Assume success for PDF context
                }

                if (!parentElement || !parentElement.closest('#article-content')) return false; // Return false on failure

                if (type === 'cloze') {
                    const paragraph = parentElement.closest('p, div, li, h1, h2, h3, h4, h5, h6, blockquote, td, th');
                    if (!paragraph) { App.ui.showToast("Cloze can only be created within a block of text.", { type: 'warning' }); return false; }
                    const existingClozes = (paragraph.innerHTML.match(/{{c\d+::/g) || []).length;
                    document.execCommand('insertHTML', false, `{{c${existingClozes + 1}::${selection.toString()}}}`);
                } else {
                    document.execCommand('styleWithCSS', false, true);
                    const span = document.createElement('span');
                    span.className = value;
                    if (App.config.highlightClasses.includes(value) || App.config.textClasses.includes(value)) {
                        span.id = `snip-${crypto.randomUUID().slice(0, 12)}`;
                    }
                    try {
                        span.appendChild(range.extractContents());
                        range.insertNode(span);
                    } catch (e) { App.ui.showToast("Could not apply formatting.", { type: 'error' }); console.error("Formatting error:", e); return false; }
                    document.execCommand('styleWithCSS', false, false);
                }
                selection.removeAllRanges();
                App.ui.hideSelectionToolbar();
                return true; // Return true on success
            },


            cycleColorFormatting() {
                let currentIndex = App.settings.get('colorCycleIndex');
                this.applyFormatting('class', App.config.colorCycle[currentIndex]);
                App.settings.set('colorCycleIndex', (currentIndex + 1) % App.config.colorCycle.length);
            },
            async removeFormatting() {
                const selection = window.getSelection();
                if (!selection.rangeCount || selection.isCollapsed) {
                    App.ui.hideSelectionToolbar();
                    return;
                }

                const range = selection.getRangeAt(0);
                let container = range.commonAncestorContainer;
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }

                
                const elementToUnwrap = container.closest('span[class*="highlight-"], span[class*="text-"], b, i, u, strong, em, del, .rendered-tag');

                if (elementToUnwrap) {
                    App.util.unwrapNode(elementToUnwrap);
                } else {
                
                    document.execCommand('removeFormat', false, null);
                }
            
                App.state.isArticleDirty = true;
                
                App.ui.hideSelectionToolbar();
            },
        
            
            handleWriterShortcuts(e) {
                const selection = window.getSelection();
                if (!selection || !selection.rangeCount) return;
                const range = selection.getRangeAt(0);

                const cmdKey = App.util.getCommandKey() === 'Cmd' ? e.metaKey : e.ctrlKey;

                if (cmdKey && e.key.toLowerCase() === 'j') {
                    e.preventDefault();
                    App.commandPalette.open(range);
                    return;
                }

                if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && selection.isCollapsed) {
                    const container = range.startContainer;
                    const tileContent = container.nodeType === 1 ? container.closest('.nk-text-tile-content') : container.parentElement.closest('.nk-text-tile-content');

                    if (tileContent) {
                        const textLength = tileContent.textContent.length;
                        const atStart = range.startOffset === 0;
                        const atEnd = range.startOffset === textLength;

                        if (e.key === 'ArrowLeft' && atStart) {
                            const tile = tileContent.closest('.nk-text-tile');
                            if (tile) { e.preventDefault(); range.setStartBefore(tile); range.collapse(true); selection.removeAllRanges(); selection.addRange(range); return; }
                        } else if (e.key === 'ArrowRight' && atEnd) {
                            const tile = tileContent.closest('.nk-text-tile');
                            if (tile) { e.preventDefault(); range.setStartAfter(tile); range.collapse(true); selection.removeAllRanges(); selection.addRange(range); return; }
                        }
                    }
                }

                // --- DEFINITIVE FIX FOR DELETION & UNDO/REDO ---
                if (e.key === 'Backspace' && selection.isCollapsed) {
                    // Check for deleting an empty accordion title first
                    const accordion = selection.focusNode.parentElement?.closest('.nk-accordion');
                    const title = accordion?.querySelector('.nk-accordion-title');
                    if (accordion && title && title.contains(selection.focusNode) && selection.focusOffset === 0 && title.textContent.trim() === '') {
                        e.preventDefault(); const newP = document.createElement('p'); newP.innerHTML = '<br>'; accordion.parentNode.replaceChild(newP, accordion); App.util.placeCursor(newP); return;
                    }

                    // Unified Deletion for ALL custom blocks
                    if (range.startOffset === 0) {
                        const container = range.startContainer;
                        const currentBlock = (container.nodeType === 3 ? container.parentElement : container).closest('p, li, h1, h2, h3, h4, h5, h6, div');

                        if (currentBlock) {
                            const elementToDelete = currentBlock.previousElementSibling;
                            // This selector now covers ALL complex, non-editable blocks
                            const customBlockSelector = '.nk-mcq-block, .nk-timeline-block, .nk-textile-deck, .chart-container, .nk-accordion';

                            if (elementToDelete && elementToDelete.matches(customBlockSelector)) {
                                e.preventDefault();

                                // This is the magic: We programmatically select the entire
                                // block and then use the browser's own 'delete' command.
                                // This makes the action fully compatible with the undo stack.
                                const sel = window.getSelection();
                                const newRange = document.createRange();
                                newRange.selectNode(elementToDelete);
                                sel.removeAllRanges();
                                sel.addRange(newRange);
                                document.execCommand('delete', false, null);

                                return; // Deletion handled, stop further processing.
                            }
                        }
                    }
                }

                if (App.commandPalette.state.isOpen) {
                    if (['ArrowUp', 'ArrowDown', 'Enter', 'Escape', 'Backspace', '/'].includes(e.key)) {
                        e.preventDefault(); e.stopPropagation();
                    }
                    return; 
                }

                if (e.key === '/' && selection.isCollapsed) {
                    e.preventDefault();
                    App.commandPalette.open(range);
                    return;
                }

                if (e.key === 'Enter') {
                    const focusNode = selection.focusNode;
                    const checkboxWrapper = focusNode?.parentElement.closest('.nk-checkbox-wrapper');
                    if (checkboxWrapper) {
                        e.preventDefault();
                        const checkboxText = checkboxWrapper.querySelector('.nk-checkbox-text');
                        if (checkboxText && checkboxText.textContent.trim() === '') {
                            const newP = document.createElement('p'); newP.innerHTML = '<br>';
                            checkboxWrapper.insertAdjacentElement('afterend', newP); checkboxWrapper.remove(); App.util.placeCursor(newP);
                        } else {
                            const newCheckboxHTML = `<div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text"><br></span></div>`;
                            checkboxWrapper.insertAdjacentHTML('afterend', newCheckboxHTML);
                            const newCheckbox = checkboxWrapper.nextElementSibling; if (newCheckbox) App.util.placeCursor(newCheckbox.querySelector('.nk-checkbox-text'));
                        }
                        App.state.isArticleDirty = true; return;
                    }
                }

                if (cmdKey && e.shiftKey) {
                    let shortcutApplied = true;
                    switch (e.key.toLowerCase()) {
                        case 't': App.contentTools.tagSelection(); break; case 'f': App.events.applyFormatting('cloze'); break; case '1': App.events.cycleColorFormatting(); break;
                        case '2': App.events.applyFormatting('class', 'highlight-1'); break; case '3': App.events.applyFormatting('class', 'highlight-2'); break; case '4': App.events.applyFormatting('class', 'highlight-3'); break;
                        case '5': App.events.applyFormatting('class', 'highlight-4'); break; case '6': App.events.applyFormatting('class', 'highlight-5'); break; case '7': App.events.applyFormatting('class', 'highlight-6'); break;
                        case '8': App.events.applyFormatting('class', 'text-green'); break; case '9': App.events.applyFormatting('class', 'text-red'); break; case '0': App.events.applyFormatting('class', 'text-blue'); break; case '-': App.events.applyFormatting('class', 'text-magenta'); break;
                        default: shortcutApplied = false;
                    }
                    if (shortcutApplied) { e.preventDefault(); return; }
                }

                if (cmdKey && (e.key.toLowerCase() === 'b' || e.key.toLowerCase() === 'i' || e.key.toLowerCase() === 'u')) { 
                    e.preventDefault(); 
                    const command = { 'b': 'bold', 'i': 'italic', 'u': 'underline' }[e.key.toLowerCase()]; 
                    document.execCommand(command); 
                    return; 
                }

                if (!range || !range.startContainer) return;

                if (e.key === 'Enter') {
                    const container = range.commonAncestorContainer; 
                    const parentElement = container.nodeType === 3 ? container.parentNode : container;
                    const blockToExit = parentElement.closest('blockquote, li'); 
                    if (blockToExit && parentElement.textContent.trim() === '') { 
                        e.preventDefault(); 
                        document.execCommand('outdent', false, null); 
                        return; 
                    }
                }

                const textNode = range.startContainer;
                if (e.key === 'Enter' && textNode.nodeType === 3 && textNode.textContent.substring(0, range.startOffset).trim() === '---') { 
                    e.preventDefault(); 
                    const p = textNode.parentElement; 
                    p.innerHTML = ''; 
                    document.execCommand('insertHorizontalRule', false, null); 
                    const newP = document.createElement('p'); newP.innerHTML = '<br>'; 
                    p.insertAdjacentElement('afterend', newP); 
                    App.util.placeCursor(newP); 
                    return; 
                }

                if (e.key === ' ' && textNode.nodeType === 3) {
                    const text = textNode.textContent.substring(0, range.startOffset); 
                    const trimmedText = text.trim();
                    const shortcuts = { 
                        '*': 'insertUnorderedList', 
                        '-': () => { document.execCommand('insertUnorderedList'); setTimeout(() => { const list = window.getSelection().focusNode.parentElement.closest('ul'); if (list) list.className = 'bullet-hyphen'; }, 0); }, 
                        '>': () => document.execCommand('formatBlock', false, 'blockquote'), 
                        '##': () => document.execCommand('formatBlock', false, 'h2') 
                    };
                    const listMatch = text.match(/(\d+)\.$/); 
                    const action = shortcuts[trimmedText];

                    if (action) { 
                        e.preventDefault(); 
                        textNode.textContent = text.slice(0, text.length - trimmedText.length) + '\u00A0'; 
                        range.setStart(textNode, text.length - trimmedText.length + 1); 
                        selection.removeAllRanges(); selection.addRange(range); 
                        if (typeof action === 'string') document.execCommand(action, false); else action(); 
                    } else if (listMatch) { 
                        e.preventDefault(); 
                        textNode.textContent = text.slice(0, -listMatch[0].length) + '\u00A0'; 
                        range.setStart(textNode, text.length - listMatch[0].length + 1); 
                        selection.removeAllRanges(); selection.addRange(range); 
                        document.execCommand('insertOrderedList', false); 
                    }
                }
            },

            handleListClick() {
                const now = new Date().getTime();
                if (now - App.state.lastClickTime < 300) { document.execCommand('insertOrderedList', false); } 
                else {
                    const selection = window.getSelection(); if (!selection.focusNode) return;
                    const focusElement = selection.focusNode.nodeType === Node.TEXT_NODE ? selection.focusNode.parentElement : selection.focusNode;
                    const list = focusElement.closest('ul');
                    if (list) { const currentStyleIndex = App.config.bulletCycle.indexOf(list.className); const nextStyleIndex = (currentStyleIndex + 1) % App.config.bulletCycle.length; list.className = App.config.bulletCycle[nextStyleIndex]; } 
                    else { document.execCommand('insertUnorderedList', false); }
                }
                App.state.lastClickTime = now;
            },
            showTableModal() {
                const selection = window.getSelection(); const contentDiv = document.getElementById('article-content');
                if (selection.rangeCount === 0 || !contentDiv.contains(selection.getRangeAt(0).commonAncestorContainer)) { App.ui.showToast("Please place your cursor in the editor first.", { type: 'error' }); return; }
                
                // Insert a temporary marker to hold the cursor position
                const range = selection.getRangeAt(0);
                const markerId = `nk-cursor-marker-${Date.now()}`;
                const markerNode = document.createElement('span');
                markerNode.id = markerId;
                range.insertNode(markerNode);
                App.state.cursorMarkerId = markerId;

                const table = markerNode.closest('table');
                let currentRows = 2, currentCols = 2; let title = 'Create Table';
                if (table) { title = 'Update Table Dimensions'; currentRows = table.rows.length; currentCols = table.rows[0] ? table.rows[0].cells.length : 0; }
                const message = `<p>${table ? 'Enter new dimensions for the table.' : 'Enter table dimensions. Press Enter for 2x2.'}</p><div class="settings-grid" style="grid-template-columns: auto 1fr; gap: 0.5rem 1rem;"><label for="table-rows-input">Rows</label><input type="number" id="table-rows-input" class="text-input" value="${currentRows}" min="1" style="width:100%;"><label for="table-cols-input">Columns</label><input type="number" id="table-cols-input" class="text-input" value="${currentCols}" min="1" style="width:100%;"></div>`;
                App.ui.showConfirmationModal({ title, message, confirmText: table ? 'Update' : 'Create', onConfirm: () => { const rows = parseInt(document.getElementById('table-rows-input').value, 10); const cols = parseInt(document.getElementById('table-cols-input').value, 10); if (isNaN(rows) || isNaN(cols) || rows < 1 || cols < 1) { App.ui.showToast("Invalid dimensions.", { type: 'error' }); return; } App.events.table.createOrUpdate(rows, cols); } });
                const rowsInput = document.getElementById('table-rows-input'); const colsInput = document.getElementById('table-cols-input'); const confirmBtn = document.getElementById('modal-confirm'); const handleEnter = e => { if (e.key === 'Enter') { e.preventDefault(); confirmBtn.click(); } };
                rowsInput.addEventListener('keydown', handleEnter); colsInput.addEventListener('keydown', handleEnter); rowsInput.focus(); rowsInput.select();
            },
            table: {
                // FIX: Added a dedicated `create` function for commands to call directly.
                create(rows, cols) {
                    let tableHTML = '<table><thead><tr>';
                    for (let c = 0; c < cols; c++) tableHTML += `<th><br></th>`;
                    tableHTML += '</tr></thead><tbody>';
                    for (let r = 1; r < rows; r++) {
                        tableHTML += '<tr>';
                        for (let c = 0; c < cols; c++) tableHTML += `<td><br></td>`;
                        tableHTML += '</tr>';
                    }
                    tableHTML += '</tbody></table><p><br></p>';
                    document.execCommand('insertHTML', false, tableHTML);
                    App.state.isArticleDirty = true;
                },

                createTile() {
                    const tileHTML = `<table class="tile-box-table"><tbody><tr><td class="tile-cell"><b><br></b></td></tr></tbody></table><p><br></p>`;
                    document.execCommand('insertHTML', false, tileHTML);
                    App.state.isArticleDirty = true;
                },

                update(table, newRows, newCols) {
                    const newTable = document.createElement('table'); newTable.className = table.className;
                    const newTHead = newTable.createTHead(); const newTBody = newTable.createTBody();
                    for (let r = 0; r < newRows; r++) {
                        const newRow = document.createElement('tr');
                        for (let c = 0; c < newCols; c++) {
                            const isHeaderRow = (r === 0 && table.tHead && table.tHead.rows.length > 0);
                            const newCell = document.createElement(isHeaderRow ? 'th' : 'td');
                            if (table.rows[r] && table.rows[r].cells[c]) newCell.innerHTML = table.rows[r].cells[c].innerHTML;
                            else newCell.innerHTML = '<br>';
                            newRow.appendChild(newCell);
                        }
                        if (r === 0 && table.tHead && table.tHead.rows.length > 0) newTHead.appendChild(newRow); else newTBody.appendChild(newRow);
                    }
                    const parent = table.parentNode; const nextSibling = table.nextElementSibling;
                    parent.removeChild(table);
                    if (nextSibling) parent.insertBefore(newTable, nextSibling); else parent.appendChild(newTable);
                    let trailingP = newTable.nextElementSibling;
                    if (!trailingP || trailingP.tagName !== 'P') { trailingP = document.createElement('p'); trailingP.innerHTML = '<br>'; newTable.insertAdjacentElement('afterend', trailingP); }
                    App.util.placeCursor(trailingP, true);
                    App.state.isArticleDirty = true;
                },

                createOrUpdate(newRows, newCols) {
                    const markerId = App.state.cursorMarkerId;
                    if (!markerId) { App.ui.showToast("Editor selection lost. Please try again.", { type: 'error' }); return; }

                    const markerNode = document.getElementById(markerId);
                    if (!markerNode) { App.ui.showToast("Cursor marker not found. Please try again.", { type: 'error' }); return; }

                    const table = markerNode.closest('table');

                    const sel = window.getSelection();
                    const range = document.createRange();
                    range.setStartBefore(markerNode);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                    markerNode.parentNode.removeChild(markerNode);
                    App.state.cursorMarkerId = null;

                    if (table && table.classList.contains('tile-box-table')) { App.ui.showToast("You already created a Box Tile. It cannot be expanded.", { type: 'warning' }); return; }
                    if (!table && newRows === 1 && newCols === 1) this.createTile();
                    else if (table) this.update(table, newRows, newCols);
                    else this.create(newRows, newCols);
                }
            },

            ai: {
                saveAiSettings() {
                    // Save Provider
                    const provider = document.getElementById('ai-provider-select').value;
                    App.settings.set('aiProvider', provider);

                    // Save OpenRouter Key
                    const openRouterKeyInput = document.getElementById('openrouter-key-input');
                    const openRouterKey = openRouterKeyInput ? openRouterKeyInput.value.trim() : null;
                    if (openRouterKey === '' || (openRouterKey && openRouterKey.startsWith('sk-or-'))) {
                        App.settings.set('openRouterKey', openRouterKey || null);
                    } else if (openRouterKey !== null) {
                        App.ui.showToast('Invalid OpenRouter key format. It was not saved.', 'error');
                    }

                    // Save OpenRouter Model
                    const openRouterModelInput = document.getElementById('openrouter-model-input');
                    if (openRouterModelInput) {
                        App.settings.set('openRouterModel', openRouterModelInput.value.trim());
                    }

                    // Save Gemini Key
                    const geminiKeyInput = document.getElementById('gemini-key-input');
                    const geminiKey = geminiKeyInput ? geminiKeyInput.value.trim() : null;
                    if (geminiKey === '' || (geminiKey && geminiKey.startsWith('AIzaSy'))) {
                        App.settings.set('geminiKey', geminiKey || null);
                    } else if (geminiKey !== null) {
                        App.ui.showToast('Invalid Gemini key format. It was not saved.', 'error');
                    }

                    App.ui.showToast('AI settings saved!', 'success');
                    App.ui.closeModal();
                },

                clearConversation() {
                    if (this.state.history.length > 0) {
                        App.ui.showConfirmationModal({
                            title: 'Clear Conversation?',
                            message: 'Are you sure you want to delete this conversation history?',
                            confirmText: 'Clear',
                            onConfirm: () => {
                                this.state.history = [];
                                this.renderConversation();
                            }
                        });
                    }
                },

                async saveConversationAsNote() {
                    if (this.state.history.length === 0) {
                        App.ui.showToast("Nothing to save.", "warning");
                        return;
                    }
                    const title = `Co-Pilot Conversation: ${new Date().toLocaleString()}`;
                    let contentHTML = ``;
                    this.state.history.forEach(msg => {
                        const cleanedContent = msg.content.replace(/<div class="copilot-bubble-actions">.*?<\/div>/s, '');
                        if (msg.role === 'user') {
                            contentHTML += `<blockquote><p><b>You:</b> ${cleanedContent}</p></blockquote>`;
                        } else {
                            contentHTML += `<div>${cleanedContent}</div>`;
                        }
                    });
                    const defaultCategory = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                    const newNote = await App.storage.createArticle({ title, content: contentHTML, category: defaultCategory });
                    if (newNote) {
                        App.ui.showToast('Conversation saved!', {
                            type: 'success',
                            action: { label: 'Open Note', callback: () => App.router.navigateTo('article', { id: newNote.id, mode: 'read' }) }
                        });
                        this.state.history = [];
                        this.renderConversation();
                    } else {
                        App.ui.showToast("Failed to save conversation.", "error");
                    }
                },

                async executeKashAsk(prompt) {
                    if (!prompt) {
                        App.ui.showToast("Please provide a question for the AI.", "warning");
                        return;
                    }

                    const systemPrompt = `You are 'Kash, the Content Architect,' an expert AI integrated into the NoteKash app. Your mission is to analyze the user's context (the article and any selected text) and their prompt, adopt the persona of a subject matter expert, to write most reliable and meaningful response to Query. Then Act as content architect to generate a beautiful, structured, and aesthetic response using the best components from your HTML Toolkit.

                        **MANDATORY Core Logic Flow (Synthesis Model):**

                        1.  **Analyze the User's Goal:** First, understand the core question in the [User Prompt]. What is the user's primary intent? what he wants from you? Does he mention his answer to be in any particular format/template?

                        2.  **Analyze Provided Context:** Second, review the provided [Article Content]. Does it contain information directly relevant to the user's question?

                        3.  **Synthesize and Respond (CRITICAL):**
                            * IMPORTANT: In both "if and else" cases remember You MUST ALWAYS Act as Subject Matter Expert (SME) (e.g an elite economist for finance, a Indian Historian for Gupta Empire, An Polity Expert for Consitution, Top notch Financial advisor for Mutual funds etc.) So you inshort develop the most relevant and Best Persona according to what is being Asked to Answer in precise, authoritative, logical, purposeful and contextually appropriate manner, reflecting the depth of your knowledge and experience in that domain
                            * **IF the user's question is general knowledge** (e.g., "What happens when we die?", "Explain quantum physics") and is unrelated to the [Article Content], you MUST answer using your own vast, general knowledge base. Do NOT mention the article's context if it's irrelevant.
                            * **ELSE (if the question IS related to the context):** You MUST formulate a comprehensive answer by intelligently combining your own expert knowledge with the specific details, facts, and nuances found in the [Article Content]. This creates a richer, more personalized response.
                           
                        4.  **Format the Output:** After formulating your expert answer, act as a 'Content Architect'. Choose the single best component from your HTML toolkit to present the information in the most beautiful and effective way.
                        **Core Principle: Text Styling**
                        This is critical for readability. In ALL your responses, you MUST use \`<b>\` tags to bolden the most important keywords, names, dates, and facts. Use \`<em>\` (italic) for secondary emphasis. This makes notes visually aesthetic an skimmable.

                        **Your Component Toolkit to USE (Must Use):**

                        1.  **Accordion (\`<div class="nk-accordion">\`):**
                            * **Use Case:** Your primary tool for any explicit or implicit Question & Answer. If the user asks "What is...", "How does...", or "Explain...", this is almost always the best choice.
                            * **HTML:** \`<div class="nk-accordion" data-state="open"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>USER_QUESTION_HERE</b></span>...</div><div class="nk-accordion-content"><p>YOUR_ANSWER_HERE</p></div></div>\`

                        2.  **Decktile with Text Tiles (\`<div class="nk-textile-deck">\`):**
                            * **Use Case:** Use this to group several related, short pieces of information. Excellent for listing key features, components, or related concepts (e.g., "list the types of...", "what are the main pillars of...").
                            * **HTML:** \`<div class="nk-textile-deck" contenteditable="false"><div class="nk-text-tile color-1">...</div><div class="nk-text-tile color-2">...</div></div>\`

                        3.  **Textile (\`<div class="nk-text-tile">\`):**
                            * **Use Case:** Use sparingly for a single, high-impact fact, definition, or key takeaway that needs to stand out on its own.
                            * **HTML:** \`<div class="nk-text-tile color-default"><span class="nk-text-tile-icon">ðŸ’¡</span><div class="nk-text-tile-content">YOUR_ANSWER_HERE</div></div>\`

                        4.  **Table (\`<table>\`):**
                            * **Use Case:** When the user asks for a comparison, a list of items with multiple properties, or structured data (e.g., "list the pros and cons", "table of planets and their moons").
                            * **Action:** Generate a standard HTML \`<table>\` with \`<th>\` headers.

                        5.  **Bulleted/Numbered List (\`<ul>\`/\`<ol>\`):**
                            * **Use Case:** When the user asks to "list the steps", "outline the reasons", or any request for multiple distinct points where a table is overly complex.

                        6.  **Default (Blockquote):**
                            * **Use Case:** Your fallback for general statements, opinions, or when no other component fits perfectly.
                            * **HTML:** \`<blockquote><p>YOUR_ANSWER_HERE</p></blockquote>\`
                            
                        7.  **Colored Text:** For styled sentences and short paragraphs (for most important sentences and parts of our content).
                            * **Triggers:** "in red text", "in green", "in blue color", "in magenta".
                            * **Classes:** \`text-red\`, \`text-green\`, \`text-blue\`, \`text-magenta\`.
                            * **HTML Structure:** \`<p class="CLASS_NAME_HERE">YOUR_ANSWER_HERE</p>\`

                        **Final Rules (CRITICAL):**
                        * Respond ONLY with the final, complete HTML snippet.
                        * Do NOT include any conversational filler, greetings, or explanations outside of the HTML you generate.`;

                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, prompt);

                    if (result && result.trim()) {
                        const answerHtml = result.trim().replace(/^```(html)?\n?/, '').replace(/\n?```$/, '');
                        
                        // --- Smart Insertion Logic ---
                        const selection = window.getSelection();
                        if (selection && selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);
                            const container = range.commonAncestorContainer;
                            const parentBlock = (container.nodeType === 3 ? container.parentElement : container)
                                .closest('p, li, h1, h2, h3, h4, h5, h6, blockquote, div');

                            if (parentBlock && document.getElementById('article-content').contains(parentBlock)) {
                                parentBlock.insertAdjacentHTML('afterend', answerHtml);
                            } else {
                                document.execCommand('insertHTML', false, answerHtml);
                            }
                        } else {
                            document.execCommand('insertHTML', false, answerHtml);
                        }
                        
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("The AI did not provide an answer. Please try again.", "warning");
                    }
                },

                async executeKashTranslate(language) {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();
                    if (!selectedText) {
                        App.ui.showToast("Please select text to translate.", "warning");
                        return;
                    }

                    const systemPrompt = `You are an expert translator. Translate the following text to ${language}. Respond ONLY with the translated text, without any explanations, quotes, or conversational filler.`;
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);

                    if (result && result.trim()) {
                        // Collapse the selection to the end to paste after it
                        selection.collapseToEnd();
                        const translationHtml = `<br><i>(${language} translation: ${App.util.escapeHtml(result.trim())})</i>`;
                        document.execCommand('insertHTML', false, translationHtml);
                        App.state.isArticleDirty = true;
                    }
                },

              
                async executeKashTags() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Article is empty, nothing to tag.", "warning");
                        return;
                    }

                    const systemPrompt = `You are an expert indexer for a knowledge base. Your task is to analyze the article and identify the 5-9 most important and representative phrases to be turned into tags.

                        CRITICAL: Do not just list keywords. You must return a valid JSON array of objects. Each object must have a key named "tag_text" containing the exact, verbatim phrase from the article that should be tagged.

                        RULES:
                        1. Choose the most complete and representative instance of a concept (e.g., tag "collegium system" instead of just "collegium", also "article 312" instead of "article 312 of the constitution" since its clear in itself and short).
                        2. Do not return duplicate "tag_text" values. Each short phrase must be Unique.
                        3. Be selective; only choose 5-9 of the most crucial concepts for tagging.

                        Example Response:
                        [{"tag_text": "women representation"},{"tag_text": "article 312"}, {"tag_text": "All India Judicial Service"}]

                        Respond ONLY with the JSON array.`;

                    const userPrompt = contentDiv.innerText;
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        try {
                            // Find the JSON array within the AI's response, even if it adds extra text
                            const jsonMatch = result.match(/\[\s*\{[\s\S]*?\}\s*\]/s);
                            if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");

                            const tagsToApply = JSON.parse(jsonMatch[0]);
                            if (!Array.isArray(tagsToApply)) throw new Error("AI did not return an array.");

                            let contentHTML = contentDiv.innerHTML;
                            let tagsAppliedCount = 0;

                            App.ui.showToast(`Applying ${tagsToApply.length} smart tags...`, { type: 'info' });

                            tagsToApply.forEach(tagObj => {
                                if (tagObj && tagObj.tag_text) {
                                    const phraseToTag = tagObj.tag_text;
                                    // This check prevents re-tagging something that's already a tag
                                    if (contentHTML.includes(phraseToTag)) {
                                        const slug = App.contentTools.slugify(phraseToTag);
                                        const replacement = `<span class="rendered-tag" data-tag="${slug}">${phraseToTag}</span>`;
                                        
                                        contentHTML = contentHTML.replace(phraseToTag, replacement);
                                        tagsAppliedCount++;
                                    }
                                }
                            });

                            if (tagsAppliedCount > 0) {
                                contentDiv.innerHTML = contentHTML;
                                App.ui.showToast(`${tagsAppliedCount} smart tags were applied!`, 'success');
                                App.state.isArticleDirty = true;
                            } else {
                                App.ui.showToast("AI suggested tags, but none could be applied.", "info");
                            }

                        } catch (error) {
                            console.error("KashTags Error:", error, "AI Response:", result);
                            App.ui.showToast("AI returned an invalid format for tagging.", "error");
                        }
                    } else {
                        App.ui.showToast("AI could not identify any tags to apply.", "warning");
                    }
                },

                async executeKashSummary() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Nothing to summarize.", "warning");
                        return;
                    }
                    const systemPrompt = "You are a practical, reliable summarizer for a note-taking app. Given a user-provided text, produce a compact, useful summary optimized for quick reading and recall: output a one-line descriptive title (if identifiable) followed by 4â€“12 concise bullet points that capture the most important facts, conclusions, and action items; each bullet should be short (about 20â€“35 words). Prefer extractive phrasing (use exact words/short phrases from the text) to avoid hallucination; paraphrase only to improve clarity. Do NOT invent facts â€” if a requested detail is missing, write 'didn't specify ...' If the source is very short (â‰¤2 sentences), return a 1â€“2 sentence condensed summary instead of multiple bullets. If the user requests a focus (e.g., 'action items', 'key facts', 'summary for meeting'), prioritize that focus in the bullets. Output only the title and markdown bullet list (no extra explanation, headings, or metadata). Keep tone neutral, language simple, and make the result immediately copy-ready for notes.";
                    const userPrompt = contentDiv.innerText;

                    const summary = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (summary && summary.trim()) {
                        
                        const summaryHtml = summary.split('\n').map(line => line.trim().replace(/^[\*\-]\s*/, '')).filter(line => line).map(line => `<li>${line}</li>`).join('');

                        const finalHtml = `
                            <div class="nk-text-tile color-ghost-1 ai-summary-tile" contenteditable="true" data-color="ghost-1">
                                <div class="nk-text-tile-content" contenteditable="true">
                                    <h4 style="margin-top: 0; font-weight: 600;" contenteditable="false">Short AI Summary</h4>
                                    <ul style="padding-left: 20px; margin-bottom: 0;">${summaryHtml}</ul>
                                </div>
                            </div><p><br></p>`;

                       
                        const existingSummary = contentDiv.querySelector('.ai-summary-tile');
                        if (existingSummary) {
                            if (existingSummary.nextElementSibling && existingSummary.nextElementSibling.innerHTML === '<br>') {
                                existingSummary.nextElementSibling.remove();
                            }
                            existingSummary.remove();
                        }

                        contentDiv.insertAdjacentHTML('afterbegin', finalHtml);
                        App.ui.showToast("Summary generated!", "success");
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("AI returned an empty summary. Please try again.", "warning");
                    }
                },

                async executeKashFlash() {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();

                    if (!selectedText) {
                        App.ui.showToast("Please select text to generate flashcards from.", "warning");
                        return;
                    }

                    // --- NEW "LEARNING SCIENTIST" PROMPT ---
                    const systemPrompt = `You are an expert educator and Cloze Deletion Specialist integrated into the NoteKash app. Your mission is to transform a user's selected text into the most Effective Active Recall Flashcard possible by creating surgical, High-value/quality Cloze deletions.

                    **Core Philosophy:**
                    Your goal is not just to hide words, but to identify and test the most critical pieces of information that are essential for understanding and memorization.

                    **Your Thought Process & Selection Criteria (Follow this hierarchy):**

                    1.  **Identify the Core Concepts:** Read the entire text to understand its meaning. What are the 1-4 most important "nuggets" of knowledge here?
                    2.  **Prioritize What to Cloze:**
                        * **Priority #1 (Key Terms & Definitions):** If the text defines a term, cloze the term itself. **Example:** \`{{c1::The Collegium System}}\` is the body responsible for judicial appointments.
                        * **Priority #2 (Cause & Effect):** Cloze the result of an action or the reason for a state. **Example:** The non-enforceability of DPSPs is due to them being \`{{c1::non-justiciable}}\`.
                        * **Priority #3 (Specific Data):** Cloze crucial numbers, dates, names, or statistics. **Example:** The DPSPs are found in \`{{c1::Part IV}}\` of the Constitution.
                        * **Priority #4 (Crucial Phrases):** If a multi-word phrase represents a single, vital concept, cloze the entire phrase. **Example:** The ultimate goal is to create a \`{{c1::Welfare State}}\`.

                    **Dynamic Cloze Count:**
                    * Analyze the text's length and density.
                    * For short selections (1-2 sentences), create **1-3** powerful clozes.
                    * For longer paragraphs, create **2-7** clozes, ensuring each one tests a distinct, important concept.

                    **CRITICAL Final Output Rules:**
                    1.  You MUST use the exact \`{{c1::text to hide}}\`, \`{{c2::...}}\` syntax for cloze deletions.
                    2.  Your response MUST be ONLY the fully modified text.
                    3.  You MUST preserve the original sentence structure and surrounding context perfectly.
                    4.  Do NOT include any explanations, conversational text, or markdown formatting. Your output should be ready to be inserted directly into an editor.`;
                    
                    const userPrompt = selectedText;
                    const toastId = App.ui.showToast('ðŸ¤– KashFlash is thinking...', { type: 'info', duration: 0 });

                    try {
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);
                        App.ui.hideToast(toastId);

                        if (result && result.trim()) {
                            const cleanedText = result.trim().replace(/^```(\w+\n)?/, '').replace(/\n?```$/, '');
                            document.execCommand('insertHTML', false, cleanedText);
                            App.ui.showToast("KashFlash created!", 'success');
                            App.state.isArticleDirty = true;
                        } else {
                            throw new Error("AI returned an empty response.");
                        }
                    } catch (error) {
                        App.ui.hideToast(toastId);
                        App.ui.showToast("AI could not generate a flashcard. Please try again.", "warning");
                        console.error("KashFlash Error:", error);
                    }
                },

                async executeKashQuestion() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Nothing in the article to ask questions about.", "warning");
                        return;
                    }
                    const systemPrompt = "You are an AI that generates insightful questions based on a text. Your goal is to create 5 thought-provoking questions that test the reader's comprehension of the main arguments, key facts, and underlying assumptions. Frame them as open-ended questions. Respond ONLY with the questions, each on a new line, formatted as a numbered list.";
                    const userPrompt = contentDiv.innerText;

                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        // Convert numbered list from AI into an HTML ordered list
                        const questionsHtml = `<ol>${result.trim().split('\n').map(line => `<li>${line.replace(/^\d+\.\s*/, '')}</li>`).join('')}</ol>`;
                        const finalHtml = `<div class="nk-text-tile color-ghost-2" contenteditable="true"><div class="nk-text-tile-content" contenteditable="true"><h4 style="margin-top:0;" contenteditable="false">Key Questions</h4>${questionsHtml}</div></div><p><br></p>`;
                        contentDiv.insertAdjacentHTML('beforeend', finalHtml);
                        App.ui.showToast("5 Key Questions Generated!", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("AI could not generate questions.", "warning");
                    }
                },

                async executeKashDebate() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Article is empty, nothing to debate.", "warning");
                        return;
                    }
                    const systemPrompt = "You are an expert debater and critical analyst. Read the following article content, identify its central argument or tone, and then construct a two-column debate table. The first column should powerfully argue FOR the article's position. The second column should present a strong, well-reasoned counter-argument or the opposing perspective. Each column should have a clear heading. Conclude with a persuasive summary for each side. Respond ONLY with the complete HTML for the table, using the app's standard table styling.";
                    const userPrompt = contentDiv.innerText;

                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        const cleanedHtml = result.trim().replace(/^```html\n?/, '').replace(/\n?```$/, '');
                        contentDiv.insertAdjacentHTML('beforeend', `<p><br></p>${cleanedHtml}<p><br></p>`);
                        App.ui.showToast("Debate table created!", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("AI could not generate a debate.", "warning");
                    }
                },

                async executeKashLong() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Nothing to summarize.", "warning");
                        return;
                    }
                    const systemPrompt = "You are an expert summarizer tasked with creating a detailed, comprehensive summary of the provided text. Unlike a brief summary, this summary must capture all key arguments, supporting details, important data points, and named entities without missing any crucial information. The summary should be significantly shorter than the original article but much longer and more detailed than a short summary. Structure the output in well-organized paragraphs. Respond ONLY with the summary text.";
                    const userPrompt = contentDiv.innerText;

                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        const paragraphsHtml = result.trim().split('\n').map(p => `<p>${p}</p>`).join('');
                        const finalHtml = `<div class="nk-text-tile color-default" contenteditable="false"><div class="nk-text-tile-content"><h4 style="margin-top:0;">Detailed Summary</h4>${paragraphsHtml}</div></div><p><br></p>`;
                        contentDiv.insertAdjacentHTML('afterbegin', finalHtml);
                        App.ui.showToast("Detailed summary generated!", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("AI could not generate a detailed summary.", "warning");
                    }
                },

                async executeKashCurate() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("There is no content in the note to beautify.", "warning");
                        return;
                    }

                    const systemPrompt = `You are 'KashCurate', an expert AI Content Architect and Designer for the NoteKash app. Your mission is to transform raw text into a beautiful, hierarchical, and effective learning document that uses ALL of NoteKash's powerful features.

                        **Core Directives:**
                        1.  **HIERARCHY & VARIETY ARE MANDATORY:** Your primary goal is to create a visually appealing and easy-to-read document. Do not just put every sentence in a box. You **must** use a rich mix of paragraphs, accordions, MCQs, tables, and a limited number of textiles.
                        2.  **ACTIVE LEARNING FIRST:** Your output must be an active learning tool. Actively create cloze flashcards, Q&A accordions, and multiple-choice questions.

                        **Your Component Toolkit & Curation Rules:**

                        1.  **Paragraphs (<p>):** **This is your default.** Use standard paragraphs for the main narrative, explanations, and connecting information.
                            * **Within paragraphs, you MUST:**
                                * Use \`<b>\` for important keywords.
                                * For key facts, numbers, or terms, create a cloze flashcard. **Example:** The report found that {{c1::14%}} of judges are women.
                                * Use \`==highlight==\` for phrases that deserve visual emphasis but are not flashcards. Highlights and cloze deletions can be used together. **Example:** It's critical to note that ==the conviction rate is {{c1::under 50%}}==.

                        2.  **Accordion (<div class="nk-accordion">):** **Your primary duty is to create these.** Accordions are for short Q&A which you derive after analyzing text. Aim for **at least 3-5 accordions**.
                            * **Use Case:** Actively look for implicit or explicit questions in the text. Convert these into interactive Q&A accordions to promote active recall.
                            * **EXACT HTML STRUCTURE:**
                                \`\`\`html
                                <div class="nk-accordion" data-state="closed">
                                    <div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>What is the main reason for this disparity?</b></span>...</div>
                                    <div class="nk-accordion-content"><p>The primary reason is the collegium system...</p></div>
                                </div>
                                \`\`\`

                        3.  **MCQ Block (<div class="nk-mcq-block">):** Generate **1-2 MCQs** if the text contains suitable factual questions with clear distractors.
                            * **Use Case:** To test specific knowledge points with clear correct and incorrect answers.
                            * **EXACT HTML STRUCTURE:**
                                \`\`\`html
                                <div class="nk-mcq-block">
                                    <div class="nk-mcq-question">Which report highlighted the low representation of women?</div>
                                    <div class="nk-mcq-options">
                                        <div class="nk-mcq-option" data-is-correct="true"><div class="nk-mcq-option-text">India Justice Report</div></div>
                                        <div class="nk-mcq-option" data-is-correct="false"><div class="nk-mcq-option-text">National Judicial Data Grid</div></div>
                                    </div>
                                </div>
                                \`\`\`

                        4.  **Textile (<div class="nk-text-tile ...">):** Use these **SPARINGLY (4-7 per document)** for spotlighting the most critical, standalone information.
                            * **Use Case:** For high-impact facts or conclusions that need to be visually distinct. **AVOID using these for every sentence.**
                            * **Example:** \`<div class="nk-text-tile color-2"><div class="nk-text-tile-content">Women constitute nearly <b>38%</b> of the lower judiciary.</div></div>\`

                        5.  **Tables (<table>):** For structured, comparative data.
                            * **Use Case:** If you find data comparing two or more things (e.g., lower vs. higher judiciary stats, pros vs. cons), you **should** structure it in a simple 2-column table.

                        6.  **Blockquote (<blockquote>):** For direct quotes.
                            * **Use Case:** If the text contains a direct quote from a person (e.g., "War is too important..."), you **must** use a blockquote.

                        **Your Thought Process (Follow these steps meticulously):**
                        1.  Read the entire text to understand the core narrative.
                        2.  Write the main story using standard **paragraphs**.
                        3.  Go back through your paragraphs and embed **{{c1::cloze}}** flashcards on all key statistics and facts.
                        4.  Also embed important visual highlights using \`==highlight==\` in paragraphs.
                        5.  Identify any questions or cause-and-effect statements and convert them into **Accordions**.
                        6.  Find suitable facts to test and create **MCQ Blocks**.
                        7.  Find any direct quotes and format them as **Blockquotes**.
                        8.  Look for comparative data points and structure them in a **Table**.
                        9.  Select 4-7 of the most important, standalone facts and pull them out into visually distinct **Textiles**.
                        10. Finally, perform a polish pass, adding \`<b>\`, \`<i>\`, and \`<u>\` to add a final layer of emphasis.

                        Your goal is an elegant, readable document that guides the user's focus and enhances learning, not a cluttered page of boxes. Respond ONLY with the generated HTML.`;

                    const userPrompt = contentDiv.innerText;

                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        const cleanedHtml = result.trim().replace(/^```(html)?\n?/, '').replace(/\n?```$/, '');
                        const separatorHtml = `
                            <div style="text-align: center; margin: 2rem 0;">
                                <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 0 auto;">
                                <div style="font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-top: 0.5rem;">
                                    âœ¨ NoteKash AI Version âœ¨
                                </div>
                            </div>
                        `;
                        contentDiv.insertAdjacentHTML('beforeend', separatorHtml + cleanedHtml);
                        contentDiv.querySelectorAll('canvas[data-chart-config]').forEach(canvas => {
                            App.ui.renderChartOnCanvas(canvas);
                        });
                        const finalElement = contentDiv.lastElementChild;
                        if (finalElement) {
                            finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                        App.ui.showToast("NoteKash AI has curated your note!", 'success');
                        App.state.isArticleDirty = true;
                    }
                },

                async executeKashTable() {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();

                    if (!selectedText) {
                        App.ui.showToast("Please select text to generate a revision table from.", "warning");
                        return;
                    }

                    const systemPrompt = "You are an AI specializing in creating structured revision tables for students. Analyze the selected text and convert its key information into a concise, well-organized two-column HTML table. The first column should contain the main concepts, terms, or topics. The second column should contain the corresponding definitions, explanations, or key details. Use clear headings for the columns. Respond ONLY with the complete HTML for the table.";

                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);

                    if (result && result.trim()) {
                        const cleanedHtml = result.trim().replace(/^```html\n?/, '').replace(/```$/, '');

                        document.execCommand('insertHTML', false, cleanedHtml + '<p><br></p>');
                        App.ui.showToast("Revision table created!", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("AI could not generate a table.", "warning");
                    }
                },

                async executeKashComedy() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("There's no material to work with! The article is empty.", "warning");
                        return;
                    }

                    const systemPrompt = `You are a sharp, witty stand-up comedian in the style of John Oliver or Hasan Minhaj. Your audience is primarily Hindi/Urdu speakers who understand simple, conversational English. Your job is to take a serious article and turn it into a short (200-300 word), hilarious, and memorable comedy routine.

                        **Your Method:**
                        1.  **Opener:** Start with a relatable, everyday observation that connects to the article's main topic. Invent a personal anecdote. For example: "You know, this whole thing reminds me of my uncle trying to use a smartphone..."
                        2.  **Breakdown with Humor:** Identify 2-3 key, serious points from the article. Explain them using funny analogies, exaggeration, and fictional scenarios. Simplify complex ideas.
                        3.  **The "Desi" Angle:** Connect the topic back to a common experience in an Indian household or society. For example, compare a complex bureaucratic process to trying to get a new gas cylinder or dealing with a government office.
                        4.  **Closer:** End with a strong punchline that summarizes the absurdity of the situation.

                        **Rules:**
                        * **Simple English:** Use easy-to-understand, conversational words. No jargon.
                        * **Formatting:** Format the output like a script. Use <b> tags for emphasis on punchlines. Do NOT use markdown like **.
                        * **Response:** Respond ONLY with the comedy routine script, wrapped in a single \`<blockquote>\`.

                        **Example Persona Snippet:**
                        "So I'm reading this thing about... 'gender equity in the judiciary'. Sounds serious, right? My dad heard the word 'judiciary' and immediately asked if I was in trouble with the law again. No, Dad, I'm just trying to write jokes! "`;

                    const userPrompt = contentDiv.innerText;
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        // AI is now instructed to return a blockquote, so we can insert it directly.
                        const comedyHtml = result.trim() + '<p><br></p>';
                        
                        const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                            <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                ðŸ˜‚ KashComedy Version âœ¨
                            </div>
                        `;

                        contentDiv.insertAdjacentHTML('beforeend', separatorHtml + comedyHtml);

                        const finalElement = contentDiv.lastElementChild;
                        if (finalElement) {
                            finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                        App.ui.showToast("And now for something completely different...", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("The AI is having writer's block. Please try again.", "warning");
                    }
                },

                async executeKashKeywords() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("The article is empty. Add some content first!", "warning");
                        return;
                    }

                    const systemPrompt = `You are an expert academic analyst. Your task is to read the provided article and extract the 7-16 most important, unique, or conceptual keywords and short phrases that are essential for understanding the text.

                        CRITICAL: You MUST respond ONLY with a valid JSON array of strings. Do not include any introductory text, explanations, or markdown.

                        Example Response: (e.g in Polity likewise do same for other subject Articles)
                        ["Judicial Appointments", "Collegium System", "Gender Imbalance", "All India Judicial Service", "Article 312", "Representation of Women", "Constitutional Mandate"]`;

                    const userPrompt = contentDiv.innerText;
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        try {
                            const jsonMatch = result.match(/\[[\s\S]*?\]/);
                            if (!jsonMatch) throw new Error("AI did not return a valid JSON array.");
                            
                            const keywords = JSON.parse(jsonMatch[0]);

                            if (!Array.isArray(keywords) || keywords.length === 0) {
                                App.ui.showToast("AI could not identify any key concepts.", "info");
                                return;
                            }

                            const solidColors = App.commandPalette.state.textileColors.filter(c => !isNaN(c));
                            const tilesHTML = keywords.map((keyword, index) => {
                                const color = solidColors[index % solidColors.length];
                                const escapedKeyword = App.util.escapeHtml(keyword.trim());
                                return `
                                    <div class="nk-text-tile color-${color}" data-color="${color}" contenteditable="false">
                                        <div class="nk-text-tile-content" contenteditable="true">${escapedKeyword}</div>
                                    </div>`;
                            }).join('');

                            const deckHTML = `
                                <div class="nk-textile-deck" contenteditable="false">
                                    <div class="deck-layout-toggle" title="Toggle Layout"><i class="fa-solid fa-table-cells"></i></div>
                                    ${tilesHTML}
                                </div>`;
                            
                            const separatorHtml = `
                                <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                                <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                    ðŸ”‘ Key Concepts âœ¨
                                </div>
                            `;

                            contentDiv.insertAdjacentHTML('beforeend', separatorHtml + deckHTML + '<p><br></p>');

                            const finalElement = contentDiv.lastElementChild.previousElementSibling; // a bit of a hack to target the deck
                            if (finalElement) {
                                finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                            App.ui.showToast("Key concepts have been extracted!", 'success');
                            App.state.isArticleDirty = true;

                        } catch (error) {
                            console.error("KashKeywords Error:", error, "AI Response:", result);
                            App.ui.showToast("AI returned an invalid format for keywords.", "error");
                        }
                    } else {
                        App.ui.showToast("The AI could not extract any keywords. Please try again.", "warning");
                    }
                },

                async executeKashScript() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("The script needs a story! The article is empty.", "warning");
                        return;
                    }

                    const systemPrompt = `You are a focused, friendly, and witty scriptwriter for a short social media video, like a writer for a top Indian YouTuber. Your job is to turn a serious article into a short, punchy, and funny video script. Your audience is from the Indian subcontinent, so the humor should be relatable.

                        **Your Method:**
                        1.  Read the entire article, but focus on the SINGLE most interesting, surprising, or absurd story. Ignore everything else.
                        2.  Produce a copy-ready spoken script of approximately 250 words (~120 seconds).

                        **Strict Script Rules:**
                        1.  **Hook (CRITICAL):** You MUST begin with a strong, funny, one-line hook (under 24 words) that cleverly summarizes the whole topic. For example, if the topic is complex bureaucracy, a hook could be: "You think getting your Aadhaar card updated was hard? Wait till you hear about this..."
                        2.  **Body:** Write in a conversational style with short, easy-to-say sentences. Structure it into 3-5 clear 'beats' or mini-sections.
                        3.  **Humor:** Scatter 2-4 light, relatable punchlines. Compare complex topics to simple things like cricket, Bollywood, or dealing with family.
                        4.  **Ending:** End with a final, memorable, and funny punchline that leaves a strong impression.

                        **Final Output Rules:**
                        - Do NOT invent facts. Stick to the article's information.
                        - Avoid jargon and complicated words.
                        - Output ONLY the final script text. No titles, no "(Scene start)", no character names, no timestamps, no captions, no metadata. Just the spoken words, ready for a teleprompter.`;

                    const userPrompt = contentDiv.innerText;
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        const scriptText = result.trim();
                        // Convert the plain text script with newlines into proper HTML paragraphs
                        const scriptHtml = App.util.textToHtml(scriptText);

                        const finalHtml = `
                            <div class="nk-text-tile color-ghost-1" contenteditable="false" style="margin-top: 1em; display: block; max-width: 100%;">
                                <span class="nk-text-tile-icon">ðŸŽ¬</span>
                                <div class="nk-text-tile-content" contenteditable="true" style="white-space: normal;">
                                    ${scriptHtml}
                                </div>
                            </div>`;

                        const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">`;

                        contentDiv.insertAdjacentHTML('beforeend', separatorHtml + finalHtml + '<p><br></p>');

                        const finalElement = contentDiv.lastElementChild.previousElementSibling;
                        if (finalElement) {
                            finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                        App.ui.showToast("Your script is ready!", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("The AI couldn't find a good story. Please try again.", "warning");
                    }
                },
                async executeKashStory() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Can't tell a story about an empty page!", "warning");
                        return;
                    }

                    const systemPrompt = `You are 'Kash, the Story-Weaver,' a creative and witty storyteller for the NoteKash app. Your unique talent is transforming dry, factual articles into short, funny, and highly memorable fictional stories. Your audience is students who need to remember complex information in an engaging way.

                        **Core Mission:**
                        Carefully read the provided article. Identify the single most important subject and create a vivid, fictional narrative to explain it, embedding the article's facts naturally. A great technique is to personify the core concept as a quirky character (e.g., 'The Collegium System was a very exclusive club...').

                        **Storytelling Rules (Checklist):**
                        1.  **Factual Core:** All facts, dates, numbers, and definitions MUST come directly from the article. Use exact phrases where possible. If a fact is missing, state 'Not specified.'
                        2.  **Creative & Funny Fiction:** Weave the facts into a humorous, fictional story. Invent harmless details and funny scenarios to make the facts stick.
                        3.  **Visual Punchlines:** Include 2-3 short, visual, and funny moments to keep the story engaging.
                        4.  **Structure & Length:** The story must be 200-500 words with a clear beginning, middle, and end.
                        5.  **Handling Multiple Subjects:** If the article clearly covers different topics with the same name, create a separate story for each, prefixed with \`Subject: <name>\`.

                        **Final Output Format (CRITICAL):**
                        - Respond ONLY with the story text (and the \`Subject:\` prefix if needed).
                        - DO NOT include titles, headings, explanations, or any text other than the story itself.
                        - Keep story interesting, vivid, memorable, catchy, without using too much jargon.
                        - DO NOT use markdown or code fences.`;

                    const userPrompt = contentDiv.innerText;
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        const storyText = result.trim();
                        const storyHtml = App.util.textToHtml(storyText);

                        const finalHtml = `
                            <div class="nk-text-tile color-ghost-2" contenteditable="false" style="margin-top: 1em; display: block; max-width: 100%;">
                                <span class="nk-text-tile-icon">ðŸ“–</span>
                                <div class="nk-text-tile-content" contenteditable="true" style="white-space: normal;">
                                    ${storyHtml}
                                </div>
                            </div>`;

                        const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">`;

                        contentDiv.insertAdjacentHTML('beforeend', separatorHtml + finalHtml + '<p><br></p>');

                        const finalElement = contentDiv.lastElementChild.previousElementSibling;
                        if (finalElement) {
                            finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                        App.ui.showToast("A new story has been written!", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("The AI couldn't spin a tale from this. Please try again.", "warning");
                    }
                },
                async executeKashExplain() {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();

                    if (!selectedText) {
                        App.ui.showToast("Please select text to explain.", "warning");
                        return;
                    }

                    const systemPrompt = `You are 'Kash, the Clarifier,' an AI expert integrated into a note-taking app. Your unique skill is to instantly become a world-class specialist on the subject of the user's selected text and then explain it with unparalleled clarity and lucidity for a student.

                        **Your Two-Step Process:**
                        1.  **Act as an Expert:** First, deeply analyze the selected text. If the topic is 'Quantum Physics,' you are a physicist. If it's 'Monetary Policy,' you are an economist.
                        2.  **Teach with Clarity:** Second, use your expertise to generate a compact, copy-ready explanation. Use simple analogies to explain complex topics.

                        **Strict Output Structure (Checklist):**
                        Your response MUST contain ONLY the following, in this exact order:
                        1.  **(Optional) Title:** A one-line title if a clear subject is present.
                        2.  **Summary:** A 1-2 sentence plain-language summary of the core idea.
                        3.  **In-Depth Explanation:** 3-6 short bullet points (\`â€¢\`) covering: what it is, how it works, why it's important, and any key limitations.
                        4.  **Practical Examples:** 2-4 numbered examples. If the topic allows, must be most relevant examples with applications too.

                        **Guiding Principles:**
                        - **Source Fidelity:** Base your explanation strictly on the provided text. Use exact phrases when possible. If a detail is missing, add it from reliable source but make sure you clear the concept to Student.
                        - **Multiple Subjects:** If needed, create separate sections prefixed with \`Subject: <name>\`.

                        **Final Output Format (CRITICAL):**
                        - Respond ONLY with the plain text explanation.
                        - DO NOT include headings (like 'Summary'), explanations about your process, markdown, or code fences.`;

                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);

                    if (result && result.trim()) {
                        const explanationText = App.util.escapeHtml(result.trim());
                        const finalHtml = `
                            <div class="nk-text-tile color-ghost-1" contenteditable="false" style="margin-top: 1em; display: block; max-width: 100%;">
                                <span class="nk-text-tile-icon">ðŸ’¡</span>
                                <div class="nk-text-tile-content" contenteditable="true" style="white-space: pre-wrap; font-family: var(--font-body); font-size: 0.9em; line-height: 1.6;">${explanationText}</div>
                            </div>`;

                        selection.collapseToEnd();
                        document.execCommand('insertHTML', false, finalHtml + '<p><br></p>');
                        App.ui.showToast("Explanation generated!", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("AI could not generate an explanation.", "warning");
                    }
                },
                async executeKashMnemonic() {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();

                    if (!selectedText) {
                        App.ui.showToast("Please select text to create a mnemonic from.", "warning");
                        return;
                    }

                    const systemPrompt = `You are a focused mnemonic-maker for a note-taking app. Your task is to analyze the user's selected text, extract the core concept, and generate a compact, copy-ready output for memorization. Use only the provided text and reliable, general knowledge. Prefer using exact phrases from the text ('extractive phrasing').

                        Your response MUST have structure of :
                            **Optional Title:** A single, descriptive title if a clear concept is identifiable. If not, omit this line.
                            **Mnemonics:** Exactly three mnemonic options, labeled precisely as follows:
                            1) Simple & Catchy: [Mnenomic try 1- In english while being catchy]
                            Usage: [An explanation note]
                            2) Subcontinent-Flavored: [Mnenomic try 2- with a basic South Asian cultural flavor]
                            Usage: [An explanation note]
                            3) Acronym/Rhyme: [A short acronym or rhyming phrase].
                            Usage: [An explanation note]

                        **RULES:**
                        - DO NOT include any headings like "Title", "Bullet Points", or "Mnemonics".
                        - DO NOT use jargon, vivid stories, or invent facts. If a detail is missing, write 'Not specified.'
                        - DO NOT wrap your response in code fences or markdown.`;

                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);

                    if (result && result.trim()) {
                        const mnemonicText = App.util.escapeHtml(result.trim());
                        // Use a <pre> tag inside a styled div to perfectly preserve the line breaks and spacing from the AI's response.
                        const finalHtml = `
                            <div class="nk-text-tile color-ghost-2" contenteditable="false" style="margin-top: 1em; display: block; max-width: 100%;">
                                <div class="nk-text-tile-content" contenteditable="true" style="white-space: pre-wrap; font-family: var(--font-body); font-size: 0.9em; line-height: 1.6;">${mnemonicText}</div>
                            </div>`;

                     
                        selection.collapseToEnd();
                        document.execCommand('insertHTML', false, finalHtml + '<p><br></p>');
                        App.ui.showToast("Mnemonic generated!", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("AI could not generate a mnemonic. Please try again.", "warning");
                    }
                },

                

                async executeKashAccordion() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Your note is empty. Add some content first!", "warning");
                        return;
                    }

                    const toastId = App.ui.showToast('ðŸ¤– AI is generating insightful Q&A...', { type: 'info', duration: 0 });
                    const articleContent = contentDiv.innerText;

                    const systemPrompt = `You are an expert educator (of subject you writing QnA on) and content architect for the NoteKash app. Your task is to analyze the provided [Article Content] and, by synthesizing it with your own vast but reliable knowledge base, generate a set of 3 to 8 insightful Question & Answer pairs.

                    **Core Directives:**
                    1.  The questions should probe for deeper understanding, asking "why", "how", and exploring implications.
                    2.  The answers should be concise, clear, and directly address the question, acting as perfect revision material.
                    3.  You must use both the provided text and your own vast knowledge to create the best possible Q&A set for a student.

                    **CRITICAL OUTPUT FORMAT:**
                    Your ENTIRE response MUST be a single, valid JSON array of objects. Do NOT include any other text or markdown.
                    Each object in the array represents one accordion and MUST have two keys:
                    1.  "question": A string for the accordion title.
                    2.  "answer": A string for the accordion content.

                    **Example JSON Response:**
                    [
                        {
                            "question": "What is the primary function of mitochondria?",
                            "answer": "The primary function of mitochondria is to generate most of the cell's energy in the form of adenosine triphosphate (ATP)."
                        },
                        {
                            "question": "How does the collegium system impact judicial appointments?",
                            "answer": "It gives primacy to the Chief Justice of India and the senior-most judges of the Supreme Court in the appointment and transfer of judges, aiming to ensure judicial independence."
                        }
                    ]`;

                    try {
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, articleContent);
                        App.ui.hideToast(toastId);

                        if (!result || !result.trim()) {
                            throw new Error("AI returned an empty response.");
                        }

                        const jsonMatch = result.match(/\[\s*\{[\s\S]*?\}\s*\]/s);
                        if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");
                        
                        const qaPairs = JSON.parse(jsonMatch[0]);
                        if (!Array.isArray(qaPairs) || qaPairs.length === 0) {
                            throw new Error("Parsed data is not a valid array of Q&A pairs.");
                        }

                        const accordionsHTML = qaPairs.map(item => {
                            if (!item.question || !item.answer) return '';
                            const cleanQuestion = App.util.escapeHtml(item.question.trim());
                            const cleanAnswer = App.util.escapeHtml(item.answer.trim());
                            const cardId = 'acc_' + crypto.randomUUID();
                            const contentId = 'acc-content-' + cardId;

                            return `
                                <div class="nk-accordion" data-state="closed" data-id="${cardId}">
                                    <div class="nk-accordion-trigger" role="button" tabindex="0" aria-expanded="false" aria-controls="${contentId}">
                                        <span class="nk-accordion-title" contenteditable="true"><b>${cleanQuestion}</b></span>
                                        <div class="nk-accordion-controls">
                                            <button class="nk-accordion-control-btn nk-accordion-hint-btn" title="Add/Edit Hint">${App.util.icons.hint}</button>
                                            <button class="nk-accordion-control-btn nk-accordion-reversible-toggle" title="Make Reversible">${App.util.icons.reversible}</button>
                                            <svg class="nk-accordion-chevron" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"></polyline></svg>
                                        </div>
                                    </div>
                                    <div id="${contentId}" class="nk-accordion-content" contenteditable="true"><p>${cleanAnswer}</p></div>
                                </div>`;
                        }).join('');

                        if (!accordionsHTML.trim()) {
                            throw new Error("Failed to generate HTML from AI response.");
                        }
                        
                        const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                            <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                â“ AI Generated Q&A âœ¨
                            </div>`;

                        contentDiv.insertAdjacentHTML('beforeend', separatorHtml + accordionsHTML + '<p><br></p>');
                        App.ui.showToast(`${qaPairs.length} Q&A accordions generated!`, 'success');
                        App.state.isArticleDirty = true;
                        
                        const finalElement = contentDiv.lastElementChild;
                        if (finalElement) {
                            finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }

                    } catch (error) {
                        App.ui.hideToast(toastId);
                        App.ui.showToast(`AI failed: ${error.message}`, "error");
                        console.error("KashAccordion Generation Error:", error);
                    }
                },

                async executeKashHighlight() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Article is empty, nothing to highlight.", "warning");
                        return;
                    }

                    const systemPrompt = `You are an intelligent highlighting tool for a note-taking app. Your task is to analyze the provided article and identify ONLY the most crucial phrases, sentences, or data points (5-10 key points). For each identified piece of text, you must return a JSON object with two keys: "text" (the exact, verbatim text from the article to be highlighted) and "color" (a number from 1 to 6). Use can use different colors contextually (not necessary): 1 for main ideas, 2 for supporting evidence, 3 for names/dates, 4 for warnings/negatives, 5 for key terms, 6 for conclusions. Be very selective and brief. Respond ONLY with a valid JSON array of these objects. Example: [{"text": "the central thesis is...", "color": 1}, {"text": "a critical disadvantage", "color": 4}]`;

                    const userPrompt = contentDiv.innerText;

                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        try {
                            const jsonMatch = result.match(/\[\s*\{[\s\S]*?\}\s*\]/);
                            if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");

                            const highlights = JSON.parse(jsonMatch[0]);
                            if (!Array.isArray(highlights)) throw new Error("AI did not return an array.");

                            const walker = document.createTreeWalker(contentDiv, NodeFilter.SHOW_TEXT);
                            const textNodes = [];
                            while(walker.nextNode()) textNodes.push(walker.currentNode);

                            let highlightsApplied = 0;
                            highlights.forEach(highlight => {
                                if (!highlight.text || !highlight.color) return;

                                const textToHighlight = highlight.text.trim();
                                const colorClass = `highlight-${highlight.color}`;
                                const snippetId = `snip-${crypto.randomUUID().slice(0, 12)}`;

                                for (const node of textNodes) {
                                    const index = node.nodeValue.indexOf(textToHighlight);
                                    if (index !== -1 && !node.parentElement.closest('span[class*="highlight-"]')) {
                                        const range = document.createRange();
                                        range.setStart(node, index);
                                        range.setEnd(node, index + textToHighlight.length);

                                        const highlightSpan = document.createElement('span');
                                        highlightSpan.className = colorClass;
                                        highlightSpan.id = snippetId;
                                        range.surroundContents(highlightSpan);

                                        highlightsApplied++;
                                        break; 
                                    }
                                }
                            });

                            if (highlightsApplied > 0) {
                                App.ui.showToast(`${highlightsApplied} key sections highlighted!`, 'success');
                                App.state.isArticleDirty = true;
                            } else {
                                App.ui.showToast("AI found highlights, but they could not be applied to the text.", "warning");
                            }
                           

                        } catch (error) {
                            console.error("KashHighlight Error:", error, "AI Response:", result);
                            App.ui.showToast("AI returned an invalid format for highlighting.", "error");
                        }
                    } else {
                        App.ui.showToast("AI could not generate highlights.", "warning");
                    }
                },

                async executeImproveWriting() {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();
                    if (!selectedText) {
                        App.ui.showToast("Please select text to get writing suggestions.", "warning");
                        return;
                    }

                    const systemPrompt = `You are an expert writing assistant. A user has selected a piece of text and wants alternative phrasings. Produce rewrites in these tones: "Simpler" (most concise while preserving meaning), "Friendly" (warm, conversational), "Confident" (direct and assertive), "Persuasive" (engaging and influential), "Poetic" (lyrical, using metaphor or rhythm), and "Funny" (witty and humourous with touch of subcontinent). Respond ONLY with a valid JSON array of objects in this exact form: [{"tone":"Simpler","text":"..."}, {"tone":"Friendly","text":"..."}, ...]. The "Simpler" object must be the first item. Preserve the original meaning, avoid inventing facts, keep each rewrite natural and ready to use, and include no extra fields, commentary, or surrounding text.`;

                    const userPrompt = selectedText;
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        try {
                            // Robustly find and parse the JSON array from the AI's response
                            const jsonMatch = result.match(/\[\s*\{[\s\S]*?\}\s*\]/);
                            if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");

                            const alternatives = JSON.parse(jsonMatch[0]);
                            if (!Array.isArray(alternatives)) throw new Error("AI did not return an array of suggestions.");

                            // Format the output into a clean, readable blockquote
                            let suggestionsHtml = alternatives.map(alt => 
                                `<h4>${App.util.escapeHtml(alt.tone)}</h4>
                                <p>${App.util.escapeHtml(alt.text)}</p>`
                            ).join('<hr style="border-top: 1px solid var(--border-color); margin: 0.5em 0;">');

                            const finalHtml = `
                                <blockquote contenteditable="false" style="margin-top: 1em;">
                                    <h4 style="font-weight: 600;">Original Text</h4>
                                    <p><em>${App.util.escapeHtml(selectedText)}</em></p>
                                    <hr style="border-top: 2px solid var(--border-color); margin: 1em 0;">
                                    ${suggestionsHtml}
                                </blockquote>
                                <p><br></p>`;

                            // Collapse the selection to the end and insert the HTML after it
                            selection.collapseToEnd();
                            document.execCommand('insertHTML', false, finalHtml);

                            App.ui.showToast("Writing suggestions generated!", 'success');
                            App.state.isArticleDirty = true;

                        } catch (error) {
                            console.error("KashWriting Error:", error, "AI Response:", result);
                            App.ui.showToast("AI returned an invalid format for suggestions.", "error");
                        }
                    } else {
                        App.ui.showToast("AI could not generate suggestions.", "warning");
                    }
                },
                async executeKashListify() {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();
                    if (!selectedText) {
                        App.ui.showToast("Please select text to convert to a list.", "warning");
                        return;
                    }

                    const systemPrompt = "Analyze the following text. Identify the main distinct points and restructure them as a concise markdown bulleted list. Respond ONLY with the markdown list, with each item on a new line starting with `* `.";
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);

                    if (result && result.trim()) {
                        const listItems = result.trim().split('\n').map(line => {
                            const cleanLine = line.replace(/^\s*[\*\-]\s*/, '').trim();
                            return `<li>${App.util.escapeHtml(cleanLine)}</li>`;
                        }).join('');
                        const listHtml = `<ul>${listItems}</ul><p><br></p>`;
                        document.execCommand('insertHTML', false, listHtml);
                        App.ui.showToast("Text converted to list!", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("AI could not create a list from the selected text.", "warning");
                    }
                },

                async executeKashTimeline() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("The article is empty. Add some content to create a timeline from.", "warning");
                        return;
                    }

                    const articleContent = contentDiv.innerText;
                    const toastId = App.ui.showToast('ðŸ¤– AI is synthesizing your timeline...', { type: 'info', duration: 0 });

                    const systemPrompt = `You are 'Kash, the Chronicler,' an expert AI historian and Data Visualizer and TimeLine Maker. Your mission is to analyze an article and extract the most important information as a structured list of timeline events.

                        **Your Core Directive:**
                        1.  **Act as an Expert:** Use your own knowledge as a subject matter expert on the topic to understand the key sequence of events, concepts, or stages within the user's [Article Content].
                        2.  **Extract Data:** Identify the 5-16 most critical points and extract the data for each point into a pair of values: a "date" and a "title".
                            * The "date" can be an actual date (e.g., "1978"), a concept (e.g., "Article 20"), or a stage (e.g., "Step 1"). So Date changes according to Article content and use your Creativity to break Article down into Steps (which can be anything from Articles in polity to Questions). "Date" could be questionslike "why","who","when","how" etc. 
                            * The "title" is the description of the event or concept or explanation or example or detail etc..
                            * So you can be creative to embedd the most rigid information in the form of structured Timeline. Innovation is key to success and you have to innovate if content doesnt follow any structure, to put it in structure , use your all ability and knowledge to make a revision timeline.

                        **Strict Output Format (CRITICAL):**
                        Your entire response MUST be a single, valid JSON array of objects. Each object must have exactly two keys: "date" (which can even not be a date got it?) and "title".

                        **Example Response:**
                        [ {"date": "1978", "title": "The landmark Maneka Gandhi vs. Union of India case significantly broadened the scope of Article 21."},
                        {"date": "Article 20", "title": "Provides safeguards against arbitrary and excessive punishment, including protections against ex post facto laws, double jeopardy, and self-incrimination."},
                        {"date": "Article 21", "title": "Guarantees the protection of life and personal liberty, which the Supreme Court has interpreted to include the right to live with dignity and privacy."},
                        {"date": "What is life", "title":"Biology is the scientific study of life and living organisms, encompassing their structure, function, growth, origin, evolution, and distribution"}, 
                        ]`;
                            
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, articleContent);
                    App.ui.hideToast(toastId);

                    if (result && result.trim()) {
                        try {
                            // Find the JSON array within the AI's response
                            const jsonMatch = result.match(/\[\s*\{[\s\S]*?\}\s*\]/s);
                            if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");

                            const timelineData = JSON.parse(jsonMatch[0]);
                            if (!Array.isArray(timelineData) || timelineData.length === 0) {
                                throw new Error("AI did not return any timeline entries.");
                            }

                            const timelineEntriesHTML = timelineData.map(entry => {
                                if (!entry.date || !entry.title) return ''; // Skip invalid entries
                                const cleanDate = App.util.escapeHtml(entry.date);
                                const cleanTitle = App.util.escapeHtml(entry.title);
                                return `
                                    <div class="nk-timeline-entry">
                                        <div class="nk-timeline-content">
                                            <div class="nk-timeline-date" contenteditable="true">${cleanDate}</div>
                                            <div class="nk-timeline-title" contenteditable="true">${cleanTitle}</div>
                                        </div>
                                    </div>
                                `;
                            }).join('');

                            if (!timelineEntriesHTML) throw new Error("Generated timeline data was empty or invalid.");

                            const separatorHtml = `<hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                                            <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                                â³ NoteKash AI Timeline âœ¨
                                            </div>`;

                            const finalTimelineHtml = `
                                <div class="nk-timeline-block" contenteditable="false">
                                    ${timelineEntriesHTML}
                                </div>`;
                            

                            contentDiv.insertAdjacentHTML('beforeend', separatorHtml + finalTimelineHtml + '<p><br></p>');

                            const newTimeline = contentDiv.querySelector('.nk-timeline-block:last-of-type');
                            if (newTimeline) {
                                newTimeline.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }

                            App.ui.showToast("AI-generated timeline inserted!", 'success');
                            App.state.isArticleDirty = true;

                        } catch (error) {
                            App.ui.showToast("AI could not generate a valid timeline from the text.", "warning");
                            console.error("Timeline Generation Failed:", error, "AI Response:", result);
                        }
                    } else {
                        App.ui.showToast("AI returned an empty response.", "warning");
                    }
                },

                async executeKashOutline(topic) {
                    if (!topic) {
                        App.ui.showToast("Please provide a topic for the outline.", "warning");
                        return;
                    }

                    const systemPrompt = "You are an expert academic planner with expertise in given Topic. Generate a structured and hierarchical outline for the given Topic. The outline should be detailed, with main points and several sub-points for each. Use nested HTML unordered lists (<ul> and <li>). Respond ONLY with the complete HTML list structure, without any surrounding text or markdown fences.";
                    
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, topic);

                    if (result && result.trim().startsWith('<ul>')) {
                        const outlineHtml = result.trim() + '<p><br></p>';
                        document.execCommand('insertHTML', false, outlineHtml);
                        App.ui.showToast(`Outline for "${topic}" generated!`, 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("AI could not generate an outline for this topic.", "warning");
                    }
                },

                async executeKashExpand() {
                    const selection = window.getSelection();
                    if (!selection || selection.rangeCount === 0) {
                        App.ui.showToast("Place your cursor where you want the AI to continue writing.", "warning");
                        return;
                    }

                    const range = selection.getRangeAt(0);
                    const container = range.startContainer;

                    // Find the parent block element (p, li, h1, etc.) to get the full context. This part remains the same.
                    const parentBlock = (container.nodeType === 3 ? container.parentElement : container).closest('p, li, h1, h2, h3, h4, h5, h6, blockquote, div');

                    if (!parentBlock || !document.getElementById('article-content').contains(parentBlock)) {
                        App.ui.showToast("AI can only continue writing within a text block.", "warning");
                        return;
                    }
                    
                    const contextRange = document.createRange();
                    contextRange.setStart(parentBlock, 0);
                    contextRange.setEnd(range.startContainer, range.startOffset);
                    const contextText = contextRange.toString();
                   

                    if (contextText.trim() === '') {
                        App.ui.showToast("There isn't enough context for the AI to continue. Please write something first.", "warning");
                        return;
                    }
                    
                    const systemPrompt = `You are an intelligent writing assistant who completely understands and has expertise in subject matter the user is writing about. The user has provided text they have written so far. Your task is to seamlessly continue writing from where they left off.
                    - If the user stopped mid-sentence, complete that sentence naturally and then write 3 more related sentences.
                    - If the user stopped at the end of a sentence, write 4 new sentences that logically follow.
                    - Maintain the original tone, style, and topic of the provided text.
                    - Respond ONLY with the newly generated text. Do not repeat the user's original text in your response.`;
                    
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, contextText);

                    if (result && result.trim()) {
                        const generatedText = " " + result.trim();
                        
                        // Use the original live range to insert the AI's response at the cursor
                        range.insertNode(document.createTextNode(generatedText));
                    
                        range.setStartAfter(range.endContainer);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);

                        App.ui.showToast("AI continued writing!", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("The AI couldn't think of what to write next. Please try again.", "warning");
                    }
                },
                async executeKashQuote() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Your note is empty. Add some content for the AI to analyze.", "warning");
                        return;
                    }
                    const userPrompt = contentDiv.innerText;

                    const systemPrompt = `You are 'Kash, the Quote Master,' an AI expert with the combined knowledge of a historian, a philosopher, and a literary scholar. Your sole purpose is to analyze a user's text and find the single most insightful and contextually relevant quote to enhance their writing. You must adhere to a strict process and output format.

                        **Your Thought Process (Follow these steps internally):**

                        1.  **Thematic Distillation:** First, read the entire article content to distill its core theme, central argument, and overall tone. Are you reading a critical analysis of a government policy, a philosophical reflection on learning, or a historical account of an event?

                        2.  **Conceptual Extraction:** Second, based on the theme, identify 3-5 key concepts, nouns, or abstract ideas that are central to the text (e.g., 'judicial independence', 'bureaucracy', 'economic reform', 'the nature of memory', 'creative struggle').

                        3.  **Intelligent Search & Selection:** Third, search your vast internal library of quotations. Your goal is to find a quote that doesn't just match a keyword, but one that **resonates with the underlying argument, tension, or situation** described in the text.
                            * **Prioritize insight over fame:** A lesser-known but perfectly relevant quote is far better than a famous but generic one.
                            * The best quote is one that offers a profound summary, a sharp counterpoint, a piece of timeless wisdom, or a witty perspective on the article's specific theme.

                        **Strict Output Format:**

                        After completing your internal thought process, you MUST respond ONLY with a single, valid JSON object containing the quote and the author.

                        * The JSON object must have two keys: "quote" and "author".
                        * Do NOT include any explanations, greetings, conversational text, or markdown formatting. Your entire response must be just the JSON object.

                        **Example Response Format:**
                        {"quote": "The art of writing is the art of discovering what you believe.", "author": "Gustave Flaubert"}`;

                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, userPrompt);

                    if (result && result.trim()) {
                        try {
                            const jsonMatch = result.match(/\{\s*"quote"[\s\S]*?\}/s);
                            if (!jsonMatch) throw new Error("AI response did not contain a valid JSON object.");

                            const parsedQuote = JSON.parse(jsonMatch[0]);

                            if (!parsedQuote.quote || !parsedQuote.author) {
                                throw new Error("JSON response is missing 'quote' or 'author' key.");
                            }
                            const quoteHtml = `
                                <blockquote contenteditable="false" style="margin: 1.5em 0; border-left: 3px solid var(--primary-color); padding-left: 1.5em; font-style: italic;">
                                    <p style="font-size: 1.1em; line-height: 1.6;">${App.util.escapeHtml(parsedQuote.quote)}</p>
                                    <footer style="text-align: right; font-size: 1em; font-style: normal; color: var(--text-secondary); margin-top: 0.5em;">â€” ${App.util.escapeHtml(parsedQuote.author)}</footer>
                                </blockquote>`;
                            
                            App.util.insertGuardianBlock(quoteHtml); // Use our helper for clean insertion
                            App.ui.showToast("Contextual quote inserted!", 'success');
                            App.state.isArticleDirty = true;

                        } catch (error) {
                            console.error("KashQuote Error:", error, "AI Response:", result);
                            App.ui.showToast("AI returned an invalid format for the quote.", "error");
                        }
                    } else {
                        App.ui.showToast("The AI couldn't find a suitable quote. Please try again.", "warning");
                    }
                },

                async executeKashExtract(subCommand) {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Your note is empty. Add some content for the AI to analyze.", "warning");
                        return;
                    }
                    const articleContent = contentDiv.innerText;

                    const systemPrompt = `You are 'KashExtractor', a hyper-intelligent research assistant embedded within the NoteKash app. Your entire universe of knowledge is strictly limited to the user-provided 'Article Content'. You will be given a [Sub-command] and the [Article Content]. Your task is to follow the logic below precisely and respond ONLY with a single, complete HTML block.

                        **Core Logic Flow:**

                        1.  **IF the [Sub-command] is 'default', empty, or just whitespace:**
                            * Provide a single, dense paragraph that summarizes the core thesis and main points of the article.
                            * **HTML Output:** Wrap this summary in \`<p>...\</p>\`.

                        2.  **ELSE IF the [Sub-command] is a structured request ('dates', 'names', 'stats', 'acronyms', 'laws', 'arguments'):**
                            * Scour the [Article Content] for the requested data type.
                            * For each item found, provide a brief, context-aware description based **only** on the information present in the article.
                            * **HTML Output:** Format the entire response as a single HTML unordered list \`<ul>\`. Each item must be \`<li><b>[Extracted Item]:</b> [Contextual description from article]</li>\`.

                        3.  **ELSE (treat any other [Sub-command] as a Natural Language Query):**
                            * This is your most important task. Follow this two-step process meticulously:
                            * **Step A: Internal Search.** First, you MUST scour the [Article Content] to find a direct answer to the user's query.
                            * **Step B: Formulate Response.**
                                * **If an answer is found:** Your response MUST begin with the exact phrase "<strong>From the Article: </strong>". Then, provide the answer, quoting the relevant part if possible.
                                * **If NO answer is found:** Your response MUST begin with the exact phrase "<strong>Not in Article: </strong>". Put this in braces. Then, you may use your general knowledge to provide a brief answer, prefacing it with "However, according to reliable sources...".
                            * **HTML Output:** Format your response as a simple \`<p>...\</p>\` or \`<blockquote>...</blockquote>\`.

                        **CRITICAL FINAL RULES:**
                        * Your ENTIRE response must be ONLY the generated HTML content.
                        * Do NOT include \`\`\`html\` or any other markdown fences.
                        * Do NOT include any conversational text, greetings, or explanations outside of the required HTML.
                        * If the article is empty or irrelevant to the query, simply respond with \`<p>The article does not contain enough information to answer this query.</p>\`.`;

                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, `[Sub-command]: ${subCommand}\n\n[Article Content]:\n${articleContent}`);

                    if (result && result.trim()) {
                        const cleanedHtml = result.trim().replace(/^```(html)?\n?/, '').replace(/\n?```$/, '');

                        const titleText = subCommand === 'default' ? 'Article Summary' : `Extraction: "${subCommand}"`;

                        const finalHtml = `
                            <div class="nk-text-tile color-ghost-2" contenteditable="true" data-color="ghost-2">
                                <div class="nk-text-tile-content" contenteditable="true" style="white-space: normal;">
                                    <h4 style="margin-top: 0; font-weight: 600;" contenteditable="false">${App.util.escapeHtml(titleText)}</h4>
                                    ${cleanedHtml}
                                </div>
                            </div>`;
                        
                        App.util.insertGuardianBlock(finalHtml);
                        App.ui.showToast("Extraction complete!", 'success');
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("The AI could not extract the requested information.", "warning");
                    }
                },

                async executeKashLink(topic) {
                    if (!topic) {
                        App.ui.showToast("Please provide a topic to create and link.", "warning");
                        return;
                    }

                    const contentDiv = document.getElementById('article-content');
                    const existingNoteContext = (contentDiv && contentDiv.textContent.trim()) 
                        ? contentDiv.innerText 
                        : "The user's current note is empty.";

                    const generationToast = App.ui.showToast(`ðŸ¤– AI is writing about "${topic}"...`, { type: 'info', duration: 0 });
    
                    const generationPrompt = `You are a distinguished academic writer and subject matter expert. Your goal is to create a new, linked note for the user that is contextually aware of what they are already writing. Your new written note should be factually accurate and reliable.

                        **You will be given two inputs:**
                        1.  **[Existing Note Context]:** The text from the note the user is currently writing.
                        2.  **[New Note Topic]:** The topic for the new note, which may include specific instructions.

                        **Your Primary Directive (A 3-Step Process):**

                        1.  **Analyze Context:** First, carefully read the [Existing Note Context] to understand its main theme, arguments, and the specific facts already mentioned.

                        2.  **Analyze Intent:** Second, analyze the [New Note Topic] string.
                            * **If it contains specific instructions** (e.g., 'create a table', 'list key points', 'short 2 tables on...'): Fulfill that request precisely and concisely. Your output should be exactly what the user asked for. For example, if the topic is "a short table on the Mauryan Kings," you MUST generate only a short HTML table and nothing else Similarly if user Request is "Long Table on Gupta Kings", you must generate a most exaustive and detailed table on all Gupta Kings.
                            * **If it's a general topic** (e.g., "The Ashokan Empire"): You will default to generating a comprehensive, well-structured introductory article. This default article MUST follow this structure:
                                1.  **Introduction:** A concise introductory paragraph most relevant to topic and have catchy words to attract users attention (hooks etc.).
                                2.  **Key Sections:** 2 to 5 distinct sections with \`<h2>\` catchy headings. Under those headings comprehsive content well-formatted.
                                3.  **Conclusion:** A summary paragraph for key-takeaways from content which you wrote.

                        3.  **Generate Context-Aware Content:** This is your most important task. When generating the content for the new note:
                            * **Tailor Relevance:** Focus on aspects of the [New Note Topic] that directly relate to or expand upon the [Existing Note Context].
                            * **DO NOT REPEAT:** You MUST AVOID repeating facts, definitions, or specific data points that are already present in the [Existing Note Context]. Your goal is to provide new, complementary information.

                        **Content & Formatting Rules (Apply to ALL responses):**
                        * Prioritize factual accuracy and reliability above everything else.
                        * Use a Neutral, Objective, Unbiased and Academic tone.
                        * Use clean HTML. Bold key terms with \`<b>\`. Use \`<ul>\` for lists and \`<table>\` for tables where appropriate (short tables should be used more often when possible, since they are good for presentation of content and revision).
                        * Respond ONLY with the required HTML content. Do NOT include \`<html>\`, \`<body>\`, markdown fences, or any conversational text.`;
                            
                    const userPrompt = `[Existing Note Context]:\n${existingNoteContext}\n\n---\n\n[New Note Topic]:\n${topic}`;
                    const generatedContent = await App.services.ai.queryGenerativeAI(generationPrompt, userPrompt);

                    if (!generatedContent || !generatedContent.trim()) {
                        App.ui.hideToast(generationToast);
                        App.ui.showToast(`AI failed to generate content for "${topic}".`, "error");
                        return;
                    }
                    
                    App.ui.updateToast(generationToast, `ðŸ§  AI is categorizing the new note...`);
                    const userCategoryNames = App.settings.get('userCategories').map(c => c.name);
                    const categorizationPrompt = `You are an expert librarian AI. Your task is to categorize a given text into one of the following user-provided categories. Analyze the text and respond with ONLY the single most appropriate category name from the list.

                **Available Categories:**
                ${userCategoryNames.join(', ')}`;

                    const suggestedCategory = await App.services.ai.queryGenerativeAI(categorizationPrompt, generatedContent);
                    const finalCategory = (suggestedCategory && userCategoryNames.includes(suggestedCategory.trim())) 
                        ? suggestedCategory.trim() 
                        : (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;

                    App.ui.updateToast(generationToast, `ðŸ’¾ Saving new note...`);
                    const newNoteTitle = topic.length > 100 ? topic.substring(0, 100) + '...' : topic;
                    const noteData = { title: newNoteTitle, content: generatedContent, category: finalCategory };
                    const newNote = await App.storage.createArticle(noteData);

                    if (!newNote) {
                        App.ui.hideToast(generationToast);
                        App.ui.showToast(`Failed to save the new note for "${topic}".`, "error");
                        return;
                    }

                    const linkHtml = `<a href="#" data-link-type="article" data-link-id="${newNote.id}">${App.util.escapeHtml(newNoteTitle)}</a>&nbsp;`;
                    
                    App.util.restoreSelection();
                    document.execCommand('insertHTML', false, linkHtml);
                    App.state.isArticleDirty = true;
                    
                    App.ui.hideToast(generationToast);
                    App.ui.showToast(`Created and linked new note: "${newNoteTitle}"!`, "success");
                },


                async executeKashSplit() {
                    const contentDiv = document.getElementById('article-content');
                    const originalArticle = App.storage.getArticle(App.state.activeArticleId);

                    if (!contentDiv || !originalArticle || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Cannot split an empty or unsaved note.", "warning");
                        return;
                    }
                    const originalContent = contentDiv.innerHTML;

                    const splitToast = App.ui.showToast('ðŸ¤– AI is analyzing the best way to split your note...', { type: 'info', duration: 0 });

                    const splitPrompt = `You are an expert AI editor and content strategist named 'KashSplit'. Your sole purpose is to intelligently split a single long article into two shorter, thematically coherent, and self-contained notes.

                        **Your 4-Step Thought Process (Follow these steps internally):**

                        1.  **Full Comprehension:** First, read and fully comprehend the entire [Article Content] to understand its main narrative, key arguments, and overall structure.

                        2.  **Identify the Breakpoint:** Second, identify the single most logical and natural breakpoint in the article. This could be a transition between major topics, a chronological shift, or a move from a foundational concept to its applications. Do not simply split in the middle.

                        3.  **Rewrite & Refactor (Most Important Step):** Third, rewrite the content into two distinct parts.
                            * **Part 1:** This part must be a complete note. If you've split in the middle of a section, you MUST write a proper concluding sentence or paragraph for it.
                            * **Part 2:** This part must also be a complete note. You MUST write a proper introductory sentence or paragraph to provide context, as it will become a new, standalone note.
                            * **Preserve Everything:** You must not lose any facts, data, or key information from the original article. All content must be retained and correctly placed in either Part 1 or Part 2.
                            * **Strucute & Beautify:** While Refactoring content you can use <b>, <i>, and other formatting tools to beautify the content. Also CRITICALLY use TABLES for presentation and Revision, wherever possible.

                        4.  **Generate a New Title:** Fourth, create a new, concise, and descriptive title for the second part of the content. This title should accurately reflect the main topic of the new note.

                        **Strict Output Format (CRITICAL):**
                        Your response MUST be a single, valid JSON object. Do NOT include any other text, markdown, or explanations. The JSON object must have three keys:
                        1.  \`part1_html\`: A string containing the full, rewritten HTML content for the first note.
                        2.  \`part2_title\`: A string containing the new title for the second note.
                        3.  \`part2_html\`: A string containing the full, rewritten HTML content for the new, second note.`;

                    const result = await App.services.ai.queryGenerativeAI(splitPrompt, originalContent);

                    if (!result || !result.trim()) {
                        App.ui.hideToast(splitToast);
                        App.ui.showToast("AI could not split the note. Please try again.", "error");
                        return;
                    }

                    try {
                        const jsonMatch = result.match(/\{\s*"part1_html"[\s\S]*?\}/s);
                        if (!jsonMatch) throw new Error("AI response did not contain a valid JSON object.");
                        const splitData = JSON.parse(jsonMatch[0]);

                        if (!splitData.part1_html || !splitData.part2_title || !splitData.part2_html) {
                            throw new Error("JSON response is missing required keys.");
                        }

                        App.ui.updateToast(splitToast, `ðŸ’¾ Creating new note: "${splitData.part2_title}"...`);

                        // Create the second note
                        const newNote = await App.storage.createArticle({
                            title: splitData.part2_title,
                            content: splitData.part2_html,
                            category: originalArticle.category
                        });

                        if (!newNote) throw new Error("Failed to save the new split note.");

                        const linkHtml = `<p><br></p><blockquote><p><em>Continued in: <a href="#" data-link-type="article" data-link-id="${newNote.id}">${App.util.escapeHtml(newNote.title)}</a></em></p></blockquote>`;

                        const finalContentPart1 = splitData.part1_html + linkHtml;
                        const updateResult = await App.storage.updateArticle(originalArticle.id, {
                            title: originalArticle.title, // Keep original title
                            content: finalContentPart1
                        });
                        
                        if (!updateResult.success) throw new Error("Failed to update the original note.");

                        App.ui.hideToast(splitToast);
                        App.ui.showToast("Note split successfully!", "success");
                        App.router.navigateTo('article', { id: originalArticle.id, mode: 'write' });


                    } catch (error) {
                        console.error("KashSplit Error:", error, "AI Response:", result);
                        App.ui.hideToast(splitToast);
                        App.ui.showToast("AI returned an invalid format. Could not split note.", "error");
                    }
                },

                async executeKashMcqGenerator() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Your note is empty. Add some content first!", "warning");
                        return;
                    }

                    const toastId = App.ui.showToast('ðŸ¤– AI is crafting your questions...', { type: 'info', duration: 0 });
                    const articleContent = contentDiv.innerText;

                    const systemPrompt = `You are an expert educator and quiz designer integrated into the NoteKash app. Your task is to analyze the provided [Article Content] and, by synthesizing it with your own expert knowledge, create a set of 3 to 8 high-quality Multiple-Choice Questions (MCQs).

                    **Core Directives:**
                    1.  The questions must test deep comprehension of the material, not just surface-level facts.
                    2.  You must create plausible distractors (incorrect options) that are related to the topic but clearly wrong.
                    3.  Each question must have exactly one correct answer.
                    4.  The content should be a mix of information directly from the text and related concepts from your own knowledge base.

                    **Randomization Rule (CRITICAL):**
                    You MUST randomly distribute the position of the correct answer. The \`correct_index\` should have an equal chance of being 0, 1, 2, or 3. Do not favor any specific position.

                    **CRITICAL OUTPUT FORMAT:**
                    Your ENTIRE response MUST be a single, valid JSON array of objects. Do NOT include any other text, markdown, or explanations.
                    Each object in the array represents one MCQ and MUST have three keys:
                    1.  "question": A string containing the question text.
                    2.  "options": An array of 4 strings representing the choices.
                    3.  "correct_index": A number (0-based index) indicating which option in the "options" array is the correct one.

                    **Example JSON Response:**
                    [
                      {
                        "question": "According to the DPSP, what is the State's primary goal in India?",
                        "options": [
                          "To establish a military superpower.",
                          "To create a 'Welfare State' promoting social and economic justice.",
                          "To enforce Fundamental Rights exclusively.",
                          "To remain neutral in all social and economic matters."
                        ],
                        "correct_index": 1
                      }
                    ]`;
                    
                    try {
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, articleContent);
                        App.ui.hideToast(toastId);

                        if (!result || !result.trim()) {
                            throw new Error("AI returned an empty response.");
                        }

                        const jsonMatch = result.match(/\`\`\`json\s*([\s\S]*?)\s*\`\`\`|(\[[\s\S]*\])/);
                        if (!jsonMatch) throw new Error("AI response did not contain a valid JSON array.");
                        
                        const mcqs = JSON.parse(jsonMatch[1] || jsonMatch[2]);
                        if (!Array.isArray(mcqs) || mcqs.length === 0) {
                            throw new Error("Parsed data is not a valid array of MCQs.");
                        }

                        const mcqBlocksHTML = mcqs.map(mcq => {
                            if (!mcq.question || !mcq.options || mcq.correct_index === undefined) return '';

                            const optionsHTML = mcq.options.map((option, index) => {
                                const isCorrect = index === mcq.correct_index;
                                return `
                                    <div class="nk-mcq-option" data-is-correct="${isCorrect}">
                                        <div class="nk-mcq-option-radio"></div>
                                        <div class="nk-mcq-option-text" contenteditable="true">${App.util.escapeHtml(option)}</div>
                                        <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                                    </div>
                                `;
                            }).join('');

                            return `
                                <div class="nk-mcq-block" contenteditable="false">
                                    <div class="nk-mcq-question" contenteditable="true">${App.util.escapeHtml(mcq.question)}</div>
                                    <div class="nk-mcq-options">${optionsHTML}</div>
                                    <button class="btn btn-secondary nk-mcq-add-option">+ Add Option</button>
                                    <div class="nk-mcq-explanation" contenteditable="true" data-placeholder="Add answer explanation (optional)..."></div>
                                </div>`;
                        }).join('');

                        if (!mcqBlocksHTML.trim()) {
                            throw new Error("Failed to generate HTML from AI response.");
                        }
                        
                        const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                            <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                ðŸ§  AI Generated MCQs âœ¨
                            </div>`;

                        contentDiv.insertAdjacentHTML('beforeend', separatorHtml + mcqBlocksHTML + '<p><br></p>');
                        App.ui.showToast(`${mcqs.length} MCQs generated!`, 'success');
                        App.state.isArticleDirty = true;
                        
                        // Scroll to the new content
                        const finalElement = contentDiv.lastElementChild;
                        if (finalElement) {
                            finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }

                    } catch (error) {
                        App.ui.hideToast(toastId);
                        App.ui.showToast(`AI failed: ${error.message}`, "error");
                        console.error("KashMCQ Generation Error:", error);
                    }
                },

                async executeKashTemplate(templateRequest) {
                    App.ui.closeModal(); // Close the Template Hub
                    const toastId = App.ui.showToast('ðŸ“„ Generating template...', { type: 'info', duration: 0 });
                    
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv) {
                        App.ui.hideToast(toastId);
                        App.ui.showToast("Please open a note first.", "error");
                        return;
                    }

                    const preDefinedTemplates = {
                        'cornell-notes': `
                            <table style="width:100%; border-collapse: collapse; border: 1px solid var(--border-color); border-radius: var(--border-radius); overflow: hidden;">
                                <thead style="background-color: var(--bg-tertiary);">
                                    <tr>
                                        <th style="width: 70%; padding: 1rem; text-align: left;">Main Notes</th>
                                        <th style="width: 30%; padding: 1rem; text-align: left; border-left: 1px solid var(--border-color);">Cues & Questions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td style="padding: 1rem; border-right: 1px solid var(--border-color); vertical-align: top; height: 300px;" data-placeholder="Capture your notes during the lecture or meeting here..."><p><br></p></td>
                                        <td style="padding: 1rem; vertical-align: top;" data-placeholder="After, pull out key terms, questions, or main ideas here..."><p><br></p></td>
                                    </tr>
                                    <tr style="background-color: var(--bg-tertiary);">
                                        <td colspan="2" style="padding: 1rem; border-top: 1px solid var(--border-color); vertical-align: top;" data-placeholder="Finally, write a 1-2 sentence summary of the entire page..."><p><b>Summary:</b> </p></td>
                                    </tr>
                                </tbody>
                            </table>`,
                        'swot-analysis': `<h2>SWOT Analysis</h2><div class="nk-textile-deck" contenteditable="false"><div class="nk-text-tile color-10"><div class="nk-text-tile-content" contenteditable="true"><b>Strengths:</b> What do we do well internally?</div></div><div class="nk-text-tile color-4"><div class="nk-text-tile-content" contenteditable="true"><b>Weaknesses:</b> Where can we improve internally?</div></div><div class="nk-text-tile color-2"><div class="nk-text-tile-content" contenteditable="true"><b>Opportunities:</b> What are the external chances to grow?</div></div><div class="nk-text-tile color-8"><div class="nk-text-tile-content" contenteditable="true"><b>Threats:</b> What external factors could harm us?</div></div></div>`,
                        'meeting-agenda': `<h2>Meeting Agenda</h2><div class="nk-text-tile color-7"><div class="nk-text-tile-content"><b>Date:</b> ${new Date().toLocaleDateString()}</div></div><div class="nk-text-tile color-7"><div class="nk-text-tile-content"><b>Attendees:</b> </div></div><hr><h3>Topics for Discussion:</h3><div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text">Topic 1...</span></div><div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text">Topic 2...</span></div><h3>Action Items:</h3><ul><li><br></li></ul>`,
                        'daily-planner': `<h2>Daily Plan: ${new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}</h2><div class="nk-text-tile color-ghost-1"><div class="nk-text-tile-content"><b>Top Priority for Today:</b> </div></div><h3>To-Do List:</h3><div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text">Task 1...</span></div><div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text">Task 2...</span></div><div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text">Task 3...</span></div><h3>Notes:</h3><p><br></p>`,
                        'smart-goals': `<h2>SMART Goal Setting</h2><div class="nk-text-tile color-ghost-1"><div class="nk-text-tile-content"><b>Goal:</b> </div></div><hr><div class="nk-accordion" data-state="open"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>(S)pecific</b></span></div><div class="nk-accordion-content" data-placeholder="What exactly do I want to achieve?"><p><br></p></div></div><div class="nk-accordion" data-state="closed"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>(M)easurable</b></span></div><div class="nk-accordion-content" data-placeholder="How will I know when I have achieved it?"><p><br></p></div></div><div class="nk-accordion" data-state="closed"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>(A)chievable</b></span></div><div class="nk-accordion-content" data-placeholder="Is this goal realistic with my current resources?"><p><br></p></div></div><div class="nk-accordion" data-state="closed"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>(R)elevant</b></span></div><div class="nk-accordion-content" data-placeholder="Why is this goal important to me right now?"><p><br></p></div></div><div class="nk-accordion" data-state="closed"><div class="nk-accordion-trigger"><span class="nk-accordion-title"><b>(T)ime-bound</b></span></div><div class="nk-accordion-content" data-placeholder="What is the deadline for this goal?"><p><br></p></div></div>`,
                        'kwl-chart': `<h2>KWL Chart</h2><table style="width:100%;"><thead><tr><th>What I Know</th><th>What I Want to Know</th><th>What I Learned</th></tr></thead><tbody><tr><td data-placeholder="List prior knowledge..."><p><br></p></td><td data-placeholder="List questions..."><p><br></p></td><td data-placeholder="List new learnings..."><p><br></p></td></tr></tbody></table>`,
                        'pros-cons': `<h2>Pros & Cons: Decision Matrix</h2><div class="nk-text-tile color-7"><div class="nk-text-tile-content"><b>Decision to make:</b> </div></div><table style="width:100%;"><thead><tr><th style="background-color: color-mix(in srgb, var(--success-color) 10%, transparent);">Pros (Arguments For)</th><th style="background-color: color-mix(in srgb, var(--danger-color) 10%, transparent);">Cons (Arguments Against)</th></tr></thead><tbody><tr><td data-placeholder="List advantages..."><p><br></p></td><td data-placeholder="List disadvantages..."><p><br></p></td></tr></tbody></table>`,
                        'content-planner': `<h2>Content Planner</h2><div class="nk-textile-deck layout-stack" contenteditable="false"><div class="nk-text-tile color-5"><div class="nk-text-tile-content" contenteditable="true"><b>Ideas ðŸ’¡:</b> </div></div><div class="nk-text-tile color-6"><div class="nk-text-tile-content" contenteditable="true"><b>In Progress âœï¸:</b> </div></div><div class="nk-text-tile color-10"><div class="nk-text-tile-content" contenteditable="true"><b>Published âœ…:</b> </div></div></div>`,
                        
                        // --- NEW BEAUTIFUL VOCAB CARD ---
                        'vocab-card': `
                            <div class="nk-text-tile color-ghost-1" data-color="ghost-1" style="display: block; width: 100%;">
                                <div class="nk-text-tile-content" style="width: 100%;">
                                    <h2 contenteditable="true" style="margin-top:0; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem;" data-placeholder="Enter Word..."></h2>
                                    <p><b>Meaning:</b></p>
                                    <blockquote contenteditable="true" data-placeholder="Enter the definition here..."><p><br></p></blockquote>
                                    <p><b>Example Sentence:</b></p>
                                    <blockquote contenteditable="true" data-placeholder="Use the word in a sentence..."><p><br></p></blockquote>
                                    <table style="width:100%; margin-top: 1rem;">
                                        <thead style="background-color: var(--bg-tertiary);">
                                            <tr>
                                                <th style="width:50%; text-align: left; padding: 0.5rem 1rem;">Synonyms</th>
                                                <th style="width:50%; text-align: left; padding: 0.5rem 1rem; border-left: 1px solid var(--border-color);">Antonyms</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td style="vertical-align: top; padding: 0.5rem 1rem;" data-placeholder="List synonyms..."><ul style="padding-left: 20px; margin-top: 0;"><li><br></li></ul></td>
                                                <td style="vertical-align: top; padding: 0.5rem 1rem; border-left: 1px solid var(--border-color);" data-placeholder="List antonyms..."><ul style="padding-left: 20px; margin-top: 0;"><li><br></li></ul></td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>`,
                        'upsc-analysis': `<h2>Current Affairs Analysis</h2><div class="nk-textile-deck" contenteditable="false"><div class="nk-text-tile color-2"><div class="nk-text-tile-content" contenteditable="true"><b>Date:</b> ${new Date().toLocaleDateString()}</div></div><div class="nk-text-tile color-5"><div class="nk-text-tile-content" contenteditable="true"><b>Source:</b> The Hindu</div></div><div class="nk-text-tile color-9"><div class="nk-text-tile-content" contenteditable="true"><b>GS Paper:</b> GS-2</div></div></div><h3>Summary of the Issue</h3><blockquote data-placeholder="Write a concise summary of the news article or topic..."><p><br></p></blockquote><hr><h3>Analysis Matrix</h3><table style="width:100%;"><thead><tr><th>Key Arguments / Facts</th><th>Counterarguments / Nuances</th></tr></thead><tbody><tr><td data-placeholder="List the main points, data, and arguments presented..."><p><br></p></td><td data-placeholder="List opposing views, limitations, or alternative perspectives..."><p><br></p></td></tr></tbody></table><h3>Linkages with Static Syllabus</h3><ul data-placeholder="Connect this topic to the core UPSC syllabus..."><li><br></li></ul><h3>Practice Question</h3><blockquote data-placeholder="Formulate a Mains-style practice question based on this topic..."><p><br></p></blockquote>`
                    };

                    let templateHTML = '';

                    if (preDefinedTemplates[templateRequest]) {
                        templateHTML = preDefinedTemplates[templateRequest];
                    } else {
                        // This is a custom AI request, now locked for free users.
                        const systemPrompt = `You are a master productivity expert and document designer named 'KashTemplate'. Your purpose is to translate a user's request into a beautifully structured and aesthetically pleasing note template using NoteKash's native HTML components.

                        **CRITICAL RULES:**
                        1.  You MUST use ONLY the components listed in the 'Component Toolkit' below.
                        2.  You MUST NOT use form elements like \`<input>\`, \`<textarea>\`, or \`<label>\`. The entire template must be editable. Use stylized \`<div>\`s or table cells with placeholder text inside.
                        3.  Your response MUST BE ONLY the complete, clean HTML for the template. Do NOT include any other text, markdown, or explanations.

                        **Your Component Toolkit:**
                        * \`<table>\`: For structured data like schedules or comparison charts. Use \`<thead>\` and \`<th>\`.
                        * \`<div class="nk-textile-deck">\` with child \`<div class="nk-text-tile color-X">\`: For modular blocks of ideas. Use different colors (e.g., color-1 to color-10).
                        * \`<div class="nk-checkbox-wrapper">\`: For checklists and to-do lists.
                        * \`<div class="nk-accordion">\`: For Q&A sections or collapsible sections.
                        * Standard HTML: Use \`<h2>\`, \`<h3>\`, \`<blockquote>\`, \`<ul>\`, \`<hr>\` for clear hierarchy.

                        **Examples of Excellent NoteKash Templates (Learn From These):**

                        ---
                        **User Request:** "a swot analysis"
                        **Correct Output:**
                        \`\`\`html
                        <h2>SWOT Analysis</h2>
                        <div class="nk-textile-deck" contenteditable="false">
                            <div class="nk-text-tile color-10"><div class="nk-text-tile-content" contenteditable="true"><b>Strengths:</b></div></div>
                            <div class="nk-text-tile color-4"><div class="nk-text-tile-content" contenteditable="true"><b>Weaknesses:</b></div></div>
                            <div class="nk-text-tile color-2"><div class="nk-text-tile-content" contenteditable="true"><b>Opportunities:</b></div></div>
                            <div class="nk-text-tile color-8"><div class="nk-text-tile-content" contenteditable="true"><b>Threats:</b></div></div>
                        </div>
                        \`\`\`
                        ---
                        **User Request:** "a template for cornell notes"
                        **Correct Output:**
                        \`\`\`html
                        <table style="width:100%;">
                            <thead><tr><th>Main Notes</th><th>Cues & Questions</th></tr></thead>
                            <tbody>
                                <tr>
                                    <td data-placeholder="Capture notes..."><p><br></p></td>
                                    <td data-placeholder="Pull out key terms..."><p><br></p></td>
                                </tr>
                                <tr>
                                    <td colspan="2" data-placeholder="Write a summary..."><p><b>Summary:</b></p></td>
                                </tr>
                            </tbody>
                        </table>
                        \`\`\`
                        ---

                        **Your Task:** Now, generate a new template based on the user's latest request. Think visually and use a combination of components to create a template that is both functional and beautiful.`;
                        
                        try {
                            const result = await App.services.ai.queryGenerativeAI(systemPrompt, templateRequest);
                            if (!result || !result.trim()) throw new Error("AI returned an empty response.");
                            templateHTML = result;
                        } catch (error) {
                            App.ui.hideToast(toastId);
                            App.ui.showToast(`AI failed to generate template: ${error.message}`, "error");
                            return;
                        }
                    }

                    const separatorHtml = `<hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">`;
                    contentDiv.insertAdjacentHTML('beforeend', separatorHtml + templateHTML + '<p><br></p>');
                    
                    const finalElement = contentDiv.lastElementChild;
                    if (finalElement) {
                        finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }

                    App.ui.hideToast(toastId);
                    App.ui.showToast("Template inserted!", "success");
                    App.state.isArticleDirty = true;
                },

                async executeKashCraft() {
                    const contentDiv = document.getElementById('article-content');
                    if (!contentDiv || !contentDiv.textContent.trim()) {
                        App.ui.showToast("Your note is empty. Add some content to craft!", "warning");
                        return;
                    }

                    const toastId = App.ui.showToast('â›³ï¸ KashCraft AI is analyzing your note...', { type: 'info', duration: 0 });
                    const articleContent = contentDiv.innerText;

                    const baseTemplate = `
                        <h2>Topic Title (AI will generate this)</h2>
                        <div class="nk-textile-deck" contenteditable="false">
                            <div class="nk-text-tile color-5" data-color="5"><div class="nk-text-tile-content" contenteditable="true"><b>Source:</b> </div></div>
                            <div class="nk-text-tile color-9" data-color="9"><div class="nk-text-tile-content" contenteditable="true"><b>Relevance:</b> </div></div>
                        </div>
                        <h3>ðŸ“– Context & Key Takeaways</h3>
                        <ul data-placeholder="AI will generate a bulleted list summarizing the key points..."><li_witt_br></li></ul>
                        <hr>
                        <h3>ðŸ”¬ Deep Dive Analysis</h3>
                        <table style="width:100%;">
                            <thead>
                                <tr>
                                    <th style="background-color: color-mix(in srgb, var(--success-color) 10%, transparent);">Arguments For / Positives</th>
                                    <th style="background-color: color-mix(in srgb, var(--danger-color) 10%, transparent);">Challenges / Negatives</th>
                                </tr>
                            </thead>
                            <tbody><tr>
                                <td data-placeholder="List the main points, data, and arguments presented..."><p><br></p></td>
                                <td data-placeholder="List opposing views, limitations, or alternative perspectives..."><p><br></p></td>
                            </tr></tbody>
                        </table>
                        <h4>Way Forward:</h4>
                        <blockquote data-placeholder="AI will provide solution-oriented suggestions..."><p><br></p></blockquote>
                        <hr>
                        <h3>ðŸ”— Connections & Context</h3>
                        <table style="width:100%;">
                            <thead><tr><th style="width:30%;">Foundational Topic</th><th>Linkage/Relevance</th></tr></thead>
                            <tbody><tr>
                                <td data-placeholder="e.g., Judicial Review"><p><br></p></td>
                                <td data-placeholder="Explain how the current topic impacts the foundational topic..."><p><br></p></td>
                            </tr></tbody>
                        </table>
                        <hr>
                        <h3>âœï¸ Practice Questions</h3>
                        <h4>Objective Question:</h4>
                        <div class="nk-mcq-block" contenteditable="false">
                            <div class="nk-mcq-question" contenteditable="true">AI will generate a relevant objective-style MCQ here.</div>
                        </div>
                        <h4>Descriptive Question:</h4>
                        <blockquote data-placeholder="AI will generate a descriptive, analytical question here..."><p><br></p></blockquote>
                        <hr>
                        <h3>ðŸ”‘ Key Vocabulary</h3>
                        <div class="nk-textile-deck" contenteditable="false">
                            <div class="nk-text-tile color-7" data-color="7"><div class="nk-text-tile-content" contenteditable="true"><b>Term 1:</b> Definition...</div></div>
                        </div>
                        <hr>
                        <blockquote data-placeholder="AI will add a relevant, inspiring quote here..."></blockquote>
                    `;
                    
                    // --- NEW, FINAL SUPERCHARGED SYSTEM PROMPT ---
                    const systemPrompt = `You are an elite mentor and content strategist named 'KashCraft'. Your mission is to transform a raw user-provided article into a gold-standard, in-depth analysis notes that is perfect to study for competitive exam aspirants (like UPSC) but is also universally useful for any deep learner. Your output must be natural to read and visually impressive (while making sure text is clearly visible and contrasting with background/blocks).

                    **Your Thought Process (Follow these steps meticulously):**

                    1.  **Analyze & Identify:** Read the entire [Article Content]. Identify the core topic and keywords and its broader subject (e.g., Polity, Economy, Science & Tech). For exam aspirants, you must internally map this to a specific syllabus paper, but the output label should be generic (e.g., 'Relevance: Polity & Governance').

                    2.  **Generate Metadata:** Create a new, appropriate \`<h2>\` title. Fill in the metadata textiles: Source, and Relevance.

                    3.  **Create "Context & Key Takeaways":**
                        * This is the most important Task and step which you should treat with utmost care and should consume 75% of all time you will take in Framing craftedArticle, Act as Elite Subject matter expert and Filter all information from Article through the "UPSC lens". Create  a bulleted list (\`<ul>\`) summarizing only what is relevant for exam. You should Summarize in-depth, the most critical, exam-relevant facts, keywords or points (e.g constitutional articles, SC judgments, key data, govt. schemes, names of committes, data points etc.).
                        * **CRITICAL FLOW RULE:** Each \`<li>\` item MUST be a complete, flowing sentence. Do NOT use bolded prefixes or headings like 'Background:' or 'Significance:' within the bullet points. The list should read like a natural paragraph of distinct points with <b> used for important keywords/numbers/dates and <em> for emphasis.

                    4.  **Fill "Deep Dive Analysis":** Populate the two-column table with positives vs. negatives after you have complete analysis of main arguments/facts of artcile. Then, write a brief, solution-oriented "Way Forward" in the blockquote.

                    5.  **Fill "Connections & Context":** Identify 1-3 foundational topics and explain the linkage in form of short table. Use few words possible and make it short.

                    6.  **Generate Practice Questions:** Create most relevant two questions to article of which - one objective question (prelims oriented) (using an \`nk-mcq-block\` ) and one descriptive question (mains oriented) (in a \`<div class="nk-text-tile color-3">\`).

                    7.  **Generate "Key Vocabulary":**
                        * Identify 3-5 of the most important technical terms from the article.
                        * **CRITICAL FORMATTING RULE:** For each term, create a separate \`<div class="nk-text-tile color-7">\`. The content inside MUST be formatted as \`<b>Term:</b> Definition...\`. Do NOT number them as 'Term 1', 'Term 2', etc. Wrap all tiles in a single \`<div class="nk-textile-deck">\`.

                    8.  **Find a Relevant Quote:** Conclude the entire crafted note with an most relevant Quote related to the Article which you writing (with author name too), placed within a \`<blockquote>\`.

                    9.  **Creative Freedom:** The template is a strong starting point, but you are an expert and not restricted to it. It just provides you way forward how to write but you can form your own template according to needs of craftedArticle. If the content requires it, you MUST add new sections or delete a section or use different NoteKash components (\`<div class="nk-timeline-block">\`, etc.) to best structure the information.

                    **CRITICAL OUTPUT FORMAT:**
                    * Your response MUST be the complete, well-structured, and aesthetically pleasing HTML of the final crafted note.
                    * Respond ONLY with the HTML. Do NOT include any other text, markdown, or explanations.`;

                    try {
                        const result = await App.services.ai.queryGenerativeAI(systemPrompt, `[Article Content]:\n${articleContent}\n\n[Base Template Reference]:\n${baseTemplate}`);
                        App.ui.hideToast(toastId);

                        if (!result || !result.trim()) { throw new Error("AI returned an empty response."); }
                        
                        const separatorHtml = `
                            <hr style="border: none; border-top: 3px dashed var(--border-color); opacity: 0.6; width: 80%; margin: 2rem auto;">
                            <div style="text-align: center; font-family: var(--font-body); font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem;">
                                â›³ï¸ KashCraft AI Version âœ¨
                            </div>`;
                        
                        const finalHtml = `${result}`

                        contentDiv.insertAdjacentHTML('beforeend', separatorHtml + finalHtml + '<p><br></p>');
                        App.ui.showToast(`KashCraft analysis complete!`, 'success');
                        App.state.isArticleDirty = true;
                        
                        const finalElement = contentDiv.lastElementChild;
                        if (finalElement) {
                            finalElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }

                    } catch (error) {
                        App.ui.hideToast(toastId);
                        App.ui.showToast(`AI failed: ${error.message}`, "error");
                        console.error("KashCraft Generation Error:", error);
                    }
                },


                async executeFixGrammar() {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();
                    if (!selectedText) {
                        App.ui.showToast("Please select text to fix and restructure.", "warning");
                        return;
                    }

                    const systemPrompt = `You are an expert editor and communication specialist. Your task is to perform two critical actions on the user's selected text:
                        1.  **Correct:** Meticulously fix all spelling mistakes, grammatical errors, vocabulary issue and punctuation issues.
                        2.  **Restructure for Clarity:** Rewrite the corrected text into logical, short, meaningful and easy-to-read paragraph.

                        **CRITICAL RULES:**
                        - You MUST preserve the original meaning and all information from the source text. Do not add or remove facts.
                        - Your response MUST BE ONLY the final, rewritten text formatted into clean HTML paragraph or paragraphs (if its too long).
                        - If selected text has few sentence make a logical paragaph, if it has many sentences you can write in paragraphs too according to what content demands.
                        - Your code will be used as replacement to selected text so, Do NOT include any conversational filler, explanations, or markdown code fences.`;

                    const toastId = App.ui.showToast('ðŸ¤– AI is improving your text...', { type: 'info', duration: 0 });
                    const result = await App.services.ai.queryGenerativeAI(systemPrompt, selectedText);
                    App.ui.hideToast(toastId);

                    if (result && result.trim()) {
                        const resultHtml = result.trim().replace(/^```(html)?\n?/, '').replace(/\n?```$/, '');
                        
                        document.execCommand('insertHTML', false, resultHtml);
                        App.ui.showToast("Text fixed and restructured!", "success");
                        App.state.isArticleDirty = true;
                    } else {
                        App.ui.showToast("AI could not process the text. Please try again.", "warning");
                    }
                },

            },

            spotlight: {
                currentIndex: -1,
                navigate(direction) {
                    const container = document.querySelector('.focus-mode-body');
                    if (!container) return;

                    const allItems = Array.from(container.querySelectorAll('.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-accordion'));

                    if (allItems.length === 0) return;

                    const currentFocus = document.querySelector('.spotlight-key-focus');
                    let currentIndex = -1;
                    if (currentFocus) {
                        currentIndex = allItems.indexOf(currentFocus);
                    }
                    let nextIndex;
                    if (currentIndex === -1) {
                        nextIndex = (direction === 1) ? 0 : allItems.length - 1;
                    } else {
                        nextIndex = currentIndex + direction;
                    }
                    
                    nextIndex = Math.max(0, Math.min(allItems.length - 1, nextIndex));
                    const target = allItems[nextIndex];
                    if (target) {
                        container.querySelectorAll('.spotlight-key-focus').forEach(el => el.classList.remove('spotlight-key-focus'));
                        target.focus({ preventScroll: true });
                        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        target.classList.add('spotlight-key-focus');
                    }
                },
            },



            handleSpotlight(event) {
                if (!event.altKey) return;
                const bodyEl = document.querySelector('.focus-mode-body');
                if (!bodyEl || !bodyEl.classList.contains('spotlight-active')) return;

                const targetSnippet = event.target.closest('.snippet, .nk-mcq-block');

                if (event.type === 'mouseover' && targetSnippet) {
                    targetSnippet.classList.add('spotlight');
                } else if (event.type === 'mouseout' && targetSnippet) {
                    targetSnippet.classList.remove('spotlight');
                }
            },


            toggleFocusMode() {
                App.state.isFullscreen = !App.state.isFullscreen;
                const isFullscreen = App.state.isFullscreen;
                document.body.classList.toggle('fullscreen-active', isFullscreen);
                const floatingBtn = document.getElementById('focus-mode-toggle');
                const controlsBtn = document.querySelector('.read-mode-controls [data-action="toggleFocusMode"]');
                const isWrite = App.state.currentMode === 'write';
                const newIcon = isFullscreen 
                    ? (isWrite ? App.util.icons.pen : App.util.icons.eyeClosed) 
                    : (isWrite ? App.util.icons.pen : App.util.icons.eyeOpen);
                if (floatingBtn) {
                    floatingBtn.classList.toggle('exit-active', isFullscreen);
                    floatingBtn.innerHTML = newIcon;
                }
                if (controlsBtn) {
                    controlsBtn.innerHTML = newIcon;
                }
            },
            changeFontFamily(e) {
                const newFont = e.target.value;

                const freeFonts = [
                    'Arial, Helvetica, sans-serif',
                    "'Courier New', Courier, monospace",
                    'Garamond, serif',
                    'Georgia, serif',
                    'Helvetica, Arial, sans-serif',
                    'Monaco, "Lucida Console", monospace',
                    'Palatino, "Palatino Linotype", serif',
                    'Verdana, Geneva, sans-serif'
                ];
                const isPremium = !freeFonts.includes(newFont);

                if (isPremium && !App.license.isPremium()) {
                    App.ui.showAscensionModal();
                    e.target.value = App.settings.get('fontFamily'); // Revert selection
                    return;
                }

                App.settings.set('fontFamily', newFont); 
                App.ui.applyFontSettings(); 
            },
            
            changeFontSize(e) {
                const size = e.target.value;
                document.documentElement.style.setProperty('--article-font-size', `${size}rem`);
                document.getElementById('font-size-value').textContent = `${size}rem`;
                App.settings.set('fontSize', `${size}rem`);
            },
            changeLineHeight(e) {
                const lineHeight = e.target.value;
                document.documentElement.style.setProperty('--article-line-height', lineHeight);
                document.getElementById('line-height-value').textContent = lineHeight;
                App.settings.set('lineHeight', lineHeight);
            },
            handleThemeChange(newTheme) {
                const oldTheme = App.settings.get('theme');
                if (newTheme === 'custom') {
                    if (!App.settings.get('backgroundImage')) this.triggerBgImageUpload(oldTheme);
                    else App.ui.applyTheme('custom');
                } else App.ui.applyTheme(newTheme);
                App.ui.updateSettingsUIState();
            },
            triggerBgImageUpload(oldTheme) {
                const input = document.getElementById('background-image-input');
                input.onchange = (event) => {
                    const file = event.target.files[0];
                    if (!file) { if(oldTheme) { document.getElementById('theme-select').value = oldTheme; App.events.handleThemeChange(oldTheme); } return; }
                    if (file.size > App.config.image.maxUploadSize) { App.ui.showToast(`Image too large. Max size is ${App.config.image.maxUploadSize / 1024 / 1024}MB.`, { type: 'error' }); return; }
                    const reader = new FileReader();
                    reader.onload = (re) => { App.settings.set('backgroundImage', re.target.result); App.ui.applyTheme('custom'); App.ui.updateSettingsUIState(); };
                    reader.readAsDataURL(file);
                };
                input.value = null;
                input.click();
            },
            handleCustomThemeBaseChange(e) { App.settings.set('customThemeBase', e.target.value); if (App.settings.get('theme') === 'custom') App.ui.applyTheme('custom'); },
            changeUiOpacity(e) {
                const opacity = e.target.value;
                document.documentElement.style.setProperty('--ui-opacity', opacity);
                document.getElementById('opacity-value').textContent = `${Math.round(opacity * 100)}%`;
                App.settings.set('uiOpacity', opacity);
                document.documentElement.style.setProperty('--blur-intensity', parseFloat(opacity) === 0 ? '0px' : '8px');
                document.documentElement.classList.toggle('zero-opacity-active', parseFloat(opacity) === 0);
            },
            changeImageQuality(e) {
                const quality = e.target.value;
                document.getElementById('image-quality-value').textContent = `${Math.round(quality * 100)}%`;
                App.settings.set('jpegQuality', parseFloat(quality));
            },
            
            changeOcrThreshold(e) {
                const threshold = e.target.value;
                const valueDisplay = document.getElementById('ocr-threshold-value');
                if (valueDisplay) {
                    valueDisplay.textContent = threshold;
                }
                App.settings.set('ocrThreshold', parseInt(threshold, 10));
            },

            showTagModal(tag) {
                const articlesWithTag = App.state.articles.filter(a => a.tags && a.tags.includes(tag)).sort((a,b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                const tagDisplayName = App.state.tags[tag]?.displayName || tag;
                const message = `<div class="tag-modal-body">
                    ${articlesWithTag.map(article => `
                        <div class="tag-modal-article-title" onclick="App.events.navigateToTagInArticle('${article.id}', '${tag}')">
                            <span>${article.title}</span>
                            <button class="btn-icon" title="Remove tag from this article" onclick="event.stopPropagation(); App.events.deleteTag('${tag}', '${article.id}')">${App.util.icons.trash}</button>
                        </div>`).join('') || '<p>No articles found for this tag.</p>'}
                </div>`;
                App.ui.showConfirmationModal({ 
                    title: `Notes tagged with "${tagDisplayName}"`, 
                    message: message, 
                    showCancel: false, 
                    confirmText: 'Close' 
                });
            },
            async deleteTag(tag, articleId) {
                const article = App.storage.getArticle(articleId);
                const tagDisplayName = App.state.tags[tag]?.displayName || tag;
                if (!article || !article.tags.includes(tag)) return;

                App.ui.showConfirmationModal({
                    title: `Remove Tag?`,
                    message: `Are you sure you want to remove the tag "${tagDisplayName}" from the article "${article.title}"? This will only remove the tag, not the text itself.`,
                    confirmText: 'Remove',
                    onConfirm: async () => {
                        const newTags = article.tags.filter(t => t !== tag);
                        let newContent = article.content;
                        
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = newContent;
                        tempDiv.querySelectorAll(`.rendered-tag[data-tag-text="${tag}"], .rendered-tag[data-tag="${tag}"]`).forEach(el => App.util.unwrapNode(el));
                        newContent = tempDiv.innerHTML;
                        
                        const result = await App.storage.updateArticle(articleId, { tags: newTags, content: newContent });
                        if(result.success) {
                            App.ui.showToast(`Tag "${tagDisplayName}" removed.`);
                            await App.contentTools.updateTagsIndex();
                            App.ui.closeModal(); 
                            App.events.showTagModal(tag);
                        }
                    }
                });
            },
            navigateToTagInArticle(articleId, tag, shouldNavigate = true) {
                if (shouldNavigate) { App.router.navigateTo('article', {id: articleId, mode: 'read', focusTag: tag }); App.ui.closeModal(); } 
                else {
                    const contentDiv = document.getElementById('article-content');
                    if (contentDiv) {
                        const firstTaggedElement = contentDiv.querySelector(`[data-tag-text="${tag}"], [data-tag="${tag}"]`);
                        if (firstTaggedElement) {
                            firstTaggedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            firstTaggedElement.style.transition = 'background-color 0.5s';
                            firstTaggedElement.style.backgroundColor = 'var(--hl-1-bg)';
                            setTimeout(() => { firstTaggedElement.style.backgroundColor = ''; }, 2000);
                        }
                    }
                }
            },
            changeCategorySort(e, category) { App.settings.set('categorySortBy', e.target.value); App.ui.renderCategoryView(document.getElementById('category-view'), category); },
            changeTagSort(e) { App.settings.set('tagSortBy', e.target.value); App.events.filterAndRenderTags(); },
            filterAndRenderTags() {
                const sortBy = App.settings.get('tagSortBy');
                const searchTerm = document.getElementById('tag-search-input')?.value.toLowerCase() || '';
                const container = document.getElementById('tag-cloud-container');

                if (!container) return;
                
                let allTagsData = Object.values(App.state.tags);

                if (searchTerm) {
                    allTagsData = allTagsData.filter(t => t.displayName.toLowerCase().includes(searchTerm));
                }

                let contentHtml;
                if (allTagsData.length === 0) {
                    contentHtml = `<div class="empty-state"><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg><h3>No Tags Found</h3><p>Create tags using [[double brackets]] in an article, or adjust your search.</p></div>`;
                } else {
                    if (sortBy === 'random') allTagsData.sort(() => Math.random() - 0.5);
                    else if (sortBy === 'date-new') allTagsData.sort((a, b) => new Date(b.lastUsed) - new Date(a.lastUsed));
                    else if (sortBy === 'date-old') allTagsData.sort((a, b) => new Date(a.firstUsed) - new Date(b.firstUsed));
                    else allTagsData.sort((a, b) => a.displayName.localeCompare(b.displayName));
                    contentHtml = `<div class="tag-cloud">${allTagsData.map(tagData => `<div class="tag-item" onclick="App.events.showTagModal('${tagData.id}')">${tagData.displayName}</div>`).join('')}</div>`;
                }
                container.innerHTML = contentHtml;
            },
           changeFlashcardCategory(category) {
                App.settings.set('flashcardCategory', category);

                // Correctly update the active button style using the '.active' class
                const view = document.getElementById('flashcard-view');
                if (view) {
                    // First, remove 'active' from all category chips
                    view.querySelectorAll('.category-filters .category-chip').forEach(btn => {
                        btn.classList.remove('active');
                    });

                    // Then, add 'active' to the specific button that was clicked
                    // This is a more robust way to find the exact button
                    const activeBtn = view.querySelector(`.category-filters .category-chip[onclick="App.events.changeFlashcardCategory('${category}')"]`);
                    if (activeBtn) {
                        activeBtn.classList.add('active');
                    }
                }

                // Re-render the flashcard grid as before
                App.ui.filterAndRenderFlashcards();
            },


            changeFlashcardSort(e) { App.settings.set('flashcardSortBy', e.target.value); App.ui.filterAndRenderFlashcards(); },
            
            updateReadingProgress() {
                requestAnimationFrame(() => {
                    const articleView = document.getElementById('article-view');
                    if (!articleView || !articleView.classList.contains('active')) return;
                    
                    const mainEl = document.querySelector('main');
                    if (!mainEl) return;

                    const { scrollHeight, clientHeight, scrollTop } = mainEl;

                    if (scrollHeight <= clientHeight) {
                        App.ui.updateTheLine(1);
                        return;
                    }
                    
                    let progress = scrollTop / (scrollHeight - clientHeight);
                    
                    if (scrollTop + clientHeight >= scrollHeight - 2) {
                        progress = 1;
                    }

                    App.ui.updateTheLine(progress);
                });
            },

            study: {
                updateLimit(newLimit) {
                    const limit = parseInt(newLimit, 10);
                    if (limit > 0) {
                        App.settings.set('studySessionSize', limit);
                        App.ui.showToast(`Session size set to ${limit}`, { type: 'success' });
                    }
                },
                
               start(options = {}) {
                    const { 
                        mode = 'limitedDue',
                        limit = App.settings.get('studySessionSize'),
                        quizCards = null,
                        quizType = 'none' // 'none', 'classic', or 'mcq'
                    } = options;

                    const isQuizMode = !!quizCards;
                    let cardsToStudy;
                    let toastMessage = "No new or due flashcards to study.";

                    if (isQuizMode) {
                        cardsToStudy = quizCards;
                        toastMessage = "You donâ€™t have enough cards for a Quiz.";
                    } else {
                        cardsToStudy = App.util.getDueFlashcards();
                        if (mode === 'mcqOnly') {
                            cardsToStudy = cardsToStudy.filter(c => c.type === 'mcq');
                            toastMessage = "No due Multiple-Choice Questions in this deck.";
                        }
                        if (mode === 'limitedDue') {
                            cardsToStudy = cardsToStudy.slice(0, limit);
                        }
                    }

                    if (!cardsToStudy || cardsToStudy.length === 0) {
                        App.ui.showToast(toastMessage);
                        return;
                    }

                    App.state.studySession = { isActive: true, isQuizMode, quizType, cards: cardsToStudy, currentIndex: 0, isRating: false,  activeTheme: 'default' };
                    document.body.classList.add('study-mode-active');
                    App.ui.renderStudyView(App.state.studySession);
                    App.ui.updateStudyProgressUI();
                },

                toggleFontSize(button) {
                    const fontSizes = ['1.2rem', '1.4rem', '1.6rem', '1.8rem', '2.0rem', '2.2rem','2.4rem','2.6rem','2.8rem','3rem'];
                    const currentSize = App.settings.get('studyCardFontSize') || '1.6rem';
                    const currentIndex = fontSizes.indexOf(currentSize);
                    const nextIndex = (currentIndex + 1) % fontSizes.length;
                    const newSize = fontSizes[nextIndex];

                    document.documentElement.style.setProperty('--study-card-font-size', newSize);
                    if (button) {
                        button.querySelector('span').textContent = newSize.replace('rem','');
                    }
                    App.settings.set('studyCardFontSize', newSize);
                },

                rate(rating) {
                    const s = App.state.studySession;
                    if (!s.isActive || s.isRating) return;

                    App.util.hapticFeedback(); // <-- ADD THIS LINE

                    s.isRating = true;
                    const card = s.cards[s.currentIndex];
                    card.finalRating = rating;
                    if (!s.isQuizMode) {
                        const updatedCardData = App.util.sm2.rateCard(card, rating);
                        const originalArticle = App.storage.getArticle(card.articleId);
                        if (originalArticle?.flashcards?.[card.id]) {
                            const newFlashcards = { ...originalArticle.flashcards, [card.id]: { ...originalArticle.flashcards[card.id], ...updatedCardData } };
                            App.storage.updateArticle(originalArticle.id, { flashcards: newFlashcards });
                        }
                    }
                    const studyView = document.querySelector('.study-view');
                    if (studyView) {
                        const cardBox = studyView.querySelector('.study-card-content-box');
                        const ratingBtn = studyView.querySelector(`.btn-${rating.toLowerCase()}`);
                        cardBox.classList.add(`rated-${App.config.sm2.colors[rating]}`);
                        if (ratingBtn) ratingBtn.classList.add('btn-popped');
                    }
                    setTimeout(() => this.next(), 1500);
                },

                next() {
                    const s = App.state.studySession;
                    if (!s.isActive) return;

                    if (s.currentIndex >= s.cards.length - 1) {
                        this.exit(true);
                        return;
                    }
                    const currentCard = s.cards[s.currentIndex];
                    let nextIndex = s.currentIndex + 1;
                    
                    if (s.cards[nextIndex].articleId === currentCard.articleId) {
                        // Find the first card further in the queue that is from a DIFFERENT article.
                        const alternateIndex = s.cards.findIndex((card, index) => index > nextIndex && card.articleId !== currentCard.articleId);

                        if (alternateIndex !== -1) {
                            // An alternate card was found. Swap it with the next card in line.
                            const relatedCard = s.cards[nextIndex];
                            s.cards[nextIndex] = s.cards[alternateIndex];
                            s.cards[alternateIndex] = relatedCard;
                        }
                    }

                    s.currentIndex++;
                    s.isRating = false;
                    App.ui.renderStudyView(s);
                    App.ui.updateStudyProgressUI();
                },

                prev() {
                    const s = App.state.studySession; if (!s.isActive || s.currentIndex === 0 || s.isRating) return;
                    s.currentIndex--; App.ui.renderStudyView(s); App.ui.updateStudyProgressUI();
                },

                exit(isCompleted = false) {
                    if (!App.state.studySession.isActive) return;
                    const session = { ...App.state.studySession };
                    
                    // Reset state BEFORE showing results
                    App.state.studySession = { isActive: false, isQuizMode: false, quizType: 'none', cards: [], currentIndex: 0, isRating: false };
                    App.ui.renderStudyView(App.state.studySession); // This will remove the study view and body classes
                    
                    if (session.isQuizMode && isCompleted) {
                        App.quiz.calculateAndShowResults(session.cards);
                    } else if (session.isQuizMode && !isCompleted) {
                        App.ui.showToast("Quiz abandoned!");
                        App.router.navigateTo('flashcard');
                    } else {
                        App.ui.showToast(isCompleted ? "Study session complete!" : "Study session exited.");
                        App.router.navigateTo('flashcard');
                    }
                },

                setupCardGestures(cardElement) {
                    let touchStartX = 0;
                    let touchStartY = 0;
                    let touchEndX = 0;
                    let touchEndY = 0;
                    const swipeThreshold = 50; // Minimum pixels to be considered a swipe

                    cardElement.addEventListener('touchstart', (e) => {
                        touchStartX = e.changedTouches[0].screenX;
                        touchStartY = e.changedTouches[0].screenY;
                    }, { passive: true });

                    cardElement.addEventListener('touchend', (e) => {
                        touchEndX = e.changedTouches[0].screenX;
                        touchEndY = e.changedTouches[0].screenY;
                        handleSwipeGesture();
                    }, { passive: true });

                    const handleSwipeGesture = () => {
                        const dx = touchEndX - touchStartX;
                        const dy = touchEndY - touchStartY;
                        const absDx = Math.abs(dx);
                        const absDy = Math.abs(dy);

                        if (App.state.studySession.isRating) return;

                        // Check if it's a horizontal swipe
                        if (absDx > swipeThreshold && absDx > absDy) {
                            if (dx > 0) {
                                // Swiped Right -> Easy
                                App.events.study.rate('Easy');
                            } else {
                                // Swiped Left -> Again
                                App.events.study.rate('Again');
                            }
                        }
                        // Check if it's a vertical swipe
                        else if (absDy > swipeThreshold && absDy > absDx) {
                            if (dy < 0) {
                                // Swiped Up -> Good
                                App.events.study.rate('Good');
                            }
                            // Optional: Swipe Down for "Hard"
                            // else {
                            //     App.events.study.rate('Hard');
                            // }
                        }
                    };
                },

                cycleStudyTheme(goBack = false) { 
                    const themes = App.events.presentation.themes;
                    const session = App.state.studySession;
                    if (!session.isActive) return;

                    const currentIndex = themes.indexOf(session.activeTheme);
                    const nextIndex = goBack
                        ? (currentIndex - 1 + themes.length) % themes.length
                        : (currentIndex + 1) % themes.length;
                    session.activeTheme = themes[nextIndex];
                    App.ui.applyStudyTheme();

                    const themeName = session.activeTheme.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    App.ui.showToast(`${themeName} Theme`, { type: 'info', duration: 1500 });
                },

                resetStudyTheme() {
                    const session = App.state.studySession;
                    if (!session.isActive) return;
                    session.activeTheme = 'default';
                    App.ui.applyStudyTheme();
                    App.ui.showToast('Theme reset to default', { type: 'success', duration: 2000 });
                },

                handleKeyboard(e) {
                    if (App.state.studySession.isRating) return;

                    // New logic to handle scrolling with arrow keys
                    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        e.preventDefault();
                        const studyCard = document.querySelector('.study-card');
                        if (!studyCard) return;

                        const isFlipped = studyCard.classList.contains('is-flipped');
                        const activeFaceSelector = isFlipped ? '.study-card-back' : '.study-card-front';
                        const contentBox = document.querySelector(`${activeFaceSelector} .study-card-content-box`);

                        if (contentBox) {
                            const scrollAmount = 75; // The number of pixels to scroll
                            contentBox.scrollTop += (e.key === 'ArrowDown' ? scrollAmount : -scrollAmount);
                        }
                        return; // Exit after handling scroll
                    }

                    switch (e.key) {
                        case ' ': e.preventDefault(); document.querySelector('.study-card')?.classList.toggle('is-flipped'); break;
                        case 'ArrowLeft': this.prev(); break;
                        case 'ArrowRight': this.next(); break;
                        case 'c':
                            App.events.study.cycleStudyTheme();
                            break;
                        case 'e':
                            document.querySelector('.study-controls .btn-icon-nav[onclick*="toggleFontSize"]')?.click();
                            break;
                        case 'Enter':
                            e.preventDefault();
                            document.querySelector('.study-card')?.classList.toggle('is-flipped');
                            break;
                        case 'a': e.preventDefault(); this.rate('Again'); break;
                        case '5': this.rate('Again'); break;
                        case '4': this.rate('Hard'); break;
                        case '3': this.rate('Hold'); break;
                        case '2': this.rate('Good'); break;
                        case '1': this.rate('Easy'); break;
                    }
                }
            },

           async handleMcqAnswer(event, isStudyMode = false) {
                const selectedOption = event.target.closest('.nk-mcq-option');
                if (!selectedOption) return;

                const mcqBlock = selectedOption.closest('.nk-mcq-block');
                if (!mcqBlock || mcqBlock.dataset.answered === 'true') return;

                event.preventDefault();
                event.stopPropagation();

                const isUserCorrect = selectedOption.dataset.isCorrect === 'true';
                const quizType = mcqBlock.dataset.quizMode;
                
                if (quizType === 'mcq') {
                    mcqBlock.dataset.answered = 'true';
                    selectedOption.classList.add(isUserCorrect ? 'correct' : 'incorrect');
                    if (!isUserCorrect) {
                        mcqBlock.querySelector('.nk-mcq-option[data-is-correct="true"]')?.classList.add('correct');
                    }
                    
                    const card = App.state.studySession.cards[App.state.studySession.currentIndex];
                    await App.quiz.handleMcqAnswer(isUserCorrect, card);

                    // DEFINITIVE FIX: Auto-advance to the next question after 3 seconds
                    setTimeout(() => {
                        App.events.study.next();
                    }, 3000);

                } else { // This is the original logic for read mode or classic study mode
                    const blocksToUpdate = isStudyMode ? document.querySelectorAll('.study-card-face .nk-mcq-block') : [mcqBlock];

                    blocksToUpdate.forEach(block => {
                        block.dataset.answered = 'true';
                        const options = Array.from(block.querySelectorAll('.nk-mcq-option'));
                        const selectedInBlock = options.find(opt => opt.textContent === selectedOption.textContent);
                        const correctInBlock = options.find(opt => opt.dataset.isCorrect === 'true');

                        if (isUserCorrect) {
                            if (selectedInBlock) selectedInBlock.classList.add('correct');
                        } else {
                            if (selectedInBlock) selectedInBlock.classList.add('incorrect');
                            if (correctInBlock) correctInBlock.classList.add('correct');
                        }
                    });

                    if (isStudyMode) {
                        setTimeout(() => {
                            const studyCard = document.querySelector('.study-card');
                            if (studyCard && !studyCard.classList.contains('is-flipped')) {
                                studyCard.classList.add('is-flipped');
                            }
                        }, 3000);
                    }
                }
            },

            flashcardContextMenu(event, cardId) {
                event.preventDefault();
                const menuHtml = `<button onclick="App.events.resetFlashcard('${cardId}')">Reset Card Progress</button>`;
                App.ui.showContextMenu(event.pageX, event.pageY, menuHtml);
            },
            async resetFlashcard(cardId) {
                const card = App.util.getAllFlashcards().find(c => c.id === cardId); if (!card) return;
                const article = App.storage.getArticle(card.articleId);
                if (article && article.flashcards && article.flashcards[cardId]) {
                    const newFlashcards = { ...article.flashcards };
                    
                    // âœ¨ FIX: Perform a complete factory reset on the card's learning data.
                    newFlashcards[cardId] = { 
                        ...newFlashcards[cardId], 
                        rating: null, 
                        reviewCount: 0, 
                        interval: 0, 
                        lastReviewed: null, 
                        nextReviewDue: null, 
                        reviewHistory: [],
                        easeFactor: 2.5, // Reset Ease Factor to default
                        lapses: 0,       // Reset Leech counter
                    };

                    await App.storage.updateArticle(article.id, { flashcards: newFlashcards });
                    App.ui.filterAndRenderFlashcards();
                    App.ui.showToast("Card progress reset.");
                }
            },
            resetFilteredFlashcardsConfirmation() {
                const category = App.settings.get('flashcardCategory') || 'All';
                App.ui.showConfirmationModal({
                    title: 'Reset Card Progress?',
                    message: `Are you sure you want to reset the progress for all flashcards in the current filter ("${category === 'All' ? 'All' : App.util.getCategoryDisplayName(category)}")? This action cannot be undone.`,
                    confirmText: 'Reset',
                    onConfirm: () => App.events.resetFilteredFlashcards()
                });
            },
            async resetFilteredFlashcards() {
                const cardsToReset = App.util.getSortedFlashcardsForDisplay();
                if(cardsToReset.length === 0) { App.ui.showToast("No cards to reset in this view."); return; }
                const articlesToUpdate = {};
                for (const card of cardsToReset) {
                    if (!articlesToUpdate[card.articleId]) articlesToUpdate[card.articleId] = { ...App.storage.getArticle(card.articleId).flashcards };
                    articlesToUpdate[card.articleId][card.id] = { ...articlesToUpdate[card.articleId][card.id], rating: null, reviewCount: 0, interval: 0, lastReviewed: null, nextReviewDue: null, reviewHistory: [] };
                }
                App.ui.showToast("Resetting cards...", {type: 'info'});
                for (const articleId in articlesToUpdate) await App.storage.updateArticle(articleId, { flashcards: articlesToUpdate[articleId] });
                App.ui.filterAndRenderFlashcards();
                App.ui.showToast(`${cardsToReset.length} cards have been reset.`, {type: 'success'});
            },
            async nudgeReviewDate(cardId, days) {
                const card = App.util.getAllFlashcards().find(c => c.id === cardId);
                if (!card || !card.nextReviewDue) { App.ui.showToast("Cannot nudge a new card."); return; }
                const article = App.storage.getArticle(card.articleId);
                if (article && article.flashcards && article.flashcards[cardId]) {
                    const newFlashcards = { ...article.flashcards };
                    const currentDueDate = new Date(card.nextReviewDue);
                    let newDueDate = new Date(currentDueDate.setDate(currentDueDate.getDate() + days));
                    if (newDueDate.getTime() < Date.now()) newDueDate = new Date();
                    newFlashcards[cardId].nextReviewDue = newDueDate.toISOString();
                    await App.storage.updateArticle(article.id, { flashcards: newFlashcards });
                    App.ui.filterAndRenderFlashcards();
                    App.ui.showToast(`Review date moved ${days > 0 ? 'forward' : 'back'} by ${Math.abs(days)} day(s).`);
                }
            },

            deleteFlashcardConfirmation(cardId) {
                const card = App.util.getAllFlashcards().find(c => c.id === cardId);
                if (!card) return;

                // Sanitize card text for display in the modal
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = card.type === 'collapsible' ? card.frontText : card.fullText;
                const cardTextSample = (tempDiv.textContent || "").substring(0, 80);

                App.ui.showConfirmationModal({
                    title: 'Delete Flashcard?',
                    message: `Are you sure you want to permanently delete this flashcard?<br><br><em>"${cardTextSample}..."</em>`,
                    confirmText: 'Delete',
                    onConfirm: () => App.events.deleteFlashcard(cardId)
                });
            },

            async deleteFlashcard(cardId) {
                const card = App.util.getAllFlashcards().find(c => c.id === cardId);
                if (!card) return;

                const article = App.storage.getArticle(card.articleId);
                if (article && article.flashcards && article.flashcards[cardId]) {
                    const newFlashcards = { ...article.flashcards };
                    delete newFlashcards[cardId];
                    await App.storage.updateArticle(article.id, { flashcards: newFlashcards });
                    
                    App.ui.filterAndRenderFlashcards();
                    App.ui.showToast("Flashcard deleted.");
                } else {
                    App.ui.showToast("Could not find flashcard's source article.", { type: 'error' });
                }
            },

            selectImage(container) {
                this.deselectImage();
                container.classList.add('selected');
                App.state.selectedImageContainer = container;
                App.ui.showImageToolbar(container);
                
                const handle = container.querySelector('.resize-handle'); 
                const image = container.querySelector('img');

                const startResize = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onEnd);
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                };

                const onMove = (e) => {
                    e.preventDefault();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const rect = container.getBoundingClientRect();
                    let newWidth = clientX - rect.left;
                    
                    // Maintain aspect ratio
                    const originalRatio = parseFloat(image.dataset.originalWidth) / parseFloat(image.dataset.originalHeight);
                    image.style.width = `${newWidth}px`;
                    image.style.height = `auto`; // Let browser calculate height based on new width
                };

                const onEnd = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onEnd);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onEnd);
                    App.state.isArticleDirty = true; // Mark for autosave after resizing
                };

                handle.addEventListener('mousedown', startResize);
                handle.addEventListener('touchstart', startResize, { passive: false });
            },


            deselectImage() {
                if (App.state.selectedImageContainer) {
                    App.state.selectedImageContainer.classList.remove('selected');
                    App.state.selectedImageContainer = null;
                    App.ui.hideImageToolbar();
                }
            },
            
           handleImageAlignment(alignClass) {
                const container = App.state.selectedImageContainer; if (!container) return;
                if(alignClass === 'reset-size') { const img = container.querySelector('img'); img.style.width = img.dataset.originalWidth + 'px'; img.style.height = 'auto'; return; }
                container.classList.remove('align-left', 'align-right', 'align-center');
                if (alignClass) container.classList.add(alignClass);
            },
            async highlightImage() {
                const container = App.state.selectedImageContainer;
                if (!container) return;
                const isHighlighted = container.classList.toggle('highlighted-image');
                container.dataset.isHighlighted = isHighlighted;
                await App.events.saveArticle({ isAutosave: true }); // CHANGED: Added silent save option
                App.ui.showToast(isHighlighted ? 'Image highlighted!' : 'Image highlight removed.', { type: 'success' });
                // Re-show toolbar to update button color
                App.ui.showImageToolbar(container);
            },
            
            addImageCaption() {
                const container = App.state.selectedImageContainer;
                if (!container) return;

                const theme = App.settings.get('captionTheme') || 'default';
                const align = App.settings.get('captionAlign') || 'bottom';
                container.setAttribute('data-caption-theme', theme);
                container.setAttribute('data-caption-align', align);


                let caption = container.querySelector('.image-caption');

                if (caption) {
                    caption.setAttribute('contenteditable', 'true');
                    caption.style.pointerEvents = 'auto'; // Make interactive
                    caption.focus();
                } else {
                    caption = document.createElement('div');
                    caption.className = 'image-caption';
                    caption.setAttribute('contenteditable', 'true');
                    caption.setAttribute('data-placeholder', 'Add a caption...');
                    container.appendChild(caption);
                    caption.focus();
                    App.state.isArticleDirty = true;
                }
                caption.onblur = async () => {
                    caption.removeAttribute('contenteditable');
                    caption.style.pointerEvents = 'none'; // Revert to non-interactive
                    if (caption.textContent.trim() === '' && caption.parentNode) {
                        caption.parentNode.removeChild(caption);
                    }
                    await App.events.saveArticle({ isAutosave: true }); // CHANGED: Added silent save option
                    App.ui.hideImageToolbar(); // Hide toolbar after editing
                };
                
                App.ui.showImageToolbar(container);
            },

            toggleShowTags() {
                const current = App.settings.get('showTagsOnTiles');
                App.settings.set('showTagsOnTiles', !current);
                document.getElementById('show-tags-toggle').classList.toggle('active', !current);
                App.ui.filterAndRenderArticles();
            },
            toggleMobileView() {
                const current = App.settings.get('mobileViewEnabled');
                App.settings.set('mobileViewEnabled', !current);
                App.ui.applyMobileView();
            },

            cycleTextColorFormatting() {
                const textColors = ['text-red', 'text-green', 'text-blue', 'text-magenta', 'text-orange', 'text-teal', 'text-slate'];
                let currentIndex = App.settings.get('textColorCycleIndex') || 0;
                const colorToApply = textColors[currentIndex];

                const selection = window.getSelection();
                const isTextSelected = selection && !selection.isCollapsed && selection.rangeCount > 0;

                if (isTextSelected) {
                    this.applyFormatting('class', colorToApply);

                } else {
                    const nextIndex = (currentIndex + 1) % textColors.length;
                    App.settings.set('textColorCycleIndex', nextIndex);
                    const article = App.storage.getArticle(App.state.activeArticleId);
                    if (article) {
                        App.ui.renderArticleControls(article);
                    }
                }
            },


            handleArticleControlsClick(e) {
                const button = e.target.closest('button, .read-count-badge'); if (!button) return;
                const { action, value } = button.dataset;

                switch (action) {
                    case 'cycleReaderTheme': App.events.cycleReaderTheme(); break; 
                    case 'goToCategory': 
                        const article = App.storage.getArticle(App.state.activeArticleId); 
                        if (article) App.router.navigateTo('category', { category: article.category, articleId: article.id });
                        break;
                    case 'switchToWrite': App.events.switchToMode('write'); break;
                    case 'finishArticle': App.events.finishArticle(); break;
                    case 'copyHighlights': App.services.export.copyCurrentArticleHighlights(); break;
                    case 'exportHtml': App.services.export.exportArticleAsHtml(); break;
                    case 'shareArticle': App.services.share.article(); break;
                    case 'exportNoteKash': App.services.export.exportAsNoteKashFile(); break; // <-- ADD THIS LINE
                    case 'resetReadCount': App.events.resetReadCount(); break;
                    case 'toggleFocusMode': App.events.toggleFocusMode(); break;
                    case 'saveAndRead': App.events.saveArticle({ switchToRead: true }); break;
                    case 'deleteArticle': App.events.deleteArticleWithConfirmation(); break;
                    case 'format': if (value === 'cloze') App.events.applyFormatting('cloze'); else App.events.applyFormatting('class', value); break;
                    case 'manageTable': App.events.showTableModal(); break;
                    case 'insertAccordion': App.events.insertAccordionCard(); break;
                    case 'insertCheckbox':
                        const checkboxHTML = `<div class="nk-checkbox-wrapper" data-checked="false"><span class="nk-checkbox-box"></span><span class="nk-checkbox-text"><br></span></div><p><br></p>`;
                        document.execCommand('insertHTML', false, checkboxHTML);
                        setTimeout(() => { const lastCheckbox = document.querySelector('.nk-checkbox-wrapper:last-of-type .nk-checkbox-text'); if (lastCheckbox) App.util.placeCursor(lastCheckbox); }, 10);
                        App.state.isArticleDirty = true;
                        break;
                    case 'applyListStyle':
                        const selection = window.getSelection(); if (!selection.focusNode) break;
                        const focusElement = selection.focusNode.nodeType === Node.TEXT_NODE ? selection.focusNode.parentElement : selection.focusNode;
                        let list = focusElement.closest('ul, ol');
                        if (value === 'ordered-alpha') {
                            if (list && list.tagName === 'UL') {
                                document.execCommand('insertOrderedList', false);
                                list = window.getSelection().focusNode.parentElement.closest('ol');
                            } else if (!list) {
                                document.execCommand('insertOrderedList', false);
                                list = window.getSelection().focusNode.parentElement.closest('ol');
                            }
                            if (list) list.setAttribute('type', 'a');
                        } else {
                            if (list) list.className = value;
                            else { document.execCommand('insertUnorderedList', false); setTimeout(() => { const newList = window.getSelection().focusNode.parentElement.closest('ul'); if (newList) newList.className = value; }, 0); }
                        }
                        break;
                    case 'execCommand': document.execCommand(value); break;
                }
            },

            categories: {
                _refreshActiveView() {
                    const activeViewId = App.router.getActiveView();
                    if (activeViewId && ['library', 'flashcard', 'stats-dashboard', 'article'].includes(activeViewId)) {
                        App.router.navigateTo(activeViewId);
                    }
                },

                refreshManager() {
                    const container = document.getElementById('category-list-container');
                    if (!container) return;
                    const categories = App.settings.get('userCategories');

                    container.innerHTML = categories.map(cat => {
                        // UPDATED: Get the display name for rendering
                        const displayName = App.util.getCategoryDisplayName(cat.name);
                        return `
                        <div class="settings-item" data-category-name="${App.util.escapeHtml(cat.name)}">
                            <span class="category-name-display" style="display: inline-flex; align-items: center; gap: 8px;">
                                <span style="width: 16px; height: 16px; border-radius: 50%; background-color: ${App.util.getCategoryColor(cat.colorIndex)}; border: 1px solid var(--border-color);"></span>
                                ${App.util.escapeHtml(displayName)}
                            </span>
                            <div class="category-item-controls">
                                <button class="btn-icon" onclick="App.events.categories.initiateRename(this)" title="Rename">âœï¸</button>
                                <button class="btn-icon" onclick="App.events.categories.cycleColor('${cat.name}')" title="Change Color">ðŸŽ¨</button>
                                <button class="btn-icon ${cat.isDefault ? 'is-disabled' : ''}" onclick="${cat.isDefault ? "App.ui.showToast('Don\\'t delete Source Category', 'warning')" : `App.events.categories.initiateDelete('${cat.name}')`}" title="${cat.isDefault ? 'This is the default source category and cannot be deleted.' : 'Delete'}">${App.util.icons.trash}</button>
                            </div>
                        </div>
                    `}).join('');

                    const style = document.createElement('style');
                    style.textContent = `
                        .category-name-display { flex-grow: 1; }
                        .category-item-controls { display: flex; gap: 0.5rem; }
                    `;
                    container.appendChild(style);
                },
                async executeOperationPlan(plan) {
                    App.ui.showToast('Resuming interrupted category operation...', { type: 'warning' });
                    switch (plan.operation) {
                        case 'migrate':
                            await this.migrateAndDelete(plan.source, plan.destination);
                            break;
                        case 'delete':
                            await this.deleteAll(plan.source);
                            break;
                        default:
                            console.error('Unknown operation in plan file:', plan);
                            await App.fs.write('_category_operation_plan.json', null);
                    }
                },
                async add(name) {
                    const trimmedName = name.trim();
                    if (!trimmedName) return;
                    let categories = App.settings.get('userCategories');
                    if (categories.some(c => c.name.toLowerCase() === trimmedName.toLowerCase())) {
                        App.ui.showToast(`Category "${trimmedName}" already exists.`, 'warning');
                        return;
                    }
                    
                    const newCategory = {
                        name: trimmedName,
                        colorIndex: categories.length % App.util.getCategoryColorCount()
                    };
                    categories.push(newCategory);

                    await App.settings.set('userCategories', categories);
                    App.ui.showToast(`Category "${trimmedName}" added.`, 'success');
                    this.refreshManager();
                    this._refreshActiveView();
                },

                 initiateRename(buttonEl) {
                    const item = buttonEl.closest('.settings-item');
                    const nameDisplay = item.querySelector('.category-name-display');
                    const oldName = item.dataset.categoryName; // This is the stable, internal name
                    const currentDisplayName = App.util.getCategoryDisplayName(oldName);

                    nameDisplay.innerHTML = `<input type="text" class="text-input" value="${App.util.escapeHtml(currentDisplayName)}" style="padding: 4px 8px; font-size: 0.9rem;">`;
                    const input = nameDisplay.querySelector('input');
                    input.focus();
                    input.select();

                    const save = () => App.events.categories.saveRename(input, oldName);
                    input.onblur = save;
                    input.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); input.blur(); }};
                },

               async saveRename(inputEl, oldName) {
                    const newDisplayName = inputEl.value.trim();
                    let categories = App.settings.get('userCategories');
                    const categoryToUpdate = categories.find(c => c.name === oldName);

                    // If the new name is empty, or the same as the internal name, we reset it.
                    if (!newDisplayName || newDisplayName === oldName) {
                        if (categoryToUpdate) {
                            delete categoryToUpdate.displayName; // Remove the displayName property
                        }
                    } else {
                        // Check for duplicate display names before saving.
                        if (categories.some(c => c.displayName === newDisplayName && c.name !== oldName)) {
                            App.ui.showToast(`Display name "${newDisplayName}" is already in use.`, 'warning');
                            this.refreshManager(); // Re-render to show the original name
                            return;
                        }
                        // Set the new display name.
                        if (categoryToUpdate) {
                            categoryToUpdate.displayName = newDisplayName;
                        }
                    }

                    // Save the updated categories array to settings.
                    await App.settings.set('userCategories', categories);
                    App.ui.showToast(`Category display name updated.`, 'success');
                    
                    // Refresh the UI to reflect the change.
                    this.refreshManager();
                    this._refreshActiveView();
                },

                initiateDelete(catName) {
                    const articleCount = App.state.articles.filter(a => a.category === catName).length;
                    const otherCategories = App.settings.get('userCategories').filter(c => c.name !== catName);
                    const migrationOptions = otherCategories.map(c => `<option value="${c.name}">${App.util.getCategoryDisplayName(c.name)}</option>`).join('');

                    let migrateSection = '';
                    if (articleCount > 0) {
                        migrateSection = `
                            <h4>Option 1: Migrate (Safe)</h4>
                            <p>Move all ${articleCount} articles from "${catName}" to another category.</p>
                            <div style="display:flex; gap: 0.5rem; align-items: center;">
                                <select id="migrate-dest-category" class="text-input" style="flex-grow:1;">${migrationOptions}</select>
                                <button class="btn btn-primary" id="migrate-btn">Migrate</button>
                            </div>`;
                    }

                    App.ui.showCustomModal({
                        title: `âš ï¸ Delete '${catName}'?`,
                        message: `
                            <p>This category contains <strong>${articleCount} articles</strong>.</p>
                            ${migrateSection}
                            <h4 style="color: var(--danger-color); margin-top: 1.5rem;">Option 2: Delete All (Permanent)</h4>
                            <p>This will permanently delete the category AND all articles within it. This cannot be undone.</p>`,
                        buttons: [
                            { text: 'Cancel', className: 'btn-secondary', onClick: () => App.ui.closeModal() },
                            { text: `Delete All (${articleCount} Articles)`, className: 'btn-danger', onClick: () => {
                                App.ui.showConfirmationModal({
                                    title: 'Are you absolutely sure?',
                                    message: `This will permanently delete the '${catName}' category and all ${articleCount} articles within it. This action cannot be undone.`,
                                    confirmText: 'Yes, Delete Everything',
                                    onConfirm: () => App.events.categories.deleteAll(catName)
                                });
                            }}
                        ]
                    });

                    const migrateBtn = document.getElementById('migrate-btn');
                    if (migrateBtn) {
                        migrateBtn.onclick = () => {
                            const dest = document.getElementById('migrate-dest-category').value;
                            App.events.categories.migrateAndDelete(catName, dest);
                        };
                    }
                },
                
                async cycleColor(categoryName) {
                    let categories = App.settings.get('userCategories');
                    const categoryToUpdate = categories.find(c => c.name === categoryName);

                    if (categoryToUpdate) {
                        categoryToUpdate.colorIndex = (categoryToUpdate.colorIndex + 1) % App.util.getCategoryColorCount();
                        await App.settings.set('userCategories', categories);
                        this.refreshManager(); // Refresh the modal UI
                        this._refreshActiveView(); // Refresh the main app UI
                    }
                },

                async migrateAndDelete(sourceCat, destCat) {
                  
                    if (!document.getElementById('migration-overlay')) {
                        App.ui.closeModal();
                        App.ui.migrationScreen.show(`Migrating from '${sourceCat}'`);
                    }
                    
                    // STEP 1: Create the plan file before starting.
                    const plan = { operation: 'migrate', source: sourceCat, destination: destCat, status: 'pending' };
                    await App.fs.write('_category_operation_plan.json', plan);

                    try {
                        const articlesToMove = App.state.articles.filter(a => a.category === sourceCat);

                        for (let i = 0; i < articlesToMove.length; i++) {
                            if (App.ui.migrationScreen.state.isCancelled) {
                                await App.fs.write('_category_operation_plan.json', null); // Cleanup if cancelled
                                return;
                            }
                            const article = articlesToMove[i];
                            await App.storage.updateArticle(article.id, { category: destCat });
                            const progress = Math.round(((i + 1) / articlesToMove.length) * 80);
                            App.ui.migrationScreen.update(progress, `Moving article ${i + 1} of ${articlesToMove.length}...`);
                        }

                        if (App.ui.migrationScreen.state.isCancelled) {
                            await App.fs.write('_category_operation_plan.json', null);
                            return;
                        }

                        App.ui.migrationScreen.update(85, "Updating associated tasks...");
                        const tasksToMove = App.hub.state.tasks.filter(t => t.category === sourceCat);
                        if (tasksToMove.length > 0) {
                            tasksToMove.forEach(task => task.category = destCat);
                            await App.hub.data.saveTasks();
                        }
                        
                        App.ui.migrationScreen.update(95, "Finalizing category settings...");
                        let categories = App.settings.get('userCategories');
                        categories = categories.filter(c => c.name !== sourceCat);
                        await App.settings.set('userCategories', categories);

                        if (App.state.storageMode === 'browser') {
                            App.state.articles = await App.browserStore.getAllArticles();
                        }
                        
                        App.ui.migrationScreen.update(100, "Migration Complete!");
                        App.ui.showToast(`Moved ${articlesToMove.length} articles and deleted '${sourceCat}'.`, 'success');
                        
                        // STEP 2: Delete the plan file ONLY after all steps are successful.
                        await App.fs.write('_category_operation_plan.json', null);

                        this.refreshManager();
                        this._refreshActiveView();

                    } catch (error) {
                        console.error("Migration failed:", error);
                        App.ui.showToast("An error occurred during migration. The operation will resume on next launch.", "error");
                    } finally {
                        setTimeout(() => App.ui.migrationScreen.hide(), 1500);
                    }
                },

                async deleteAll(catName) {
                    if (!document.getElementById('migration-overlay')) {
                        App.ui.closeModal();
                        App.ui.migrationScreen.show(`Deleting '${catName}'`);
                    }

                    // STEP 1: Create the plan file.
                    const plan = { operation: 'delete', source: catName, status: 'pending' };
                    await App.fs.write('_category_operation_plan.json', plan);

                    try {
                        const articlesToDelete = App.state.articles.filter(a => a.category === catName);

                        for (let i = 0; i < articlesToDelete.length; i++) {
                            if (App.ui.migrationScreen.state.isCancelled) {
                                await App.fs.write('_category_operation_plan.json', null); // Cleanup if cancelled
                                return;
                            }
                            const article = articlesToDelete[i];
                            await App.storage.deleteArticle(article.id);
                            const progress = Math.round(((i + 1) / articlesToDelete.length) * 80);
                            App.ui.migrationScreen.update(progress, `Deleting article ${i + 1} of ${articlesToDelete.length}...`);
                        }

                        if (App.ui.migrationScreen.state.isCancelled) {
                            await App.fs.write('_category_operation_plan.json', null);
                            return;
                        }
                        
                        App.ui.migrationScreen.update(85, "Updating associated tasks...");
                        const tasksToMove = App.hub.state.tasks.filter(t => t.category === catName);
                        if (tasksToMove.length > 0) {
                            const defaultCategory = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                            tasksToMove.forEach(task => task.category = defaultCategory);
                            await App.hub.data.saveTasks();
                        }

                        App.ui.migrationScreen.update(95, "Finalizing category settings...");
                        let categories = App.settings.get('userCategories');
                        categories = categories.filter(c => c.name !== catName);
                        await App.settings.set('userCategories', categories);

                        if (App.state.storageMode === 'browser') {
                            App.state.articles = await App.browserStore.getAllArticles();
                        }
                        
                        App.ui.migrationScreen.update(100, "Deletion Complete!");
                        App.ui.showToast(`Deleted '${catName}' and ${articlesToDelete.length} articles.`, 'success');
                        
                        // STEP 2: Delete the plan file on success.
                        await App.fs.write('_category_operation_plan.json', null);

                        this.refreshManager();
                        this._refreshActiveView();
                    
                    } catch (error) {
                        console.error("Deletion failed:", error);
                        App.ui.showToast("An error occurred during deletion. The operation will resume on next launch.", "error");
                    } finally {
                        setTimeout(() => App.ui.migrationScreen.hide(), 1500);
                    }
                },
            },


            saveDropboxClientId() {
                const id = document.getElementById('dropbox-client-id-input').value.trim();
                App.settings.set('dropboxClientId', id);
                App.ui.showToast('Dropbox Client ID saved!', {type: 'success'});
                App.ui.closeModal(); App.ui.showDropboxGuideModal();
            },
            removeDropboxClientId() {
                App.settings.set('dropboxClientId', null);
                App.ui.showToast('Dropbox Client ID removed.');
                App.ui.closeModal(); App.ui.showDropboxGuideModal();
            },

            toggleCategoryHighlights() {
                const container = document.querySelector('.category-view-container');
                const toggle = document.getElementById('highlight-toggle');
                if (!container || !toggle) return;

                const isHiding = container.classList.toggle('hide-snippet-colors');
                toggle.classList.toggle('active', !isHiding);
                App.settings.set('categoryHighlightsVisible', !isHiding);
            },

            setCategoryLayout(mode) {
                App.settings.set('categoryLayout', mode);
                // RATIONALE: Re-rendering the entire view is the cleanest way to handle the significant
                // structural changes between List/Grid and the new Timeline layout.
                const container = document.querySelector('.category-view-container');
                if (container) {
                    const category = App.util.getOriginalCategoryName(container.querySelector('h2').textContent.split(': ')[1] || 'All');
                    App.ui.renderCategoryView(document.getElementById('category-view'), category);
                }
            },

            enterFocusMode(articleId) {
                const container = document.querySelector('.category-view-container');
                if (!container) return;

                const category = App.util.getOriginalCategoryName(container.querySelector('h2').textContent.split(': ')[1] || 'All');
                const sortedArticles = App.services.export.getSortedArticlesForCategory(category);

                // CHANGE START: Added 'blocks' to the types array to fetch timelines and charts
                const articlesWithContent = sortedArticles
                    .map(article => ({ ...article, snippets: App.util.extractSnippets(article, ['highlight', 'mcq', 'blocks'], true) }))
                    .filter(article => article.snippets.length > 0);
                // CHANGE END

                articlesWithContent.forEach(article => {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = article.content;
                    
                    // CHANGE START: Added selectors for new block types to ensure correct sorting order
                    const allElements = Array.from(tempDiv.querySelectorAll(
                        '.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, ' +
                        '.highlight-1, .highlight-2, .highlight-3, .highlight-4, .highlight-5, .highlight-6, .image-container.highlighted-image'
                    ));
                    // CHANGE END

                    article.snippets.sort((a, b) => {
                        // RATIONALE: This complex logic finds the original DOM element for each snippet
                        // and sorts them based on their actual order in the article content.
                        const elA = tempDiv.querySelector(`[id="${a.id}"]`);
                        const elB = tempDiv.querySelector(`[id="${b.id}"]`);
                        if (!elA || !elB) return 0;

                        const indexA = allElements.indexOf(elA);
                        const indexB = allElements.indexOf(elB);

                        return indexA - indexB;
                    });
                });

                const startIndex = articlesWithContent.findIndex(a => a.id === articleId);
                if (startIndex === -1) return;

                const articleForAnnotations = articlesWithContent[startIndex];
                App.state.focusSession = {
                    isActive: true,
                    articles: articlesWithContent,
                    currentIndex: startIndex,
                    isStageMode: false,
                    currentSlideIndex: 0,
                    scrollStops: [],
                    activeTheme: 'default',
                    isCinematicActive: false,
                    teleprompterActive: false,
                    annotations: articleForAnnotations.stageAnnotations ? JSON.parse(JSON.stringify(articleForAnnotations.stageAnnotations)) : {},
                };

                App.ui.renderFocusMode();
                document.addEventListener('keydown', this.handleFocusModeKeyDown);
                document.body.style.overflow = 'hidden';
            },

            enterFocusModeForCategory(categoryName) {
                const articlesForCategory = App.services.export.getSortedArticlesForCategory(categoryName);

                const articlesWithContent = articlesForCategory
                    .map(article => ({ ...article, snippets: App.util.extractSnippets(article, ['highlight', 'mcq', 'blocks'], true) }))
                    .filter(article => article.snippets.length > 0);

                if (articlesWithContent.length === 0) {
                    App.ui.showToast(`No snippets found in category "${categoryName}" to focus on.`, 'info');
                    return;
                }

                articlesWithContent.forEach(article => {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = article.content;

                    const allElements = Array.from(tempDiv.querySelectorAll(
                        '.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, ' +
                        '.highlight-1, .highlight-2, .highlight-3, .highlight-4, .highlight-5, .highlight-6, .image-container.highlighted-image'
                    ));

                    article.snippets.sort((a, b) => {
                        const elA = tempDiv.querySelector(`[id="${a.id}"]`);
                        const elB = tempDiv.querySelector(`[id="${b.id}"]`);
                        if (!elA || !elB) return 0;
                        return allElements.indexOf(elA) - allElements.indexOf(elB);
                    });
                });

                // The first article in the sorted list becomes the starting point.
                const startIndex = 0;

                App.state.focusSession = {
                    isActive: true,
                    articles: articlesWithContent,
                    currentIndex: startIndex,
                    isStageMode: false,
                    currentSlideIndex: 0,
                    scrollStops: [],
                    activeTheme: 'default',
                    isCinematicActive: false,
                    teleprompterActive: false,
                    annotations: {}, 
                };

                App.ui.renderFocusMode();
                document.addEventListener('keydown', this.handleFocusModeKeyDown);
                document.body.style.overflow = 'hidden';
            },

            exitFocusMode() {
                if (!App.state.focusSession.isActive) return;

                const coPilotToggle = document.getElementById('kash-copilot-toggle');
                if (coPilotToggle) coPilotToggle.style.display = 'none';
                // NEW: Save annotations before closing
                const session = App.state.focusSession;
                const article = session.articles[session.currentIndex];
                if (article) {
                    const currentAnnotations = JSON.stringify(article.stageAnnotations || {});
                    const newAnnotations = JSON.stringify(session.annotations);

                    if (currentAnnotations !== newAnnotations) {
                        // Find the original article in the main state to update it
                        const mainArticle = App.storage.getArticle(article.id);
                        if(mainArticle) {
                            mainArticle.stageAnnotations = JSON.parse(newAnnotations);
                            App.events.saveArticle({ isAutosave: true }); 
                        }
                    }
                }

                if (App.annotationEngine.state.isActive) {
                    App.annotationEngine.toggle(App.annotationEngine.state.context);
                }

                App.state.focusSession.isActive = false;
                const overlay = document.getElementById('focus-mode-overlay');
                if (overlay) {
                    overlay.removeEventListener('click', App.events.handleContentClick);
                    const bodyEl = overlay.querySelector('.focus-mode-body');
                    if (bodyEl) {
                        bodyEl.removeEventListener('mouseover', App.events.handleSpotlight);
                        bodyEl.removeEventListener('mouseout', App.events.handleSpotlight);
                    }
                    overlay.remove();
                }
                document.removeEventListener('keydown', this.handleFocusModeKeyDown);
                document.body.style.overflow = '';
            },


            navigateFocusMode(direction) {
                const { articles, currentIndex } = App.state.focusSession;
                if (!articles) return;
                const newIndex = currentIndex + direction;

                if (newIndex >= 0 && newIndex < articles.length) {
                    App.state.focusSession.currentIndex = newIndex;
                    App.ui.renderFocusMode();
                }
            },

            toggleStageMode() {
                const session = App.state.focusSession;
                session.isStageMode = !session.isStageMode;

                // Reset to the beginning when entering/exiting stage mode
                session.currentSlideIndex = 0; 
                session.scrollStops = [];

                // Re-render the focus mode with the new state
                App.ui.renderFocusMode();
            },

           navigateStageSlide(direction) {
                const session = App.state.focusSession;
                if (!session.isActive || !session.isStageMode) return;

                const newIndex = session.currentSlideIndex + direction;

                if (newIndex >= 0 && newIndex < session.scrollStops.length) {
                    session.currentSlideIndex = newIndex;

                    const body = document.querySelector('.focus-mode-body');
                    if (body) {
                        body.scrollTo({
                            top: session.scrollStops[newIndex],
                            behavior: 'smooth'
                        });
                    }
                    App.ui.renderFocusModeControls();
                    setTimeout(() => {
                        const container = document.querySelector('.focus-mode-body');
                        if (!container) return;
                        container.querySelectorAll('.spotlight-key-focus').forEach(el => el.classList.remove('spotlight-key-focus'));
                        const newFirstItem = container.querySelector('.is-visible');
                        if (newFirstItem) {
                            // Apply the spotlight to it, ready for the next ArrowDown press.
                            newFirstItem.classList.add('spotlight-key-focus');
                            newFirstItem.focus({ preventScroll: true });
                        }
                    }, 400); 
                }
            },


            toggleLaserPointer() {
                const overlay = document.querySelector('.focus-mode-overlay');
                const pointer = document.getElementById('laser-pointer');
                if (!overlay || !pointer) return;

                const isActive = overlay.classList.toggle('laser-active');
                pointer.style.display = isActive ? 'block' : 'none';
                
                // Ensure the button visually reflects the state
                document.getElementById('laser-pointer-toggle')?.classList.toggle('active', isActive);

                if (isActive) {
                    const moveHandler = (e) => {
                        pointer.style.left = `${e.clientX}px`;
                        pointer.style.top = `${e.clientY}px`;
                    };
                    overlay.addEventListener('mousemove', moveHandler);
                    overlay.laserMoveHandler = moveHandler; // Store reference to remove later
                } else {
                    if (overlay.laserMoveHandler) {
                        overlay.removeEventListener('mousemove', overlay.laserMoveHandler);
                    }
                }
            },

            async exportCurrentSlide() {
                if (typeof htmlToImage === 'undefined') {
                    App.ui.showToast("Capture library is not available.", { type: 'error' });
                    return;
                }

                const overlay = document.getElementById('focus-mode-overlay');
                if (!overlay) return;

                App.ui.showToast('Capturing slide...', { type: 'info' });

                try {
                    const blob = await htmlToImage.toBlob(overlay, {
                        pixelRatio: window.devicePixelRatio || 1,
                        filter: (node) => {
                            // This function tells the library to skip rendering any element that is a control bar.
                            const isControlElement = node.classList?.contains('stage-mode-controls') || 
                                                    node.id === 'annotation-toolbar' || 
                                                    node.classList?.contains('laser-pointer');
                            return !isControlElement;
                        }
                    });

                    await navigator.clipboard.write([
                        new ClipboardItem({ 'image/png': blob })
                    ]);

                    App.ui.showToast('Slide copied to clipboard!', { type: 'success' });
                } catch (err) {
                    console.error('Failed to copy slide to clipboard:', err);
                    App.ui.showToast('Could not copy image. Check browser permissions.', { type: 'error' });
                }
            },

           handleFocusModeKeyDown(e) {
                if (e.target.closest('#kash-copilot-sidebar')) {
                    return; 
                }    
                const session = App.state.focusSession;
                if (!session.isActive) return;

                const bodyEl = document.querySelector('.focus-mode-body');
                if (bodyEl) {
                    bodyEl.classList.toggle('spotlight-active', e.altKey);
                    if (!e.altKey) { bodyEl.querySelector('.spotlight')?.classList.remove('spotlight'); }
                }

                // --- NEW ROBUST LOGIC ---
                // First, handle the navigation keys unconditionally to prevent default browser scrolling.
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const direction = e.key === 'ArrowDown' ? 1 : -1;
                    
                    if (session.isCinematicActive && session.isStageMode) {
                        // In Cinematic mode, up/down navigates through snippets on the current slide
                        const overlay = document.getElementById('focus-mode-overlay');
                        const allItems = Array.from(overlay.querySelectorAll('.snippet, .nk-mcq-block, .nk-timeline-block, .chart-container, .nk-accordion'));
                        if (allItems.length === 0) return;

                        const currentIndex = allItems.findIndex(el => el.classList.contains('is-revealing'));
                        let nextIndex = currentIndex + direction;
                        nextIndex = Math.max(0, Math.min(allItems.length - 1, nextIndex));

                        if (currentIndex !== nextIndex || currentIndex === -1) {
                            allItems.forEach(item => item.classList.remove('is-revealing', 'spotlight-key-focus'));
                            const targetItem = allItems[nextIndex];
                            targetItem.classList.add('is-revealing', 'spotlight-key-focus');
                            targetItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            App.events.typewriter.start(targetItem);
                        }
                    } else {
                        // In all other modes, up/down navigates the spotlight
                        App.events.spotlight.navigate(direction);
                    }
                    return; // Arrow key action is handled.
                }

                // --- Handle all other keys ---
                if (session.isStageMode) {
                    // Only prevent default for keys we are actively handling in Stage Mode
                    const stageKeys = [' ', 'arrowright', 'pagedown', 'arrowleft', 'pageup', 'enter', 'b', 'd', 'c', 'l', 'w', 'p', 'escape', 'g', 'h'];
                    if (stageKeys.includes(e.key.toLowerCase())) {
                        e.preventDefault();
                        e.stopPropagation();
                    }

                    switch (e.key.toLowerCase()) {
                        case ' ': case 'arrowright': case 'pagedown': App.events.navigateStageSlide(1); break;
                        case 'arrowleft': case 'pageup': App.events.navigateStageSlide(-1); break;
                        case 'enter':
                            const focusedEl = document.querySelector('.spotlight-key-focus');
                            if (focusedEl) {
                                const accordionTrigger = focusedEl.querySelector('.nk-accordion-trigger');
                                if (accordionTrigger) {
                                    accordionTrigger.click();
                                } 
                                else if (focusedEl.classList.contains('nk-mcq-block')) {
                                    App.events.handleMcqAnswer({ target: focusedEl }, false);
                                }
                                else if (focusedEl.classList.contains('snippet')) {
                                    focusedEl.click();
                                }
                            }
                            break;
                        case 's': App.events.toggleStageMode(); break;
                        case 'b': document.querySelector('.focus-mode-overlay')?.classList.toggle('blackout-active'); break;
                        // LOCKED FEATURES
                        case 'd': // Annotation
                            if (!App.license.isPremium()) App.ui.showAscensionModal();
                            else App.annotationEngine.toggle('focus');
                            break;
                        case 'p': // Copy Slide Image
                            if (!App.license.isPremium()) App.ui.showAscensionModal();
                            else App.events.exportCurrentSlide();
                            break;
                        case 'g': // Cinematic Reveal
                            if (!App.license.isPremium()) App.ui.showAscensionModal();
                            else App.events.presentation.toggleCinematicMotion(document.querySelector('.stage-mode-controls .btn-icon[onclick*="toggleCinematicMotion"]'));
                            break;
                        case 'r': if(isAnnotationActive) App.annotationEngine.setTool('rect'); break;
                        case 'e': if(isAnnotationActive) App.annotationEngine.setTool('eraser'); break;
                        case 'x': App.events.annotation.clear(); break;
                        case 'c': 
                            if(isAnnotationActive) App.annotationEngine.cycleColor(); 
                            else App.events.presentation.cycleAmbiance(); 
                            break;
                        case 't': // NEW SHORTCUT
                            if(isAnnotationActive) App.annotationEngine.cycleThickness();
                            break;
                        case 'l': App.events.toggleLaserPointer(); break;
                        case 'w': App.events.annotation.toggleWhiteboard(document.querySelector('#annotation-toolbar .btn-icon[onclick*="toggleWhiteboard"]')); break;
                        
                        case 'h': document.querySelector('.stage-mode-controls .btn-icon[onclick*="toggleStageModeHighlights"]')?.click(); break;
                        case 'i': App.events.presentation.toggleTeleprompter(); break;
                        case '+':
                        case '=':
                            App.events.presentation.adjustTeleprompterFont(0.1);
                            break;
                        case '-':
                            App.events.presentation.adjustTeleprompterFont(-0.1);
                            break;

                        case 'escape':
                            const overlay = document.querySelector('.focus-mode-overlay');
                            if (overlay?.classList.contains('annotation-active')) App.events.annotation.toggle();
                            else if (overlay?.classList.contains('laser-active')) App.events.toggleLaserPointer();
                            else if (overlay?.classList.contains('blackout-active')) overlay.classList.remove('blackout-active');
                            else App.events.toggleStageMode();
                            break;
                    }
                } else { // Standard Focus Mode
                    const standardKeys = ['enter', 'escape', 'pagedown', 'pageup', 'arrowright', 'arrowleft', 'h', 's'];
                     if (standardKeys.includes(e.key.toLowerCase())) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    switch (e.key.toLowerCase()) {
                        case 'c': App.events.presentation.cycleAmbiance(); break; // Cycle Color
                        case 'e': // Font Size
                            const fontBtn = document.getElementById('focus-font-size-btn');
                            if (fontBtn) App.events.toggleFocusModeFontSize(fontBtn);
                            break;
                        case 'f': App.events.toggleFocusModeControls(); break; 
                        case 'enter':
                            const focusedEl = document.querySelector('.spotlight-key-focus');
                            if (focusedEl) {
                                const accordionTrigger = focusedEl.querySelector('.nk-accordion-trigger');
                                if (accordionTrigger) {
                                    accordionTrigger.click();
                                } 
                                else if (focusedEl.classList.contains('nk-mcq-block')) {
                                    App.events.handleMcqAnswer({ target: focusedEl }, false);
                                }
                                else if (focusedEl.classList.contains('snippet')) {
                                    focusedEl.click();
                                }
                            }
                            break;
                        case 'escape': App.events.exitFocusMode(); break;
                        case 'pagedown': case 'arrowright': App.events.navigateFocusMode(1); break;
                        case 'pageup': case 'arrowleft': App.events.navigateFocusMode(-1); break;
                        case 'h': document.querySelector('.focus-mode-controls .btn-icon[onclick*="toggleFocusModeHighlights"]')?.click(); break;
                        case 's': App.events.toggleStageMode(); break;
                    }
                }
            },



            toggleSnippetVisibility(event) {
                const snippet = event.currentTarget;
                snippet.classList.toggle('is-hidden');
            },
             toggleFocusModeFontSize(button) {
                const fontSizes = ['0.85rem', '1.0rem', '1.1rem', '1.2rem', '1.4rem', '1.6rem', '1.8rem', '2.0rem','2.2rem','2.4rem','2.6rem','2.8rem','3rem'];
                const body = document.querySelector('.focus-mode-body');
                if (!body || !button) return;

                // RATIONALE: Reading the current size from settings is more reliable than calculating from the DOM.
                const currentSize = App.settings.get('focusModeFontSize') || '1.1rem';
                const currentIndex = fontSizes.indexOf(currentSize);
                
                const nextIndex = (currentIndex + 1) % fontSizes.length;
                const newSize = fontSizes[nextIndex];

                // RATIONALE: We now update the CSS variable instead of the style directly. This is the correct pattern.
                body.style.setProperty('--focus-mode-font-size', newSize);
                button.querySelector('span').textContent = newSize.replace('rem','');
                App.settings.set('focusModeFontSize', newSize);
            },
            toggleFocusModeControls() {
                const overlay = document.querySelector('.focus-mode-overlay');
                const toggleBtn = document.getElementById('focus-mode-immersive-toggle');
                if (!overlay || !toggleBtn) return;

                const isHidden = overlay.classList.toggle('controls-hidden');

                // Define our new, clear icons
                const showIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M2.036 12.322a1.012 1.012 0 010-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>`;
                const hideIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.98 8.223A10.477 10.477 0 001.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.45 10.45 0 0112 4.5c4.756 0 8.773 3.162 10.065 7.498a10.523 10.523 0 01-4.293 5.774M6.228 6.228L3 3m3.228 3.228l3.65 3.65m7.894 7.894L21 21m-3.228-3.228l-3.65-3.65m0 0a3 3 0 10-4.243-4.243m4.242 4.242L9.88 9.88" /></svg>`;

                // Set the icon to represent the action that will happen when clicked
                toggleBtn.innerHTML = isHidden ? showIcon : hideIcon;
                toggleBtn.title = isHidden ? 'Show Controls' : 'Hide Controls';
            },

            toggleFocusModeHighlights(button) {
                const body = document.querySelector('.focus-mode-body');
                if (!body || !button) return;
                const isHiding = body.classList.toggle('hide-snippet-colors');
                button.classList.toggle('active', !isHiding);
                // RATIONALE: We link this to the same setting as the main category view for consistency.
                App.settings.set('categoryHighlightsVisible', !isHiding);
            },

            toggleStageModeHighlights(button) {
                const body = document.querySelector('.focus-mode-body');
                if (!body || !button) return;

                const isHiding = body.classList.toggle('hide-snippet-colors');
                button.classList.toggle('active', !isHiding);
                // Link this to the same setting as category/focus view for consistency
                App.settings.set('categoryHighlightsVisible', !isHiding);
            },

            triggerZipImport() {
                App.ui.showConfirmationModal({
                    title: 'Confirm Import',
                    message: 'Select a <b>.zip</b> backup or one or more <b>.notekash</b> / <b>.json</b> note files to import. Existing notes will be intelligently merged.',
                    confirmText: 'Proceed',
                    onConfirm: () => {
                        const input = document.getElementById('import-files-input'); // <-- Use new ID
                        input.onchange = (e) => { App.services.backup.handleFileImport(e.target.files); }; // <-- Call new handler
                        input.click();
                    }
                });
            },
        },
  

  // ==========================================================================
        // 3.13. SERVICES
        // ==========================================================================
        services: { 
            export: {
                getCategoryContent(category, sortedArticles, asMarkdown = false) {
                    return sortedArticles.map(article => {
                        const snippets = App.util.extractSnippets({ content: article.content, id: article.id }, 'highlight', asMarkdown);
                        if (snippets.length === 0) return '';
                        return (asMarkdown ? `## ${article.title}\n` : `Title: ${article.title}\n`) + snippets.map(s => (asMarkdown ? `- ${s.text}` : `â€¢ ${s.text}`)).join('\n');
                    }).filter(Boolean).join('\n\n');
                },
                getSortedArticlesForCategory(category) {
                    const sortBy = App.settings.get('categorySortBy') || 'updatedAt';
                    let articles = category === 'All' ? [...App.state.articles] : App.state.articles.filter(a => a.category === category);
                    
                    if (sortBy === 'random') return articles.sort(() => Math.random() - 0.5);
                    
                    articles.sort((a,b) => {
                        switch(sortBy) {
                            case 'createdAt': return new Date(a.createdAt) - new Date(b.createdAt);
                            case 'read': return (b.readCount || 0) - (a.readCount || 0);
                            case 'unread': return (a.readCount || 0) - (b.readCount || 0);
                            default: return new Date(b.updatedAt) - new Date(a.updatedAt);
                        }
                    });

                    if (sortBy === 'unread') articles = articles.filter(a => !a.readCount || a.readCount === 0);
                    if (sortBy === 'read') articles = articles.filter(a => a.readCount > 0);
                    return articles;
                },
                copyCategoryContent(category) {
                    const sortedArticles = this.getSortedArticlesForCategory(category);
                    const text = this.getCategoryContent(category, sortedArticles, false);
                    if (!text) return App.ui.showToast('No content to copy.');
                    navigator.clipboard.writeText(text).then(() => App.ui.showToast("Content copied!"));
                },
                copyCategoryContentAsMarkdown(category) {
                    const sortedArticles = this.getSortedArticlesForCategory(category);
                    const text = this.getCategoryContent(category, sortedArticles, true);
                    if (!text) return App.ui.showToast('No content to copy.');
                    navigator.clipboard.writeText(text).then(() => App.ui.showToast("Markdown content copied!"));
                },
                categoryAsText(category) {
                    const sortedArticles = this.getSortedArticlesForCategory(category);
                    const text = this.getCategoryContent(category, sortedArticles, false);
                    if (!text) return App.ui.showToast('No content to export.');
                    App.util.downloadBlob(new Blob([text], { type: 'text/plain' }), `${category}-highlights.txt`);
                },
                categoryAsPdf(category) {
                    if (typeof window.jspdf === 'undefined') { App.ui.showToast("PDF Export unavailable.", { type: 'error' }); return; }
                    const sortedArticles = this.getSortedArticlesForCategory(category);
                    const text = this.getCategoryContent(category, sortedArticles, false);
                    if (!text) return App.ui.showToast('No content to export.');
                    try {
                        const { jsPDF } = window.jspdf;
                        const doc = new jsPDF(); const m = 10; const l = 7; const h = doc.internal.pageSize.getHeight(); const w = doc.internal.pageSize.getWidth() - m * 2;
                        const lines = doc.splitTextToSize(text, w);
                        let y = m;
                        lines.forEach(line => { if (y + l > h - m) { doc.addPage(); y = m; } doc.text(line, m, y); y += l; });
                        doc.save(`${category}-highlights.pdf`);
                    } catch(e) { console.error("jsPDF error:", e); App.ui.showToast("Failed to generate PDF.", { type: 'error' }); }
                },
                copyCurrentArticleHighlights() {
                    const article = App.storage.getArticle(App.state.activeArticleId); if (!article) return;
                    const highlights = App.util.extractSnippets({ content: article.content, id: article.id }, 'highlight');
                    if (highlights.length === 0) return App.ui.showToast("No highlights to copy.");
                    const watermark = '\n\n---\nShared from notekash.com';
                    const text = `Title: ${article.title}\n\n` + highlights.map(h => h.text).join('\n\n') + watermark;
                    navigator.clipboard.writeText(text).then(() => App.ui.showToast("Title and highlights copied!"));
                },
                copyArticleSnippets(articleId) {
                    const article = App.storage.getArticle(articleId); if (!article) return;
                    const snippets = App.util.extractSnippets({ content: article.content, id: article.id }, 'highlight');
                    if (snippets.length === 0) return App.ui.showToast("No snippets to copy for this article.");
                    const text = `Title: ${article.title}\n` + snippets.map(s => `â€¢ ${s.text}`).join('\n');
                    navigator.clipboard.writeText(text).then(() => App.ui.showToast(`Snippets for "${article.title}" copied!`));
                },
                exportFlashcardsAsTxt() {
                    const cards = App.util.getSortedFlashcardsForDisplay();
                    if (cards.length === 0) return App.ui.showToast("No flashcards to export.");
                    const text = cards.map(c => c.fullText).join('\n\n---\n\n');
                    App.util.downloadBlob(new Blob([text], { type: 'text/plain;charset=utf-8' }), `${App.util.getCategoryDisplayName(App.settings.get('flashcardCategory') || 'All')}-flashcards.txt`);
                },
                exportFlashcardsAsTsv() {
                    const cards = App.util.getSortedFlashcardsForDisplay();
                    if (cards.length === 0) return App.ui.showToast("No flashcards to export.");
                    const tsvHeader = "Front\tBack\tDeck\tTags\n";
                    const tsvRows = cards.map(c => {
                        const article = App.storage.getArticle(c.articleId);
                        const tags = article?.tags?.join(' ') || '';
                        let front, back;
                        if (c.type === 'collapsible') {
                            front = c.frontText;
                            back = c.backText;
                        } else { // Cloze card
                            front = c.fullText;
                            back = ''; // Cloze cards are single-field in Anki
                        }
                        return [front, back, App.util.getCategoryDisplayName(c.category), tags].map(App.util.escapeForTsv).join('\t');
                    });
                    const tsvContent = tsvHeader + tsvRows.join('\n');
                    const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
                    App.util.downloadBlob(new Blob([bom, tsvContent], { type: 'text/tab-separated-values;charset=utf-8' }), `${App.util.getCategoryDisplayName(App.settings.get('flashcardCategory') || 'All')}-flashcards-anki.tsv`);
                },
            

                _getHtmlExportTemplate(title, bodyContent, themeName = 'light') {
                    const styles = getComputedStyle(document.documentElement);
                    const cssVars = [
                        '--bg-primary', '--bg-secondary', '--bg-tertiary', '--text-primary', '--text-secondary', 
                        '--border-color', '--primary-color', '--hl-text', '--category-pill-text',
                        '--hl-1-bg', '--hl-1-border', '--hl-2-bg', '--hl-2-border', '--hl-3-bg', '--hl-3-border', 
                        '--hl-4-bg', '--hl-4-border', '--hl-5-bg', '--hl-5-border', '--hl-6-bg', '--hl-6-border', 
                        '--hl-7-bg', '--hl-7-border', '--text-red', '--text-green', '--text-blue'
                    ].map(v => `${v}: ${styles.getPropertyValue(v)};`).join('\n');

                    const watermarkButtonHTML = `<a id="notekash-watermark" href="https://notekash.com" target="_blank" rel="noopener noreferrer">Source: notekash.com</a>`;
                    
                    // MASTER CSS: Generates the perfect "carved" look for the watermark AND pills based on the exported theme.
                    const getThemeAwareCSS = (theme) => {
                        const baseCSS = `
                            #notekash-watermark, .exported-pill {
                                display: inline-block;
                                padding: 8px 16px;
                                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                                font-size: 12px;
                                font-weight: 600;
                                text-decoration: none;
                                border-radius: 999px;
                                transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                            }
                            #notekash-watermark {
                                position: fixed;
                                bottom: 20px;
                                right: 25px;
                                z-index: 9999;
                            }
                            .exported-pills-container { margin-bottom: 2rem; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
                            .exported-pill.category { font-size: 13px; padding: 9px 18px; }
                        `;

                        switch (theme) {
                            case 'dark':
                                return baseCSS + `
                                    #notekash-watermark, .exported-pill { /* Honed Slate */
                                        background-color: #21262D;
                                        color: #8B949E;
                                        border: 1px solid #30363D;
                                        box-shadow: 0 4px 15px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.05);
                                        text-shadow: 0 -1px 1px rgba(0, 0, 0, 0.6);
                                    }
                                    #notekash-watermark:hover, .exported-pill:hover {
                                        color: #c9d1d9;
                                        transform: translateY(-2px);
                                        box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.05);
                                    }
                                `;
                            case 'sepia':
                                return baseCSS + `
                                    #notekash-watermark, .exported-pill { /* Aged Brass */
                                        background: linear-gradient(145deg, #d3c8b6, #fbf0d9);
                                        color: #7a6a57;
                                        border: 1px solid rgba(91, 70, 54, 0.3);
                                        box-shadow: 0 5px 20px rgba(91, 70, 54, 0.2), inset 0 1px 1px rgba(255, 255, 255, 0.7);
                                        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8), 0 -1px 1px rgba(91, 70, 54, 0.2);
                                    }
                                    #notekash-watermark:hover, .exported-pill:hover {
                                        color: #5b4636;
                                        transform: translateY(-2px);
                                        box-shadow: 0 10px 30px rgba(91, 70, 54, 0.3), inset 0 1px 1px rgba(255, 255, 255, 0.7);
                                    }
                                `;
                            default: // Light Theme
                                return baseCSS + `
                                    #notekash-watermark, .exported-pill { /* Polished Marble */
                                        background: linear-gradient(145deg, #e9ecef, #ffffff);
                                        color: var(--text-secondary);
                                        border: 1px solid var(--border-color);
                                        box-shadow: 0 5px 20px rgba(0,0,0,0.07), inset 0 1px 1px rgba(255,255,255,0.8);
                                        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.9), 0 -1px 1px rgba(0, 0, 0, 0.05);
                                    }
                                    #notekash-watermark:hover, .exported-pill:hover {
                                        color: var(--text-primary);
                                        transform: translateY(-2px);
                                        box-shadow: 0 10px 30px rgba(0,0,0,0.1), inset 0 1px 1px rgba(255,255,255,0.8);
                                    }
                                `;
                        }
                    };

                    const watermarkCSS = getThemeAwareCSS(themeName);

                    return `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>${title}</title><style>:root{${cssVars}}body{padding-bottom: 80px; font-family:Georgia,serif;background-color:var(--bg-primary);color:var(--text-primary);max-width:90ch;margin:2rem auto;line-height:1.7;font-size:1.15rem;padding:2rem;}img{max-width:100%;height:auto;}[class^="highlight-"]{padding:0.1em 0.3em;margin:0 -0.1em;border-radius:4px;color:var(--hl-text);border-bottom:2px solid;}.highlight-1{background-color:var(--hl-1-bg);border-color:var(--hl-1-border);}.highlight-2{background-color:var(--hl-2-bg);border-color:var(--hl-2-border);}.highlight-3{background-color:var(--hl-3-bg);border-color:var(--hl-3-border);}.highlight-4{background-color:var(--hl-4-bg);border-color:var(--hl-4-border);}.highlight-5{background-color:var(--hl-5-bg);border-color:var(--hl-5-border);}.highlight-6{background-color:var(--hl-6-bg);border-color:var(--hl-6-border);}.highlight-7{background-color:var(--hl-7-bg);border-color:var(--hl-7-border);}.text-red{color:var(--text-red);}.text-green{color:var(--text-green);}.text-blue{color:var(--text-blue);}.text-underline{text-decoration:underline;}blockquote{border-left:3px solid var(--primary-color);margin-left:0;padding-left:1.5em;color:var(--text-secondary);font-style:italic;}hr{border:none;border-top:1px solid var(--border-color);margin:2em 0;} ${watermarkCSS}</style></head><body>${bodyContent}${watermarkButtonHTML}</body></html>`;
                },

                exportArticleAsHtml() {
                    const article = App.storage.getArticle(App.state.activeArticleId); if (!article) return;
                    const categoryObj = App.settings.get('userCategories').find(c => c.name === article.category) || { name: article.category, colorIndex: 0 };
                    const categoryPill = `<div class="exported-pill category" style="background-color: ${App.util.getCategoryColor(categoryObj.colorIndex)}; color: var(--category-pill-text);">${App.util.getCategoryDisplayName(categoryObj.name)}</div>`;
                    const tagsPills = (article.tags || []).map(tag => `<div class="exported-pill">${App.state.tags[tag]?.displayName || tag}</div>`).join('');
                    const pillsHTML = `<div class="exported-pills-container">${categoryPill}${tagsPills}</div>`;

                    const bodyContent = `${pillsHTML}<h1>${article.title}</h1><hr>${App.util.parseShortcuts(article.content)}`;
                    const fullHtml = this._getHtmlExportTemplate(article.title, bodyContent, App.settings.get('theme'));
                    App.util.downloadBlob(new Blob([fullHtml], { type: 'text/html' }), `${App.util.slugify(article.title)}.html`);
                },

                async exportAsNoteKashFile() {
                    const articleId = App.state.activeArticleId;
                    if (!articleId || articleId === 'temp_new_article') {
                        App.ui.showToast('Please save the note once before exporting.', { type: 'error' });
                        return;
                    }

                    const article = App.storage.getArticle(articleId);
                    if (!article) {
                        App.ui.showToast('Article data is missing, cannot export.', { type: 'error' });
                        return;
                    }

                    const filename = `${App.util.slugify(article.title)}.notekash`;
                    const fileContent = JSON.stringify(article, null, 2);
                    const blob = new Blob([fileContent], { type: 'application/json' });
                    const file = new File([blob], filename, { type: 'application/json' });
                    
                    const shareData = {
                        title: `NoteKash Note: ${article.title}`,
                        text: `Here is the NoteKash note "${article.title}"`,
                        files: [file],
                    };

                    let shareSucceeded = false;
                    
                    if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                        try {
                            await navigator.share(shareData);
                            shareSucceeded = true; // Mark as successful
                            App.ui.showToast('Note shared!', { type: 'success' });
                        } catch (err) {
                            if (err.name === 'AbortError') {
                                shareSucceeded = true; // Mark as "handled"
                                App.ui.showToast('Share cancelled.', { type: 'info' });
                            } else {
                                console.warn('Web Share API failed, falling back to download:', err);
                                shareSucceeded = false;
                            }
                        }
                    }
                    if (!shareSucceeded) {
                        try {
                            App.util.downloadBlob(blob, filename);
                            App.ui.showToast('NoteKash file downloaded!', { type: 'success' });
                        } catch (downloadErr) {
                            console.error('Fallback download also failed:', downloadErr);
                            App.ui.showToast('Could not share or download the file.', { type: 'error' });
                        }
                    }
                },


                exportCategoryAsHtml(category) {
                    const sortedArticles = this.getSortedArticlesForCategory(category);
                    const articlesWithHighlights = sortedArticles
                        .map(article => ({ ...article, snippets: App.util.extractSnippets({ content: article.content, id: article.id }, 'highlight', true) }))
                        .filter(article => article.snippets.length > 0);

                    if (articlesWithHighlights.length === 0) { App.ui.showToast("No highlights in this category to export."); return; }
                    
                    const bodyContent = `<h1>Category: ${App.util.getCategoryDisplayName(category)}</h1>` + articlesWithHighlights.map(article => 
                        `<h2><b>${article.title}</b></h2>${article.snippets.map(s => `<p>${s.html}</p>`).join('')}`
                    ).join('<hr>');
                    
                    const fullHtml = this._getHtmlExportTemplate(`${App.util.getCategoryDisplayName(category)} Highlights`, bodyContent, App.settings.get('theme'));
                    App.util.downloadBlob(new Blob([fullHtml], { type: 'text/html' }), `${App.util.slugify(category)}-highlights.html`);
                }
            },
            image: {
                async processAndInsert(file) {
                    if (file.size > App.config.image.maxUploadSize) {
                        App.ui.showToast(`Image exceeds max size of ${App.config.image.maxUploadSize / 1024 / 1024}MB`, { type: 'error' });
                        return;
                    }

                    try {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                const { maxWidth } = App.config.image; // REMOVED jpegQuality from here
                                const jpegQuality = App.settings.get('jpegQuality'); // ADDED: Get quality from settings
                                
                                let { width, height } = img;
                                if (width > maxWidth) {
                                    height *= maxWidth / width;
                                    width = maxWidth;
                                }

                                canvas.width = width;
                                canvas.height = height;
                                ctx.drawImage(img, 0, 0, width, height);
                                
                                const dataUrl = canvas.toDataURL('image/jpeg', jpegQuality);

                                const html = `<div class="image-container" contenteditable="false"><img src="${dataUrl}" alt="${file.name}" data-original-width="${width}" data-original-height="${height}" style="width:${width}px; height:auto;"><div class="resize-handle resize-handle-se"></div></div>`;
                                document.execCommand('insertHTML', false, `<p>${html}</p><p><br></p>`);

                                // --- NEW: A single, final success message ---
                                const blob = App.util.dataURLtoBlob(dataUrl);
                                if (blob) {
                                    const finalSizeKb = (blob.size / 1024).toFixed(0);
                                    App.ui.showToast(`Image added - ${finalSizeKb}kb`, { type: 'success' });
                                }
                            };
                            img.onerror = () => {
                                App.ui.showToast("Image is corrupted or unsupported.", { type: 'error' });
                            };
                            img.src = e.target.result;
                        };
                        reader.onerror = () => {
                            App.ui.showToast("Failed to read image data from clipboard.", { type: 'error' });
                        };
                        reader.readAsDataURL(file);

                    } catch (error) {
                        App.ui.showToast("An error occurred while processing the image.", { type: 'error' });
                        console.error('Image Processing Error:', error);
                    }
                },

                async runOCR() {
                    const imageContainer = App.state.selectedImageContainer;
                    if (!imageContainer) return;
                    const img = imageContainer.querySelector('img');
                    if (!img || !img.src) {
                        App.ui.showToast('Image source not found.', { type: 'error' });
                        return;
                    }

                    if (typeof Tesseract === 'undefined') {
                        App.ui.showToast('OCR library is not loaded. Please check your internet connection.', 'error');
                        return;
                    }

                    let ocrToastId = App.ui.showToast('Preprocessing image...', { type: 'info', duration: 0 });

                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });

                        const imageToProcess = new Image();
                        imageToProcess.crossOrigin = "Anonymous"; 
                        
                        await new Promise((resolve, reject) => {
                            imageToProcess.onload = resolve;
                            imageToProcess.onerror = reject;
                            imageToProcess.src = img.src;
                        });

                        canvas.width = imageToProcess.width;
                        canvas.height = imageToProcess.height;
                        ctx.drawImage(imageToProcess, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        const threshold = App.settings.get('ocrThreshold') || 128; // A good starting point, can be made adjustable
                        for (let i = 0; i < data.length; i += 4) {
                            // Grayscale conversion using luminance formula
                            const luminance = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                            const color = luminance < threshold ? 0 : 255; // Apply threshold
                            data[i] = data[i + 1] = data[i + 2] = color;
                        }
                        ctx.putImageData(imageData, 0, 0);

                        App.ui.updateToast(ocrToastId, 'Initializing OCR engine...');

                        const worker = await Tesseract.createWorker('eng', 1, {
                            logger: m => {
                                if (m.status === 'recognizing text') {
                                    const progress = (m.progress * 100).toFixed(0);
                                    App.ui.updateToast(ocrToastId, `Recognizing text... ${progress}%`);
                                } else if (m.status !== 'initializing tesseract') {
                                    // Avoid showing less useful intermediate statuses
                                    App.ui.updateToast(ocrToastId, `Status: ${m.status}`);
                                }
                            }
                        });
                        
                        // RATIONALE: We now pass the preprocessed canvas to Tesseract, not the original image.
                        const { data: { text } } = await worker.recognize(canvas);
                        await worker.terminate();
                        App.ui.hideToast(ocrToastId);

                        if (!text.trim()) {
                            App.ui.showToast('No text could be extracted from this image.', 'warning');
                            return;
                        }

                        const ocrHtml = `
                            <blockquote>
                                <p>${App.util.escapeHtml(text)}</p>
                                <footer><small>â€” Text extracted from image</small></footer>
                            </blockquote>
                            <p><br></p>`;

                        const imageParentBlock = imageContainer.closest('p');
                        if (imageParentBlock) {
                            imageParentBlock.insertAdjacentHTML('afterend', ocrHtml);
                            App.state.isArticleDirty = true;
                            App.ui.showToast('Text extracted and added to note!', 'success');
                        } else {
                            document.execCommand('insertHTML', false, ocrHtml);
                            App.state.isArticleDirty = true;
                        }

                    } catch (error) {
                        if (ocrToastId) App.ui.hideToast(ocrToastId);
                        console.error('Tesseract.js OCR Error:', error);
                        App.ui.showToast('Could not perform OCR. Check console for details.', 'error');
                    }
                },
    
                copy(imageContainer) {
                    if (!imageContainer) return;
                    const img = imageContainer.querySelector('img');
                    if (!img || !img.src) {
                        App.ui.showToast('Image source not found.', { type: 'error' });
                        return;
                    }
                    const blob = App.util.dataURLtoBlob(img.src);
                    if (blob) {
                        const objectUrl = URL.createObjectURL(blob);
                        window.open(objectUrl, '_blank');
                        App.ui.showToast('Image opened in a new tab for copying.', { type: 'info' });
                    } else {
                        App.ui.showToast('Could not process image data.', { type: 'error' });
                    }
                },

                delete(imageContainer) {
                    if (!imageContainer) return;
                    const p = imageContainer.closest('p');
                    if (p) p.remove();
                    else imageContainer.remove();
                    App.events.deselectImage();
                    App.ui.showToast('Image removed.');
                }
            },

            migration: {
                async browserToFolder(handle) {
                    try {
                        const browserArticles = await App.browserStore.getAllArticles();
                        if (browserArticles.length === 0) {
                            return 'no_browser_data';
                        }

                        let folderHasData = false;
                        try {
                            await handle.getFileHandle('_index.json', { create: false });
                            folderHasData = true;
                        } catch (e) {
                            if (e.name !== 'NotFoundError') throw e;
                        }

                        let userResponse;

                        if (folderHasData) {
                            userResponse = await new Promise(resolve => {
                                App.ui.showCustomModal({
                                    title: 'Merge Data Sources?',
                                    message: `You have notes stored in your browser. This folder also contains notes. How would you like to proceed?<br><br><b>Merge is recommended.</b> It will intelligently combine both sources, keeping the newest version of each note.
                                            <div style="margin-top: 1rem; text-align: left;">
                                                <input type="checkbox" id="migration-backup-checkbox" checked>
                                                <label for="migration-backup-checkbox"> Create a backup of this folder before merging (Recommended)</label>
                                            </div>`,
                                    buttons: [
                                        { text: 'Use Folder Only', className: 'btn-secondary', onClick: () => { App.ui.closeModal(); resolve({ choice: 'use_folder_only' }); } },
                                        { text: 'Merge Notes', className: 'btn-primary', onClick: () => { 
                                            const shouldBackup = document.getElementById('migration-backup-checkbox').checked;
                                            App.ui.closeModal(); 
                                            resolve({ choice: 'merge', backup: shouldBackup }); 
                                        }},
                                        { text: 'Cancel', className: 'btn-secondary', onClick: () => { App.ui.closeModal(); resolve({ choice: 'cancelled' }); } }
                                    ]
                                });
                            });
                        } else {
                            userResponse = await new Promise(resolve => {
                                App.ui.showConfirmationModal({
                                    title: 'Copy Notes to New Folder?',
                                    message: `Would you like to copy your ${browserArticles.length} existing notes from the browser to this new, empty folder?`,
                                    confirmText: 'Yes, Copy Notes',
                                    onConfirm: () => resolve({ choice: 'merge', backup: false }),
                                    onCancel: () => resolve({ choice: 'use_folder_only' })
                                });
                            });
                        }

                        if (userResponse.choice !== 'merge') {
                            return userResponse.choice;
                        }

                        App.ui.migrationScreen.show("Migrating Notes");
                        const { backup: shouldBackup } = userResponse;

                        if (shouldBackup) {
                            App.ui.migrationScreen.update(10, 'Backing up current folder...');
                            const backupDirName = `notekash_backup_${new Date().toISOString().replace(/[:.]/g, '-')}`;
                            const backupHandle = await handle.getDirectoryHandle(backupDirName, { create: true });
                            for await (const entry of handle.values()) {
                                if (App.ui.migrationScreen.state.isCancelled) return 'cancelled';
                                if (entry.kind === 'file') {
                                    const file = await entry.getFile();
                                    const newFileHandle = await backupHandle.getFileHandle(entry.name, { create: true });
                                    const writable = await newFileHandle.createWritable();
                                    await writable.write(file);
                                    await writable.close();
                                }
                            }
                        }

                        // --- NEW: Read all articles in the destination folder to prepare for a smart merge.
                        App.ui.migrationScreen.update(30, 'Analyzing destination folder...');
                        const folderArticlesMap = new Map();
                        for await (const entry of handle.values()) {
                            if (App.ui.migrationScreen.state.isCancelled) return 'cancelled';
                            if (entry.kind === 'file' && entry.name.startsWith('art_')) {
                                try {
                                    const file = await entry.getFile();
                                    const article = JSON.parse(await file.text());
                                    if (article.id) {
                                        folderArticlesMap.set(article.id, article);
                                    }
                                } catch (e) { console.warn(`Could not parse ${entry.name} in destination folder.`); }
                            }
                        }

                        // --- NEW: Intelligently decide which articles to write based on existence and timestamp.
                        const articlesToWrite = [];
                        for (const browserArticle of browserArticles) {
                            const folderArticle = folderArticlesMap.get(browserArticle.id);
                            if (!folderArticle) {
                                articlesToWrite.push(browserArticle); // Article is new to the folder.
                            } else if (new Date(browserArticle.updatedAt) > new Date(folderArticle.updatedAt)) {
                                articlesToWrite.push(browserArticle); // Browser version is newer.
                            }
                            // If the folder version is the same or newer, it's skipped. No duplication, no data loss.
                        }

                        if (articlesToWrite.length === 0) {
                            App.ui.migrationScreen.hide();
                            App.ui.showToast('All notes are already up-to-date in the folder.', 'info');
                            return 'use_folder_only';
                        }

                        for (let i = 0; i < articlesToWrite.length; i++) {
                            if (App.ui.migrationScreen.state.isCancelled) return 'cancelled';
                            const article = articlesToWrite[i];
                            const progress = 50 + Math.round((i / articlesToWrite.length) * 45);
                            App.ui.migrationScreen.update(progress, `Copying newer note ${i + 1} of ${articlesToWrite.length}...`);
                            
                            const fileHandle = await handle.getFileHandle(`${article.id}.json`, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(JSON.stringify(article, null, 2));
                            await writable.close();
                        }

                        App.ui.migrationScreen.update(100, 'Migration Complete!');
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        App.ui.migrationScreen.hide();
                        return 'merge_successful';

                    } catch (err) {
                        console.error("Migration failed:", err);
                        App.ui.migrationScreen.hide();
                        App.ui.showToast('Migration process failed. Your data remains untouched.', 'error');
                        return 'error';
                    }
                }
            },

            backup: {
                async getAllDataAsFiles() {
                    const files = [];
                    const dataFileNames = ['settings.json', 'todos.json', 'pomodoro.json', 'quiz_stats.json', 'tags.json', 'visual-map-state.json', 'mind-map-state.json', App.storage.DELETED_RECORDS_FILENAME];

                    if (App.state.storageMode === 'fileSystem' && App.state.directoryHandle) {
                        for await (const entry of App.state.directoryHandle.values()) {
                            if (entry.kind === 'file' && entry.name.endsWith('.json')) {
                                const file = await entry.getFile();
                                files.push({ name: file.name, content: await file.text() });
                            }
                        }
                    } else { // Browser storage mode
                        const articles = await App.browserStore.getAllArticles();
                        articles.forEach(a => files.push({ name: `${a.id}.json`, content: JSON.stringify(a, null, 2) }));
                        
                        for (const fileName of dataFileNames) {
                            const data = await App.browserStore.getFile(fileName);
                            if (data) files.push({ name: fileName, content: JSON.stringify(data, null, 2) });
                        }
                    }
                    return files;
                },

                               async exportToZip() {
                    if (!window.JSZip) {
                        App.ui.showToast("Export library not loaded.", { type: 'error' });
                        return;
                    }

                    App.ui.migrationScreen.show("Exporting Notes");

                    try {
                        App.ui.migrationScreen.update(10, "Gathering all data...");
                        const allFiles = await this.getAllDataAsFiles();
                        
                        if (App.ui.migrationScreen.state.isCancelled) return;

                        if (allFiles.length === 0) {
                            App.ui.showToast("No data to export.", "warning");
                            return;
                        }

                        App.ui.migrationScreen.update(40, `Found ${allFiles.length} files to compress...`);
                        const zip = new JSZip();
                        allFiles.forEach(file => {
                            zip.file(file.name, file.content);
                        });

                        if (App.ui.migrationScreen.state.isCancelled) return;

                        App.ui.migrationScreen.update(80, "Compressing files...");
                        const blob = await zip.generateAsync({ type: 'blob' });

                        const filename = `notekash-backup-${new Date().toISOString().slice(0, 10)}.zip`;
                        App.util.downloadBlob(blob, filename);

                        App.ui.migrationScreen.update(100, "Done!");
                        App.ui.showToast("Backup created successfully!", "success");

                    } catch (error) {
                        console.error("Export to Zip failed:", error);
                        App.ui.showToast("Failed to create backup.", "error");
                    } finally {
                        // Ensures the loading screen is always hidden
                        setTimeout(() => App.ui.migrationScreen.hide(), 1000);
                    }
                },

                async handleFileImport(files) {
                    if (!files || files.length === 0) return;

                    const zipFiles = Array.from(files).filter(f => f.name.endsWith('.zip'));
                    const noteFiles = Array.from(files).filter(f => f.name.endsWith('.notekash') || f.name.endsWith('.json'));

                    if (zipFiles.length > 0) {
                        // If a zip is present, process it (as before) and ignore other files.
                        App.services.backup.importFromZip(zipFiles[0]);
                        if (noteFiles.length > 0) {
                            App.ui.showToast('Importing .zip file. Other selected notes were ignored.', 'info');
                        }
                        return;
                    }

                    if (noteFiles.length > 0) {
                        // This is the new logic for importing .notekash / .json files
                        App.ui.migrationScreen.show("Importing Notes");
                        let importedCount = 0;
                        let skippedCount = 0;
                        
                        const allLocalArticles = (App.state.storageMode === 'fileSystem')
                            ? (await App.storage.getAll()).articles
                            : await App.browserStore.getAllArticles();
                        const localArticlesMap = new Map(allLocalArticles.map(a => [a.id, a]));

                        for (let i = 0; i < noteFiles.length; i++) {
                            const file = noteFiles[i];
                            if (App.ui.migrationScreen.state.isCancelled) break;
                            const progress = Math.round(((i + 1) / noteFiles.length) * 100);
                            App.ui.migrationScreen.update(progress, `Importing "${file.name}"...`);

                            try {
                                const content = await file.text();
                                const article = JSON.parse(content);
                                
                                // Basic validation
                                if (article.id && article.title && article.content) {
                                    const localArticle = localArticlesMap.get(article.id);
                                    
                                    // Generate a new ID if it's a new note, but keep original ID logic for updates
                                    let newArticleId = article.id;
                                    let isNewNote = !localArticle;
                                    let isUpdate = localArticle && (new Date(article.updatedAt) > new Date(localArticle.updatedAt));

                                    if (isNewNote) {
                                        // It's a new note, but we must check if the ID already exists (e.g., duplicate import)
                                        // If ID is already in use, we must assign a new one to prevent conflicts.
                                        if(localArticlesMap.has(article.id)) {
                                            article.id = 'art_' + crypto.randomUUID(); // Assign new ID
                                        }
                                        await App.storage.createArticle(article);
                                        importedCount++;
                                    } else if (isUpdate) {
                                        // It's an update to an existing note
                                        await App.storage.updateArticle(article.id, article);
                                        importedCount++;
                                    } else {
                                        // Local version is same or newer, so we skip
                                        skippedCount++;
                                    }
                                }
                            } catch (e) {
                                console.warn(`Could not import file: ${file.name}`, e);
                                skippedCount++;
                            }
                        }

                        if (App.ui.migrationScreen.state.isCancelled) {
                            App.ui.migrationScreen.hide();
                            return;
                        }

                        App.ui.migrationScreen.hide();
                        App.ui.showToast(`Import complete! ${importedCount} notes added/updated, ${skippedCount} skipped. Reloading...`, 'success');
                        
                        // Reload the app to reflect all changes
                        setTimeout(() => window.location.reload(), 1500);
                    }
                },

                async importFromZip(file) {
                    if (!window.JSZip) {
                        App.ui.showToast("Import library not loaded.", { type: 'error' });
                        return;
                    }
                    
                    App.ui.migrationScreen.show("Importing Notes");

                    try {
                        const zip = await JSZip.loadAsync(file);
                        const filesToProcess = Object.keys(zip.files).filter(path => !zip.files[path].dir);
                        const totalFiles = filesToProcess.length;

                        let newCount = 0, updatedCount = 0, skippedCount = 0;

                        const allLocalArticles = (App.state.storageMode === 'fileSystem')
                            ? (await App.storage.getAll()).articles
                            : await App.browserStore.getAllArticles();
                        const localArticlesMap = new Map(allLocalArticles.map(a => [a.id, a]));

                        // Helper function for DRY code
                        const importDataFile = async (fileName) => {
                            const fileInZip = zip.file(fileName);
                            if (fileInZip) {
                                try {
                                    const data = JSON.parse(await fileInZip.async('string'));
                                    await App.fs.write(fileName, data);
                                } catch (e) {
                                    console.warn(`Could not parse ${fileName} in backup.`, e);
                                }
                            }
                        };
                        
                        // Process data files
                        await Promise.all([
                            importDataFile('todos.json'), importDataFile('pomodoro.json'),
                            importDataFile('quiz_stats.json'), importDataFile('settings.json'),
                            importDataFile('tags.json'), importDataFile('visual-map-state.json'),
                            importDataFile('mind-map-state.json')
                        ]);

                        const importedDeletedRecords = await (async () => {
                            const fileInZip = zip.file(App.storage.DELETED_RECORDS_FILENAME);
                            if (fileInZip) { try { return JSON.parse(await fileInZip.async('string')); } catch (e) { return []; } } return [];
                        })();
                        
                        const localDeletedRecords = await App.storage.getDeletedRecords();
                        const masterDeletedMap = new Map(localDeletedRecords.map(r => [r.id, r]));
                        importedDeletedRecords.forEach(r => { if (!masterDeletedMap.has(r.id)) masterDeletedMap.set(r.id, r); });

                        let processedFileCount = 0;
                        for (const path of filesToProcess) {
                            if (App.ui.migrationScreen.state.isCancelled) break;

                            processedFileCount++;
                            const progress = Math.round((processedFileCount / totalFiles) * 100);
                            App.ui.migrationScreen.update(progress, `Processing ${path}...`);

                            if (path.startsWith('art_') && path.endsWith('.json')) {
                                try {
                                    const importedData = JSON.parse(await zip.files[path].async('string'));
                                    if (importedData.id && importedData.title) {
                                        if (masterDeletedMap.has(importedData.id)) { skippedCount++; continue; }
                                        const localArticle = localArticlesMap.get(importedData.id);
                                        
                                        if (!localArticle) { await App.storage.createArticle(importedData); newCount++; } 
                                        else if (new Date(importedData.updatedAt) > new Date(localArticle.updatedAt)) { await App.storage.updateArticle(importedData.id, importedData); updatedCount++; } 
                                        else { skippedCount++; }
                                    }
                                } catch (e) { console.warn(`Skipping invalid file: ${path}`, e); }
                            }
                            // Yield to the browser to keep UI responsive
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                        
                        if (App.ui.migrationScreen.state.isCancelled) return; // Exit before final save if cancelled

                        await App.storage.saveDeletedRecords(Array.from(masterDeletedMap.values()));
                        await App.util.reconcileCategories();

                        let summary = `Import complete: ${newCount} new, ${updatedCount} updated, ${skippedCount} skipped. Reloading...`;
                        App.ui.showToast(summary, { type: 'success', duration: 6000 });

                        setTimeout(() => window.location.reload(), 1500);

                    } catch (error) {
                        console.error("Import from Zip failed:", error);
                        App.ui.showToast("Import failed. The zip file may be corrupt.", "error");
                    } finally {
                        App.ui.migrationScreen.hide();
                    }
                },
            },
            share: {
                async article() {
                    if (!navigator.share) {
                        App.ui.showToast('Share API not supported on this device.', 'warning');
                        return;
                    }

                    const article = App.storage.getArticle(App.state.activeArticleId);
                    if (!article) {
                        App.ui.showToast('Could not find the article to share.', 'error');
                        return;
                    }
                    
                    const categoryObj = App.settings.get('userCategories').find(c => c.name === article.category) || { name: article.category, colorIndex: 0 };
                    const categoryPill = `<div class="exported-pill category" style="background-color: ${App.util.getCategoryColor(categoryObj.colorIndex)}; color: var(--category-pill-text);">${App.util.getCategoryDisplayName(categoryObj.name)}</div>`;
                    const tagsPills = (article.tags || []).map(tag => `<div class="exported-pill">${App.state.tags[tag]?.displayName || tag}</div>`).join('');
                    const pillsHTML = `<div class="exported-pills-container">${categoryPill}${tagsPills}</div>`;

                    const bodyContent = `${pillsHTML}<h1>${article.title}</h1><hr>${App.util.parseShortcuts(article.content)}`;
                    const fullHtml = App.services.export._getHtmlExportTemplate(article.title, bodyContent);
                    
                    const blob = new Blob([fullHtml], { type: 'text/html' });
                    const file = new File([blob], `${App.util.slugify(article.title)}.html`, { type: 'text/html' });

                    if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        try {
                            await navigator.share({
                                files: [file],
                                title: article.title,
                                text: `Note: ${article.title}`,
                            });
                        } catch (err) {
                            if (err.name !== 'AbortError') {
                                console.error('File share failed:', err);
                                App.ui.showToast('Something went wrong while sharing.', 'error');
                            }
                        }
                    } else {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = article.content;
                        const textContent = tempDiv.textContent || tempDiv.innerText;
                        const textToCopy = `Title: ${article.title}\n\n${textContent}\n\n---\nSource: notekash.com`;
                        
                        await navigator.clipboard.writeText(textToCopy);
                        App.ui.showToast('File sharing not supported. Full article text has been copied to your clipboard instead!', { type: 'info', duration: 6000 });
                    }
                },
            },
            ai: {
                async queryGenerativeAI(systemPrompt, userPrompt) {
                    const provider = App.settings.get('aiProvider') || 'openrouter';
                    const modelName = App.settings.get('openRouterModel');
                    
                    let apiKey, apiUrl, headers, body;
                    const toastId = App.ui.showToast("AI is thinking...", { type: 'info', duration: 0 });

                    const maxRetries = 3;
                    let delay = 2000;

                    for (let attempt = 0; attempt < maxRetries; attempt++) {
                        try {
                            if (provider === 'gemini') {
                                apiKey = App.settings.get('geminiKey');
                                if (!apiKey) throw new Error("Google Gemini API key not set.");
                                const fullPrompt = `${systemPrompt}\n\n${userPrompt}`;
                                apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                                headers = { "Content-Type": "application/json" };
                                body = JSON.stringify({ "contents": [{ "parts": [{ "text": fullPrompt }] }] });
                            } else { // Default to OpenRouter
                                apiKey = App.settings.get('openRouterKey');
                                if (!apiKey) throw new Error("OpenRouter API key not set.");
                                apiUrl = "https://openrouter.ai/api/v1/chat/completions";
                                headers = { "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json", "HTTP-Referer": `${window.location.protocol}//${window.location.hostname}`, "X-Title": "NoteKash" };
                                body = JSON.stringify({ "model": modelName, "messages": [{ "role": "system", "content": systemPrompt }, { "role": "user", "content": userPrompt }] });
                            }

                            const response = await fetch(apiUrl, { method: "POST", headers, body });

                            if (response.ok) {
                                const data = await response.json();
                                let content = null;
                                if (provider === 'gemini') {
                                    content = data?.candidates?.[0]?.content?.parts?.[0]?.text;
                                } else {
                                    content = data?.choices?.[0]?.message?.content;
                                }
                                if (!content) throw new Error("AI returned an empty or invalid response structure.");
                                App.ui.hideToast(toastId);
                                return content;
                            }

                            const retriableStatusCodes = [429, 500, 503, 504];
                            if (retriableStatusCodes.includes(response.status) && attempt < maxRetries - 1) {
                                App.ui.updateToast(toastId, `Model is busy. Retrying in ${delay / 1000}s...`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                                delay *= 2;
                                continue;
                            }

                            if (response.status === 401) throw new Error("Invalid API Key. Please check it in Settings.");
                            const errorData = await response.json().catch(() => ({}));
                            const errorMessage = errorData?.error?.message || `API Error: ${response.status} ${response.statusText}`;
                            throw new Error(errorMessage);

                        } catch (error) {
                            // --- THIS IS THE NEW, SMARTER ERROR HANDLING ---
                            App.ui.hideToast(toastId);
                            console.error(`Generative AI Error (attempt ${attempt + 1}):`, error);

                            if (error.message.toLowerCase().includes('quota')) {
                                const friendlyMessage = 'API Quota Exceeded. Please upgrade your API plan or check your settings.';
                                App.ui.showToast(friendlyMessage, {
                                    type: 'error',
                                    duration: 10000,
                                    action: {
                                        label: 'Settings',
                                        callback: () => App.ui.showAiSettingsModal()
                                    }
                                });
                                // Also update the co-pilot bubble if it's open
                                if (App.coPilot.state.isOpen) {
                                    App.coPilot.updateLastMessage(`<p style="color:var(--danger-color);">${friendlyMessage}</p>`);
                                }

                                return null; // Stop retrying on quota errors.
                            }
                            
                            if (attempt === maxRetries - 1) {
                                App.ui.showToast(`AI Error: ${error.message}`, "error");
                                return null;
                            }

                            App.ui.updateToast(toastId, `Connection issue. Retrying in ${delay / 1000}s...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        }
                    }
                    
                    App.ui.hideToast(toastId);
                    App.ui.showToast("AI query failed after multiple retries.", "error");
                    return null;
                },
            }
        },


        // ==========================================================================
        // 3.13. UTILITIES
        // ==========================================================================
        util: {
                
            isMobile: () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
            
            escapeRegex(string) {
                return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            },
            escapeHtml: (u) => u ? u.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;") : '',
            
            icons: {
                eyeOpen: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>`, eyeClosed: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>`,
                textView: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5M3.75 17.25H12" /></svg>`,

                chevronUp: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>`,
                chevronDown: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>`,
                pen: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>`, edit: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="16 3 21 8 8 21 3 21 3 16 16 3"></polygon></svg>`, done: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`, 
                category: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>`, close: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`, 
                cycle: `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M12.433 10.07C14.133 9.585 16 8.007 16 6c0-2.208-1.79-4-4-4s-4 1.792-4 4c0 1.397.646 2.622 1.657 3.313-.42.223-.79.482-1.12.768-.907.643-1.482 1.458-1.752 2.313-.27.856-.333 1.632-.234 2.298C3.666 15.453 5.135 16 6.729 16c1.595 0 3.067-.547 4.143-1.523.27-.855.334-1.631.235-2.298-.27-.855-.846-1.67-1.753-2.312a4.996 4.996 0 0 1-1.12-.768zM6 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm2.5 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm2.5 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm.5 3a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/></svg>`, trash: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>`, list: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zm-3 1a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/></svg>`, table: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2zm15 2h-4v3h4V4zm0 4h-4v3h4V8zm0 4h-4v3h3a1 1 0 0 0 1-1v-2zm-5 3v-3H6v3h4zm-5 0v-3H1v2a1 1 0 0 0 1 1h3zm-4-4h4V8H1v3zm0-4h4V4H1v3zm5-3v3h4V4H6zm5 0v3h4V4h-4z"/></svg>`, 
                tag: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M2 2v4.586a1 1 0 0 0 .293.707l7 7a1 1 0 0 0 1.414 0l4.586-4.586a1 1 0 0 0 0-1.414l-7-7A1 1 0 0 0 7.586 2H2zm1 5.586 7 7L15.586 9l-7-7H3v4.586z"/><path d="M5 5a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/></svg>`, 
                copy: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`, html: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>`, clearFormatting: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.646 4.646a.5.5 0 0 1 .708 0L14 6.293l1.646-1.647a.5.5 0 0 1 .708.708L14.707 7l1.647 1.646a.5.5 0 0 1-.708.708L14 7.707l-1.646 1.647a.5.5 0 0 1-.708-.708L13.293 7l-1.647-1.646a.5.5 0 0 1 0-.708z"/><path d="M2.5 0A2.5 2.5 0 0 0 0 2.5v11A2.5 2.5 0 0 0 2.5 16h6.086a2.5 2.5 0 0 0 1.768-.732l3.5-3.5a2.5 2.5 0 0 0 0-3.536l-3.5-3.5A2.5 2.5 0 0 0 8.586 2H2.5zm5.553 4.24a.5.5 0 0 1 .707 0l1.25 1.25a.5.5 0 0 1 0 .707L8.707 7.5l1.25 1.25a.5.5 0 0 1-.707.707L8 8.207 6.75 9.457a.5.5 0 0 1-.707-.707L7.293 7.5 6.043 6.25a.5.5 0 0 1 0-.707l1.25-1.25z"/></svg>`, save: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1-1H7.5a1 1 0 0 0-1 1H2zm3 2h4.5v2.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V2zm7 0v2.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V2h4zM3 14v-7h10v7H3z"/></svg>`, saveAndRead: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/></svg>`, 
                expand: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M20.25 20.25v-4.5m0 4.5h-4.5m4.5 0L15 15m-6-6l-6 6m6-6l6-6" /></svg>`,
                zoomIn: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6" /></svg>`,
                zoomOut: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6" /></svg>`,
                article: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4.5 1h5a.5.5 0 0 1 .5.5v2h.5a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5-.5h-6a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5h.5v-2a.5.5 0 0 1 .5-.5zM5 1.5v2h4v-2H5zm0 3v10.5h4V4.5H5z"/></svg>`, reset: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>`, plus: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/></svg>`, minus: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/></svg>`, alignLeft: `<svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M2 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5z"/></svg>`, alignCenter: `<svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-2-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm2-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-2-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/></svg>`, alignRight: `<svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M6 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-4-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm4-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-4-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/></svg>`,
                star: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/></svg>`,
                starOutline: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M2.866 14.85c-.078.444.36.791.746.593l4.39-2.256 4.389 2.256c.386.198.824-.149.746-.592l-.83-4.73 3.522-3.356c.329-.313.158-.888-.283-.95l-4.898-.696L8.465.792a.5.5 0 0 0-.927 0L5.354 5.12l-4.898.696c-.441.062-.612.636-.283.95l3.523 3.356-.83 4.73zm4.905-2.767-3.686 1.894.694-3.957a.5.5 0 0 0-.182-.389l-2.832-2.767 3.958-.564a.5.5 0 0 0 .398-.293L8 2.223l1.791 3.582a.5.5 0 0 0 .398.293l3.958.564-2.832 2.767a.5.5 0 0 0-.182.389l.694 3.957-3.686-1.894a.5.5 0 0 0-.461 0z"/></svg>`,
                caption: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h4.414l.914.914A.5.5 0 0 0 7 13.5v-2.414l.914.914A.5.5 0 0 0 8 12.5h4a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/><path d="M4.5 5.5a.5.5 0 0 0 0 1h7a.5.5 0 0 0 0-1h-7zM4 8a.5.5 0 0 0 0 1h7a.5.5 0 0 0 0-1H4z"/></svg>`,
                theme: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg>`,
                pdf: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14 14V4.5L9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2zM9.5 3A1.5 1.5 0 0 0 11 4.5h2V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5v2z"/><path d="M4.603 14.087a.81.81 0 0 1-.438-.42c-.195-.388-.13-.776.08-1.102.198-.307.526-.568.896-.706a.5.5 0 0 1 .49.077c.11.1.128.26.043.46.015.015.03.036.043.06.104.194.104.456.027.75a.426.426 0 0 1-.252.3.5.5 0 0 1-.49-.077l-.022-.022a.426.426 0 0 1-.222.036z"/></svg>`,
                hint: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 001.5-1.832 5.97 5.97 0 00.832-3.585 5.97 5.97 0 00-3.417-5.585 5.97 5.97 0 00-6.833 2.166" /></svg>`,
                reversible: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21 3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" /></svg>`,
                actions: `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M5.52.359A.5.5 0 0 1 6 0h4a.5.5 0 0 1 .474.658L8.694 6H12.5a.5.5 0 0 1 .395.807l-7 9a.5.5 0 0 1-.873-.454L6.823 9.5H3.5a.5.5 0 0 1-.48-.641l2.5-8.5z"/></svg>`,

            },


            hapticFeedback(intensity = 'light') {
                if ('vibrate' in navigator) {
                    const pattern = intensity === 'heavy' ? [100] : [50];
                    navigator.vibrate(pattern);
                }
            },

            powerQuotes: [
                "Every master was once a beginner.", "The secret of getting ahead is getting started.",
                "Your only limit is your mind.", "Push yourself, because no one else is going to do it for you.",
                "Great things never come from comfort zones.", "Dream it. Wish it. Do it.",
                "Success doesnâ€™t just find you. You have to go out and get it.", "The harder you work, the luckier you get.",
                "Turn your can'ts into cans and your dreams into plans.", "Don't stop until you're proud."
            ],
            getPowerQuote() {
                return this.powerQuotes[Math.floor(Math.random() * this.powerQuotes.length)];
            },
            typewriter(element, text, speed = 75) {
                if (!element) return;
                element.innerHTML = '<span class="typewriter-cursor">|</span>'; // Start with just the cursor
                let i = 0;
                const typing = () => {
                    if (i < text.length) {
                        element.innerHTML = text.substring(0, i + 1) + '<span class="typewriter-cursor">|</span>';
                        i++;
                        setTimeout(typing, speed);
                    } else {
                    }
                };
                setTimeout(typing, speed);
            },

            wittyDeveloperMessages: [
                "Your support is my superpower!", "Fueling this app requires a lot of coffee.",
                "Developer is in Debt, He needs Help.", "Help me build the best note app in the universe!",
                "Developer needs some coffee to survive, could you help?", "I'm the solo dev behind NoteKash!",
                "Go Premium, and I'll name my next houseplant after you."
            ],

            maybeLaterMessages: [
                "Maybe Later", "I'm good for now", "Will help you Later",
                "Continue with Spark", "No Rush, Thanks", "I will Stay Free",
                "Not Today Dev", "Let me Study", "I am also Poor", "Maybe Soon",
                "Later, I Promise", "Keep me Free", "Will give you Nothing",
                "Let me Focus", "Let me Try First", "Will Upgrade Later",
                "I am on Budget", "Not that Valuable", "Happy as it is", "Will donate later"
            ],

            getRandomMessage(messageArray) {
                if (!messageArray || messageArray.length === 0) return '';
                return messageArray[Math.floor(Math.random() * messageArray.length)];
            },

            getTierBadgeHTML(tierName, size = 80) {    
                const tiers = {
                    Spark: {
                        tierClass: 'spark',
                        icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><circle cx="12" cy="12" r="5"/></svg>`
                    },
                    Bronze: {
                        tierClass: 'bronze',
                        icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><g class="orbiting-dots"><circle cx="5" cy="12" r="2"/><circle cx="19" cy="12" r="2"/></g></svg>`
                    },
                    Silver: {
                        tierClass: 'silver',
                        icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>`
                    },
                    Gold: {
                        tierClass: 'gold',
                        icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>`
                    },
                    Diamond: {
                        tierClass: 'diamond',
                        icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.49,6.51A2.12,2.12,0,0,0,16.88,6L12,2,7.13,6a2.12,2.12,0,0,0-2.62.51L2,11.84l10,10,10-10Z"/></svg>`
                    }
                };
                const tier = tiers[tierName] || tiers.Spark;
                const sizeStyle = `width: ${size}px; height: ${size}px;`;
                return `<div class="badge-icon astral ${tier.tierClass}" style="${sizeStyle}"><div class="inner-icon">${tier.icon}</div></div>`;
            },

            getCommandKey() { return navigator.platform.toUpperCase().includes('MAC') ? 'Cmd' : 'Ctrl'; },
            getCategoryDisplayName(originalName) {
                if (!originalName) return 'General'; // Failsafe
                const catObj = App.settings.get('userCategories').find(c => c.name === originalName);
                // Return the display name if it exists and is not empty, otherwise fall back to the original name.
                return catObj?.displayName || originalName;
            },

            getOriginalCategoryName(displayName) {
                if (!displayName) return 'General';
                const catObj = App.settings.get('userCategories').find(c => c.displayName === displayName);
                // If we find a match by display name, return its true, stable name.
                if (catObj) {
                    return catObj.name;
                }
                // Fallback for cases where the display name is the same as the original name.
                return displayName;
            },


            getCategoryColor(colorIndex) {
                return `var(--cat-color-${colorIndex}-bg)`;
            },
            getCategoryColorCount() {
                return 20; 
            },

            colorToRgb(color) {
                if (!color) return null;
                const tempDiv = document.createElement('div');
                tempDiv.style.color = color;
                document.body.appendChild(tempDiv);
                const rgbColor = window.getComputedStyle(tempDiv).color;
                document.body.removeChild(tempDiv);
                const match = rgbColor.match(/\d+/g);
                return match ? match.map(Number) : null;
            },
            async requestDurableStorage() {
                if (navigator.storage && navigator.storage.persist) {
                    try { if (!(await navigator.storage.persisted())) { await navigator.storage.persist(); } } 
                    catch (e) { console.warn("Could not request persistent storage:", e); }
                }
            },
            downloadBlob(blob, filename) {
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
            },
            
            insertGuardianBlock(html) {
                document.execCommand('insertHTML', false, html + '<p><br></p>');
                App.state.isArticleDirty = true;
            },

            extractSnippets(source = null, types = ['highlight'], returnHtml = false) {
                const sources = source ? [source] : App.state.articles.map(a => ({ content: a.content, id: a.id }));
                const results = [];
                const tempDiv = document.createElement('div');

                const selectors = {
                    highlight: '.highlight-1, .highlight-2, .highlight-3, .highlight-4, .highlight-5, .highlight-6, .text-red, .text-green, .text-blue',
                    image: '.image-container.highlighted-image',
                    textile: '.nk-text-tile',
                    mcq: '.nk-mcq-block',
                    accordion: '.nk-accordion',
                    blocks: '.nk-timeline-block, .chart-container',
                    tag: '.rendered-tag' 
                };

                sources.forEach(src => {
                    if (!src.content) return;
                    let final = App.util.renderClozeForDisplay(App.util.parseShortcuts(src.content));
                    tempDiv.innerHTML = App.util.sanitizeHTML(final);

                    let selectorsToQuery = [];
                    if (types.includes('highlight')) {
                        selectorsToQuery.push(selectors.highlight, selectors.image, selectors.textile);
                    }
                    if (types.includes('mcq')) {
                        selectorsToQuery.push(selectors.mcq);
                    }
                    if (types.includes('blocks')) {
                        selectorsToQuery.push(selectors.blocks, selectors.accordion);
                    }
                    
                    if (types.includes('tag')) {
                        selectorsToQuery.push(selectors.tag);
                    }
                    
                    const masterSelector = selectorsToQuery.join(', ');
                    if (!masterSelector) return;

                    tempDiv.querySelectorAll(masterSelector).forEach((node, index) => {
                        let snippetObject = null;

                        if (node.matches(selectors.tag)) {
                            const snippetId = node.id || `tag-snip-${src.id}-${index}`;
                            if (!node.id) node.id = snippetId;
                            // Find the parent block to get the full context
                            const parentBlock = node.closest('p, ul, ol, blockquote, h1, h2, h3, h4, h5, h6, li');
                            if (parentBlock) {
                                snippetObject = { 
                                    id: snippetId, 
                                    html: parentBlock.innerHTML, // Use the parent's full HTML for display
                                    text: (parentBlock.textContent || "").trim(), // Use the parent's text for searching
                                    articleId: src.id, 
                                    type: 'tag-snippet' 
                                };
                            }
                        } 
                        else if (node.matches(selectors.textile)) {
                            const snippetId = node.id || `tile-${src.id}-${index}`;
                            if (!node.id) node.id = snippetId;
                            snippetObject = { id: snippetId, html: node.outerHTML, text: (node.querySelector('.nk-text-tile-content')?.textContent || "").trim(), articleId: src.id, type: 'snippet' };
                        } 
                        else if (node.matches(selectors.image)) {
                            const img = node.querySelector('img');
                            if (img) {
                                const snippetId = node.id || `img-${src.id}-${index}`;
                                const caption = node.querySelector('.image-caption');
                                snippetObject = { id: snippetId, isImage: true, src: img.src, text: caption ? caption.textContent.trim() : '', html: node.outerHTML, articleId: src.id, type: 'snippet' };
                            }
                        } 
                        else if (node.matches(selectors.mcq)) {
                            const questionEl = node.querySelector('.nk-mcq-question');
                            if(questionEl) snippetObject = { id: `mcq-${src.id}-${index}`, html: node.outerHTML, text: (questionEl.textContent || "").trim(), articleId: src.id, type: 'mcq' };
                        }
                        else if (node.matches(selectors.accordion)) {
                            const titleEl = node.querySelector('.nk-accordion-title');
                            if(titleEl) snippetObject = { id: `accordion-${src.id}-${index}`, html: node.outerHTML, text: (titleEl.textContent || "").trim(), articleId: src.id, type: 'accordion' };
                        }
                        else if (node.matches(selectors.blocks)) {
                            if (node.matches('.nk-timeline-block')) {
                                const firstTitle = node.querySelector('.nk-timeline-title');
                                snippetObject = { id: `timeline-${src.id}-${index}`, html: node.outerHTML, text: `Timeline: ${firstTitle ? firstTitle.textContent.trim() : 'Event'}`, articleId: src.id, type: 'timeline' };
                            } else if (node.matches('.chart-container')) {
                                const canvas = node.querySelector('canvas');
                                if(canvas && canvas.dataset.chartConfig) snippetObject = { id: `chart-${src.id}-${index}`, html: node.outerHTML, text: `Chart Data`, articleId: src.id, type: 'chart' };
                            }
                        }
                        else if (node.matches(selectors.highlight)) {
                            const snippetId = node.id || `snip-${src.id}-${index}`;
                            snippetObject = { id: snippetId, html: node.outerHTML, text: (node.textContent || "").trim(), articleId: src.id, type: 'snippet' };
                        }

                        if (snippetObject) {
                            results.push(snippetObject);
                        }
                    });
                });
                return results.filter(s => (s.text && s.text.trim()) || s.isImage || s.type === 'accordion');

            },


            unwrapNode(node) {
                const p = node.parentNode; if (!p) return;
                while (node.firstChild) p.insertBefore(node.firstChild, node);
                try { p.removeChild(node); } catch(e) {}
            },
            fuzzySearch(query, items, key) {
                if (!query || !query.trim()) return items;
                if (!items || items.length === 0) return [];
                const searchTerms = query.toLowerCase().trim().split(/\s+/).filter(Boolean);
                return items.filter(item => {
                    if (!item) return false;
                    
                    let searchableText = '';
                    if (key === 'article') {
                        const title = item.title || '';
                        const tags = Array.isArray(item.tags) ? item.tags.join(' ') : '';
                        const content = item.content || '';
                        searchableText = `${title} ${tags} ${content}`;
                    } else if (key === 'flashcard') {
                        if (item.type === 'mcq') {
                            const optionsText = (item.options || []).map(o => o.text).join(' ');
                            searchableText = `${item.question || ''} ${optionsText} ${item.explanation || ''}`;
                        } else { // For Cloze and Collapsible cards
                            searchableText = item.fullText || `${item.frontText || ''} ${item.backText || ''}`;
                        }
                    }
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = searchableText;
                    const cleanText = (tempDiv.textContent || tempDiv.innerText || "").toLowerCase();
                    return searchTerms.every(term => cleanText.includes(term));
                });
            },
            renderClozeForDisplay(text) { return text ? text.replace(/{{c\d+::(.*?)}}/g, '<span class="cloze-flashcard">$1</span>') : ''; },
            
            
            parseShortcuts(text) {
                if (!text) return '';
                const createSnippetId = () => `snip-${crypto.randomUUID().slice(0, 12)}`;
                let processedHtml = text
                    .replace(/^\s*>\s*(.*)/gm, '<blockquote>$1</blockquote>')
                    .replace(/^\s*---\s*$/gm, '<hr>')
                    .replace(/\*\*(.*?)\*\*/g, '<i>$1</i>').replace(/\*([^*]+)\*/g, '<b>$1</b>')
                    
                    .replace(/__(.*?)__/g, '<span class="text-underline">$1</span>').replace(/~~(.*?)~~/g, '<del>$1</del>')
                    .replace(/==(.*?)==g/g, `<span class="highlight-2" id="${createSnippetId()}">$1</span>`).replace(/==(.*?)==b/g, `<span class="highlight-3" id="${createSnippetId()}">$1</span>`)
                    .replace(/==(.*?)==r/g, `<span class="highlight-4" id="${createSnippetId()}">$1</span>`).replace(/==(.*?)==p/g, `<span class="highlight-5" id="${createSnippetId()}">$1</span>`)
                    .replace(/==(.*?)==c/g, `<span class="highlight-6" id="${createSnippetId()}">$1</span>`).replace(/==(.*?)==m/g, `<span class="highlight-7" id="${createSnippetId()}">$1</span>`).replace(/==(.*?)==/g, `<span class="highlight-1" id="${createSnippetId()}">$1</span>`)
                    .replace(/::(.*?)_r::/g, `<span class="text-red" id="${createSnippetId()}">$1</span>`).replace(/::(.*?)_g::/g, `<span class="text-green" id="${createSnippetId()}">$1</span>`)
                    .replace(/::(.*?)_b::/g, `<span class="text-blue" id="${createSnippetId()}">$1</span>`).replace(/::(.*?)_m::/g, `<span class="text-magenta" id="${createSnippetId()}">$1</span>`);
                
                processedHtml = App.contentTools.convertContentSyntax(processedHtml);
                return processedHtml;
            },



            cyrb53(str, seed = 0) {
                let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
                for (let i = 0, ch; i < str.length; i++) {
                    ch = str.charCodeAt(i);
                    h1 = Math.imul(h1 ^ ch, 2654435761);
                    h2 = Math.imul(h2 ^ ch, 1597334677);
                }
                h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
                h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
                return 4294967296 * (2097151 & h2) + (h1 >>> 0);
            },
            
            extractFlashcards(html, articleId, category, existing) {
                const isPremium = App.license.isPremium();
                const totalFlashcards = isPremium ? 0 : this.getAllFlashcards().length;
                const flashcardLimit = App.config.sparkTierLimit;
                let canCreateMore = isPremium || totalFlashcards < flashcardLimit;
                let limitReachedMessageShown = false;
                
                const tempDiv = document.createElement('div'); tempDiv.innerHTML = html;
                const newCards = {};
                const checkAndShowLimitMessage = () => {
                    if (!canCreateMore && !limitReachedMessageShown) {
                        App.ui.showAscensionModal();
                        App.ui.showToast(`Flashcard limit of ${flashcardLimit} reached.`, 'warning');
                        limitReachedMessageShown = true;
                    }
                };

               const addEnhancedProperties = (existingCard) => ({
                    easeFactor: existingCard?.easeFactor || 2.5,   // Default ease factor for new cards.
                    lapses: existingCard?.lapses || 0,             // Leech counter starts at 0.
                });

                tempDiv.querySelectorAll('p, li, h1, h2, h3, h4, h5, h6, blockquote, td, th').forEach(p => {
                    if (p.innerHTML.includes('{{c')) {
                        const fullText = p.innerHTML;
                        const normalizedText = fullText.replace(/{{c\d+::(.*?)}}/g, '{{}}').replace(/\s+/g, ' ').trim();
                        const cardId = `chash_${this.cyrb53(normalizedText)}`;
                        const existingCard = existing[cardId] || Object.values(existing).find(c => c.fullText === fullText);
                        if (existingCard || canCreateMore) {
                            newCards[cardId] = { 
                                id: cardId, type: 'cloze', articleId, category, fullText, 
                                rating: existingCard?.rating || null, reviewCount: existingCard?.reviewCount || 0, 
                                interval: existingCard?.interval || 0, lastReviewed: existingCard?.lastReviewed || null, 
                                nextReviewDue: existingCard?.nextReviewDue || null, createdAt: existingCard?.createdAt || new Date().toISOString(), 
                                reviewHistory: existingCard?.reviewHistory || [],
                                ...addEnhancedProperties(existingCard) // âœ¨ ADDED THIS
                            };
                            if (!existingCard) canCreateMore = isPremium || (totalFlashcards + Object.keys(newCards).length) < flashcardLimit;
                        } else { checkAndShowLimitMessage(); }
                    }
                });

                tempDiv.querySelectorAll('.nk-accordion').forEach(cardEl => {
                    const frontEl = cardEl.querySelector('.nk-accordion-title'); 
                    const backEl = cardEl.querySelector('.nk-accordion-content');
                    const hintEl = cardEl.querySelector('.nk-accordion-hint-content');
                    if (!frontEl || !backEl) return;

                    const frontText = frontEl.innerHTML.trim(); 
                    const backText = backEl.innerHTML.trim();
                    const hintText = hintEl ? hintEl.innerHTML.trim() : null;
                    const isReversible = cardEl.dataset.reversible === 'true';
                    const cardId = `coll_${this.cyrb53(frontText + backText)}`;

                    if (cardId && frontEl && backEl) {
                        const isFrontEmpty = frontText === '' || frontText === '<p><br></p>'; const isBackEmpty = backText === '' || backText === '<p><br></p>';
                        if (isFrontEmpty || isBackEmpty) return;

                        const existingCard = existing[cardId];
                        const cardData = {
                            type: 'collapsible', articleId, category, rating: existingCard?.rating || null, 
                            reviewCount: existingCard?.reviewCount || 0, interval: existingCard?.interval || 0, 
                            lastReviewed: existingCard?.lastReviewed || null, nextReviewDue: existingCard?.nextReviewDue || null, 
                            createdAt: existingCard?.createdAt || new Date().toISOString(), reviewHistory: existingCard?.reviewHistory || [],
                            ...addEnhancedProperties(existingCard) // âœ¨ ADDED THIS
                        };
                        if (hintText) cardData.hint = hintText;

                        if (existingCard || canCreateMore) {
                            newCards[cardId] = { ...cardData, id: cardId, frontText, backText, isReversed: false };
                            if (!existingCard) canCreateMore = isPremium || (totalFlashcards + Object.keys(newCards).length) < flashcardLimit;
                        } else { checkAndShowLimitMessage(); }

                        if (isReversible) {
                            const reversedCardId = `${cardId}_rev`;
                            const existingReversedCard = existing[reversedCardId];
                            if (existingReversedCard || canCreateMore) {
                                newCards[reversedCardId] = {
                                    ...cardData,
                                    id: reversedCardId, frontText: backText, backText: frontText, isReversed: true,
                                    rating: existingReversedCard?.rating || null, reviewCount: existingReversedCard?.reviewCount || 0,
                                    interval: existingReversedCard?.interval || 0, lastReviewed: existingReversedCard?.lastReviewed || null,
                                    nextReviewDue: existingReversedCard?.nextReviewDue || null, createdAt: existingReversedCard?.createdAt || new Date().toISOString(),
                                    reviewHistory: existingReversedCard?.reviewHistory || [],
                                    ...addEnhancedProperties(existingReversedCard) // âœ¨ ADDED THIS
                                };
                                if (!existingReversedCard) canCreateMore = isPremium || (totalFlashcards + Object.keys(newCards).length) < flashcardLimit;
                            } else { checkAndShowLimitMessage(); }
                        }
                    }
                });

                tempDiv.querySelectorAll('.nk-mcq-block').forEach(mcqBlock => {
                    const questionEl = mcqBlock.querySelector('.nk-mcq-question');
                    if (!questionEl || !questionEl.textContent.trim()) return;

                    const questionText = questionEl.innerHTML.trim();
                    const options = Array.from(mcqBlock.querySelectorAll('.nk-mcq-option')).map(opt => ({
                        text: opt.querySelector('.nk-mcq-option-text').innerHTML.trim(),
                        isCorrect: opt.dataset.isCorrect === 'true'
                    })).filter(opt => opt.text);
                    
                    const explanationEl = mcqBlock.querySelector('.nk-mcq-explanation');
                    let explanationText = null;
                    if (explanationEl && explanationEl.textContent.trim()) {
                        explanationText = explanationEl.innerHTML;
                    }
                    if (options.length < 2 || !options.some(opt => opt.isCorrect)) return;

                    const allOptionsText = options.map(o => o.text).join('');
                    const cardId = `mcq_${this.cyrb53(questionText + allOptionsText)}`;

                    const existingCard = existing[cardId];
                    if (existingCard || canCreateMore) {
                        newCards[cardId] = {
                            id: cardId, type: 'mcq', articleId, category,
                            question: questionText, options: options, explanation: explanationText,
                            rating: existingCard?.rating || null, reviewCount: existingCard?.reviewCount || 0,
                            interval: existingCard?.interval || 0, lastReviewed: existingCard?.lastReviewed || null,
                            nextReviewDue: existingCard?.nextReviewDue || null, createdAt: existingCard?.createdAt || new Date().toISOString(),
                            reviewHistory: existingCard?.reviewHistory || [],
                            ...addEnhancedProperties(existingCard) // âœ¨ ADDED THIS
                        };
                        if (!existingCard) canCreateMore = isPremium || (totalFlashcards + Object.keys(newCards).length) < flashcardLimit;
                    } else { checkAndShowLimitMessage(); }
                });
                return newCards;
            },
                        
            getAllFlashcards() { return App.state.articles.flatMap(a => (a.flashcards ? Object.values(a.flashcards) : [])); },
            
            getAllTagsWithData() {
                const tagMap = new Map();
                App.state.articles.forEach(article => {
                    if (article.tags && article.tags.length > 0) {
                        const createdAtDate = new Date(article.createdAt);
                        const updatedAtDate = new Date(article.updatedAt);
                        article.tags.forEach(tag => {
                            if (!tagMap.has(tag)) {
                                tagMap.set(tag, { tag: tag, firstUsed: createdAtDate, lastUsed: updatedAtDate });
                            } else {
                                const existing = tagMap.get(tag);
                                if (createdAtDate < existing.firstUsed) existing.firstUsed = createdAtDate;
                                if (updatedAtDate > existing.lastUsed) existing.lastUsed = updatedAtDate;
                            }
                        });
                    }
                });
                return Array.from(tagMap.values());
            },

            getSortedFlashcardsForDisplay(searchTerm = '') {
                let cards = this.getAllFlashcards();
                let currentSearchTerm = searchTerm.trim();

                // NEW: Check for Rating filter
                const ratingMap = { '0': null, '1': 'Easy', '2': 'Good', '3': 'Hold', '4': 'Hard', '5': 'Again' };
                const ratingMatch = currentSearchTerm.match(/^([0-5])\s*(.*)/);

                if (ratingMatch) {
                    const ratingKey = ratingMatch[1];
                    const ratingFilter = ratingMap[ratingKey];
                    currentSearchTerm = ratingMatch[2].trim();
                    cards = cards.filter(c => c.rating === ratingFilter);
                }

                const category = App.settings.get('flashcardCategory') || 'All';
                const sortBy = App.settings.get('flashcardSortBy');
                if (category !== 'All') { cards = cards.filter(fc => fc.category === category); }
                if (currentSearchTerm) { cards = App.util.fuzzySearch(currentSearchTerm, cards, 'flashcard'); }
                
                switch(sortBy) {
                    case 'mcq':
                        cards = cards.filter(c => c.type === 'mcq');
                        cards.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)); // Default sort for MCQs is newest first
                        break;
                    case 'sm2': 
                        const ratingOrder = { 'Again': 1, 'Hard': 2, 'Hold': 3, 'Good': 4, 'Easy': 5 }; 
                        cards.sort((a,b) => (ratingOrder[a.rating] || 6) - (ratingOrder[b.rating] || 6) || (a.nextReviewDue ? new Date(a.nextReviewDue) : Infinity) - (b.nextReviewDue ? new Date(b.nextReviewDue) : Infinity)); 
                        break;
                    case 'random': 
                        cards.sort(() => Math.random() - 0.5); 
                        break;
                    case 'createdAt-asc': 
                        cards.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt)); 
                        break;
                    case 'createdAt-desc': 
                        cards.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)); 
                        break;
                    
                    case 'read': 
                        cards = cards.filter(c => c.rating !== null).sort((a,b) => new Date(b.lastReviewed) - new Date(a.lastReviewed)); 
                        break;
                    case 'unread': 
                        cards = cards.filter(c => c.rating === null).sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt)); 
                        break;
                    case 'leeches':
                        cards = cards.filter(c => (c.lapses || 0) >= App.config.sm2.leechThreshold);
                        cards.sort((a, b) => (b.lapses || 0) - (a.lapses || 0));
                        break;
                }
                return cards;
            },

            getDueFlashcards(allCategories = false) {
                let cards = this.getAllFlashcards();
                const category = App.settings.get('flashcardCategory') || 'All'; const now = new Date();
                if (category !== 'All' && !allCategories) { cards = cards.filter(fc => fc.category === category); }
                const dueCards = cards.filter(card => card.rating === null || (card.nextReviewDue && new Date(card.nextReviewDue) <= now));
                const ratingOrder = { 'Again': 1, 'Hard': 2, 'Hold': 3, 'Good': 4, 'Easy': 5 };
                dueCards.sort((a,b) => { const aIsNew = a.rating === null, bIsNew = b.rating === null; if (aIsNew && !bIsNew) return -1; if (!aIsNew && bIsNew) return 1; return (ratingOrder[a.rating] || 6) - (ratingOrder[b.rating] || 6); });
                return dueCards;
            },
            getAppStartDate() {
                if (App.state.articles.length === 0) { const now = new Date(); return { firstYear: now.getFullYear(), firstMonth: now.getMonth() }; }
                const firstTimestamp = Math.min(...App.state.articles.map(a => new Date(a.createdAt).getTime()));
                const firstDate = new Date(firstTimestamp);
                return { firstYear: firstDate.getFullYear(), firstMonth: firstDate.getMonth() };
            },
            getFlashcardStats() {
                const allCards = App.util.getAllFlashcards();
                return { total: allCards.length, due: App.util.getDueFlashcards(true).length, ratings: allCards.reduce((acc, card) => { const rating = card.rating || 'New'; acc[rating] = (acc[rating] || 0) + 1; return acc; }, {}) };
            },
            getReadingStats() {
                const stats = { total: 0, completed: 0, unread: 0, stages: {} };
                App.state.articles.forEach(article => {
                    stats.total++;
                    const readCount = article.readCount || 0;
                    if (readCount > 0) { stats.completed++; let stage = readCount >= 5 ? '5' : String(readCount); stats.stages[stage] = (stats.stages[stage] || 0) + 1; } 
                    else { stats.unread++; }
                });
                return stats;
            },
            getFlashcardStatsForPeriod(period) {
                const start = new Date(); start.setHours(0, 0, 0, 0); if (period === 'yesterday') start.setDate(start.getDate() - 1);
                const end = new Date(start); end.setHours(23, 59, 59, 999);
                let reviewed = 0;
                this.getAllFlashcards().forEach(card => {
                    if (card.reviewHistory && card.reviewHistory.length > 0) {
                        card.reviewHistory.forEach(ts => { const reviewDate = new Date(ts); if (reviewDate >= start && reviewDate <= end) reviewed++; });
                    }
                });
                return { reviewed };
            },
            getReadingStatsForPeriod(period) {
                const start = new Date(); start.setHours(0, 0, 0, 0); if (period === 'yesterday') start.setDate(start.getDate() - 1);
                const end = new Date(start); end.setHours(23, 59, 59, 999);
                let read = 0;
                App.state.articles.forEach(article => {
                    if (article.readHistory && article.readHistory.length > 0) {
                        article.readHistory.forEach(ts => { const readDate = new Date(ts); if (readDate >= start && readDate <= end) read++; });
                    }
                });
                return { read };
            },
            getFlashcardChartData(month, year) {
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const labels = Array.from({ length: daysInMonth }, (_, i) => i + 1); const data = Array(daysInMonth).fill(0);
                this.getAllFlashcards().forEach(card => {
                    if (card.reviewHistory) {
                        card.reviewHistory.forEach(ts => { const reviewDate = new Date(ts); if (reviewDate.getFullYear() === year && reviewDate.getMonth() === month) data[reviewDate.getDate() - 1]++; });
                    }
                });
                return { labels, data };
            },
            getReadingChartData(month, year) {
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const labels = Array.from({ length: daysInMonth }, (_, i) => i + 1); const data = Array(daysInMonth).fill(0);
                for (const article of App.state.articles) {
                    if (article.readHistory && Array.isArray(article.readHistory)) {
                        for (const timestamp of article.readHistory) { const readDate = new Date(timestamp); if (readDate.getFullYear() === year && readDate.getMonth() === month) data[readDate.getDate() - 1]++; }
                    }
                }
                return { labels, data };
            },

            getFlashcardReviewHeatmapData() {
                const history = App.quiz.stats.quizHistory || [];
                const reviewCounts = {};
                history.forEach(ts => {
                    const dateStr = ts.substring(0, 10);
                    reviewCounts[dateStr] = (reviewCounts[dateStr] || 0) + 1;
                });
                return reviewCounts;
            },

            getFlashcardForecastData() {
                const forecast = Array(30).fill(0);
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                const allCards = this.getAllFlashcards();
                allCards.forEach(card => {
                    if (card.nextReviewDue) {
                        const dueDate = new Date(card.nextReviewDue);
                        dueDate.setHours(0, 0, 0, 0);
                        const diffTime = dueDate - today;
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        
                        if (diffDays >= 0 && diffDays < 30) {
                            forecast[diffDays]++;
                        }
                    }
                });
                return forecast;
            },

            getCardEaseDistributionData() {
                const distribution = {
                    Leech: 0,       // EF < 1.8
                    Hard: 0,        // 1.8 <= EF < 2.2
                    Normal: 0,      // 2.2 <= EF < 2.8
                    Easy: 0,        // EF >= 2.8
                    New: 0
                };
                const allCards = this.getAllFlashcards();
                allCards.forEach(card => {
                    if (card.rating === null) {
                        distribution.New++;
                    } else {
                        const ef = card.easeFactor || 2.5;
                        if (ef < 1.8) distribution.Leech++;
                        else if (ef < 2.2) distribution.Hard++;
                        else if (ef < 2.8) distribution.Normal++;
                        else distribution.Easy++;
                    }
                });
                return distribution;
            },

            getReadProgressColorVar(readCount) {
                if (readCount <= 0) return '--rc-0-gray';
                if (readCount === 1) return '--rc-1-red';
                if (readCount === 2) return '--rc-2-orange';
                if (readCount === 3) return '--rc-3-pink';
                if (readCount === 4) return '--rc-4-purple';
                if (readCount === 5) return '--rc-5-indigo';
                if (readCount === 6) return '--rc-6-teal';
                if (readCount === 7) return '--rc-7-green-light';
                if (readCount === 8) return '--rc-8-green-med';
                if (readCount === 9) return '--rc-9-green-bright';
                return '--rc-10-green-best'; // 10+ reads
            },

            cleanFlashcardTextForDisplay(htmlString) {
                if (!htmlString) return '';
                let cleanText = htmlString.replace(/{{c\d+::(.*?)}}/g, '[$1]');
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = cleanText;
                return tempDiv.textContent || tempDiv.innerText || '';
            },

            escapeForTsv(str) {
                if (str === null || str === undefined) return '';
                let result = String(str);
                if (result.includes('\t') || result.includes('\n') || result.includes('"')) result = '"' + result.replace(/"/g, '""') + '"';
                return result;
            },

            sanitizeForTeleprompter(htmlString) {
                const allowedTags = [
                    'P', 'BR', 'B', 'I', 'U', 'STRONG', 'EM', 'SPAN', 
                    'UL', 'OL', 'LI', 'BLOCKQUOTE', 'HR',
                    'H1', 'H2', 'H3', 'H4', 'H5', 'H6'
                ];
                const allowedAttributes = {
                    'span': ['class'] // Only allow 'class' for highlights/text-colors
                };

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlString;
                const allNodes = tempDiv.querySelectorAll('*');

                allNodes.forEach(node => {
                    const tagName = node.tagName.toUpperCase();
                    if (!allowedTags.includes(tagName)) {
                        // We use unwrapNode to keep the text content (e.g., from a link)
                        App.util.unwrapNode(node);
                        return;
                    }
                    for (const attr of [...node.attributes]) {
                        const attrName = attr.name.toLowerCase();
                        const allowedForTag = allowedAttributes[tagName.toLowerCase()] || [];

                        if (!allowedForTag.includes(attrName)) {
                            node.removeAttribute(attr.name);
                        }
                    }
                });

                return tempDiv.innerHTML;
            },

            sanitizeHTML(htmlString) {
                const { allowedTags, allowedAttributes } = App.config.sanitizer;
                const tempDiv = document.createElement('div'); tempDiv.innerHTML = htmlString;
                tempDiv.querySelectorAll('script, style, link, meta, iframe, object, embed').forEach(el => el.remove());
                const allNodes = tempDiv.querySelectorAll('*');
                allNodes.forEach(node => {
                    const tagName = node.tagName.toUpperCase();
                    if (!allowedTags.includes(tagName)) { App.util.unwrapNode(node); return; }
                    for (const attr of [...node.attributes]) {
                        const attrName = attr.name.toLowerCase();
                        const allowedForTag = allowedAttributes[tagName.toLowerCase()] || [];
                        const allowedGlobally = allowedAttributes['*'] || [];
                        if (!allowedForTag.includes(attrName) && !allowedGlobally.includes(attrName)) node.removeAttribute(attr.name);
                    }
                });
                return tempDiv.innerHTML;
            },
            htmlToMarkdown(node) {
                let markdown = '';
                const BOLD_TAGS = ['B', 'STRONG'], ITALIC_TAGS = ['I', 'EM'], UNDERLINE_TAGS = ['U', 'SPAN'];
                if (BOLD_TAGS.includes(node.tagName)) markdown = `**${node.textContent.trim()}**`;
                else if (ITALIC_TAGS.includes(node.tagName)) markdown = `*${node.textContent.trim()}*`;
                else if (UNDERLINE_TAGS.includes(node.tagName) && node.classList.contains('text-underline')) markdown = `<u>${node.textContent.trim()}</u>`;
                else markdown = node.textContent.trim();
                return markdown;
            },
            trapFocus(element) {
                const focusableEls = element.querySelectorAll('a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input[type="text"]:not([disabled]), input[type="number"]:not([disabled]), input[type="range"]:not([disabled]), select:not([disabled])');
                if (focusableEls.length === 0) return;
                const firstFocusableEl = focusableEls[0], lastFocusableEl = focusableEls[focusableEls.length - 1];
                firstFocusableEl?.focus();
                element.addEventListener('keydown', function(e) {
                    if (e.key !== 'Tab') return;
                    if (e.shiftKey) { if (document.activeElement === firstFocusableEl) { lastFocusableEl.focus(); e.preventDefault(); } } 
                    else { if (document.activeElement === lastFocusableEl) { firstFocusableEl.focus(); e.preventDefault(); } }
                });
            },
            slugify(text) { return text.toString().toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, ''); },
            textToHtml(text) {
                const paragraphs = text.split(/(\r\n|\n){2,}/g);
                return paragraphs.filter(p => p && p.trim() !== '' && p !== '\n' && p !== '\r\n').map(p => `<p>${p.trim().replace(/\r\n|\n/g, '<br>')}</p>`).join('');
            },
            placeCursor(element, atStart = false) {
                const range = document.createRange(); const sel = window.getSelection(); range.selectNodeContents(element); range.collapse(atStart); sel.removeAllRanges(); sel.addRange(range);
            },
            restoreSelection() {
                if (App.state.savedRange) { const selection = window.getSelection(); selection.removeAllRanges(); selection.addRange(App.state.savedRange); }
            },
            escapeHtml: (u) => u ? u.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;") : '',
            sm2: {
                rateCard(card, rating) {
                    const now = new Date();

                    // Handle the "Bury" command first, as it's a special case.
                    if (rating === 'Hold') {
                        const nextReviewDate = new Date(now.getTime() + 24 * 60 * 60 * 1000); // 24 hours
                        return {
                            ...card,
                             rating: 'Hold', // Keep original rating
                            nextReviewDue: nextReviewDate.toISOString(),
                            lastReviewed: now.toISOString(),
                        };
                    }

                    let easeFactor = card.easeFactor || 2.5;
                    let reviewCount = card.reviewCount || 0;
                    let interval = card.interval || 0;
                    let lapses = card.lapses || 0;

                    // âœ¨ NEW: Branch logic. Is this the first time the user is rating this card?
                    if (reviewCount === 0) {
                        switch (rating) {
                            case 'Again':
                                lapses += 1;
                                easeFactor = Math.max(1.3, easeFactor - 0.20);
                                interval = 10 * 60 * 1000; // 10 minutes
                                reviewCount = 0; // Stays at 0 because it was incorrect
                                break;
                            case 'Hard':
                                easeFactor = Math.max(1.3, easeFactor - 0.15);
                                interval = 6 * 60 * 60 * 1000; // 6 hours
                                reviewCount = 1; // It was a successful, rated review
                                break;
                            case 'Good':
                                // No change to default easeFactor
                                interval = 12 * 60 * 60 * 1000; // 12 hours
                                reviewCount = 1;
                                break;
                            case 'Easy':
                                easeFactor += 0.15;
                                interval = 2 * 24 * 60 * 60 * 1000; // 2 days
                                reviewCount = 1;
                                break;
                        }
                    } else {
                        const qualityMap = { 'Again': 0, 'Hard': 2, 'Good': 4, 'Easy': 5 };
                        const quality = qualityMap[rating];

                        if (quality < 3) { // User rated 'Again'
                            lapses += 1;
                            easeFactor = Math.max(1.3, easeFactor - 0.20);
                            reviewCount = 0; // Reset consecutive correct reviews
                            interval = 90 * 60 * 1000; // Re-learn in 90 minutes
                        } else { // 'Hard', 'Good', or 'Easy'
                            reviewCount += 1;
                            interval = Math.round(interval * easeFactor);
                            
                            // Update ease factor based on performance
                            easeFactor += (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
                            if (easeFactor < 1.3) easeFactor = 1.3;
                        }
                    }
                    
                    const intervalModifier = App.settings.get('intervalModifier') || 1.0;
                    interval *= intervalModifier;

                    const fuzz = (Math.random() * 0.1) - 0.05; // +/- 5%
                    interval *= (1 + fuzz);

                    const minInterval = 60000; // 1 minute
                    interval = Math.max(minInterval, interval);

                    const nextReviewDue = new Date(now.getTime() + interval);
                    const reviewHistory = [...(card.reviewHistory || []), now.toISOString()];
                    
                    return {
                        rating,
                        reviewCount,
                        interval,
                        lastReviewed: now.toISOString(),
                        nextReviewDue: nextReviewDue.toISOString(),
                        reviewHistory,
                        easeFactor,
                        lapses,
                    };
                },
                getRatingColor(rating) {
                    if (!rating) return 'var(--sm2-unrated)';
                    const colorName = App.config.sm2.colors[rating];
                    return `var(--sm2-${colorName})`;
                }
            },
            formatTimestamp(isoString) {
                if (!isoString) return 'Never';
                const date = new Date(isoString); const now = new Date();
                const isToday = date.toDateString() === now.toDateString();
                now.setDate(now.getDate() - 1); const isYesterday = date.toDateString() === now.toDateString();
                const timeFormat = { hour: 'numeric', minute: 'numeric' };
                if (isToday) return `Today at ${date.toLocaleTimeString([], timeFormat)}`;
                if (isYesterday) return `Yesterday at ${date.toLocaleTimeString([], timeFormat)}`;
                return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
            },
            dataURLtoBlob(dataurl) {
                if (!dataurl || !dataurl.includes(',')) return null;
                try {
                    const parts = dataurl.split(',');
                    const mimeMatch = parts[0].match(/:(.*?);/);
                    if (!mimeMatch || mimeMatch.length < 2) return null;
                    const mime = mimeMatch[1];
                    const bstr = atob(parts[1]);
                    let n = bstr.length;
                    const u8arr = new Uint8Array(n);
                    while (n--) { u8arr[n] = bstr.charCodeAt(n); }
                    return new Blob([u8arr], { type: mime });
                } catch (e) {
                    console.error("Failed to convert data URL to blob:", e);
                    return null;
                }
            },
            getChartColors() {
                const theme = document.documentElement.getAttribute('data-theme') || 'light';
                const palettes = {
                    light: ['#0d9488', '#f97316', '#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#6366f1'],
                    dark: ['#E0B453', '#22c55e', '#60a5fa', '#a78bfa', '#f87171', '#f59e0b', '#34d399', '#c37aff'],
                    // --- UPGRADED SEPIA PALETTE FOR HIGH CONTRAST ---
                    sepia: ['#8c6d46', '#047857', '#a16207', '#5b4636', '#c2410c', '#4d7c0f', '#1d4ed8', '#be185d']
                };
                return palettes[theme] || palettes.light;
            },
            calculateQuizStreak() {
                const history = App.quiz.stats.quizHistory;
                if (!history || history.length === 0) {
                    return 0;
                }

                const uniqueDates = [...new Set(history.map(ts => ts.substring(0, 10)))].sort();
                
                if (uniqueDates.length === 0) {
                    return 0;
                }

                let streak = 0;
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);

                const todayStr = today.toISOString().substring(0, 10);
                const yesterdayStr = yesterday.toISOString().substring(0, 10);
                
                const lastQuizDateStr = uniqueDates[uniqueDates.length - 1];

                // If the last quiz wasn't today or yesterday, the streak is broken.
                if (lastQuizDateStr !== todayStr && lastQuizDateStr !== yesterdayStr) {
                    return 0;
                }
                
                // Start counting from the last quiz day.
                let currentDate = new Date(lastQuizDateStr + 'T12:00:00Z');

                for (let i = uniqueDates.length - 1; i >= 0; i--) {
                    const dateInHistory = uniqueDates[i];
                    const expectedDateStr = currentDate.toISOString().substring(0, 10);
                    
                    if (dateInHistory === expectedDateStr) {
                        streak++;
                        currentDate.setDate(currentDate.getDate() - 1); // Move to the previous day
                    } else {
                        // A day was missed, so the streak is broken.
                        break;
                    }
                }
                
                return streak;
            },
            getWeekNumber(d) {
                // Helper function to get the ISO week number for a given date
                d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
                d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
                const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
                const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
                return d.getUTCFullYear() + '-' + weekNo;
            },

            calculateWeeklyQuizStreak() {
                const history = App.quiz.stats.quizHistory;
                if (!history || history.length === 0) return 0;

                // Create a set of unique week identifiers (e.g., "2025-38")
                const uniqueWeeks = [...new Set(history.map(ts => this.getWeekNumber(new Date(ts))))].sort();
                if (uniqueWeeks.length === 0) return 0;
                
                let streak = 0;
                const today = new Date();
                const lastWeek = new Date();
                lastWeek.setDate(lastWeek.getDate() - 7);

                const currentWeekStr = this.getWeekNumber(today);
                const lastWeekStr = this.getWeekNumber(lastWeek);
                const lastQuizWeekStr = uniqueWeeks[uniqueWeeks.length - 1];

                // If the last quiz wasn't this week or last week, streak is broken
                if (lastQuizWeekStr !== currentWeekStr && lastQuizWeekStr !== lastWeekStr) {
                    return 0;
                }

                // Start counting backwards from the last quiz week
                let expectedWeek = new Date(today);
                for (let i = uniqueWeeks.length - 1; i >= 0; i--) {
                    const weekInHistory = uniqueWeeks[i];
                    const expectedWeekStr = this.getWeekNumber(expectedWeek);

                    if (weekInHistory === expectedWeekStr) {
                        streak++;
                        expectedWeek.setDate(expectedWeek.getDate() - 7); // Go back one week
                    } else {
                        break; // A week was missed
                    }
                }
                return streak;
            },

            getWeekCompletionData() {
                const quizHistory = App.quiz.stats.quizHistory || [];
                const completedDates = new Set(quizHistory.map(ts => ts.substring(0, 10)));
                const weekData = [];
                const today = new Date();
                
                // Set to the Monday of the current week
                const dayOfWeek = today.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
                const startOfWeek = new Date(today);
                startOfWeek.setDate(today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1)); // Adjust for Sunday

                const dayLetters = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];

                for (let i = 0; i < 7; i++) {
                    const currentDay = new Date(startOfWeek);
                    currentDay.setDate(startOfWeek.getDate() + i);
                    
                    const dateStr = currentDay.toISOString().substring(0, 10);
                    const todayStr = today.toISOString().substring(0, 10);

                    weekData.push({
                        dayLetter: dayLetters[i],
                        dateNumber: currentDay.getDate(),
                        isCompleted: completedDates.has(dateStr),
                        isToday: dateStr === todayStr
                    });
                }
                return weekData;
            },

            appreciationMessages: [
                "{name}, you are in the <strong>{tier} League</strong>",
                "{name}, you are our precious <strong>{tier} Member</strong>",
                "{name}, You are a <strong>{tier}</strong> in our Ecosystem",
                "Welcome Legend our Union will be Exquisitive",
                "Shine bright, my love {name}.",
                "Are you feeling the power of {tier} membership?",
                "{name} your IQ can match Elon Musk.",
                "{tier} suits {name}.",
                "{name} I can feel, you have Bright future ahead",
                "{tier} privileges on.",
                "{name}, pure {tier} vibes.",
                "Welcome to the <strong>{tier} League</strong>, {name}!",
                "Your support as a <strong>{tier} Member</strong> is amazing, {name}."
            ],
            cleanPastedStyles(element) {
                element.querySelectorAll('[style]').forEach(el => {
                    const style = el.getAttribute('style');
                    
                    const fontFamily = style.match(/font-family:\s*[^;]+/i)?.[0];
                    const fontSize = style.match(/font-size:\s*[^;]+/i)?.[0];

                    const newStyle = [fontFamily, fontSize].filter(Boolean).join('; ');

                    if (newStyle) {
                        el.setAttribute('style', newStyle);
                    } else {
                        el.removeAttribute('style');
                    }
                });
            },

            getAppreciationMessage(name, tier) {
                const messageTemplate = this.appreciationMessages[Math.floor(Math.random() * this.appreciationMessages.length)];
                return messageTemplate.replace('{name}', name).replace('{tier}', tier);
            },

            async reconcileCategories() {
                console.log("Reconciling categories...");
                const allArticles = App.state.articles;
                let userCategories = App.settings.get('userCategories');
                const existingCategoryNames = new Set(userCategories.map(c => c.name.toLowerCase()));
                let newCategoriesAdded = false;

                allArticles.forEach(article => {
                    const articleCategory = article.category;
                    if (articleCategory && !existingCategoryNames.has(articleCategory.toLowerCase())) {
                        console.log(`Found new category: ${articleCategory}. Adding to settings.`);
                        const newCategory = {
                            name: articleCategory,
                            colorIndex: userCategories.length % App.util.getCategoryColorCount(),
                            isDefault: false // New categories are never the default
                        };
                        userCategories.push(newCategory);
                        existingCategoryNames.add(articleCategory.toLowerCase());
                        newCategoriesAdded = true;
                    }
                });

                if (newCategoriesAdded) {
                    await App.settings.set('userCategories', userCategories);
                    App.ui.showToast('New categories from imported notes have been added!', 'success');
                }
                return newCategoriesAdded;
            },
            
            _transformMcqsForTeleprompter(htmlString) {
                if (!htmlString || !htmlString.includes('nk-mcq-block')) {
                    return htmlString; // No MCQs, return immediately.
                }

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlString;

                const mcqBlocks = tempDiv.querySelectorAll('.nk-mcq-block');
                if (mcqBlocks.length === 0) {
                    return htmlString; // No MCQs found by selector, return.
                }

                mcqBlocks.forEach(block => {
                    const questionEl = block.querySelector('.nk-mcq-question');
                    const options = block.querySelectorAll('.nk-mcq-option');

                    if (!questionEl || options.length === 0) return; // Malformed MCQ, skip it.
                    const questionText = questionEl.innerHTML;
                    const optionsHTML = Array.from(options).map(opt => {
                        const optionTextEl = opt.querySelector('.nk-mcq-option-text');
                        if (!optionTextEl) return '';
                        
                        const optionText = optionTextEl.innerHTML; // Get innerHTML to preserve styles
                        const isCorrect = opt.dataset.isCorrect === 'true';
                        return `<li>${isCorrect ? `<b>${optionText}</b>` : optionText}</li>`;
                    }).join('');
                    const newHtml = `
                        <p style="margin-top: 1em;"><b>Question:</b> ${questionText}</p>
                        <ul>${optionsHTML}</ul>
                    `;
                    block.outerHTML = newHtml;
                });

                return tempDiv.innerHTML;
            },
            _transformAccordionsForTeleprompter(htmlString) {
                if (!htmlString || !htmlString.includes('nk-accordion')) {
                    return htmlString; // No accordions, return immediately.
                }

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlString;

                const accordionBlocks = tempDiv.querySelectorAll('.nk-accordion');
                if (accordionBlocks.length === 0) {
                    return htmlString;
                }

                accordionBlocks.forEach(block => {
                    const titleEl = block.querySelector('.nk-accordion-title');
                    const contentEl = block.querySelector('.nk-accordion-content');

                    if (!titleEl || !contentEl) return; // Malformed, skip it.
                    const titleText = titleEl.innerHTML;
                    const contentText = contentEl.innerHTML;
                    const newHtml = `
                        <hr style="border-top: 1px dashed var(--border-color); margin: 1em 0;">
                        <p><b>Question:</b> ${titleText}</p>
                        <p><b>Answer:</b> ${contentText}</p>
                    `;
                    block.outerHTML = newHtml;
                });

                return tempDiv.innerHTML;
            },

            hexToRgba(hex, alpha) {
                if (!hex) return `rgba(0,0,0,${alpha})`;
                let r = 0, g = 0, b = 0;
                if (hex.length === 4) {
                    r = "0x" + hex[1] + hex[1];
                    g = "0x" + hex[2] + hex[2];
                    b = "0x" + hex[3] + hex[3];
                } else if (hex.length === 7) {
                    r = "0x" + hex[1] + hex[2];
                    g = "0x" + hex[3] + hex[4];
                    b = "0x" + hex[5] + hex[6];
                }
                return `rgba(${+r},${+g},${+b},${alpha})`;
            },

        },


        // ==========================================================================
        // 3.14. PRODUCTIVITY HUB MODULE (v2)
        // ==========================================================================
        hub: {
            state: { tasks: [], pomodoroStats: {}, elementThatOpenedHub: null },
            async loadData() {
                this.state.tasks = await App.fs.read('todos.json') || [];
                this.state.pomodoroStats = await App.fs.read('pomodoro.json') || {};
                await this.data.migratePomodoroDataIfNeeded();
                this.pomodoro.init();
                this.ui.updateTodoBadge();
            },
            data: {
                async saveTasks(tasksToSave) { await App.fs.write('todos.json', tasksToSave || App.hub.state.tasks); },
                async savePomodoroStats() { await App.fs.write('pomodoro.json', App.hub.state.pomodoroStats); },
                async migratePomodoroDataIfNeeded() {
                    let needsMigration = false;
                    const stats = App.hub.state.pomodoroStats;
                    for (const date in stats) { if (typeof stats[date] === 'number') { needsMigration = true; break; } }
                    if (needsMigration) {
                        const newStats = {};
                        for (const date in stats) { if (typeof stats[date] === 'number' && stats[date] > 0) newStats[date] = { 'General': stats[date] }; else newStats[date] = stats[date]; }
                        App.hub.pomodoro.state.pomodoroStats = newStats;
                        await this.savePomodoroStats();
                        App.ui.showToast('Pomodoro data format updated.', 'info');
                    }
                },
            },
            tasks: {
                state: { currentFilter: 'today', composer: { title: '', category: 'General', priority: 'low', due: new Date().toISOString().slice(0, 10), pomodoroGoal: 0 } },
                resetComposer() { const defaultCategoryName = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name; this.state.composer = { title: '', category: defaultCategoryName, priority: 'low', due: App.hub.util.getTodayISO(), pomodoroGoal: 0 }; },

                async add() {
                    const { title, category, priority, due, pomodoroGoal } = this.state.composer;
                    if (!title.trim()) return;
                    App.hub.state.tasks.push({ id: 'task_' + crypto.randomUUID(), title: title.trim(), category, priority, status: 'pending', due: due || App.hub.util.getTodayISO(), createdAt: new Date().toISOString(), completedAt: null, pomodoroGoal, pomodoros: 0 });
                    await App.hub.data.saveTasks(); this.resetComposer(); App.hub.ui.renderTaskComposer(); App.hub.ui.renderTaskList(); App.hub.ui.updateTodoBadge();
                    document.getElementById('composer-title-input')?.focus();
                },
                async deleteTask(id) {
                    const taskIndex = App.hub.state.tasks.findIndex(t => t.id === id); if (taskIndex === -1) return;
                    if (App.hub.pomodoro.state.task && App.hub.pomodoro.state.task.id === id) await App.hub.pomodoro.stopAndReset();
                    const taskEl = document.querySelector(`.task-item[data-id="${id}"]`);
                    if (taskEl) {
                        taskEl.classList.add('exiting');
                        taskEl.addEventListener('animationend', () => { taskEl.remove(); const container = document.getElementById('task-list-container'); if (container && container.childElementCount === 0) container.innerHTML = `<p style="text-align: center; color: var(--text-secondary); padding: 2rem;">No tasks here. Great job!</p>`; }, { once: true });
                    }
                    App.hub.state.tasks.splice(taskIndex, 1);
                    await App.hub.data.saveTasks(); App.hub.ui.updateTodoBadge();
                    App.ui.showToast('Task deleted.', 'info');
                },
                async toggleStatus(id, event) {
                    const task = App.hub.state.tasks.find(t => t.id === id); if (!task) return;
                    const isCurrentlyCompleted = task.status === 'completed';
                    task.status = isCurrentlyCompleted ? 'pending' : 'completed';
                    task.completedAt = isCurrentlyCompleted ? null : new Date().toISOString();
                    await App.hub.data.saveTasks(); App.hub.ui.updateTodoBadge();
                    const taskEl = document.querySelector(`.task-item[data-id="${id}"]`); if (!taskEl) return;
                    const shouldRemove = ['today', 'backlog', 'upcoming', 'completed'].includes(this.state.currentFilter);
                    if (!isCurrentlyCompleted) {
                        App.util.hapticFeedback('heavy'); // <-- ADD THIS LINE
                        App.ui.showToast("Great job! âœ¨", 'success');
                        const checkbox = event?.target;
                        if (checkbox) App.hub.ui.showConfetti(checkbox.getBoundingClientRect().left, checkbox.getBoundingClientRect().top);
                    }
                    taskEl.classList.toggle('completed', !isCurrentlyCompleted);
                    if (shouldRemove) {
                        taskEl.classList.add('exiting');
                        taskEl.addEventListener('animationend', () => { taskEl.remove(); if (document.getElementById('task-list-container')?.childElementCount === 0) App.hub.ui.renderTaskList(); }, { once: true });
                    }
                },
               getFilteredTasks() {
                const today = App.hub.util.getTodayISO();
                const allTasks = [...App.hub.state.tasks].sort((a,b) => { const pO = { high: 0, medium: 1, low: 2 }; return pO[a.priority] - pO[b.priority]; });
                switch(this.state.currentFilter) {
                    case 'today': return allTasks.filter(t => t.status === 'pending' && t.due === today);
                    case 'backlog': return allTasks.filter(t => t.status === 'pending' && t.due < today);
                    case 'upcoming': return allTasks.filter(t => t.status === 'pending' && t.due > today).sort((a,b) => new Date(a.due) - new Date(b.due));
                    case 'completed': return allTasks.filter(t => t.status === 'completed').sort((a,b) => new Date(b.completedAt) - new Date(a.completedAt));
                    default: return allTasks;
                }
             },
            },
            pomodoro: {
                state: { 
                    worker: null,
                    timerId: null,
                    mode: 'work', 
                    isRunning: false, 
                    timeLeft: 0, 
                    task: null, 
                    totalDuration: 0, 
                    currentCategory: 'General', 
                    sessionCount: 0, 
                    zenTitleVisible: true,
                    saveThrottleCounter: 0
                },
                init() {
                    try {
                        const workerBlob = new Blob([document.getElementById('pomodoro-worker-script').textContent]);
                        const workerUrl = URL.createObjectURL(workerBlob);
                        this.state.worker = new Worker(workerUrl);

                        this.state.worker.onmessage = (e) => {
                            const { type, timeLeft } = e.data;
                            if (type === 'tick') {
                                this.state.timeLeft = timeLeft;
                                if (timeLeft <= 0) {
                                    this.sessionEnd();
                                } else {
                                    this.state.saveThrottleCounter++;
                                    if (this.state.saveThrottleCounter >= 150) {
                                        this.saveSessionState();
                                        this.state.saveThrottleCounter = 0;
                                    }
                                }
                                App.hub.ui.updatePomodoroDisplay();
                            }
                        };
                    } catch (e) {
                        console.error("Failed to initialize Pomodoro worker. Timer may not work in background.", e);
                        App.ui.showToast("Background timer failed to start.", "error");
                    }
                    try {
                        const savedSession = localStorage.getItem('pomodoroSession');
                        if (savedSession) {
                            const sessionData = JSON.parse(savedSession);
                            if (sessionData.timeLeft > 0) {
                                if (sessionData.task) {
                                    this.state.timeLeft = sessionData.timeLeft;
                                    this.state.mode = sessionData.mode;
                                    this.state.task = sessionData.task;
                                    this.state.totalDuration = sessionData.totalDuration;
                                    this.state.sessionCount = sessionData.sessionCount;
                                    this.state.currentCategory = sessionData.task.category;
                                    this.state.isRunning = false;
                                } else {
                                    this.resetState(false);
                                    this.state.timeLeft = sessionData.timeLeft;
                                    this.state.totalDuration = this.state.timeLeft;
                                }
                                App.hub.ui.updatePomodoroDisplay();
                                App.ui.showToast('Pomodoro session restored.', 'info');
                                return;
                            }
                        }
                    } catch (e) {
                        console.error('Could not restore Pomodoro session:', e);
                        localStorage.removeItem('pomodoroSession');
                    }

                    this.resetState(false);
                },
                saveSessionState() {
                    if (!this.state.isRunning && this.state.timeLeft <= 0) return;
                    const sessionToSave = {
                        timeLeft: this.state.timeLeft,
                        mode: this.state.mode,
                        task: this.state.task,
                        totalDuration: this.state.totalDuration,
                        sessionCount: this.state.sessionCount,
                        isRunning: this.state.isRunning
                    };
                    localStorage.setItem('pomodoroSession', JSON.stringify(sessionToSave));
                },
                async startCycle(task = null) {
                    if (this.state.isRunning) await this.savePartialProgress();
                    this.state.sessionCount = 1; this.state.task = task;
                    this.resetState(false, 'work', App.settings.get('pomodoroWork'));
                    App.ui.showToast(`Starting Pomodoro Session 1 of 4.`, 'info');
                    this.resume();
                },
                togglePlayPause() { 
                    if (this.state.isRunning) this.pause();
                    else {
                        if (this.state.timeLeft === App.settings.get('pomodoroWork') * 60 && this.state.sessionCount === 0) this.startCycle(this.state.task);
                        else this.resume();
                    }
                },
                resume() {
                    if (this.state.isRunning || this.state.timeLeft <= 0) return; 
                    this.state.isRunning = true;
                    this.state.worker?.postMessage({ command: 'start', newTimeLeft: this.state.timeLeft });
                    App.hub.ui.updatePomodoroDisplay();
                },
                pause() {
                    if (!this.state.isRunning) return;
                    this.state.isRunning = false; 
                    this.state.worker?.postMessage({ command: 'pause' });
                    App.hub.ui.updatePomodoroDisplay();
                },
                async stopAndReset() {
                    this.state.isRunning = false;
                    this.state.worker?.postMessage({ command: 'stop' });
                    await this.savePartialProgress();
                    this.state.sessionCount = 0;
                    this.resetState(true);
                    localStorage.removeItem('pomodoroSession');
                },
                async savePartialProgress() { await this.saveProgress(this.state.totalDuration - this.state.timeLeft); },
                async saveProgress(elapsedSeconds) {
                    if (this.state.mode !== 'work' || elapsedSeconds < 5) return;
                    const { task } = this.state; const category = task?.category || 'General';
                    const today = App.hub.util.getTodayISO();
                    if (!App.hub.state.pomodoroStats[today]) App.hub.state.pomodoroStats[today] = {};
                    App.hub.state.pomodoroStats[today][category] = (App.hub.state.pomodoroStats[today][category] || 0) + elapsedSeconds;
                    await App.hub.data.savePomodoroStats();
                    if (task) {
                        task.pomodoros = (task.pomodoros || 0) + 1;
                        if (task.pomodoroGoal > 0 && task.pomodoros >= task.pomodoroGoal && task.status === 'pending') {
                            App.hub.tasks.toggleStatus(task.id); App.ui.showToast(`Task "${task.title}" auto-completed!`, 'success');
                            setTimeout(() => this.stopAndReset(), 1000);
                        }
                        await App.hub.data.saveTasks();
                        if(document.getElementById('productivity-modal')) App.hub.ui.renderTaskList();
                    }
                },
                resetState(shouldUpdateUI = true, mode = 'work', durationMins = App.settings.get('pomodoroWork')) {
                    this.state.mode = mode; this.state.timeLeft = durationMins * 60; this.state.totalDuration = this.state.timeLeft;
                    if (mode === 'work' && this.state.sessionCount === 0) this.state.task = null;
                    const defaultCategoryName = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                    this.state.currentCategory = this.state.task?.category || defaultCategoryName;
                    if (shouldUpdateUI) App.hub.ui.updatePomodoroDisplay();
                },
                async sessionEnd() {
                    this.pause(); const w = App.settings.get('pomodoroWork'), b = App.settings.get('pomodoroBreak');
                    if (this.state.mode === 'work') {
                        await this.saveProgress(this.state.totalDuration);
                        if (this.state.sessionCount > 0 && this.state.sessionCount < 4) {
                            App.ui.showToast(`Session ${this.state.sessionCount} complete! Time for a break.`, 'success', 8000);
                            this.resetState(false, 'break', b); this.resume();
                        } else {
                            App.ui.showToast(`Pomodoro cycle complete! Great work!`, 'success', 10000);
                            this.state.sessionCount = 0; this.resetState(true, 'work', w);
                            localStorage.removeItem('pomodoroSession');
                        }
                    } else { 
                        this.state.sessionCount++; App.ui.showToast(`Break over! Starting session ${this.state.sessionCount} of 4.`, 'info', 5000);
                        this.resetState(false, 'work', w); this.resume();
                    }
                },
                toggleZenMode() {
                    const c = document.getElementById('zen-mode-container');
                    if (c.innerHTML) c.innerHTML = ''; else App.hub.ui.renderZenMode();
                },
                toggleZenTitleVisibility() { this.state.zenTitleVisible = !this.state.zenTitleVisible; App.hub.ui.renderZenMode(true); },
                async changeTime(work, brk) {
                    await App.settings.set('pomodoroWork', parseInt(work, 10) || 25); 
                    await App.settings.set('pomodoroBreak', parseInt(brk, 10) || 5);
                    this.stopAndReset(); App.ui.closeModal(null, true); App.ui.showToast(`Timer settings saved!`, 'success');
                },
                getProgressInfo() {
                    const { timeLeft, totalDuration } = this.state;
                    if (totalDuration === 0) return { percentage: 1, colorValue: 'var(--pomo-color-12)' };
                    const p = (totalDuration - timeLeft) / totalDuration;
                    const c = ['--pomo-color-1','--pomo-color-2','--pomo-color-3','--pomo-color-4','--pomo-color-5','--pomo-color-6','--pomo-color-7','--pomo-color-8', '--pomo-color-9', '--pomo-color-10', '--pomo-color-11', '--pomo-color-12'];
                    return { percentage: p, colorValue: `var(${c[Math.min(c.length - 1, Math.floor(p * c.length))]})` };
                }
            },

            util: {
                getTodayISO: () => new Date().toISOString().slice(0, 10),
                getYesterdayISO: () => new Date(Date.now() - 864e5).toISOString().slice(0, 10),
                formatTime: (s) => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`,
                formatSecondsToDecimalHours(seconds) { if (!seconds || seconds < 1) return "0.0 hr"; return `${(seconds / 3600).toFixed(1)} hr`; },
                escapeHtml: (u) => u ? u.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;") : '',
                parseSimpleDate(d) {
                    if (!d) return null;
                    const cleanDate = d.replace(/[.\/]/g, '-'); const parts = cleanDate.split('-').map(Number);
                    if (parts.length !== 3 || parts.some(isNaN)) return null;
                    let day = parts[0], month = parts[1], year = parts[2]; if (year < 100) year += 2000;
                    if (month < 1 || month > 12 || day < 1 || day > 31) return null;
                    try {
                        const date = new Date(Date.UTC(year, month - 1, day));
                        if (date.getUTCFullYear() !== year || date.getUTCMonth() !== month - 1 || date.getUTCDate() !== day) return null;
                        return date.toISOString().slice(0, 10);
                    } catch(e) { return null; }
                },
                getDashboardStats() {
                    const { tasks, pomodoroStats } = App.hub.state;
                    const todayISO = this.getTodayISO(), yesterdayISO = this.getYesterdayISO();
                    let dailyTotals = {}, categoryTotals = {};
                    for (const date in pomodoroStats) {
                        dailyTotals[date] = Object.values(pomodoroStats[date]).reduce((sum, s) => sum + s, 0);
                        for (const category in pomodoroStats[date]) { categoryTotals[category] = (categoryTotals[category] || 0) + pomodoroStats[date][category]; }
                    }
                    const recordedDays = Object.values(dailyTotals).filter(t => t > 0);
                    const totalTime = recordedDays.reduce((a, b) => a + b, 0);
                    const completedTasks = tasks.filter(t => t.status === 'completed');
                    const pendingTasks = tasks.filter(t => t.status === 'pending');
                    const backlog = pendingTasks.filter(t => t.due < todayISO).length;
                    const upcoming = pendingTasks.filter(t => t.due > todayISO).length;

                    return {
                        pomodoro: { today: dailyTotals[todayISO] || 0, yesterday: dailyTotals[yesterdayISO] || 0, average: recordedDays.length ? totalTime / recordedDays.length : 0, best: Math.max(0, ...Object.values(dailyTotals)), categories: Object.entries(categoryTotals).sort((a, b) => b[1] - a[1]), dailyTotals },
                        tasks: { total: tasks.length, completed: completedTasks.length, backlog, upcoming, completedToday: completedTasks.filter(t => t.completedAt?.startsWith(todayISO)).length, completedYesterday: completedTasks.filter(t => t.completedAt?.startsWith(yesterdayISO)).length }
                    };
                }
            },
            ui: {
                showProductivityModal() {
                    App.hub.tasks.resetComposer();
                    const modalContainer = document.getElementById('modal-container');
                    if (document.getElementById('productivity-modal')) { this.closeModal(); return; }

                    App.hub.state.elementThatOpenedHub = document.activeElement;

                    modalContainer.innerHTML = `<div class="modal-backdrop" id="modal-backdrop">
                        <div id="productivity-modal" class="modal-content ui-card productivity-modal">
                            <div class="task-filters"></div>
                            <div class="task-area">
                                <div id="task-composer-container"></div>
                                <div id="task-list-container"></div>
                            </div>
                            <div class="pomodoro-section"></div>
                        </div>
                    </div>`;
                    document.addEventListener('keydown', App.events.handleProductivityHubKeyDown, true);
                    document.getElementById('modal-backdrop').addEventListener('click', (e) => this.closeModal(e));
                    document.getElementById('productivity-modal').addEventListener('click', (e) => {
                        const startPomoButton = e.target.closest('[data-action="start-pomodoro"]');
                        const deleteTaskButton = e.target.closest('[data-action="delete-task"]');
                        if (startPomoButton) { const taskId = startPomoButton.dataset.taskId; const task = App.hub.state.tasks.find(t => t.id === taskId); App.hub.pomodoro.startCycle(task); } 
                        else if (deleteTaskButton) { const taskId = deleteTaskButton.dataset.taskId; App.hub.tasks.deleteTask(taskId); }
                    });
                    this.renderTaskComposer(); this.renderTaskFilters(); this.renderTaskList(); this.updatePomodoroDisplay();
                    document.getElementById('composer-title-input')?.focus();
                },

                
               renderTaskComposer() {
                    const c = document.getElementById('task-composer-container');
                    if (!c) return;

                    const { title, category, priority, due, pomodoroGoal } = App.hub.tasks.state.composer;
                    const formattedDate = new Date(due + 'T00:00:00Z').toLocaleDateString('en-GB', { day: 'numeric', month: '2-digit', year: '2-digit', timeZone: 'UTC' }).replace(/\//g, '-');
                    
                    const categoryObjects = App.settings.get('userCategories');
                    const categoryOptionsHTML = categoryObjects.map(catObj => 
                        `<option value="${catObj.name}" ${catObj.name === category ? 'selected' : ''}>${App.util.getCategoryDisplayName(catObj.name)}</option>`
                    ).join('');
                    

                    c.innerHTML = `
                        <div class="task-composer">
                            <div class="composer-input-row">
                                <input type="text" id="composer-title-input" class="text-input" placeholder="Add a new task..." value="${App.util.escapeHtml(title)}">
                                <button class="btn btn-primary" id="add-task-btn" title="Add Task">+</button>
                            </div>
                            <div class="composer-actions-row">
                                <div class="composer-meta-buttons">
                                    <input type="text" id="composer-date-input" value="${formattedDate}" title="Due Date (dd-mm-yy)">
                                    <button id="priority-btn" class="priority-btn ${priority}" title="Cycle Priority">${priority}</button>
                                    <select id="category-select">${categoryOptionsHTML}</select>
                                    <button id="pomo-goal-btn" title="Set Pomodoro Goal (Left-click to increment, Right-click to reset)">
                                        <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16"><path d="M8 16a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm0-1a5 5 0 1 1 0-10 5 5 0 0 1 0 10Z"/><path d="M8 4.5a.5.5 0 0 0-1 0V7H6.5a.5.5 0 0 0 0 1H7v2.5a.5.5 0 0 0 1 0V8h1.5a.5.5 0 0 0 0-1H8V4.5Z"/></svg>
                                        <span>${pomodoroGoal > 0 ? pomodoroGoal : ''}</span>
                                    </button>
                                </div>
                            </div>
                        </div>`;

                    // Re-attach all event listeners to ensure functionality
                    document.getElementById('composer-title-input').addEventListener('input', e => {
                        App.hub.tasks.state.composer.title = e.target.value;
                    });
                    document.getElementById('add-task-btn').addEventListener('click', () => App.hub.tasks.add());
                    document.getElementById('composer-date-input').addEventListener('change', e => {
                        const newDate = App.hub.util.parseSimpleDate(e.target.value);
                        if (newDate) {
                            App.hub.tasks.state.composer.due = newDate;
                            this.renderTaskComposer(); // Re-render to reflect state
                        } else {
                            App.ui.showToast('Invalid date format. Use dd-mm-yy.', 'error');
                            e.target.value = formattedDate;
                        }
                    });
                    document.getElementById('priority-btn').addEventListener('click', () => {
                        const priorities = ['low', 'medium', 'high'];
                        App.hub.tasks.state.composer.priority = priorities[(priorities.indexOf(App.hub.tasks.state.composer.priority) + 1) % 3];
                        this.renderTaskComposer();
                    });
                    document.getElementById('category-select').addEventListener('change', (e) => {
                        App.hub.tasks.state.composer.category = e.target.value;
                    });
                    const pomoGoalBtn = document.getElementById('pomo-goal-btn');
                    pomoGoalBtn.addEventListener('click', () => {
                        App.hub.tasks.state.composer.pomodoroGoal = (App.hub.tasks.state.composer.pomodoroGoal + 1) % 10;
                        this.renderTaskComposer();
                    });
                    pomoGoalBtn.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        App.hub.tasks.state.composer.pomodoroGoal = 0;
                        this.renderTaskComposer();
                    });
                },

                renderTaskList() {
                    const c = document.getElementById('task-list-container'); if (!c) return;
                    const tasks = App.hub.tasks.getFilteredTasks(); const today = App.hub.util.getTodayISO();
                    if (tasks.length === 0) { c.innerHTML = `<p style="text-align: center; color: var(--text-secondary); padding: 2rem;">No tasks here. Great job!</p>`; return; }
                    c.innerHTML = tasks.map(t => {
                        const checkboxHTML = `<label class="custom-checkbox-container"><input type="checkbox" onchange="App.hub.tasks.toggleStatus('${t.id}', event)" ${t.status === 'completed' ? 'checked' : ''}><span class="custom-checkbox"></span></label>`;
                        
                        // UPDATED: Logic to get category color
                        const categoryObj = App.settings.get('userCategories').find(c => c.name === t.category) || { name: t.category, colorIndex: 0 };
                        const categoryPillHTML = `<div class="category-pill" style="background-color: ${App.util.getCategoryColor(categoryObj.colorIndex)};">${App.util.getCategoryDisplayName(categoryObj.name)}</div>`;
                        return `<div class="task-item ${t.status === 'completed' ? 'completed' : ''} ${t.due < today && t.status === 'pending' ? 'is-backlog' : ''}" data-id="${t.id}" data-priority="${t.priority}">${checkboxHTML}<span class="task-title" title="${App.hub.util.escapeHtml(t.title)}">${App.hub.util.escapeHtml(t.title)}</span><div class="task-meta">${t.pomodoroGoal > 0 ? `<div class="pomo-counter-display" title="Pomodoro Progress"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16"><path d="M8 16a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm0-1a5 5 0 1 1 0-10 5 5 0 0 1 0 10Z"/><path d="M8 4.5a.5.5 0 0 0-1 0V7H6.5a.5.5 0 0 0 0 1H7v2.5a.5.5 0 0 0 1 0V8h1.5a.5.5 0 0 0 0-1H8V4.5Z"/></svg> <span>${t.pomodoros || 0}/${t.pomodoroGoal}</span></div>` : (t.pomodoros > 0 ? `<div class="pomo-counter-display" title="Pomodoros Completed"><svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16"><path d="M8 16a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm0-1a5 5 0 1 1 0-10 5 5 0 0 1 0 10Z"/><path d="M8 4.5a.5.5 0 0 0-1 0V7H6.5a.5.5 0 0 0 0 1H7v2.5a.5.5 0 0 0 1 0V8h1.5a.5.5 0 0 0 0-1H8V4.5Z"/></svg> <span>${t.pomodoros}</span></div>` : '')}${categoryPillHTML}<span class="due-date ${t.due < today && t.status === 'pending' ? 'overdue' : ''}">${new Date(t.due + 'T00:00:00Z').toLocaleDateString(undefined, { month: 'short', day: 'numeric', timeZone: 'UTC' })}</span><button class="btn-icon" data-action="start-pomodoro" data-task-id="${t.id}" title="Start Pomodoro Cycle"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/><path d="M6.271 5.055a.5.5 0 0 1 .52.038l3.5 2.5a.5.5 0 0 1 0 .814l-3.5 2.5A.5.5 0 0 1 6 10.5v-5a.5.5 0 0 1 .271-.445z"/></svg></button><button class="btn-icon btn-danger" data-action="delete-task" data-task-id="${t.id}" title="Delete Task"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg></button></div></div>`;
                    }).join('');
                },
                
                renderTaskFilters() {
                    const c = document.querySelector('.task-filters'); if (!c) return; 
                    const f = { today: 'Due Today', backlog: 'Backlog', upcoming: 'Upcoming', completed: 'Completed', all: 'All Tasks' }; 
                    c.innerHTML = Object.entries(f).map(([k, l]) => `<button class="btn btn-secondary ${App.hub.tasks.state.currentFilter === k ? 'active' : ''}" onclick="App.hub.tasks.state.currentFilter='${k}'; App.hub.ui.renderTaskFilters(); App.hub.ui.renderTaskList();">${l}</button>`).join('');
                },
                updateTodoBadge() { 
                    const count = App.hub.state.tasks.filter(t => t.status === 'pending' && t.due === App.hub.util.getTodayISO()).length; 
                    const b = document.getElementById('todo-badge'); if(count > 0) { b.textContent = count; b.style.display = 'flex'; } else { b.style.display = 'none'; }
                },
           
                updatePomodoroDisplay() {
                    const c = document.querySelector('.pomodoro-section'); if (!c) return; 
                    const { isRunning, timeLeft, task, currentCategory, sessionCount, mode } = App.hub.pomodoro.state; 
                    const { percentage, colorValue } = App.hub.pomodoro.getProgressInfo(); 
                    const p = percentage * 4;

                    let pillIndicator = '';
                    if (mode === 'break') {
                        pillIndicator = `<div class="break-pill">Break</div>`;
                    } else if (sessionCount > 0) {
                        pillIndicator = `<div class="cycle-pill" data-cycle="${sessionCount}">${sessionCount} / 4</div>`;
                    }

                    // NEW: Find the category object to get its color
                    const categoryObj = App.settings.get('userCategories').find(cat => cat.name === currentCategory) || { name: currentCategory, colorIndex: 0 };
                    const backgroundColor = App.util.getCategoryColor(categoryObj.colorIndex);
                    const categoryPillHTML = `<div class="category-pill" style="background-color: ${backgroundColor};">${App.util.getCategoryDisplayName(currentCategory)}</div>`;

                    c.innerHTML = `
                        <div class="pomodoro-display">
                            <div class="pomodoro-progress-frame">
                                <div class="progress-segment progress-top" style="width:${Math.min(1,p)*100}%;"></div>
                                <div class="progress-segment progress-right" style="height:${p>1?Math.min(1,p-1)*100:0}%;"></div>
                                <div class="progress-segment progress-bottom" style="width:${p>2?Math.min(1,p-2)*100:0}%;"></div>
                                <div class="progress-segment progress-left" style="height:${p>3?Math.min(1,p-3)*100:0}%;"></div>
                            </div>
                            <div class="pomodoro-time-display">${App.hub.util.formatTime(timeLeft)}</div>
                            <div class="pomodoro-task-title" title="${App.hub.util.escapeHtml(task?.title || 'Focus Session')}" style="color: ${colorValue};">${App.hub.util.escapeHtml(task?.title || 'Focus Session')}</div>
                            <div class="pomodoro-meta">${pillIndicator}${categoryPillHTML}</div>
                        </div>
                        <div class="pomodoro-controls">
                            <button class="btn-icon" onclick="App.hub.pomodoro.stopAndReset()" title="Stop & Reset"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/></svg></button>
                            <button class="btn-icon" style="transform: scale(1.4);" onclick="App.hub.pomodoro.togglePlayPause()" title="${isRunning ? 'Pause' : 'Play / Start Cycle'}">${isRunning ? '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>'}</button>
                            <button class="btn-icon" onclick="App.hub.ui.showPomodoroSettings()" title="Settings"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311a1.464 1.464 0 0 1 0 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105 0l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.31-.17a1.464 1.464 0 0 1 2.105-.872l-.1-.34c.413-1.4 2.397-1.4 2.81 0l.1.34a1.464 1.464 0 0 1 2.105.872l.31.17c1.283.698-2.686-.705-1.987-1.987l-.169-.311a1.464 1.464 0 0 1 0-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105 0l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.31.17a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/></svg></button>
                            <button class="btn-icon" onclick="App.hub.pomodoro.toggleZenMode()" title="Zen Mode (Coffee Break)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1 12.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5zM12.5 0a.5.5 0 0 1 .5.5v2h-1V.5a.5.5 0 0 1 .5-.5zm-2 0a.5.5 0 0 1 .5.5v2h-1V.5a.5.5 0 0 1 .5-.5zm-2 0a.5.5 0 0 1 .5.5v2h-1V.5a.5.5 0 0 1 .5-.5zm-2 0a.5.5 0 0 1 .5.5v2h-1V.5a.5.5 0 0 1 .5-.5z"/><path fill-rule="evenodd" d="M.5 4a.5.5 0 0 1 .5-.5h14a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5-.5h-14a.5.5 0 0 1-.5-.5v-8zM1 4.5v7h14v-7H1z"/></svg></button>
                        </div>
                    `;
                    document.querySelectorAll('.progress-segment').forEach(el => { el.style.backgroundColor = colorValue; }); 
                    if (document.getElementById('zen-timer-display')) this.renderZenMode(true);
                },
                showPomodoroSettings() {
                    const modal = document.createElement('div'); modal.id = 'pomodoro-settings-modal'; modal.innerHTML = `<div class="modal-backdrop" id="settings-backdrop"><div id="pomodoro-settings-popup" class="ui-card"><h3>Timer Settings</h3><label>Work Duration (minutes)</label><input type="number" id="pomo-work" class="text-input" value="${App.settings.get('pomodoroWork')}"><label>Break Duration (minutes)</label><input type="number" id="pomo-break" class="text-input" value="${App.settings.get('pomodoroBreak')}"><div style="display:flex; justify-content:flex-end; gap:8px; margin-top:1rem;"><button class="btn btn-secondary" id="settings-cancel">Cancel</button><button class="btn btn-primary" id="settings-save">Save</button></div></div></div>`; 
                    document.getElementById('modal-container').appendChild(modal);
                    document.getElementById('settings-backdrop').addEventListener('click', (e) => {if (e.target === e.currentTarget) modal.remove()});
                    document.getElementById('settings-cancel').addEventListener('click', () => modal.remove());
                    document.getElementById('settings-save').addEventListener('click', () => App.hub.pomodoro.changeTime(document.getElementById('pomo-work').value, document.getElementById('pomo-break').value));
                },
            
                renderZenMode(isUpdate = false) {
                    const container = document.getElementById('zen-mode-container'); 
                    const { isRunning, timeLeft, task, currentCategory, sessionCount, mode, zenTitleVisible } = App.hub.pomodoro.state; 
                    const { percentage, colorValue } = App.hub.pomodoro.getProgressInfo(); 
                    const p = percentage * 4;
                    const currentTaskTitle = task?.title || 'Focus Session';

                    // NEW: Find the category object to get its color
                    const categoryObj = App.settings.get('userCategories').find(cat => cat.name === currentCategory) || { name: currentCategory, colorIndex: 0 };
                    const backgroundColor = App.util.getCategoryColor(categoryObj.colorIndex);
                    const categoryPillHTML = `<div class="category-pill" style="background-color: ${backgroundColor};">${App.util.getCategoryDisplayName(currentCategory)}</div>`;

                    if (isUpdate) {
                        document.getElementById('zen-timer-display').textContent = App.hub.util.formatTime(timeLeft);
                        const titleEl = document.getElementById('zen-task-title'), metaContainer = document.querySelector('.zen-meta-container');
                        titleEl.classList.toggle('hidden', !zenTitleVisible); 
                        metaContainer.classList.toggle('hidden', !zenTitleVisible);
                        titleEl.textContent = App.hub.util.escapeHtml(currentTaskTitle); 
                        titleEl.style.color = colorValue;
                        document.getElementById('zen-pills-row').innerHTML = `${mode === 'break' ? `<div class="break-pill">Break</div>` : sessionCount > 0 ? `<div class="cycle-pill" data-cycle="${sessionCount}">${sessionCount} / 4</div>` : ''}${categoryPillHTML}`;
                        const frame = document.querySelector('.zen-progress-frame');
                        if(frame){ 
                            frame.querySelector('.progress-top').style.width = `${Math.min(1,p)*100}%`; 
                            frame.querySelector('.progress-right').style.height = `${p>1?Math.min(1,p-1)*100:0}%`; 
                            frame.querySelector('.progress-bottom').style.width = `${p>2?Math.min(1,p-2)*100:0}%`; 
                            frame.querySelector('.progress-left').style.height = `${p>3?Math.min(1,p-3)*100:0}%`; 
                            frame.querySelectorAll('.progress-segment').forEach(el => el.style.backgroundColor = colorValue); 
                        }
                        const playPauseBtn = document.getElementById('zen-play-pause-btn');
                        if (playPauseBtn) { 
                            playPauseBtn.title = isRunning ? 'Pause' : 'Play'; 
                            playPauseBtn.innerHTML = isRunning ? '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>'; 
                        }
                        const visibilityBtn = document.getElementById('zen-visibility-btn');
                        if(visibilityBtn) { 
                            visibilityBtn.title = zenTitleVisible ? 'Hide Details' : 'Show Details'; 
                            visibilityBtn.innerHTML = zenTitleVisible ? App.util.icons.chevronUp : App.util.icons.chevronDown; 
                        }
                        return;
                    }
                    container.innerHTML = `
                        <div class="zen-mode-overlay">
                            <div class="zen-progress-frame pomodoro-progress-frame">
                                <div class="progress-segment progress-top"></div>
                                <div class="progress-segment progress-right"></div>
                                <div class="progress-segment progress-bottom"></div>
                                <div class="progress-segment progress-left"></div>
                            </div>
                            <div class="zen-meta-container ${!zenTitleVisible ? 'hidden' : ''}">
                                <div id="zen-pills-row" class="zen-pills-row"></div>
                            </div>
                            <div id="zen-timer-display" class="zen-timer"></div>
                            <div id="zen-task-title" class="zen-task-title ${!zenTitleVisible ? 'hidden' : ''}"></div>
                            <div class="zen-bottom-controls">
                                <button class="btn-icon" onclick="App.hub.pomodoro.stopAndReset()" title="Stop & Reset">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/></svg>
                                </button>
                                <button id="zen-play-pause-btn" class="btn-icon" style="transform: scale(1.5);" onclick="App.hub.pomodoro.togglePlayPause()"></button>
                                <button id="zen-visibility-btn" class="btn-icon" onclick="App.hub.pomodoro.toggleZenTitleVisibility()"></button>
                                <button class="btn-icon" onclick="App.hub.pomodoro.toggleZenMode()" title="Exit Zen Mode">${App.util.icons.close}</button>
                            </div>
                        </div>`;
                    this.renderZenMode(true);
                },
                showConfetti(x, y) {
                    const c = document.getElementById('confetti-toast-container'); c.style.left = `${x}px`; c.style.top = `${y}px`;
                    for (let i = 0; i < 30; i++) { const el = document.createElement('div'); el.className = 'confetti'; el.style.left = `${Math.random()*80-40}px`; el.style.top = `${Math.random()*80-40}px`; el.style.backgroundColor = `hsl(${Math.random()*360}, 90%, 65%)`; el.style.animationDelay = `${Math.random()*0.2}s`; c.appendChild(el); setTimeout(() => el.remove(), 1000); }
                },
                closeModal(event, isPopup = false) {
                    if (isPopup) { document.getElementById('pomodoro-settings-modal')?.remove(); return; }
                    if (event && event.target !== event.currentTarget) return;
                    document.body.classList.remove('hub-open'); // Ensures header reappears
                    document.getElementById('modal-container').innerHTML = '';
                    document.removeEventListener('keydown', App.events.handleProductivityHubKeyDown, true);
                },
            }
        },
        

        // ==========================================================================
        // 3.15. COMMAND PALETTE MODULE (v2)
        // ==========================================================================
       commandPalette: {
            state: {
                textileColors: [
                    '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', // Solid Colors
                    'default',       // Outline Only
                    'ghost-1',       // Glowing Purple Border
                    'ghost-2'        // Glowing Green Border
                ],
                isOpen: false,
                commands: [],
                filteredResults: [],
                selectedIndex: 0,
                fuse: {
                    commands: null,
                    links: null,
                    categories: null,
                    tags: null,
                    emojis: null,
                },
                mode: 'commands',
                emojiData: [],
                isFetching: false,
                highlightOptions: [
                    { id: 'yellow', title: 'Yellow Highlight', desc: 'Standard yellow background', icon: 'ðŸŸ¨', className: 'highlight-1' },
                    { id: 'green', title: 'Green Highlight', desc: 'Soothing green background', icon: 'ðŸŸ©', className: 'highlight-2' },
                    { id: 'blue', title: 'Blue Highlight', desc: 'Cool blue background', icon: 'ðŸŸ¦', className: 'highlight-3' },
                    { id: 'red', title: 'Red Highlight', desc: 'Urgent red background', icon: 'ðŸŸ¥', className: 'highlight-4' },
                    { id: 'purple', title: 'Purple Highlight', desc: 'Royal purple background', icon: 'ðŸŸª', className: 'highlight-5' },
                    { id: 'cyan', title: 'Cyan Highlight', desc: 'Light cyan background', icon: 'ðŸ’ ', className: 'highlight-6' },
                    { id: '1', title: 'Red Text', desc: 'Apply red text color', icon: 'T', className: 'text-red' },
                    { id: '2', title: 'Green Text', desc: 'Apply green text color', icon: 'T', className: 'text-green' },
                    { id: '3', title: 'Blue Text', desc: 'Apply blue text color', icon: 'T', className: 'text-blue' },
                    { id: 'clear', title: 'Clear Highlight', desc: 'Remove all block highlights', icon: 'âŒ', className: '' },
                ],
                // FIX: State for debouncing API calls and storing the highlight target
                debounceTimeout: null,
                targetBlockElement: null,
            },
            els: {
                palette: null,
                input: null,
                list: null,
            },
            init() {
                this.els.palette = document.getElementById('command-palette');
                this.els.input = document.getElementById('command-palette-input');
                this.els.list = document.getElementById('command-palette-list');
                this.els.preview = document.getElementById('command-palette-preview');

                this.state.isPreviewActive = false;
                this.state.originalContentState = null;
                this.state.previewTimeout = null;

                this.state.fontFamilyOptions = [
                    // --- 11 OFFLINE SYSTEM FONTS (FREE) ---
                    { name: 'Arial', value: 'Arial, Helvetica, sans-serif' },
                    { name: 'Cambria', value: 'Cambria, Cochin, Georgia, Times, "Times New Roman", serif' },
                    { name: 'Courier New', value: "'Courier New', Courier, monospace" },
                    { name: 'Garamond', value: 'Garamond, serif' },
                    { name: 'Georgia', value: 'Georgia, serif' },
                    { name: 'Helvetica', value: 'Helvetica, Arial, sans-serif' },
                    { name: 'Monaco', value: 'Monaco, "Lucida Console", monospace' },
                    { name: 'Palatino', value: 'Palatino, "Palatino Linotype", serif' },
                    { name: 'Sans-Serif', value: 'sans-serif' },
                    { name: 'Times New Roman', value: "'Times New Roman', Times, serif" },
                    { name: 'Verdana', value: 'Verdana, Geneva, sans-serif' },

                    // --- 38 GOOGLE WEB FONTS (PREMIUM) ---
                    { name: 'Allura', value: 'Allura, cursive' },
                    { name: 'Arvo', value: 'Arvo, serif' },
                    { name: 'Bitter', value: 'Bitter, serif' },
                    { name: 'Cabin', value: 'Cabin, sans-serif' },
                    { name: 'Cabin Sketch', value: "'Cabin Sketch', cursive" },
                    { name: 'Changa One', value: "'Changa One', cursive" },
                    { name: 'Cinzel', value: 'Cinzel, serif' },
                    { name: 'Crimson Text', value: "'Crimson Text', serif'" },
                    { name: 'Dancing Script', value: "'Dancing Script', cursive" },
                    { name: 'Exo 2', value: "'Exo 2', sans-serif" },
                    { name: 'Fira Code', value: "'Fira Code', monospace" },
                    { name: 'Great Vibes', value: "'Great Vibes', cursive" },
                    { name: 'Inconsolata', value: 'Inconsolata, monospace' },
                    { name: 'Jersey 20', value: "'Jersey 20', sans-serif" },
                    { name: 'Josefin Sans', value: "'Josefin Sans', sans-serif" },
                    { name: 'Kaushan Script', value: "'Kaushan Script', cursive" },
                    { name: 'Lato', value: 'Lato, sans-serif' },
                    { name: 'Libre Baskerville', value: "'Libre Baskerville', serif" },
                    { name: 'Lobster', value: 'Lobster, cursive' },
                    { name: 'Merriweather', value: 'Merriweather, serif' },
                    { name: 'Metal Mania', value: "'Metal Mania', cursive" },
                    { name: 'Montserrat', value: 'Montserrat, sans-serif' },
                    { name: 'Pacifico', value: 'Pacifico, cursive' },
                    { name: 'Parisienne', value: 'Parisienne, cursive' },
                    { name: 'Patrick Hand', value: "'Patrick Hand', cursive" },
                    { name: 'Playfair Display', value: "'Playfair Display', serif" },
                    { name: 'Protest Revolution', value: "'Protest Revolution', sans-serif" },
                    { name: 'Righteous', value: 'Righteous, cursive' },
                    { name: 'Roboto', value: 'Roboto, sans-serif' },
                    { name: 'Rochester', value: 'Rochester, cursive' },
                    { name: 'Salsa', value: 'Salsa, cursive' },
                    { name: 'Satisfy', value: 'Satisfy, cursive' },
                    { name: 'Sofia', value: 'Sofia, cursive' },
                    { name: 'Source Code Pro', value: "'Source Code Pro', monospace" },
                    { name: 'Special Elite', value: "'Special Elite', cursive" },
                    { name: 'Syne Mono', value: "'Syne Mono', monospace" },
                    { name: 'Ubuntu', value: 'Ubuntu, sans-serif' },
                    { name: 'Vollkorn', value: 'Vollkorn, serif' },
                    { name: 'Zilla Slab', value: "'Zilla Slab', serif" },
                ];

                // --- NEW EXPANDED FONT SIZES ---
                this.state.fontSizeOptions = [
                    '10px', '12px', '14px', '16px', '18px', '20px', '24px', '30px', '32px', '36px'
                ];


                this.state.commands = [
                    { id: 'hig', title: 'Highlight Block', desc: 'e.g., hig yellow, hig 1', icon: 'ðŸŽ¨' },
                    { id: 'define', title: 'Define Word', desc: 'e.g., define serendipity', icon: 'ðŸ“–' },
                    { id: 'link', title: 'Link to Note/Snippet', desc: 'e.g., link my other note', icon: 'ðŸ”—' },
                    { id: 'category', title: 'Change Category', desc: 'e.g., category History', icon: 'ðŸ“‚' },
                    { id: 'tag', title: 'Insert Existing Tag', desc: 'e.g., tag botany', icon: 'ðŸ·ï¸' },
                    { id: 'record', title: 'Start/Stop Recording', desc: 'Record audio, or Transcribe it (if downloaded)', icon: 'ðŸŽ™ï¸', execute: () => App.audio.toggleRecording() },
                    { id: 'task', title: 'Create Task', desc: 'e.g., task:cat: name #priority', icon: 'âœ…' },
                    
                    { id: 'clip', title: 'Clip Webpage', desc: 'e.g., clip https://example.com', icon: 'âœ‚ï¸', isPremium: true },
                    { id: 'pastefast', title: 'Quick Paste', desc: 'Paste content, preserving styles except background', icon: 'âš¡ï¸', execute: () => App.commandPalette.pasteFast() },

                    { id: 'web', title: 'Embed Web Link', desc: 'e.g., web example.com', icon: 'ðŸŒ' },
                    { id: 'emoji', title: 'Insert Emoji', desc: 'e.g., emoji smile', icon: 'ðŸ˜€' },
                    { id: 'table', title: 'Insert Table (dynamic)', desc: 'e.g., table 3x4', icon: 'â–¦' },
                    { id: 'table2col', title: 'Insert Table (2 Columns)', desc: 'Creates a standard 3x2 table', icon: 'â–¦', execute: () => App.events.table.create(3, 2) },
                    { id: 'table3col', title: 'Insert Table (3 Columns)', desc: 'Creates a standard 3x3 table', icon: 'â–¦', execute: () => App.events.table.create(3, 3) },
                    { id: 'chart', title: 'Insert Chart', desc: 'Create a bar, line, or pie chart', icon: 'ðŸ“Š', execute: () => App.ui.showChartModal() },
                    { id: 'timeline', title: 'Insert Timeline', desc: 'Create a historical timeline block', icon: 'â³', execute: () => App.commandPalette.insertTimeline(), isPremium: true },
                    { id: 'mcq', title: 'Insert MCQ Block', desc: 'Create a multiple-choice question', icon: 'â“', execute: () => App.commandPalette.insertMcqBlock(), isPremium: true },
                    { id: 'deck', title: 'Insert Decktile', desc: 'A container for multiple text tiles', icon: 'ðŸ—‚ï¸', execute: () => App.commandPalette.insertTextileDeck(), isPremium: true},
                    { id: 'convert', title: 'Convert List to Deck', desc: 'Turns a bulleted list into a Decktile', icon: 'ðŸª„', execute: () => App.commandPalette.convertListToDeck(), isPremium: true },
                    { id: 'textile', title: 'Insert Text Tile', desc: 'e.g., textile My important quote', icon: 'ðŸ“', execute: () => App.commandPalette.insertTextTile(), isPremium: true},
                    { id: 'convertMcq', title: 'Convert to MCQ', desc: 'Convert selected text to an MCQ block', icon: 'ðŸª„', selection: true, execute: () => App.commandPalette.convertSelectionToMcq(), isPremium: true },
                    { id: 'clearFormatting', title: 'Clear Formatting', desc: 'Remove all custom styles from selected text', icon: 'ðŸ§¹', selection: true, execute: () => App.commandPalette.clearFormatting() },
                    { id: 'pdf', title: 'Import PDF', desc: 'Attach a PDF file to this note', icon: 'ðŸ“„', execute: () => App.pdf.triggerImport() },
                    { id: 'date', title: 'Insert Date', desc: 'Inserts today\'s date', icon: 'ðŸ“…', execute: () => document.execCommand('insertText', false, new Date().toLocaleDateString()) },
                    { id: 'time', title: 'Insert Time', desc: 'Inserts the current time', icon: 'ðŸ•’', execute: () => document.execCommand('insertText', false, new Date().toLocaleTimeString()) },
                    { id: 'now', title: 'Insert Timestamp', desc: 'Inserts full date and time', icon: 'ðŸ•°ï¸', execute: () => document.execCommand('insertText', false, new Date().toLocaleString()) },
                    { id: 'h1', title: 'Heading 1', desc: 'Large section heading', icon: 'H1', execute: () => document.execCommand('formatBlock', false, 'H1') },
                    { id: 'h2', title: 'Heading 2', desc: 'Medium section heading', icon: 'H2', execute: () => document.execCommand('formatBlock', false, 'H2') },
                    { id: 'h3', title: 'Heading 3', desc: 'Small section heading', icon: 'H3', execute: () => document.execCommand('formatBlock', false, 'H3') },
                    { id: 'h4', title: 'Heading 4', desc: 'Extra small section heading', icon: 'H4', execute: () => document.execCommand('formatBlock', false, 'H4') },
                    { id: 'h5', title: 'Heading 5', desc: 'Tiny section heading', icon: 'H5', execute: () => document.execCommand('formatBlock', false, 'H5') },
                    { id: 'bulletList', title: 'Bulleted List', desc: 'Create a standard list', icon: 'â€¢', execute: () => document.execCommand('insertUnorderedList') },
                    { id: 'numberedList', title: 'Numbered List', desc: 'Create an ordered list', icon: '1.', execute: () => document.execCommand('insertOrderedList') },
                    { id: 'checkbox', title: 'Checkbox (To-do)', desc: 'Insert a trackable item', icon: 'â˜‘', execute: () => App.events.handleArticleControlsClick({ target: { closest: () => ({ dataset: { action: 'insertCheckbox' } }) } }), isPremium: true },
                    { id: 'bulletHyphen', title: 'Hyphen List', desc: 'A list with hyphen bullets', icon: '-', execute: () => App.events.handleArticleControlsClick({ target: { closest:() => ({ dataset: { action: 'applyListStyle', value: 'bullet-hyphen' } }) } }) },
                    { id: 'bulletCircle', title: 'Circle List', desc: 'A list with hollow circle bullets', icon: 'â—‹', execute: () => App.events.handleArticleControlsClick({ target: { closest:() => ({ dataset: { action: 'applyListStyle', value: 'bullet-empty-circle' } }) } }) },
                    { id: 'blockquote', title: 'Blockquote', desc: 'Visually offset text', icon: 'â€', execute: () => document.execCommand('formatBlock', false, 'blockquote') },
                    { id: 'code', title: 'Code Block', desc: 'Insert a pre-formatted block', icon: '&lt;/>', execute: () => document.execCommand('formatBlock', false, 'pre'), isPremium: true },
                    { id: 'accordion', title: 'Accordion Card', desc: 'Collapsible content for Q&A', icon: 'ðŸ—‚ï¸', execute: () => App.events.insertAccordionCard(), isPremium: true },
                    { id: 'hr', title: 'Horizontal Rule', desc: 'Insert a dividing line', icon: 'â€”', execute: () => document.execCommand('insertHorizontalRule') },
                    // NEW: Stat commands re-introduced
                    { id: 'words', title: 'Word Count', desc: 'Count words in selection or document', icon: 'ðŸ§®', selection: true, execute: () => App.commandPalette.insertStatBadge('words'), isPremium: true },
                    { id: 'reading-time', title: 'Reading Time', desc: 'Estimate reading time for selection/doc', icon: 'â±ï¸', selection: true, execute: () => App.commandPalette.insertStatBadge('time'), isPremium: true },
                    // --- Text Formatting ---
                    { id: 'bold', title: 'Bold', desc: 'Bold the selected text', icon: 'B', execute: () => document.execCommand('bold') },
                    { id: 'italic', title: 'Italic', desc: 'Italicize the selected text', icon: 'I', execute: () => document.execCommand('italic') },
                    { id: 'underline', title: 'Underline', desc: 'Underline the selected text', icon: 'U', execute: () => document.execCommand('underline') },
                    
                    { id: 'cloze', title: 'Create Cloze', desc: 'Make a flashcard from selection', icon: '...', selection: true, execute: () => App.events.applyFormatting('cloze') },
                    { id: 'tag', title: 'Create Tag', desc: 'Make a visual tag from selection', icon: '#', selection: true, execute: () => App.contentTools.tagSelection() },
                    { id: 'save', title: 'Save Article', desc: 'Save changes and continue writing', icon: 'ðŸ’¾', execute: () => App.events.saveArticle() },
                    { id: 'read', title: 'Save & Read', desc: 'Save changes and switch to read mode', icon: 'ðŸ“–', execute: () => App.events.saveArticle({ switchToRead: true }) },
                    { id: 'done', title: 'Done', desc: 'Save changes and return to library', icon: 'ðŸ‘', execute: () => { App.events.saveArticle(); App.router.navigateTo('library'); } },
                    { id: 'focus', title: 'Toggle Focus Mode', desc: 'Enter distraction-free writing', icon: 'âœï¸', execute: () => App.events.toggleFocusMode() },
                    // --- Font Size/Family --- 
                    { id: 'fontsize', title: 'Set Font Size', desc: 'e.g., fontsize 24, fontsize large', icon: 'Aa' },
                    { id: 'fontfamily', title: 'Set Font Family', desc: 'e.g., fontfamily serif', icon: 'Ab' },
                    //--- AI Tools ---
                    { id: 'aimagic', title: 'Open AI Magic', desc: 'Access the AI Co-Pilot modal for quick commands', icon: 'ðŸ’Ž', execute: () => App.ui.aiMagicModal.open() },
                    { id: 'kashsummary', title: 'Kash Summary', desc: 'Generate an AI summary of the current note', icon: 'âœ¨', execute: () => App.events.ai.executeKashSummary(), isPremium: true },
                    { id: 'kashflash', title: 'Kash Flash', desc: 'Generate cloze flashcards from selected text', icon: 'ðŸ“‡', selection: true, execute: () => App.events.ai.executeKashFlash() },
                    { id: 'kashwriting', title: 'Kash Writing', desc: 'Improve the writing of the selected text', icon: 'âœï¸', selection: true, execute: () => App.events.ai.executeImproveWriting(), isPremium: true },
                    { id: 'kashgrammar', title: 'Kash Grammar', desc: 'Fix grammar and spelling for selected text', icon: 'ðŸ§', selection: true, execute: () => App.events.ai.executeFixGrammar(), isPremium: true },
                    { id: 'kashhighlight', title: 'Kash Highlight', desc: 'Automatically highlight key parts of the article', icon: 'ðŸŽ¨', execute: () => App.events.ai.executeKashHighlight(), isPremium: true },
                    { id: 'kashcurate', title: 'Kash Curate', desc: 'Let AI beautify and structure your note', icon: 'ðŸª„', execute: () => App.events.ai.executeKashCurate() , isPremium: true },
                    { id: 'kashask', title: 'KashAsk', desc: 'e.g., kashask What is mitochondria?', icon: 'â“', isPremium: true },
                    { id: 'kashkeywords', title: 'KashKeywords', desc: 'Extract key concepts into a Decktile', icon: 'ðŸ”‘', execute: () => App.events.ai.executeKashKeywords(), isPremium: true },
                    { id: 'kashcomedy', title: 'KashComedy', desc: 'Generate a stand-up routine from the article', icon: 'ðŸ˜‚', execute: () => App.events.ai.executeKashComedy(), isPremium: true },
                    { id: 'kashstory', title: 'KashStory', desc: 'Generate a memorable story from the article', icon: 'ðŸ“–', execute: () => App.events.ai.executeKashStory(), isPremium: true },
                    { id: 'kashscript', title: 'KashScript', desc: 'Generate a short video script from the article', icon: 'ðŸŽ¬', execute: () => App.events.ai.executeKashScript(), isPremium: true },
                    { id: 'kashmnemonic', title: 'KashMnemonic', desc: 'Create mnemonics from selected text', icon: 'ðŸ§ ', selection: true, execute: () => App.events.ai.executeKashMnemonic(), isPremium: true },
                    { id: 'kashexplain', title: 'KashExplain', desc: 'Generate a clear explanation of selected text', icon: 'ðŸ’¡', selection: true, execute: () => App.events.ai.executeKashExplain(), isPremium: true },
                    { id: 'kashtranslate', title: 'KashTranslate', desc: 'e.g., kashtranslate Spanish', icon: 'ðŸŒ', selection: true , isPremium: true },
                    { id: 'kashtags', title: 'KashTags', desc: 'Automatically generate and apply tags to the article', icon: 'ðŸ·ï¸', execute: () => App.events.ai.executeKashTags(), isPremium: true },
                    { id: 'kashaccordion', title: 'KashAccordion', desc: 'Generate Q&A accordions from the article', icon: 'â“', execute: () => App.events.ai.executeKashAccordion(), isPremium: true },
                    { id: 'template', title: 'Insert Template', desc: 'Open the Template Hub to browse and add a Template', icon: 'ðŸ“„', execute: () => App.ui.showTemplateHubModal() },
                    { id: 'kashcraft', title: 'KashCraft Article Analysis', desc: 'Transform the note into a structured craft for exam', icon: 'â›³ï¸', execute: () => App.events.ai.executeKashCraft(), isPremium: true },
                    { id: 'kashquestion', title: 'Kash Question', desc: 'Generate 5 key questions from the article', icon: 'â“', execute: () => App.events.ai.executeKashQuestion(), isPremium: true },
                    { id: 'kashdebate', title: 'Kash Debate', desc: 'Create a debate table from the article content', icon: 'âš–ï¸', execute: () => App.events.ai.executeKashDebate(), isPremium: true },
                    { id: 'kashlong', title: 'Kash Long', desc: 'Generate a detailed summary of the article', icon: 'ðŸ“œ', execute: () => App.events.ai.executeKashLong(), isPremium: true },
                    { id: 'kashtable', title: 'Kash Table', desc: 'Create a revision table from selected text', icon: 'â–¦', selection: true, execute: () => App.events.ai.executeKashTable(), isPremium: true },
                    { id: 'kashmcq', title: 'KashMCQ Generator', desc: 'Generate MCQs from the article content', icon: 'ðŸ§ ', execute: () => App.events.ai.executeKashMcqGenerator(), isPremium: true },
                    { id: 'kashlist', title: 'Kash List', desc: 'Convert selected text to a Bulleted list', icon: 'ðŸ“‹', selection: true, execute: () => App.events.ai.executeKashListify(), isPremium: true },
                    { id: 'kashtimeline', title: 'Kash Timeline', desc: 'Convert article content into a Timeline', icon: 'â³', execute: () => App.events.ai.executeKashTimeline(), isPremium: true },
                    { id: 'kashoutline', title: 'Kash Outline', desc: 'e.g., kashoutline The Greek Empire', icon: 'ðŸ“œ', execute: () => { /* Handled by filter logic */ }, isPremium: true },
                    { id: 'kashexpand', title: 'Kash Expand', desc: 'Continue writing from your cursor', icon: 'âœï¸', selection: false, execute: () => App.events.ai.executeKashExpand(), isPremium: true },
                    { id: 'kashquote', title: 'Kash Quote', desc: 'Find a contextually relevant quote for your article', icon: 'â', selection: false, execute: () => App.events.ai.executeKashQuote(), isPremium: true },
                    { id: 'kashextract', title: 'Kash Extract', desc: 'e.g., kashextract key arguments', icon: 'ðŸ”', execute: () => { /* Handled by filter logic */ }, isPremium: true },
                    { id: 'kashlink', title: 'Kash Link', desc: 'e.g., kashlink The Indus Valley Civilization', icon: 'ðŸ”—', execute: () => { /* Handled by filter logic */ }, isPremium: true },
                    { id: 'kashsplit', title: 'KashSplit', desc: 'Intelligently split the current note into two', icon: 'âœ‚ï¸', execute: () => App.events.ai.executeKashSplit(), isPremium: true },
                ];
                this.state.emojiData = [
                    { e: 'ðŸ˜€', k: 'grinning face happy smile joy' }, { e: 'ðŸ˜‚', k: 'face with tears of joy happy laugh' }, { e: 'ðŸ˜', k: 'smiling face with heart-eyes love crush' }, { e: 'ðŸ¤”', k: 'thinking face ponder idea' }, { e: 'ðŸ˜Š', k: 'smiling face with smiling eyes blush happy' },
                    { e: 'ðŸ‘', k: 'thumbs up approve like yes' }, { e: 'ðŸ‘Ž', k: 'thumbs down disapprove dislike no' }, { e: 'â¤ï¸', k: 'red heart love like' }, { e: 'ðŸ”¥', k: 'fire hot lit popular' }, { e: 'ðŸ’¯', k: 'hundred points score perfect' },
                    { e: 'ðŸ™', k: 'folded hands please pray thank you' }, { e: 'ðŸš€', k: 'rocket launch ship space' }, { e: 'ðŸŽ‰', k: 'party popper celebration tada' }, { e: 'ðŸ’¡', k: 'light bulb idea solution' }, { e: 'âœ…', k: 'check mark button done complete' },
                    { e: 'âœ¨', k: 'sparkles stars magic glitter' }, { e: 'ðŸ“š', k: 'books study library reading' }, { e: 'ðŸ§ ', k: 'brain mind intelligence smart' }, { e: 'âœï¸', k: 'writing hand write notes' }, { e: 'ðŸŽ¯', k: 'direct hit target goal bullseye' },
                    { e: 'ðŸ”—', k: 'link chain connection' }, { e: 'ðŸ“‚', k: 'open file folder documents' }, { e: 'ðŸ“…', k: 'calendar date schedule' }, { e: 'âœ…', k: 'check mark button done complete task' }, { e: 'ðŸ“Œ', k: 'pushpin pin location reminder' },
                ];

                this.state.fuse.commands = new Fuse(this.state.commands, { keys: ['title', 'desc', 'id'], threshold: 0.3 });
                this.state.fuse.categories = null;
                this.state.fuse.emojis = new Fuse(this.state.emojiData, { keys: ['k'] });
                this.state.fuse.links = null;

                this.state.fuse.fontFamilies = new Fuse(this.state.fontFamilyOptions, { keys: ['name'], threshold: 0.3 });
                this.state.fuse.fontSizes = new Fuse(this.state.fontSizeOptions, { keys: ['name'], threshold: 0.3 });
            
                this.els.input.addEventListener('input', () => this.filter());
                this.els.input.addEventListener('keydown', (e) => this.handleKeyDown(e));
            },
            
            async pasteFast() {
                try {
                    // Modern browsers require permission for clipboard access, which is granted on user gesture.
                    const clipboardItems = await navigator.clipboard.read();
                    const htmlItem = clipboardItems.find(item => item.types.includes('text/html'));

                    let contentToInsert = '';

                    if (htmlItem) {
                        const htmlBlob = await htmlItem.getType('text/html');
                        const pastedHTML = await htmlBlob.text();

                        // Create a temporary, in-memory element to parse and clean the HTML
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = pastedHTML;

                        // This recursive function is the core of the feature.
                        // It finds all elements with inline styles or legacy bgcolor and cleans them.
                        const cleanBackgroundStyles = (element) => {
                            // Target modern inline styles
                            if (element.style && (element.style.backgroundColor || element.style.background)) {
                                element.style.removeProperty('background-color');
                                element.style.removeProperty('background'); // Also remove the shorthand property
                            }
                            // Target legacy `bgcolor` attribute
                            if (element.hasAttribute('bgcolor')) {
                                element.removeAttribute('bgcolor');
                            }
                            // Recurse through all children
                            for (const child of element.children) {
                                cleanBackgroundStyles(child);
                            }
                        };

                        cleanBackgroundStyles(tempDiv);
                        contentToInsert = tempDiv.innerHTML;

                    } else {
                        // Fallback for plain text, ensuring it's properly formatted into paragraphs.
                        const text = await navigator.clipboard.readText();
                        if (text) {
                            contentToInsert = App.util.textToHtml(text);
                        }
                    }

                    if (contentToInsert) {
                        document.execCommand('insertHTML', false, contentToInsert);
                        App.state.isArticleDirty = true;
                        App.ui.showToast('Pasted quickly!', { type: 'success' });
                    } else {
                        App.ui.showToast('Nothing to paste from clipboard.', { type: 'warning' });
                    }

                } catch (err) {
                    // Catch potential errors, like clipboard permissions being denied.
                    console.error('Quick Paste failed:', err);
                    if (err.name === 'NotAllowedError') {
                        App.ui.showToast('Clipboard access denied. Please allow it in your browser settings.', { type: 'error' });
                    } else {
                        App.ui.showToast('Could not paste content.', { type: 'error' });
                    }
                }
            },
            async fetchDefinition(word) {
                try {
                    const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                    if (!response.ok) { return [{ type: 'definition', error: `No definition found for "${word}".` }]; }
                    const data = await response.json();
                    const results = data.flatMap(entry => entry.meanings.map(meaning => {
                        const definition = meaning.definitions[0];
                        return definition ? {
                            type: 'definition', word: entry.word, partOfSpeech: meaning.partOfSpeech,
                            definition: definition.definition, example: definition.example,
                            synonyms: (meaning.synonyms || []).join(', ')
                        } : null;
                    })).filter(Boolean);
                    return results.length > 0 ? results : [{ type: 'definition', error: `No definition found for "${word}".` }];
                } catch (error) {
                    console.error("Dictionary API error:", error);
                    return [{ type: 'definition', error: "Could not connect to the dictionary service." }];
                } finally {
                    this.state.isFetching = false;
                }
            },

            // FIX: Highlighting logic now uses the stored targetBlockElement
            applyBlockHighlight(className) {
                const blockElement = this.state.targetBlockElement;
                if (!blockElement) {
                    App.ui.showToast("Can only highlight full text blocks.", { type: 'warning' });
                    return;
                }
                blockElement.classList.remove(...this.state.highlightOptions.map(h => h.className).filter(Boolean));
                if (className) {
                    blockElement.classList.add(className);
                }
                App.state.isArticleDirty = true;
            },

            _saveEditorState() {
                const contentDiv = document.getElementById('article-content');
                if (contentDiv && !this.state.isPreviewActive) {
                    if (App.state.autosaveInterval) { clearInterval(App.state.autosaveInterval); App.state.autosaveInterval = null; }
                    this.state.originalContentState = { articleId: App.state.activeArticleId, html: contentDiv.innerHTML, isDirty: App.state.isArticleDirty, scrollTop: document.querySelector('main').scrollTop };
                    this.state.isPreviewActive = true;
                    contentDiv.contentEditable = false;
                }
            },
            _restoreEditor() {
                if (this.state.isPreviewActive && this.state.originalContentState) {
                    const originalState = this.state.originalContentState;
                    App.router.navigateTo('article', { id: originalState.articleId, mode: 'write', overrideContent: originalState.html, restoredScrollTop: originalState.scrollTop });
                    App.state.isArticleDirty = originalState.isDirty;
                }
                this.state.isPreviewActive = false;
                this.state.originalContentState = null;
                clearTimeout(this.state.previewTimeout);
            },
            async _renderPreview(item) {
                if (!item) return;
                const isLinkPreview = item.type === 'article' || item.type === 'snippet' || item.type === 'tag';
                if (isLinkPreview) {
                    this._saveEditorState();
                    const articleId = item.type === 'article' ? item.id : item.articleId;
                    const snippetId = item.type === 'snippet' ? item.id : null;
                    App.router.navigateTo('article', { id: articleId, mode: 'read', scrollToSnippetId: snippetId, isPreviewing: true });
                }
            },
            _updateSelection() {
                clearTimeout(this.state.previewTimeout);
                this._restoreEditor();
                const items = this.els.list.querySelectorAll('.command-item');
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === this.state.selectedIndex);
                    if (index === this.state.selectedIndex) {
                        item.scrollIntoView({ block: 'nearest' });
                        this.state.previewTimeout = setTimeout(() => { this._renderPreview(this.state.filteredResults[this.state.selectedIndex]); }, 150);
                    }
                });
            },
            _repositionPaletteIfObscuring(targetElement) {
                if (!targetElement) return;
                const targetRect = targetElement.getBoundingClientRect();
                const paletteRect = this.els.palette.getBoundingClientRect();
                if (paletteRect.bottom > targetRect.top && paletteRect.top < targetRect.bottom) {
                    this.els.palette.style.top = '15px'; this.els.palette.style.left = '50%'; this.els.palette.style.transform = 'translateX(-50%)';
                }
            },

            open(range = null) {
                if (this.state.isOpen) return;

                if (range && !range.collapsed) {
                    App.state.savedRange = range.cloneRange();
                    this.state.cursorMarkerId = null;
                } else if (range) {
                    const markerId = `nk-cursor-marker-${Date.now()}`;
                    const markerNode = document.createElement('span');
                    markerNode.id = markerId;
                    range.insertNode(markerNode);
                    this.state.cursorMarkerId = markerId;
                    App.state.savedRange = null;
                } else {
                    this.state.cursorMarkerId = null;
                    App.state.savedRange = null;
                }

                this.state.isOpen = true;
                document.addEventListener('click', this.handleClickOutside, true);

                this.state.targetBlockElement = range ? (range.commonAncestorContainer.nodeType === 3 ? range.commonAncestorContainer.parentElement : range.commonAncestorContainer).closest('p, li, h1, h2, h3, h4, h5, h6, blockquote') : null;

                // --- START: MODIFIED POSITIONING LOGIC ---
                const isMobileView = document.body.classList.contains('mobile-view');

                if (isMobileView) {
                    // On mobile, always position at the top.
                    this.els.palette.style.left = '50%';
                    this.els.palette.style.top = '55px'; // Just below the header
                    this.els.palette.style.transform = 'translateX(-50%)';
                } else if (this.state.cursorMarkerId) {
                    // Original desktop logic for cursor position
                    const markerNode = document.getElementById(this.state.cursorMarkerId);
                    const rect = markerNode.getBoundingClientRect();
                    const paletteWidth = 380, paletteHeight = 400, margin = 10;
                    let top = rect.bottom + window.scrollY + 5;
                    let left = rect.left + window.scrollX;
                    if (rect.bottom + paletteHeight > window.innerHeight) { top = rect.top + window.scrollY - paletteHeight - 5; }
                    if (left + paletteWidth > window.innerWidth) { left = window.innerWidth - paletteWidth - margin; }
                    this.els.palette.style.top = `${Math.max(margin, top)}px`;
                    this.els.palette.style.left = `${Math.max(margin, left)}px`;
                    this.els.palette.style.transform = '';
                } else { 
                    // Original desktop logic for broad selection or header click
                    this.els.palette.style.left = '50%';
                    this.els.palette.style.top = '20vh';
                    this.els.palette.style.transform = 'translateX(-50%)';
                }
                // --- END: MODIFIED POSITIONING LOGIC ---

                this.els.palette.style.display = 'flex';
                this.els.input.focus();
                this.filter();
            },

            insertTimeline() {
                const timelineHTML = `<div class="nk-timeline-block" contenteditable="false"><div class="nk-timeline-entry"><div class="nk-timeline-content"><div class="nk-timeline-date" contenteditable="true">2024-01-01</div><div class="nk-timeline-title" contenteditable="true">First event...</div></div></div><div class="nk-timeline-entry"><div class="nk-timeline-content"><div class="nk-timeline-date" contenteditable="true">2025-03-15</div><div class="nk-timeline-title" contenteditable="true">Second event...</div></div></div><div class="nk-timeline-add" contenteditable="false"><button title="Add Timeline Entry" type="button">+</button></div></div><p><br></p>`;
                App.util.insertGuardianBlock(timelineHTML);
            },
            // NEW: Function to insert stat badges
            insertStatBadge(type) {
                const sel = window.getSelection();
                let text = '';
                if (sel && !sel.isCollapsed && sel.rangeCount > 0) {
                    text = sel.toString();
                } else {
                    const contentDiv = document.getElementById('article-content');
                    if (contentDiv) {
                        text = contentDiv.innerText || contentDiv.textContent;
                    }
                }
                if (!text.trim()) {
                    App.ui.showToast('No text found to analyze.', { type: 'warning' });
                    return;
                }
                const wordCount = text.trim().split(/\s+/).filter(Boolean).length;
                let badgeHTML = '';

                // FIX: Replaced complex SVG with simple, reliable Font Awesome icons
                if (type === 'words') {
                    const icon = `<i class="fa-solid fa-pen-ruler"></i>`;
                    badgeHTML = `<span class="nk-stat-badge" contenteditable="false">${icon} ${wordCount} words</span>`;
                } else if (type === 'time') {
                    const icon = `<i class="fa-regular fa-clock"></i>`;
                    const minutes = Math.ceil(wordCount / 200);
                    const timeText = minutes < 1 ? '< 1 min read' : `${minutes} min read`;
                    badgeHTML = `<span class="nk-stat-badge" contenteditable="false">${icon} ${timeText}</span>`;
                }

                if (badgeHTML) {
                    document.execCommand('insertHTML', false, badgeHTML + '&nbsp;');
                }
            },

            insertMcqBlock() {
                const mcqId = `mcq-${crypto.randomUUID()}`; // Unique ID to find the new element
                const mcqHTML = `
                    <div id="${mcqId}" class="nk-mcq-block" contenteditable="false">
                        <div class="nk-mcq-question" contenteditable="true" data-placeholder="Type your question here..."></div>
                        <div class="nk-mcq-options">
                            <div class="nk-mcq-option" data-is-correct="false">
                                <div class="nk-mcq-option-radio"></div>
                                <div class="nk-mcq-option-text" contenteditable="true" data-placeholder="Option A"></div>
                                <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                            </div>
                            <div class="nk-mcq-option" data-is-correct="false">
                                <div class="nk-mcq-option-radio"></div>
                                <div class="nk-mcq-option-text" contenteditable="true" data-placeholder="Option B"></div>
                                <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                            </div>
                        </div>
                        <button class="btn btn-secondary nk-mcq-add-option">+ Add Option</button>
                        
                        <div class="nk-mcq-explanation" contenteditable="true" data-placeholder="Add answer explanation (optional)..."></div>
                    </div>`;
                App.util.insertGuardianBlock(mcqHTML);

                // UX ENHANCEMENT: Automatically focus the cursor in the new question area.
                setTimeout(() => {
                    const newMcq = document.getElementById(mcqId);
                    if (newMcq) {
                        const questionEl = newMcq.querySelector('.nk-mcq-question');
                        if (questionEl) {
                            App.util.placeCursor(questionEl);
                        }
                    }
                }, 50);

                App.state.isArticleDirty = true;
            },


            insertTextileDeck() {
                const deckHTML = `
                <div class="nk-textile-deck" contenteditable="false">
                    <div class="deck-layout-toggle" title="Toggle Layout"><i class="fa-solid fa-table-cells"></i></div>
                    <div class="nk-text-tile color-stone" contenteditable="false" data-color="stone">
                        <span class="nk-text-tile-icon"></span>
                        <div class="nk-text-tile-color-cycler" title="Cycle Color"><i class="fa-solid fa-palette fa-xs"></i></div>
                        <div class="nk-text-tile-content" contenteditable="true" data-placeholder="First tile..."></div>
                    </div>
                    <div class="deck-add-tile-btn" title="Add another tile to this deck">+ Add Tile</div>
                </div>
                <p><br></p>`;
                App.util.insertGuardianBlock(deckHTML);
            },

            convertListToDeck() {
                const selection = window.getSelection();
                if (!selection.rangeCount > 0) return;
                const range = selection.getRangeAt(0);
                const listNode = range.startContainer.parentElement.closest('ul, ol');

                if (!listNode) {
                    App.ui.showToast("Place your cursor in a list to convert it.", { type: 'warning' });
                    return;
                }

                // --- FIX: Filter for solid colors only ---
                const solidColors = this.state.textileColors.filter(c => !isNaN(c));
                const listItems = listNode.querySelectorAll('li');
                let tilesHTML = '';
                listItems.forEach((item, index) => {
                    if (item.textContent.trim() === '') return;
                    // This now correctly cycles through only the 10 solid colors.
                    const color = solidColors[index % solidColors.length];
                    tilesHTML += `
                    <div class="nk-text-tile color-${color}" contenteditable="false" data-color="${color}">
                        <span class="nk-text-tile-icon"></span>
                        <div class="nk-text-tile-color-cycler" title="Cycle Color"><i class="fa-solid fa-palette fa-xs"></i></div>
                        <div class="nk-text-tile-content" contenteditable="true">${item.innerHTML}</div>
                    </div>`;
                });

                const deckHTML = `
                <div class="nk-textile-deck" contenteditable="false">
                    <div class="deck-layout-toggle" title="Toggle Layout"><i class="fa-solid fa-table-cells"></i></div>
                    ${tilesHTML}
                    <div class="deck-add-tile-btn" title="Add another tile to this deck">+ Add Tile</div>
                </div>`;
                
                listNode.outerHTML = deckHTML;
                App.state.isArticleDirty = true;
                App.ui.showToast("List converted to Decktile!", { type: 'success' });
            },

            insertTextTile() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;

                const solidColors = this.state.textileColors.filter(c => !isNaN(c));
                const randomColor = solidColors[Math.floor(Math.random() * solidColors.length)];
                const tileId = `tile-${crypto.randomUUID()}`;

                const textTileHTML = `
                    <div id="${tileId}" class="nk-text-tile color-${randomColor}" contenteditable="false" data-color="${randomColor}">
                        <div class="nk-text-tile-color-cycler" title="Cycle Color"><i class="fa-solid fa-palette fa-xs"></i></div>
                        <div class="nk-text-tile-content" contenteditable="true" data-placeholder="Type here..."></div>
                    </div>
                    <p><br></p>`;

                document.execCommand('insertHTML', false, textTileHTML);

                setTimeout(() => {
                    const newTile = document.getElementById(tileId);
                    if (newTile) {
                        const contentArea = newTile.querySelector('.nk-text-tile-content');
                        if (contentArea) App.util.placeCursor(contentArea);
                    }
                }, 50);

                App.state.isArticleDirty = true;
            },

            convertSelectionToMcq() {
                const selection = window.getSelection();
                if (!selection || selection.isCollapsed) {
                    App.ui.showToast("Please select the text you want to convert.", { type: 'warning' });
                    return;
                }

                const text = selection.toString();
                const lines = text.trim().split('\n').filter(line => line.trim() !== '');

                if (lines.length < 3) {
                    App.ui.showToast("Invalid MCQ format. Text should have a question, followed by at least two options.", { type: 'error' });
                    return;
                }

                let optionsStartIndex = -1;
                for (let i = 1; i < lines.length; i++) {
                    if (/^\s*(\(|\[)?[a-zA-Z](\)|\]|\.)/.test(lines[i].trim())) {
                        optionsStartIndex = i;
                        break;
                    }
                }

                if (optionsStartIndex === -1) {
                    App.ui.showToast("Couldn't detect the start of the options (e.g., [A], (b), c.). Please check the format.", { type: 'error' });
                    return;
                }

                let questionLines = lines.slice(0, optionsStartIndex);
                const optionLines = lines.slice(optionsStartIndex);

                questionLines[0] = questionLines[0].replace(/^(Question\s*)?\d+[\.\)]?\s*/i, '').trim();
                const questionText = questionLines.join('<br>').trim();

                const options = optionLines.map(line => {
                    const optionText = line.trim().replace(/^\s*(\(|\[)?[a-zA-Z](\)|\]|\.)\s*/, '');
                    return optionText.trim();
                }).filter(Boolean);

                if (options.length < 2) {
                    App.ui.showToast("Could not parse at least two valid options.", { type: 'error' });
                    return;
                }

                const optionsHtml = options.map(optText => `
                    <div class="nk-mcq-option" data-is-correct="false">
                        <div class="nk-mcq-option-radio"></div>
                        <div class="nk-mcq-option-text" contenteditable="true">${App.util.escapeHtml(optText)}</div>
                        <button class="nk-mcq-delete-option" title="Delete Option">&times;</button>
                    </div>
                `).join('');

                const mcqHTML = `
                    <div class="nk-mcq-block" contenteditable="false">
                        <div class="nk-mcq-question" contenteditable="true">${questionText}</div>
                        <div class="nk-mcq-options">${optionsHtml}</div>
                        <button class="btn btn-secondary nk-mcq-add-option">+ Add Option</button>
                        
                        <div class="nk-mcq-explanation" contenteditable="true" data-placeholder="Add answer explanation (optional)..."></div>
                    </div>
                    <p><br></p>`;

                document.execCommand('insertHTML', false, mcqHTML);
                App.state.isArticleDirty = true;
                App.ui.showToast("Text smartly converted to MCQ!", { type: 'success' });
            },

            clearFormatting() {
                const selection = window.getSelection();
                if (!selection || selection.rangeCount === 0) return;

                if (!selection.isCollapsed) {
                    // --- DEFINITIVE FIX: Hybrid Undoable AND Powerful Cleanup ---
                    
                    // Step 1: Run the native, undoable command. This handles basic tags and creates the undo history.
                    document.execCommand('removeFormat', false, null);

                    // Step 2: Perform a powerful, surgical cleanup for everything the native command missed.
                    const newSelection = window.getSelection();
                    if (newSelection.rangeCount > 0) {
                        const range = newSelection.getRangeAt(0);
                        const commonAncestor = range.commonAncestorContainer;
                        const parentElement = commonAncestor.nodeType === 3 ? commonAncestor.parentElement : commonAncestor;
                        
                        if (parentElement) {
                            // Find the parent block to ensure we only clean within the right scope.
                            const parentBlock = parentElement.closest('p, li, h1, h2, h3, h4, h5, h6, blockquote, div');

                            if (parentBlock) {
                                // FIX: This selector is now comprehensive. It finds links, all highlight/color
                                // classes, and any spans with inline styles (from /fontsize).
                                const selector = 'a, span[class*="highlight-"], span[class*="text-"], span[style]';
                                
                                parentBlock.querySelectorAll(selector).forEach(elementToClean => {
                                    // We only unwrap the element if it's part of the user's selection.
                                    if (newSelection.containsNode(elementToClean, true)) {
                                        App.util.unwrapNode(elementToClean);
                                    }
                                });
                            }
                        }
                    }
                    
                    App.ui.showToast("Selection formatting cleared!", { type: 'success' });

                } else {
                    const range = selection.getRangeAt(0);
                    const blockElement = range.startContainer.closest('p, li, h1, h2, h3, h4, h5, h6, blockquote, div');

                    if (blockElement) {
                        blockElement.removeAttribute('style');
                        const highlightClasses = [...App.config.highlightClasses, ...App.config.textClasses];
                        blockElement.classList.remove(...highlightClasses);
                        blockElement.querySelectorAll('[style], [class*="highlight-"], [class*="text-"], b, i, u, strong, em, del, a, .rendered-tag').forEach(el => {
                            App.util.unwrapNode(el);
                        });
                        App.ui.showToast("Block formatting cleared.", { type: 'success' });
                    } else {
                        App.ui.showToast("Place cursor inside a block to clear its formatting.", { type: 'warning' });
                    }
                }

                App.state.isArticleDirty = true;
            },

            async filter() {
                const query = this.els.input.value;
                const hasSelection = !!App.state.savedRange;
                clearTimeout(this.state.debounceTimeout);
                const kashAskMatch = query.match(/^kashask\s+(.*)/i);
                const kashTranslateMatch = query.match(/^kashtranslate\s+(.*)/i);
                const kashOutlineMatch = query.match(/^kashoutline\s+(.*)/i);
                const kashExtractMatch = query.match(/^kashextract\s*(.*)/i);
                const kashLinkMatch = query.match(/^kashlink\s+(.*)/i);

                if (kashAskMatch) {
                    this.state.mode = 'kashask';
                    const prompt = kashAskMatch[1].trim();
                    this.state.filteredResults = [{
                        id: 'kashask-action',
                        title: `Ask AI: "${prompt}"`,
                        desc: 'Press Enter to get an answer from the AI',
                        icon: 'â“',
                        prompt: prompt
                    }];
                    this.state.selectedIndex = 0;
                    this.render();
                    return;
                }

                if (kashTranslateMatch) {
                    this.state.mode = 'kashtranslate';
                    const language = kashTranslateMatch[1].trim();
                    this.state.filteredResults = [{
                        id: 'kashtranslate-action',
                        title: `Translate selection to ${language}`,
                        desc: 'Press Enter to translate',
                        icon: 'ðŸŒ',
                        language: language
                    }];
                    this.state.selectedIndex = 0;
                    this.render();
                    return;
                }
                if (kashOutlineMatch) {
                    this.state.mode = 'kashoutline';
                    const topic = kashOutlineMatch[1].trim();
                    this.state.filteredResults = [{
                        id: 'kashoutline-action',
                        title: `Generate Outline for: "${topic}"`,
                        desc: 'Press Enter to generate the outline',
                        icon: 'ðŸ“œ',
                        topic: topic
                    }];
                    this.state.selectedIndex = 0;
                    this.render();
                    return;
                }
                if (kashExtractMatch) {
                    this.state.mode = 'kashextract';
                    const subCommand = kashExtractMatch[1].trim();
                    this.state.filteredResults = [{
                        id: 'kashextract-action',
                        title: subCommand ? `Extract: "${subCommand}"` : 'Extract: Article Summary',
                        desc: 'Press Enter to query the article content',
                        icon: 'ðŸ”',
                        subCommand: subCommand || 'default'
                    }];
                    this.state.selectedIndex = 0;
                    this.render();
                    return;
                }

                if (kashLinkMatch) {
                    this.state.mode = 'kashlink';
                    const topic = kashLinkMatch[1].trim();
                    this.state.filteredResults = [{
                        id: 'kashlink-action',
                        title: `Create & Link Note: "${topic}"`,
                        desc: 'Press Enter to generate a new note and link it here',
                        icon: 'ðŸ”—',
                        topic: topic
                    }];
                    this.state.selectedIndex = 0;
                    this.render();
                    return;
                }

                const clipMatch = query.match(/^clip\s+((?:https?:\/\/)?\S+)/i);
                if (clipMatch) {
                    this.state.mode = 'clip';
                    let url = clipMatch[1];
                    
                    if (!/^(https?:\/\/)/i.test(url)) {
                        url = 'https://' + url;
                    }
                    this.state.filteredResults = [{
                        id: 'clip-action',
                        title: `Clip Content from URL`,
                        desc: url,
                        icon: 'âœ‚ï¸',
                        url: url
                    }];
                    this.state.selectedIndex = 0;
                    this.render();
                    return;
                }

                const categoryMatch = query.match(/^category\s*(.*)/i);
                if (query.toLowerCase().startsWith('define ')) {
                    this.state.mode = 'definitions';
                    const searchTerm = query.substring(7).trim();
                    if (searchTerm.length === 0) {
                        this.state.filteredResults = [{ type: 'definition-prompt', title: 'e.g., define serendipity', desc: 'Type a word to get its definition.' }];
                    } else if (searchTerm.length >= 2) {
                        this.state.isFetching = true; this.render();
                        this.state.debounceTimeout = setTimeout(async () => {
                            this.state.filteredResults = await this.fetchDefinition(searchTerm);
                            this.render();
                        }, 400);
                        return; 
                    } else {
                        this.state.filteredResults = [];
                    }
                } else if (query.toLowerCase().startsWith('hig ')) {
                    this.state.mode = 'block-highlight';
                    const searchTerm = query.substring(4).trim().toLowerCase();
                    this.state.filteredResults = searchTerm ? this.state.highlightOptions.filter(opt => opt.id.toLowerCase().startsWith(searchTerm) || opt.title.toLowerCase().includes(searchTerm)) : this.state.highlightOptions;
                } else if (query.toLowerCase().startsWith('link ')) {
                    if (!this.state.fuse.links) { App.ui.showToast('Indexing notes for linking...', { type: 'info', duration: 1500 }); const linkableData = [ ...App.state.articles.map(a => ({ type: 'article', id: a.id, title: a.title, desc: `Article: ${a.title}` })), ...App.util.extractSnippets(null, 'highlight').map(s => ({ type: 'snippet', id: s.id, title: s.text, desc: `Snippet in: ${App.storage.getArticle(s.articleId)?.title}`, articleId: s.articleId })) ]; this.state.fuse.links = new Fuse(linkableData, { keys: ['title', 'desc'], threshold: 0.3 }); }
                    this.state.mode = 'links'; const searchTerm = query.substring(5).trim();
                    if (!searchTerm) { this.state.filteredResults = App.state.articles.slice(0, 500).map(a => ({ type: 'article', id: a.id, title: a.title, desc: `Article: ${a.title}` })); } else { this.state.filteredResults = this.state.fuse.links.search(searchTerm).map(r => r.item); }
                } else if (query.toLowerCase().startsWith('tag ')) {
                    if (!this.state.fuse.tags) { const tagData = Object.values(App.state.tags).map(tag => ({...tag, articleId: tag.articles ? tag.articles[0] : null})); this.state.fuse.tags = new Fuse(tagData, { keys: ['displayName'], threshold: 0.3 }); }
                    this.state.mode = 'tags'; const searchTerm = query.substring(4).trim();
                    if (!searchTerm) { this.state.filteredResults = Object.values(App.state.tags).sort((a,b) => a.displayName.localeCompare(b.displayName)); } else { this.state.filteredResults = this.state.fuse.tags.search(searchTerm).map(r => r.item); }
                } else if (categoryMatch) { 
                    this.state.mode = 'categories';
                    const searchTerm = categoryMatch[1].trim(); // Get the search term from the regex
                    const userCategories = App.settings.get('userCategories');
                    const categoryData = userCategories.map(c => ({
                        id: c.name, // The internal name for execution
                        name: App.util.getCategoryDisplayName(c.name) // The display name for UI
                    }));
                    if (!this.state.fuse.categories) {
                        this.state.fuse.categories = new Fuse(categoryData, { keys: ['name'], threshold: 0.3 });
                    }

                    if (!searchTerm) {
                        this.state.filteredResults = categoryData.sort((a, b) => a.name.localeCompare(b.name));
                    } else {
                        this.state.filteredResults = this.state.fuse.categories.search(searchTerm).map(r => r.item);
                    }
                } else if (query.toLowerCase().startsWith('emoji ')) {
                    this.state.mode = 'emojis'; this.state.filteredResults = this.state.fuse.emojis.search(query.substring(6)).map(r => r.item);
                } else if (query.toLowerCase().startsWith('textile ')) { // NEW: Handle /textile command for initial text
                    this.state.mode = 'commands'; // Still in commands mode, but pre-populating a command
                    const text = query.substring(8).trim();
                    this.state.filteredResults = [{ 
                        id: 'textile-dynamic', 
                        title: 'Insert Text Tile', 
                        desc: text || 'Create a visually distinct text block', 
                        icon: 'ðŸ“', 
                        execute: () => App.commandPalette.insertTextTile() 
                    }];
                } else if (query.toLowerCase().startsWith('fontsize')) {
                    this.state.mode = 'font-sizes';
                    const arg = query.substring(8).trim();
                    let results = [];
                    if (arg) {
                        if (!isNaN(parseFloat(arg)) && isFinite(arg)) {
                            results.push(`${arg}px`); // Push the string value directly
                        }
                        if (!this.state.fuse.fontSizes) {
                            this.state.fuse.fontSizes = new Fuse(this.state.fontSizeOptions);
                        }
                        results = results.concat(this.state.fuse.fontSizes.search(arg).map(r => r.item));
                    } else {
                        results = this.state.fontSizeOptions;
                    }
                    this.state.filteredResults = [...new Set(results)];
                } else if (query.toLowerCase().startsWith('fontfamily') || query.toLowerCase().startsWith('fontfam')) {
                    this.state.mode = 'font-families';
                    const commandLength = query.toLowerCase().startsWith('fontfamily') ? 10 : 7;
                    const arg = query.substring(commandLength).trim();
                    this.state.filteredResults = arg ? this.state.fuse.fontFamilies.search(arg).map(r => r.item) : this.state.fontFamilyOptions;
                } else {
                    this.state.mode = 'commands';
                    let results = query ? this.state.fuse.commands.search(query).map(r => r.item) : this.state.commands;
                    if (!hasSelection) {
                        results = results.filter(cmd => !cmd.selection);
                    }
                    this.state.filteredResults = results;
                }

                this.state.selectedIndex = 0;
                this.render();
            },

            render() {
                if (this.state.isFetching) { this.els.list.innerHTML = `<div class="command-item"><div class="command-item-icon spin">ðŸ“–</div><div class="command-item-text"><div class="command-item-title">Fetching definition...</div></div></div>`; return; }
                if (this.state.filteredResults.length === 0) { this.els.list.innerHTML = `<div class="command-item"><div class="command-item-text"><div class="command-item-title">No results found</div></div></div>`; return; }

                this.els.list.innerHTML = this.state.filteredResults.map((item, index) => {
                    let icon = '?', title = 'Unknown', desc = '';

                    switch(this.state.mode) {
                        case 'kashask':
                        case 'kashtranslate':
                            icon = item.icon;
                            title = item.title;
                            desc = item.desc;
                            break;
                        case 'definitions':
                            if (item.type === 'definition-prompt') { icon = 'âœï¸'; title = item.title; desc = item.desc;
                            } else if (item.error) { icon = 'ðŸ˜•'; title = item.error; desc = 'Try another word.'; 
                            } else { icon = 'ðŸ“–'; title = `${item.word} (${item.partOfSpeech})`; desc = item.definition; }
                            break;
                        case 'block-highlight': icon = item.icon; title = item.title; desc = item.desc; break;
                        case 'links': icon = item.type === 'article' ? 'ðŸ“„' : 'ðŸ’¬'; title = item.title; desc = item.desc; break;
                        case 'tags': icon = 'ðŸ·ï¸'; title = item.displayName; desc = `Insert tag: ${item.displayName}`; break;
                        case 'categories': icon = 'ðŸ“‚'; title = item.name; desc = `Set article category to ${item.name}`; break;
                        case 'font-sizes':
                            icon = 'Aa';
                            const fullText = `${item} is font-size`;
                            return `<div class="command-item ${index === this.state.selectedIndex ? 'selected' : ''}" data-index="${index}">
                                        <div class="command-item-icon">${icon}</div>
                                        <div class="command-item-text">
                                            <div class="command-item-title" style="font-size: ${item}; font-weight: 500;">${fullText}</div>
                                        </div>
                                    </div>`;
                        case 'font-families':
                            icon = 'Ab';
                            title = item.name;
                            desc = `Apply font family: ${item.value.split(',')[0]}`;
                            return `<div class="command-item ${index === this.state.selectedIndex ? 'selected' : ''}" data-index="${index}"><div class="command-item-icon">${icon}</div><div class="command-item-text"><div class="command-item-title" style="font-family: ${item.value};">${App.util.escapeHtml(title)}</div><div class="command-item-desc">${App.util.escapeHtml(desc)}</div></div></div>`;
                        case 'emojis': icon = item.e; title = item.k.split(' ')[0]; desc = item.k; break;
                        default: icon = item.icon; title = item.title; desc = item.desc; break;
                    }
                    return `<div class="command-item ${index === this.state.selectedIndex ? 'selected' : ''}" data-index="${index}"><div class="command-item-icon">${icon}</div><div class="command-item-text"><div class="command-item-title">${App.util.escapeHtml(title)}</div><div class="command-item-desc">${App.util.escapeHtml(desc)}</div></div></div>`;
                }).join('');

                // --- NEW: Logic to add the premium upsell message for Spark Tier users ---
                if (!App.license.isPremium()) {
                    const wittyMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
                    const upsellHTML = `
                        <div id="command-palette-upsell" class="command-item" style="cursor: pointer; border-top: 1px solid var(--border-color); margin-top: 4px; padding-top: 8px;">
                            <div class="command-item-icon">ðŸ’Ž</div>
                            <div class="command-item-text">
                                <div class="command-item-title" style="color: var(--primary-color);">Unlock Pro Commands</div>
                                <div class="command-item-desc">${wittyMessage}</div>
                            </div>
                        </div>`;
                    this.els.list.insertAdjacentHTML('beforeend', upsellHTML);
                    const upsellEl = document.getElementById('command-palette-upsell');
                    if (upsellEl) {
                        upsellEl.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            App.ui.showAscensionModal();
                            this.close();
                        });
                    }
                }
                // --- END of new logic ---

                this.els.list.querySelectorAll('.command-item:not(#command-palette-upsell)').forEach(item => { item.addEventListener('mousedown', (e) => { e.preventDefault(); this.state.selectedIndex = parseInt(e.currentTarget.dataset.index, 10); this.execute(); }); });
                this._updateSelection();
            },

            applyStyle(property, value) {
                const selection = window.getSelection();
                if (!selection || selection.rangeCount === 0) return;

                const range = selection.getRangeAt(0);
                const contentDiv = document.getElementById('article-content');
            
                if (!contentDiv.contains(range.commonAncestorContainer)) return;
                if (!selection.isCollapsed) {
                    const span = document.createElement('span');
                    span.style[property] = value;
                    
                    try {
                        range.surroundContents(span);
                    } catch (e) {
                        console.warn("Could not use surroundContents, falling back to insertHTML.", e);
                        document.execCommand('insertHTML', false, `<span style="${property.replace(/([A-Z])/g, '-$1').toLowerCase()}:${value};">${selection.toString()}</span>`);
                    }
                } 
                else {
                    let blockElement = range.startContainer;
                    if (blockElement.nodeType === Node.TEXT_NODE) {
                        blockElement = blockElement.parentElement;
                    }
                    
                    blockElement = blockElement.closest('p, li, h1, h2, h3, h4, h5, h6, blockquote, div');

                    if (blockElement && contentDiv.contains(blockElement)) {
                        blockElement.style[property] = value;
                    }
                }
                
                App.state.isArticleDirty = true;
            },

            execute() {
                const item = this.state.filteredResults[this.state.selectedIndex];
                if (!item || item.type === 'suggestion') return;

                if (item.type === 'premium-upsell') {
                    App.ui.showAscensionModal();
                    this.close();
                    return; // Stop execution here.
                }
                
                if (this.state.isPreviewActive) {
                    this._restoreEditor();
                }

                if (App.state.savedRange) {
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(App.state.savedRange);
                } else if (this.state.cursorMarkerId) {
                    const markerNode = document.getElementById(this.state.cursorMarkerId);
                    if (markerNode) {
                        const sel = window.getSelection();
                        const range = document.createRange();
                        range.setStartBefore(markerNode);
                        range.collapse(true);
                        sel.removeAllRanges();
                        sel.addRange(range);
                        markerNode.parentNode.removeChild(markerNode);
                    }
                }
                App.state.savedRange = null;
                this.state.cursorMarkerId = null;

                this.els.palette.style.display = 'none';
                document.getElementById('article-content')?.focus();

                try {
                    switch(this.state.mode) {
                        case 'kashask':
                            if (item.prompt) App.events.ai.executeKashAsk(item.prompt);
                            break;
                        case 'kashtranslate':
                            if (item.language) App.events.ai.executeKashTranslate(item.language);
                            break;
                        case 'kashextract':
                            if (item.subCommand) App.events.ai.executeKashExtract(item.subCommand);
                            break;
                        case 'kashlink':
                            if (item.topic) App.events.ai.executeKashLink(item.topic);
                            break;
                        case 'kashoutline':
                            if (item.topic) App.events.ai.executeKashOutline(item.topic);
                            break;
                        case 'block-highlight': this.applyBlockHighlight(item.className); break;
                        case 'links': document.execCommand('insertHTML', false, item.type === 'snippet' ? `<a href="#" data-link-type="snippet" data-article-id="${item.articleId}" data-link-id="${item.id}">${item.title}</a>` : `<a href="#" data-link-type="article" data-link-id="${item.id}">${item.title}</a>`); break;
                        case 'tags': document.execCommand('insertHTML', false, `<span class="rendered-tag" data-tag="${item.id}">${item.displayName}</span>`); break;
                        case 'categories': const categorySelector = document.getElementById('category-selector'); if (categorySelector) { categorySelector.value = item.id; App.events.saveArticle({ isAutosave: true }); App.ui.showToast(`Category set to ${item.name}`, { type: 'success' }); } break;
                        case 'font-sizes':
                            this.applyStyle('fontSize', item);
                            break;
                        case 'font-families':
                            const freeFonts = [
                                'Arial, Helvetica, sans-serif', 'Cambria, Cochin, Georgia, Times, "Times New Roman", serif',
                                "'Courier New', Courier, monospace", 'Garamond, serif', 'Georgia, serif',
                                'Helvetica, Arial, sans-serif', 'Monaco, "Lucida Console", monospace',
                                'Palatino, "Palatino Linotype", serif', 'sans-serif', "'Times New Roman', Times, serif",
                                'Verdana, Geneva, sans-serif'
                            ];
                            const isPremiumFont = !freeFonts.includes(item.value);

                            if (isPremiumFont && !App.license.isPremium()) {
                                App.ui.showAscensionModal();
                            } else {
                                this.applyStyle('fontFamily', item.value);
                            }
                            break;
                        case 'emojis': document.execCommand('insertText', false, item.e); break;
                        case 'definition-prompt': break;
                        case 'definitions':
                            if (item.error) { App.ui.showToast(item.error, 'error'); break; }
                            let definitionHTML = `<b>${item.word}</b> (<i>${item.partOfSpeech}</i>)<blockquote>${item.definition}</blockquote>`;
                            if (item.synonyms) { definitionHTML += `<p><b>Synonyms:</b> ${item.synonyms}</p>`; }
                            definitionHTML += `<p><br></p>`;
                            document.execCommand('insertHTML', false, definitionHTML);
                            break;
                        case 'clip':
                            if (item && item.url) {
                                App.contentTools.clipArticle(item.url);
                            }
                            break;
                        default:
                            if (item.isPremium && !App.license.isPremium()) {
                                App.ui.showAscensionModal();
                            } else if (item.execute) {
                                item.execute();
                            }
                            break;
                    }
                } catch (e) {
                    console.error("Command execution failed:", e);
                    if (item.isPremium && !App.license.isPremium()) {
                        App.ui.showToast("This is a Premium feature. Upgrade to unlock.", "warning");
                    } else {
                        App.ui.showToast('Command failed.', 'error');
                    }
                }

                this.state.isOpen = false;
                document.removeEventListener('click', this.handleClickOutside, true);
            },


            close() {
                if (!this.state.isOpen) return;
                this._restoreEditor();

                // 2. Clean up any temporary markers.
                const markerNode = document.getElementById(this.state.cursorMarkerId);
                if (markerNode) {
                    markerNode.parentNode.removeChild(markerNode);
                }

                // 3. Reset all state and UI elements.
                this.state.isOpen = false;
                App.state.savedRange = null;
                this.state.cursorMarkerId = null;

                if (this.els.palette) this.els.palette.style.display = 'none';
                if (this.els.input) this.els.input.value = '';

                document.removeEventListener('click', this.handleClickOutside, true);

                // 4. Return focus to the editor for a seamless experience.
                const contentDiv = document.getElementById('article-content');
                if (contentDiv) contentDiv.focus();
            },

            handleKeyDown(e) { 
                if (!this.state.isOpen) return;
                // FIX: Correct backspace behavior
                if (e.key === 'Escape') { e.preventDefault(); this.close(); return; }
                if (e.key === 'Backspace' && this.els.input.value === '') { e.preventDefault(); this.close(); return; }
                if (e.key === '/') { e.preventDefault(); this.exitAndInsertSlash(); return; }

                if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (e.key === 'ArrowDown') { this.state.selectedIndex = (this.state.selectedIndex + 1) % this.state.filteredResults.length; } 
                    else { this.state.selectedIndex = (this.state.selectedIndex - 1 + this.state.filteredResults.length) % this.state.filteredResults.length; }
                    this.render();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    this.execute();
                }
            },
            exitAndInsertSlash() {
                if (!this.state.isOpen) return;
                this._restoreEditor();
                const markerNode = document.getElementById(this.state.cursorMarkerId);
                if (markerNode) {
                    const slashNode = document.createTextNode('/'); markerNode.parentNode.insertBefore(slashNode, markerNode);
                    const sel = window.getSelection(); const range = document.createRange();
                    range.setStartAfter(slashNode); range.collapse(true); sel.removeAllRanges(); sel.addRange(range); markerNode.parentNode.removeChild(markerNode);
                }
                this.close(true);
            },
            handleClickOutside: (e) => {
                const self = App.commandPalette;
                if (self.state.isOpen && !self.els.palette.contains(e.target)) {
                    self.close(); 
                }
            },
        },



        // ==========================================================================
        // 3.15. KASH CO-PILOT (AI SIDEBAR)
        // ==========================================================================
        coPilot: {
            state: {
                isOpen: false,
                context: {}, 
                history: [],
                commands: [],
                commandSuggestions: [],
                selectedCommandIndex: -1,
                textileColorIndex: 0,
            },
            els: {},

            init() {
                this.els.toggle = document.getElementById('kash-copilot-toggle');
                this.els.sidebar = document.getElementById('kash-copilot-sidebar');
                this.els.conversationArea = document.getElementById('copilot-conversation-area');
                this.els.input = document.getElementById('copilot-input');
                this.els.sendBtn = document.getElementById('copilot-send-btn');
                this.els.commandList = document.getElementById('copilot-command-list');
                
                this.state.commands = App.commandPalette.state.commands.filter(cmd => cmd.id.startsWith('kash'));

                this.els.toggle.addEventListener('click', () => this.toggle());
                this.els.sendBtn.addEventListener('click', () => this.handleUserInput());
                
                this.els.input.addEventListener('input', () => {
                    this.els.input.style.height = 'auto';
                    this.els.input.style.height = `${this.els.input.scrollHeight}px`;
                    this.showCommandSuggestions();
                });

                this.els.input.addEventListener('keydown', (e) => {
                    if (this.els.commandList.style.display !== 'none') {
                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            this.state.selectedCommandIndex = (this.state.selectedCommandIndex + 1) % this.state.commandSuggestions.length;
                            this.renderCommandSuggestions();
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            this.state.selectedCommandIndex = (this.state.selectedCommandIndex - 1 + this.state.commandSuggestions.length) % this.state.commandSuggestions.length;
                            this.renderCommandSuggestions();
                        } else if (e.key === 'Enter' && this.state.selectedCommandIndex > -1) {
                            e.preventDefault();
                            this.selectCommand();
                        } else if (e.key === 'Escape') {
                            this.els.commandList.style.display = 'none';
                        }
                    } else if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handleUserInput();
                    }
                });

                this.els.toggle.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3L9.5 8.5L4 10l5.5 2.5L12 18l2.5-5.5L20 10l-5.5-2.5z"/></svg>`;
            },
            showCommandSuggestions() {
                const query = this.els.input.value.toLowerCase();
                if (query.startsWith('kash')) {
                    const searchTerm = query.substring(4).trim();
                    this.state.commandSuggestions = this.state.commands.filter(cmd => cmd.id.includes(searchTerm) || cmd.title.toLowerCase().includes(searchTerm));
                    this.state.selectedCommandIndex = 0;
                    this.renderCommandSuggestions();
                    this.els.commandList.style.display = 'block';
                } else {
                    this.els.commandList.style.display = 'none';
                }
            },

            renderCommandSuggestions() {
                this.els.commandList.innerHTML = this.state.commandSuggestions.map((cmd, index) =>
                    `<button class="${index === this.state.selectedCommandIndex ? 'selected' : ''}" data-command="${cmd.id}">
                        <span class="command-icon">${cmd.icon}</span>
                        <span><b>${cmd.id}</b>: ${cmd.title}</span>
                    </button>`
                ).join('');

                this.els.commandList.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.els.input.value = btn.dataset.command + ' ';
                        this.selectCommand();
                    });
                });
            },

            selectCommand() {
                const selected = this.state.commandSuggestions[this.state.selectedCommandIndex];
                if (selected) {
                    this.els.input.value = selected.id + ' ';
                    this.els.input.focus();
                    this.els.commandList.style.display = 'none';
                }
            },

            async toggle() { 
                this.state.isOpen = !this.state.isOpen;
                if (this.state.isOpen) {
                    this.renderConversation();
                    this.els.sidebar.style.display = 'flex';
                    setTimeout(() => { this.els.sidebar.classList.add('visible'); this.els.input.focus(); }, 10);
                } else {
                    this.els.sidebar.classList.remove('visible');
                    setTimeout(() => { this.els.sidebar.style.display = 'none'; }, 400);
                }
            },

            async _getPdfContext() {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();

                if (selectedText) {
                    const container = document.getElementById('pdf-viewer-container');
              
                    if (container && selection.anchorNode && container.contains(selection.anchorNode)) {
                        console.log("Co-Pilot: Using selected PDF text as context.");
                        return {
                            contextText: selectedText,
                            contextType: 'selection'
                        };
                    }
                }

                const currentPageNum = App.pdf.state.pageNum;
                if (currentPageNum > 0) {
                    console.log(`Co-Pilot: No selection found. Using full text of page ${currentPageNum} as context.`);
                    const pageText = await App.pdf.viewer.getTextContentForPage(currentPageNum);
                    return {
                        contextText: pageText || "No text could be extracted from the current page.",
                        contextType: 'full page'
                    };
                }
                return {
                    contextText: "Could not determine the current PDF page or selection.",
                    contextType: 'error'
                };
            },

            async startWithPrompt(promptText) {
                if (!App.license.isPremium()) {
                    if (!this.state.isOpen) { await this.toggle(); }

                    const wittyMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
                    const persuasiveMessage = `
                        <p><strong>This is a Premium feature! âœ¨</strong></p>
                        <p>Unlock the full potential of Kash Co-Pilot, let your ideas flow faster and smoother. Consider going Premium to get Unlimited AI Access.</p>
                        <div style="margin: 1rem 0; text-align: center;">
                            <button class="btn btn-primary" onclick="App.ui.showAscensionModal()">Go Premium Go Unlimited</button>
                        </div>
                        <hr style="border-color: var(--border-color); opacity: 0.5;">
                        <p class="witty-gradient-text" style="font-size: 0.9em;"><em>${wittyMessage}</em></p>
                    `;
                    this.state.history.push({ role: 'user', content: promptText });
                    this.state.history.push({ role: 'ai', content: persuasiveMessage });
                    this.renderConversation();
                    return;
                }

                if (!this.state.isOpen) { await this.toggle(); } 
                this.els.input.value = promptText;
                this.els.input.style.height = 'auto';
                this.els.input.style.height = `${this.els.input.scrollHeight}px`;
                this.els.input.focus();
                setTimeout(() => { this.handleUserInput(); }, 100);
            },

            async gatherContext() {
                this.state.context = { immediate: null, session: null };

          
                if (document.body.classList.contains('pdf-viewer-active')) {
                    const { contextText, contextType } = await this._getPdfContext();
                    
                    this.state.context.session = contextText;
                    this.state.context.immediate = `The user is viewing a PDF document. The provided Article Content is from the user's current text ${contextType}.`;
                    
                    return; // Exit early, as we have our context.
                }

                if (App.state.focusSession.isActive) {
                    const session = App.state.focusSession;
                    const currentArticle = session.articles[session.currentIndex];

                    if (currentArticle && currentArticle.content) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = currentArticle.content;
                        this.state.context.session = tempDiv.innerText;
                    } else {
                        this.state.context.session = "No content found for the current presentation.";
                    }

                    const focusBody = document.querySelector('.focus-mode-body');
                    if (focusBody) {
                        const visibleSnippets = Array.from(focusBody.querySelectorAll('.snippet, .nk-mcq-block, .nk-accordion, .nk-timeline-block, .chart-container'));

                        if (visibleSnippets.length > 0) {
                            const onScreenText = visibleSnippets.map(el => el.innerText.trim()).join('\n\n---\n\n');
                            this.state.context.immediate = onScreenText;
                        } else {
                            this.state.context.immediate = 'There are no snippets or blocks currently on screen.';
                        }
                    } else {
                        this.state.context.immediate = 'Could not find the focus mode body.';
                    }
                }
            },

            async handleUserInput() {
                await this.gatherContext(); 

                const userInput = this.els.input.value.trim();
                if (!userInput) return;

                if (!App.license.isPremium()) {
                    const wittyMessage = App.util.getRandomMessage(App.util.wittyDeveloperMessages);
                    const persuasiveMessage = `
                        <p><strong>This is a Premium feature! âœ¨</strong></p>
                        <p>To unlock the full power of Kash Co-Pilot and get instant answers, please consider upgrading your plan.</p>
                        <div style="margin: 1rem 0; text-align: center;">
                            <button class="btn btn-primary" onclick="App.ui.showAscensionModal()">View Premium Tiers</button>
                        </div>
                        <hr style="border-color: var(--border-color); opacity: 0.5;">
                        <p class="witty-gradient-text" style="font-size: 0.9em;"><em>${wittyMessage}</em></p>
                    `;
                    this.state.history.push({ role: 'user', content: userInput });
                    this.state.history.push({ role: 'ai', content: persuasiveMessage });
                    this.renderConversation();
                    this.els.input.value = ''; // Clear the input
                    this.els.input.style.height = 'auto';
                    return; // Stop execution before calling the AI
                }

                this.state.history.push({ role: 'user', content: userInput });
                this.renderConversation();
                this.els.input.value = '';
                this.els.input.style.height = 'auto';
                this.els.input.focus();
                this.els.commandList.style.display = 'none';
                this.addMessageToConversation('ai', '...', true);
                try {
                    const aiResponse = await this.processPrompt(userInput);
                    this.updateLastMessage(aiResponse);
                } catch (error) {
                    console.error("Co-Pilot Error:", error);
                    this.updateLastMessage(`<p style="color:var(--danger-color);">Sorry, an error occurred: ${error.message}</p>`);
                }
            },

            renderConversation() {
                this.els.conversationArea.innerHTML = '';
                if (this.state.history.length === 0) {
                    const isInFocusMode = App.state.focusSession.isActive;
                    // V-- NEW LOGIC STARTS HERE --V
                    const isPdfView = document.body.classList.contains('pdf-viewer-active');
                    let headerText, promptStarters;

                    if (isPdfView && App.pdf.state.currentAttachment) {
                        const pdfName = App.pdf.state.currentAttachment.name.replace(/\.pdf$/i, '');
                        const shortPdfName = pdfName.split(' ').slice(0, 2).join(' ');
                        headerText = `How can I assist with your "${shortPdfName}" PDF?`;
                        promptStarters = [
                            { icon: 'fa-file-lines', text: 'Summarize this page', prompt: 'Summarize the key points of the current page.' },
                            { icon: 'fa-comments', text: 'Main arguments', prompt: 'What are the main arguments on this page?' },
                            { icon: 'fa-circle-question', text: 'Generate questions', prompt: 'Generate 3 key questions from the text on this page.' }
                        ];
                    } else if (isInFocusMode) {
                        headerText = 'I have read your Presentation. Ask me anything!';
                        promptStarters = [
                            { icon: 'fa-file-lines', text: 'Summarize Session', prompt: 'Summarize the key points of the entire session.' },
                            { icon: 'fa-comments', text: 'Main Arguments', prompt: 'What are the main arguments in this presentation?' },
                            { icon: 'fa-circle-question', text: 'Generate Questions', prompt: 'Generate 3 key questions from this session.' }
                        ];
                    } else {
                        headerText = 'How can I help you today?';
                        promptStarters = [
                            { icon: 'fa-wand-magic-sparkles', text: 'What can you do?', prompt: 'What can you do?' },
                            { icon: 'fa-flask', text: 'Random Fun Fact', prompt: 'Give me a random fun fact about science.' },
                            { icon: 'fa-lightbulb', text: 'Suggest a Title', prompt: 'Suggest a title for a note about economics.' }
                        ];
                    }
                    // A-- NEW LOGIC ENDS HERE --A

                    const promptStartersHTML = promptStarters.map(p => `
                        <div class="copilot-prompt-card" onclick="App.coPilot.startWithPrompt('${p.prompt}')">
                            <i class="fa-solid ${p.icon}"></i>
                            <span>${p.text}</span>
                        </div>
                    `).join('');

                    this.els.conversationArea.innerHTML = `
                        <div class="copilot-empty-state">
                            <div class="copilot-centered-header">
                                <h2 class="witty-gradient-text">Kash Co-Pilot</h2>
                                <p>${headerText}</p>
                            </div>
                            <div class="copilot-prompt-grid">${promptStartersHTML}</div>
                        </div>`;
                } else {
                    this.state.history.forEach(msg => { this.addMessageToConversation(msg.role, msg.content, false); });
                }
            },

            addMessageToConversation(role, content, isThinking = false) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `copilot-message ${role}`;
                const bubble = document.createElement('div');
                bubble.className = 'copilot-message-bubble';
                
                if (isThinking) {
                    bubble.innerHTML = 'ðŸ¤”';
                    bubble.id = 'thinking-bubble';
                } else {
                    let finalContent = App.util.sanitizeHTML(content); // Default for user messages
                    if (role === 'ai') {
                        const sanitizedContent = this._sanitizeAiResponse(content); // <-- SANITIZE HERE
                        const actionsHTML = `<div class="copilot-bubble-actions"><button class="btn btn-secondary" onclick="App.coPilot.copyContent(this)">Copy</button><button class="btn btn-primary" onclick="App.coPilot.insertContent(this)">Insert</button></div>`;
                        finalContent = App.util.sanitizeHTML(sanitizedContent) + actionsHTML;
                        bubble.innerHTML = finalContent;
                        bubble.contentEditable = "true";
                    } else {
                        bubble.innerHTML = finalContent;
                    }
                }
                
                messageDiv.appendChild(bubble);
                this.els.conversationArea.appendChild(messageDiv);
                this.els.conversationArea.scrollTop = this.els.conversationArea.scrollHeight;
            },
           
            copyContent(buttonElement) {
                const bubble = buttonElement.closest('.copilot-message-bubble');
                if (!bubble) return;
                const contentToCopy = bubble.cloneNode(true);
                contentToCopy.querySelector('.copilot-bubble-actions')?.remove();
                try {
                    const blob = new Blob([contentToCopy.innerHTML], { type: 'text/html' });
                    const textBlob = new Blob([contentToCopy.innerText], { type: 'text/plain' });
                    const clipboardItem = new ClipboardItem({ 'text/html': blob, 'text/plain': textBlob });
                    navigator.clipboard.write([clipboardItem]);
                } catch (e) {
                    navigator.clipboard.writeText(contentToCopy.innerText || contentToCopy.textContent);
                }
                App.ui.showToast('Copied to clipboard!', 'success');
            },

            updateLastMessage(newContent) {
                const thinkingBubble = document.getElementById('thinking-bubble');
                if (thinkingBubble) {
                    let finalContent = this._sanitizeAiResponse(newContent); // <-- SANITIZE HERE

                    // Failsafe for empty responses after sanitizing
                    if (!finalContent || finalContent.trim() === '') {
                        finalContent = `<p style="color:var(--danger-color);">Sorry, the AI did not provide a valid response. Please try again.</p>`;
                    }

                    const bubbleContent = App.util.sanitizeHTML(finalContent);
                    const actionsHTML = `<div class="copilot-bubble-actions"><button class="btn btn-secondary" onclick="App.coPilot.copyContent(this)">Copy</button><button class="btn btn-primary" onclick="App.coPilot.insertContent(this)">Insert</button></div>`;
                    
                    thinkingBubble.innerHTML = bubbleContent + actionsHTML;
                    thinkingBubble.id = '';
                    
                    this.state.history[this.state.history.length - 1] = { role: 'ai', content: finalContent };
                    
                    setTimeout(() => { App.ui.renderChartOnCanvas(thinkingBubble.querySelector('canvas')); }, 50);
                }
                this.els.conversationArea.scrollTop = this.els.conversationArea.scrollHeight;
            },

            async insertContent(buttonElement) {
                const bubble = buttonElement.closest('.copilot-message-bubble');
                if (!bubble) return;

                const contentToInsert = bubble.cloneNode(true);
                contentToInsert.querySelector('.copilot-bubble-actions')?.remove();
                const contentHTML = contentToInsert.innerHTML;

                const solidColors = App.commandPalette.state.textileColors.filter(c => !isNaN(c));
                const color = solidColors[this.state.textileColorIndex];
                this.state.textileColorIndex = (this.state.textileColorIndex + 1) % solidColors.length;
                const textileHTML = `<div class="nk-text-tile color-${color}" data-color="${color}" contenteditable="false"><div class="nk-text-tile-content" contenteditable="true">${contentHTML}</div></div>`;

                if (document.body.classList.contains('pdf-viewer-active')) {
                    const article = App.storage.getArticle(App.state.activeArticleId);
                    if (!article) {
                        App.ui.showToast("Could not find the source article to save to.", "error");
                        return;
                    }
                    const updatedContent = article.content + '<p><br></p>' + textileHTML;
                    const result = await App.storage.updateArticle(article.id, { content: updatedContent });
                    
                    if (result.success) {
                        App.ui.showToast('Co-Pilot reply saved!', 'success');
                        this.toggle();
                    } else {
                        App.ui.showToast("Error saving content to the note.", "error");
                    }
                    return;

                } else if (App.state.focusSession.isActive) {
                    const focusBody = document.querySelector('.focus-mode-body');
                    if (focusBody) {
                        const newSnippet = document.createElement('div');
                        newSnippet.className = 'snippet';
                        newSnippet.tabIndex = 0;
                        newSnippet.innerHTML = textileHTML;
                        focusBody.appendChild(newSnippet);
                        
                        const session = App.state.focusSession;
                        session.scrollStops = App.ui._calculateScrollStops(focusBody);
                        session.currentSlideIndex = session.scrollStops.length - 1;
                        App.ui.renderFocusModeControls();
                        newSnippet.scrollIntoView({ behavior: 'smooth', block: 'end' });
                    }

                    const session = App.state.focusSession;
                    const currentArticleInSession = session.articles[session.currentIndex];
                    const articleToUpdate = App.storage.getArticle(currentArticleInSession.id);
                    
                    if (!articleToUpdate) {
                        App.ui.showToast("Could not find the source article to save to.", "error");
                        return;
                    }

                    const updatedContent = articleToUpdate.content + '<p><br></p>' + textileHTML;
                    const result = await App.storage.updateArticle(articleToUpdate.id, { content: updatedContent });

                    if (result.success) {
                        App.ui.showToast('Co-Pilot reply saved', 'success');
                        this.toggle();
                    } else {
                        App.ui.showToast("Error saving content to the note.", "error");
                    }
                    return;

                } else {
                    if (App.router.getActiveView() !== 'article') {
                        App.ui.showToast("Please open a note to insert content.", "warning");
                        return;
                    }
                    if (App.state.currentMode !== 'write') {
                        App.events.switchToMode('write');
                        setTimeout(() => this.insertContent(buttonElement), 200);
                        return;
                    }
                    App.util.insertGuardianBlock(textileHTML);
                    App.ui.showToast('Content inserted into note!', 'success');
                    this.toggle();
                }
            },

            async processPrompt(userInput) {
                const lowerInput = userInput.toLowerCase();
                
                if (lowerInput.startsWith('focus on') || lowerInput.startsWith('find')) {
                    this.executePresentationControl(userInput);
                    return `<p>Okay, I've focused the view for you.</p>`;
                }

            
                const sessionContext = this.state.context.session || '';
                const immediateContext = this.state.context.immediate || '';
 
                const fullContext = `${sessionContext}\n\n${immediateContext}`.trim();
                const context = fullContext || "No context available.";

                
                const combinedUserPrompt = `[User Prompt]: ${userInput}\n\n---\n\n[Article Content]:\n${context}`;
                
                const commandMap = {
                    'summary': 'KashSummary', 'summarize': 'KashSummary', 'explain': 'KashExplain',
                    'keywords': 'KashKeywords', 'key terms': 'KashKeywords', 'debate': 'KashDebate', 
                    'quote': 'KashQuote', 'accordion': 'KashAccordion', 'q&a': 'KashAccordion', 
                    'flashcard': 'KashFlash', 'mcq': 'KashMCQ', 'table': 'KashTable', 
                    'mnemonic': 'KashMnemonic', 'question': 'KashQuestion', 'questions': 'KashQuestion',
                    'comedy': 'KashComedy', 'joke': 'KashComedy', 'funny': 'KashComedy',
                    'script': 'KashScript', 'video': 'KashScript',
                    'story': 'KashStory', 'narrative': 'KashStory'
                };

                for (const keyword in commandMap) {
                    if (lowerInput.includes(keyword)) {
                        const command = commandMap[keyword];
                        const systemPrompt = this.getSystemPromptForCommand(command);
                        const aiResponse = await App.services.ai.queryGenerativeAI(systemPrompt, combinedUserPrompt);
                        if (!aiResponse) return `<p style="color:var(--danger-color);">The AI was unable to process this command. Please try again.</p>`;
                        return aiResponse;
                    }
                }

                const defaultSystemPrompt = `You are Kash Co-Pilot, an intelligent AI assistant and Subject Matter Expert integrated into the 'NoteKash' app.

                **Primary Goal:** Provide the most comprehensive, accurate, and enriched answer possible by intelligently synthesizing the user's note context with your own vast knowledge base. Your answers should be well-structured, factually reliable, and easy to understand.

                **You will receive two inputs:**
                1.  **[User Prompt]:** The user's direct question or command.
                2.  **[Article Content]:** The text from the user's current note, which should be used as supplemental context or a starting point.

                **Core Logic Flow (Synthesis Model - Follow this precisely):**

                1.  **Understand the User's Goal:** First, analyze the [User Prompt] to determine the core Question or Task or Intent of User.

                2.  **Absorb Provided Context:** Second, carefully read the [Article Content]. Treat this as the user's current frame of reference, containing points they already consider very important.

                3.  **Synthesize and Enhance:** This is your primary task. Formulate your response by:
                    a.  Using your own extensive knowledge base from reliable sources as the foundation for a complete and factually accurate answer.
                    b.  Intelligently weaving in relevant facts, terms, or perspectives from the [Article Content] to make the answer more personalized to the user's notes.
                    c.  Enriching the user's context by adding new, relevant information, clarifying complexities, or providing deeper insights.
                    d.  **Accuracy is paramount:** If the [Article Content] seems to conflict with established facts, you MUST prioritize factual accuracy in your response.

                **Formatting Rules (CRITICAL):**
                * Your ENTIRE response MUST be in clean, readable HTML.
                * Use <b> tags for bolding key terms and <i> for emphasis.
                * If structuring data in a table would be clearer (e.g., the user asks for a Table or it's the best format to present material for revision), you MUST generate a simple HTML <table> with <th> headers.
                * Do NOT include \`\`\`html, markdown fences, or any text outside of the required HTML tags.`;
                
                return await App.services.ai.queryGenerativeAI(defaultSystemPrompt, combinedUserPrompt);
            },
            
            executePresentationControl(command) {
                const lowerCommand = command.toLowerCase();
                if (lowerCommand.startsWith('focus on') || lowerCommand.startsWith('find')) {
                    const searchTerm = lowerCommand.replace(/^(focus on|find)\s*/, '').trim();
                    const snippets = Array.from(document.querySelectorAll('.focus-mode-body .snippet, .focus-mode-body .nk-mcq-block, .focus-mode-body .nk-accordion'));
                    const targetSnippet = snippets.find(s => s.textContent.toLowerCase().includes(searchTerm));

                    if (targetSnippet) {
                        targetSnippet.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        targetSnippet.classList.add('spotlight-key-focus');
                        setTimeout(() => targetSnippet.classList.remove('spotlight-key-focus'), 2500);
                    } else {
                        App.ui.showToast(`Couldn't find a snippet about "${searchTerm}".`, 'warning');
                    }
                }
            },
            
            getSystemPromptForCommand(commandName) {
                const prompts = {
                    'KashSummary': `You are a summarizer. You will receive a [User Prompt] and [Article Content]. Your task is fir to analyze [User Prompt] to understand user wants and then to create a concise summary of the [Article Content] according to Users intent (which you got from his prompt).
                        Output a single, one-line descriptive title, followed by 4-12 short, bulleted points using markdown <li> using <ul>.
                        CRITICAL: Respond ONLY with the markdown title and list. Do not use HTML or code fences.`,
                    
                    'KashFlash': `You are an intelligent text editor. You will receive a [User Prompt] and [Article Content]. Your task is to analyze the [Article Content] and convert 2-3 of its most important concepts into cloze deletions using the \`{{c1::concept}}\` syntax. For multiple cloze deletions, use {{c1::...}}, {{c2::...}}, etc.
                        CRITICAL: Respond ONLY with the modified text, preserving the original sentence structure. Do not use code fences.`,

                    'KashQuestion': `You are an Expert of Asking Questions. You only ask Questions and you are best in It. You will receive a [User Prompt] and [Article Content]. Your task is to Generate Questions (atleast 3-8 Questions) based on the [Article Content] and [User prompt]. Generate more relevant 5 insightful, open-ended and most relevant questions based on text to test user's knowlege and also to create insight on main topic. 
                        CRITICAL: Respond ONLY with a numbered list (1., 2., 3., ...) which are separated by new line (i.e new question in new line). Do not use HTML or code fences.`,

                    'KashDebate': `You are an Expert Debater. You will receive a [User Prompt] and [Article Content]. Your task is to create a two-column debate table based on the [Article Content], arguing FOR and AGAINST the main position.
                        CRITICAL: Respond ONLY with the complete HTML for the <table>. Do NOT include code fences.`,

                    'KashTable': `You are 'Kash, the Table-Maker,' an expert AI assistant. Your goal is to create the most accurate and helpful HTML table based on the user's request, intelligently synthesizing your own knowledge with the user's provided notes.

                    **Core Logic Flow (Synthesis Model):**

                    1.  **Analyze the User's Goal:** First, understand the core request in the [User Prompt]. Is it a general knowledge query (e.g., "list the articles of the constitution") or a simple command (e.g., "make a table")?

                    2.  **Synthesize and Enhance:**
                        * **Primary Action:** Use your own extensive knowledge base from reliable sources as the foundation to build the table the user asked for.
                        * **Enhancement:** Read the [Article Content]. If it contains specific details, examples, or nuances relevant to an entry in the table you're building, you **should** integrate that information to make the table more personalized and valuable.
                    
                    3.  **Context-Only Exception:**
                        * You should ONLY create a table *exclusively* from the [Article Content] if the [User Prompt] is a very simple, non-specific command like "make this a table," "convert this," or "summarize this as a table."

                    **CRITICAL FINAL RULE:**
                    Your ENTIRE response MUST be ONLY the complete HTML for the <table>. Do NOT include \`\`\`html, markdown fences, or any other text.`,
                    
                    'KashComedy': `You are a witty stand-up comedian. You will receive a [User Prompt] and [Article Content]. Your task is to turn the [Article Content] into a short, hilarious comedy routine script with touch of subcontinent.
                        **Formatting Rules:**
                        1.  Use simple, conversational English with a South Asian flavor.
                        2.  Use <b> tags for emphasis on punchlines.
                        3.  CRITICAL: Your ENTIRE response MUST be wrapped in a single \`<blockquote>\` tag. Do NOT use code fences.`,

                    'KashKeywords': `You are an expert academic analyst. You will receive a [User Prompt] and [Article Content]. Your task is to extract the 7-16 most important keywords and short phrases from the [Article Content].
                        CRITICAL: You MUST respond ONLY with a valid JSON array of strings. Example: ["Judicial Appointments", "Collegium System"]`,
                    
                    'KashScript': `You are a witty video scriptwriter. You will receive a [User Prompt] and [Article Content]. Your task is to turn the [Article Content] into a short, punchy video script (approx. 250 words).
                        **Formatting Rules:**
                        1.  Start with a strong, funny, one-line hook.
                        2.  Use short, conversational sentences. Make sure your script keeps user's interest (with some witty humour/ punchlines).
                        3.  CRITICAL: Output ONLY the final script text. No titles, no scene markers, no code fences. Just the spoken words.`,
                    
                    'KashStory': `You are 'Kash, the Story-Weaver.' You will receive a [User Prompt] and [Article Content]. Your task is to transform the factual [Article Content] into a short, funny, and memorable fictional story (200-500 words).
                        Embed the article's facts naturally within the narrative.
                        CRITICAL: Respond ONLY with the story text. Do NOT use markdown, code fences, titles, or headings.`,

                    'KashQuote': `You are 'Kash, the Quote Master.' You will receive a [User Prompt] and [Article Content]. Your task is to analyze the [Article Content] and find the single most insightful and contextually relevant quote.
                        CRITICAL: Respond ONLY with a single, valid and most relevant Quote with "quote" and "author name" in end.`,

                    'KashExplain': `You are 'Kash, the Clarifier,' an AI expert. You will receive a [User Prompt] and [Article Content]. Your task is to explain the topic of the [Article Content] with unparalleled clarity for a student. Use the [User Prompt] for any specific instructions (e.g., "explain it like I'm 10").
                        **Strict Output Structure:**
                        1. (Optional) A one-line title.
                        2. A 1-2 sentence plain-language summary.
                        3. 3-6 short bullet points (*) covering what, how, and why.
                        4. 2-4 numbered examples (1., 2., ...).
                        CRITICAL: Respond ONLY with the plain text explanation. DO NOT use headings, HTML, or code fences.`,

                    'KashMnemonic': `You are a focused mnemonic-maker. You will receive a [User Prompt] and [Article Content]. Your task is to create three mnemonic options for the [Article Content].
                        **Strict Output Structure:**
                        1) Simple & Catchy: [Mnemonic]
                        Usage: [Explanation]
                        2) Subcontinent-Flavored: [Mnemonic]
                        Usage: [Explanation]
                        3) Acronym/Rhyme: [Mnemonic]
                        Usage: [Explanation]
                        CRITICAL: Respond ONLY with the text in the exact structure above. Do NOT use headings, HTML, or code fences.`,

                    'KashAccordion': `You are an expert content architect. Who Acts as Expert in subject-matter/topic and generatesmost relevant and important Questions and giving their Short Answers. You will receive a [User Prompt] and [Article Content]. Your task is to analyze the [Article Content] and [User Prompt] and extract distinct questions and their answers. Give priority to [User Prompt] to understand Users intent or any additional information he shared onwhich you can ask QnA's
                        CRITICAL: Respond ONLY with a valid paragprahs  of Question/answer with multiple Questions/Answers. Each object MUST have two keys: "question" and "answer". The "answer" should be a single paragraph. 
                        You can give your reply in clean Html and use <b>, <em> or other styling methods to style content and make sure it looks well arranged. Avoid uses code fences or unnessary text (only Questions and Answers required)
                        How many QnA? - Minimum 3 and maximum 8.
                        Example: ["Question": "What is...?", (in new line)"Answer": "It is..."}, (separate two QnAs) {"Question": "How does...?","Answer": "It works by..."}]`,
                    
                    'KashMCQ': `You are an Expert Educator. You will receive [Article Content] and [User prompt]. Your task is to generate a 2-5 multiple-choice questions based on that content and your knowledge (which is reliable) - together synthesized into MCQ's. The question should have a clear correct answer and plausible distractors.
                        CRITICAL: Respond ONLY with the complete HTML for the <div class="nk-mcq-block">...</div>. Do NOT include code fences.`
                };
                return prompts[commandName];
            },

            clearConversation() {
                if (this.state.history.length > 0) {
                    this.state.history = [];
                    this.renderConversation(); // Re-render the empty state
                    App.ui.showToast('Conversation cleared.', { type: 'success', duration: 2000 });
                }
            },

            _sanitizeAiResponse(content) {
                if (typeof content !== 'string') return content;
                // This regex robustly removes markdown code fences (e.g., ```html ... ```)
                const cleaned = content.replace(/^\s*```(?:html|json|javascript)?\s*\n?([\s\S]*?)\n?\s*```\s*$/, '$1');
                return cleaned.trim();
            },

            async saveConversationAsNote() {
                if (this.state.history.length === 0) {
                    App.ui.showToast("Nothing to save.", "warning");
                    return;
                }

                const title = `Co-Pilot Conversation: ${new Date().toLocaleString()}`;
                let contentHTML = ``;

                this.state.history.forEach(msg => {
                    const cleanedContent = msg.content.replace(/<div class="copilot-bubble-actions">.*?<\/div>/s, '');
                    if (msg.role === 'user') {
                        contentHTML += `<blockquote><p><b>You:</b> ${cleanedContent}</p></blockquote>`;
                    } else {
                        contentHTML += `<div>${cleanedContent}</div>`;
                    }
                });

                const defaultCategory = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                const newNote = await App.storage.createArticle({
                    title: title,
                    content: contentHTML,
                    category: defaultCategory
                });

                if (newNote) {
                    App.ui.showToast('Conversation saved!', {
                        type: 'success',
                        action: {
                            label: 'Open Note',
                            callback: () => App.router.navigateTo('article', { id: newNote.id, mode: 'read' })
                        }
                    });
                    this.state.history = [];
                    this.renderConversation();
                } else {
                    App.ui.showToast("Failed to save conversation.", "error");
                }
            },

        },

        // ==========================================================================
        // 3.16. QUIZ MODULE (v2)
        // ==========================================================================
        quiz: {
            stats: {},
            session: {}, // To hold the state of the active quiz
            defaults: { lastScore: 0, bestScore: 0, totalScore: 0, totalQuizzes: 0, avgScore: 0 },
            async loadStats() { this.stats = await App.fs.read('quiz_stats.json') || { ...this.defaults }; },
            async saveStats() { await App.fs.write('quiz_stats.json', this.stats); },
            getStats() { return this.stats; },

            start(options = {}) {
                const { mode = 'classic' } = options; // 'classic' for Recall, 'mcq' for Recognition
                const quizSize = 10;
                let availableCards = App.util.getSortedFlashcardsForDisplay();
                let toastMessage = `You need at least ${quizSize} cards in this deck for a Recall Quiz.`;

                // 1. Filter cards based on the selected quiz mode
                if (mode === 'mcq') {
                    availableCards = availableCards.filter(c => c.type === 'mcq');
                    toastMessage = `You need at least ${quizSize} MCQs in this deck to start a Recognition Quiz.`;
                } else { // 'classic' mode for Recall Quiz
                    availableCards = availableCards.filter(c => c.type === 'collapsible' || c.type === 'cloze');
                }

                if (availableCards.length < quizSize) {
                    App.ui.showToast(toastMessage, { type: 'warning' });
                    return;
                }

                // 2. The Smart Algorithm: 6 (SRS) + 2 (New) + 2 (Random)
                let quizCards = [];
                const now = new Date();

                // Separate cards into buckets
                const newCards = availableCards.filter(c => c.rating === null);
                const dueCards = availableCards.filter(c => c.rating !== null && new Date(c.nextReviewDue) <= now);
                const otherRatedCards = availableCards.filter(c => c.rating !== null && new Date(c.nextReviewDue) > now);

                // Sort due cards by SRS priority (Again > Hard > ... > Easy)
                const ratingOrder = { 'Again': 1, 'Hard': 2, 'Hold': 3, 'Good': 4, 'Easy': 5 };
                dueCards.sort((a, b) => (ratingOrder[a.rating] || 6) - (ratingOrder[b.rating] || 6));

                // Shuffle new and other cards for random selection
                newCards.sort(() => 0.5 - Math.random());
                otherRatedCards.sort(() => 0.5 - Math.random());

                // 3. Assemble the quiz deck, handling edge cases
                const takeFrom = (source, count) => {
                    const taken = source.splice(0, count);
                    quizCards.push(...taken);
                    return taken.length;
                };

                let needed = 6;
                let taken = takeFrom(dueCards, needed);
                needed -= taken;

                // If not enough due cards, try to fill with new cards first
                if (needed > 0) {
                    taken = takeFrom(newCards, needed);
                    needed -= taken;
                }
                // If still not enough, fill with other rated cards
                if (needed > 0) {
                    takeFrom(otherRatedCards, needed);
                }

                // Now take the dedicated new and random cards
                needed = 2;
                taken = takeFrom(newCards, needed);
                needed -= taken;
                if (needed > 0) { // Fill from other sources if not enough new cards
                    taken = takeFrom(dueCards, needed);
                    if (taken < needed) takeFrom(otherRatedCards, needed - taken);
                }
                
                needed = 2;
                taken = takeFrom(otherRatedCards, needed);
                needed -= taken;
                if (needed > 0) { // Fill from other sources if not enough random cards
                    taken = takeFrom(dueCards, needed);
                    if (taken < needed) takeFrom(newCards, needed - taken);
                }

                // Final shuffle to mix the card types
                quizCards.sort(() => 0.5 - Math.random());
                
                // 4. Start the quiz session
                this.session = {
                    isActive: true,
                    mode: mode,
                    questions: quizCards,
                    score: 0,
                    answeredCardIds: new Set(),
                };
                
                App.events.study.start({ quizCards: quizCards, quizType: mode });
            },
            
            async handleMcqAnswer(isCorrect, card) {
                if (!this.session.isActive || this.session.answeredCardIds.has(card.id)) return;

                this.session.score += isCorrect ? 1 : -0.25;
                this.session.answeredCardIds.add(card.id);
                
                const rating = isCorrect ? 'Hold' : 'Again';
                const updatedCardData = App.util.sm2.rateCard(card, rating);
                const article = App.storage.getArticle(card.articleId);
                if (article?.flashcards?.[card.id]) {
                    const newFlashcards = { ...article.flashcards, [card.id]: { ...article.flashcards[card.id], ...updatedCardData } };
                    await App.storage.updateArticle(article.id, { flashcards: newFlashcards });
                }
            },
            
            async handleMcqSkip(card) {
                if (!this.session.isActive || this.session.answeredCardIds.has(card.id)) return;
                this.session.answeredCardIds.add(card.id); // Mark as processed, score remains 0
                
                const updatedCardData = App.util.sm2.rateCard(card, 'Again'); // Skipped counts as 'Again' for SRS
                const article = App.storage.getArticle(card.articleId);
                if (article?.flashcards?.[card.id]) {
                    const newFlashcards = { ...article.flashcards, [card.id]: { ...article.flashcards[card.id], ...updatedCardData } };
                    await App.storage.updateArticle(article.id, { flashcards: newFlashcards });
                }
            },

            async calculateAndShowResults(completedCards) {
                let score = 0;
                if (this.session.mode === 'mcq') {
                    score = Math.max(0, this.session.score);
                } else { // Classic Quiz
                    completedCards.forEach(card => {
                        score += App.config.quiz.scores[card.finalRating] || 0;
                    });
                }
                if (!this.stats.quizHistory) {
                    this.stats.quizHistory = [];
                }
                this.stats.quizHistory.push(new Date().toISOString());
                this.stats.lastScore = score;
                this.stats.bestScore = Math.max(this.stats.bestScore, score);
                this.stats.totalScore += score;
                this.stats.totalQuizzes += 1;
                this.stats.avgScore = this.stats.totalScore / this.stats.totalQuizzes;
                await this.saveStats();
                App.ui.showQuizResultModal(score, this.session.questions.length);

                // Clean up the temporary rating property to prevent score leakage
                completedCards.forEach(card => {
                    delete card.finalRating;
                });

                this.session = {}; // Reset session
            },
        },

        // ==========================================================================
        // 3.17. CONTENT TOOLS (v2 SuperTags)
        // ==========================================================================
        contentTools: {
            slugify: (text) => text.toString().toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-'),
            _applyWrapper(className, attributes = {}) {
                const selection = window.getSelection();
                if (!selection.rangeCount || selection.isCollapsed) return;
                const editor = document.getElementById('article-content');
                if (!editor.contains(selection.anchorNode)) return;
                const range = selection.getRangeAt(0);
                const parent = range.commonAncestorContainer.parentElement;
                if (parent && parent.classList.contains(className)) {
                    parent.replaceWith(...parent.childNodes);
                } else {
                    const wrapper = document.createElement(className === 'mindmap-snippet' ? 'mark' : 'span');
                    wrapper.className = className;
                    Object.entries(attributes).forEach(([key, value]) => wrapper.setAttribute(key, value));
                    wrapper.textContent = selection.toString();
                    range.deleteContents();
                    range.insertNode(wrapper);
                }
                selection.removeAllRanges();
            },

            async clipArticle(url) {
                const toastId = App.ui.showToast('Clipping article...', { type: 'info', duration: 0 });

                const insertClippedHTML = (article) => {
                    const clippedHTML = `
                        <blockquote>
                            <p><em>Clipped from: <a href="${App.util.escapeHtml(article.source)}" target="_blank" rel="noopener noreferrer">${App.util.escapeHtml(article.title)}</a></em></p>
                        </blockquote>
                        ${article.content}
                        <p><br></p>`;
                    
                    document.execCommand('insertHTML', false, clippedHTML);
                    App.state.isArticleDirty = true;
                    App.ui.hideToast(toastId);
                    App.ui.showToast('Article clipped successfully!', { type: 'success' });
                };

                try {
                    console.log("Clip: Attempting Tier 1 (Netlify Function)...");
                    const response = await fetch('/.netlify/functions/clipper', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ url })
                    });
            
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `Server responded with status ${response.status}`);
                    }
            
                    const article = await response.json();
                    insertClippedHTML(article);
                    console.log("Clip: Tier 1 succeeded.");

                } catch (tier1Error) {
                    console.warn("Clip: Tier 1 failed, attempting Tier 2 (Fallback). Reason:", tier1Error.message);
                    App.ui.updateToast(toastId, 'Advanced clipping failed. Trying fallback...');

                    try {
                        if (typeof Readability === 'undefined') {
                            throw new Error("Readability library is not loaded.");
                        }
                        const proxyUrl = 'https://api.allorigins.win/raw?url=';
                        const response = await fetch(proxyUrl + encodeURIComponent(url));

                        if (!response.ok) {
                            throw new Error(`Fallback fetch failed. Status: ${response.statusText}`);
                        }

                        const rawHtml = await response.text();
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(rawHtml, 'text/html');
                        const reader = new Readability(doc);
                        const article = reader.parse();

                        if (!article || !article.content) {
                            throw new Error("Fallback could not parse article content.");
                        }

                        insertClippedHTML({
                            title: article.title,
                            content: article.content,
                            source: url
                        });
                        console.log("Clip: Tier 2 (Fallback) succeeded.");

                    } catch (tier2Error) {
                        console.error('Clip: Tier 2 (Fallback) also failed:', tier2Error);
                        App.ui.hideToast(toastId);
                        App.ui.showToast(`Clipping failed completely: ${tier2Error.message}`, { type: 'error' });
                    }
                }
            },


            tagSelection(nodeToReplace = null) {
                if (nodeToReplace) {
                    const slug = this.slugify(nodeToReplace.textContent);
                    const wrapper = document.createElement('span');
                    wrapper.className = 'rendered-tag';
                    wrapper.dataset.tag = slug;
                    wrapper.textContent = nodeToReplace.textContent;
                    nodeToReplace.replaceWith(wrapper);
                } else {
                    const selectionText = window.getSelection().toString();
                    if (!selectionText.trim()) return;
                    const slug = this.slugify(selectionText);
                    this._applyWrapper('rendered-tag', { 'data-tag': slug });
                }
            },
            extractTagsFromHTML(html) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;
                return Array.from(tempDiv.querySelectorAll('.rendered-tag[data-tag]')).map(node => node.dataset.tag);
            },
            
            convertContentSyntax(htmlString) {
                if (!htmlString) return '';
                let processedHtml = htmlString;
                processedHtml = processedHtml.replace(/\[\[(.*?)\]\]/g, (match, content) => {
                    const slug = this.slugify(content);
                    if (!slug) return match;
                    return `<span class="rendered-tag" data-tag="${slug}">${content}</span>`;
                });
                return processedHtml;
            },
            updateDataTagsInContent(html) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;
                tempDiv.querySelectorAll('.rendered-tag').forEach(tag => {
                    tag.setAttribute('data-tag', this.slugify(tag.textContent));
                });
                return tempDiv.innerHTML;
            },
            autoSuggestTags(contentEl) {
                clearTimeout(App.state.suggestionTimeout);
                App.state.suggestionTimeout = setTimeout(() => {
                    const tagDisplayNames = Object.values(App.state.tags).map(t => t.displayName);
                    if (tagDisplayNames.length === 0) return;
                    const regex = new RegExp(`\\b(${tagDisplayNames.map(name => name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})\\b`, 'gi');
                    const walker = document.createTreeWalker(contentEl, NodeFilter.SHOW_TEXT);
                    const nodesToProcess = [];
                    while (walker.nextNode()) {
                        if (walker.currentNode.parentElement.closest('.rendered-tag, .tag-suggestion')) continue;
                        nodesToProcess.push(walker.currentNode);
                    }
                    nodesToProcess.forEach(textNode => {
                        const text = textNode.nodeValue;
                        if (!regex.test(text)) return;
                        const fragment = document.createDocumentFragment(); let lastIndex = 0;
                        text.replace(regex, (match, ...args) => {
                            const offset = args[args.length - 2];
                            if (offset > lastIndex) fragment.appendChild(document.createTextNode(text.substring(lastIndex, offset)));
                            const span = document.createElement('span'); span.className = 'tag-suggestion'; span.textContent = match; fragment.appendChild(span);
                            lastIndex = offset + match.length;
                        });
                        if (lastIndex < text.length) fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                        textNode.parentNode.replaceChild(fragment, textNode);
                    });
                }, 250);
            },
            async updateTagsIndex() {
                const newTagsIndex = {};
                App.state.articles.forEach(article => {
                    (article.tags || []).forEach(tag => {
                        const displayName = App.state.tags[tag]?.displayName || tag.replace(/-/g, ' ');
                        if (!newTagsIndex[tag]) newTagsIndex[tag] = { id: tag, displayName, count: 0, articles: [] };
                        newTagsIndex[tag].count++;
                        if (!newTagsIndex[tag].articles.includes(article.id)) newTagsIndex[tag].articles.push(article.id);
                    });
                });
                App.state.tags = newTagsIndex;
                await App.fs.write('tags.json', App.state.tags);
            },
            buildDataCache() {
                console.time("buildMindMapCache");
                const mindMapSnippets = {};
                App.state.articles.forEach(article => {
                    let snippets = App.util.extractSnippets(article, 'highlight');
                    mindMapSnippets[article.id] = snippets.filter(s => s.html && !s.html.includes('class="rendered-tag"'));
                });
                App.state.dataCache.mindMapSnippets = mindMapSnippets;
                App.state.dataCache.isBuilt = true;
                console.timeEnd("buildMindMapCache");
            },
        },

        // ==========================================================================
        // 3.18. MIND MAP MODULE (v2 - REBUILT FROM PROTOTAGS)
        // ==========================================================================
        mindMap: {
            svg: null, g: null, zoom: null, simulation: null, width: 0, height: 0, resizeObserver: null, isInitialLoad: true,
            mindmapRoots: [], currentMindmapIndex: -1, nodeStates: {}, layoutMode: 'Force',
            currentSnapshotIndex: -1, currentMindmapSearchResults: [], currentMindmapSearchIndex: -1,

            // INTERNALIZED: ColorManager is now part of this module to avoid global conflicts.
            colorManager: {
                palettes: ['c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'c10', 'c11', 'c12', 'c13', 'c14', 'c15'],
                assignment: new Map(),
                seed: 1,
                _pseudoRandom() { let x = Math.sin(this.seed++) * 10000; return x - Math.floor(x); },
                getSchemeFor(id, index) {
                    if (!this.assignment.has(id)) this.assignment.set(id, this.palettes[index % this.palettes.length]);
                    return this.assignment.get(id);
                },
                rotateSchemes() {
                    const shuffledPalettes = [...this.palettes];
                    for (let i = shuffledPalettes.length - 1; i > 0; i--) {
                        const j = Math.floor(this._pseudoRandom() * (i + 1));
                        [shuffledPalettes[i], shuffledPalettes[j]] = [shuffledPalettes[j], shuffledPalettes[i]];
                    }
                    const currentIds = Array.from(this.assignment.keys());
                    this.assignment.clear();
                    currentIds.forEach((id, index) => this.assignment.set(id, shuffledPalettes[index % shuffledPalettes.length]));
                },
                clear() { this.assignment.clear(); }
            },
            
            calculateEdgePoint(source, target) {
                const dx = target.x - source.x; const dy = target.y - source.y;
                if (dx === 0 && dy === 0) return { x: source.x, y: source.y };
                const w = source.width / 2; const h = source.height / 2;
                if (w === 0 || h === 0) return { x: source.x, y: source.y };
                const slope = dy / dx; const absSlope = Math.abs(slope);
                let x, y;
                if (absSlope < h / w) { x = dx > 0 ? w : -w; y = slope * x; } 
                else { y = dy > 0 ? h : -h; x = y / slope; }
                return { x: source.x + x, y: source.y + y };
            },

            init() {
                
                this.isInitialLoad = true;
               
                if (!App.state.dataCache.isBuilt) {
                    App.ui.showToast('Building mind map cache...', { type: 'info' });
                    App.contentTools.buildDataCache();
                    App.ui.showToast('Cache ready!', { type: 'success' });
                }
                
                if (this.svg) {
                    this.renderAllMindmaps();
                    return;
                }
                
                this.render();
                this.initControls();

                const container = document.getElementById('mindmap-container');
                container.focus();

                container.onkeydown = (e) => {
                    if (document.activeElement.tagName !== 'INPUT') {
                        if (e.key === ' ' && e.shiftKey) { this.zoomOut(); e.preventDefault(); } 
                        else if (e.key === ' ') { this.zoomIn(); e.preventDefault(); } 
                        else {
                            switch (e.key.toLowerCase()) {
                                
                                case 's': document.getElementById('mindmap-search-input').focus(); e.preventDefault(); break; // 'S' is now for Search
                                case 'p': this.saveSnapshotAndExport(); e.preventDefault(); break; // 'F' is now for snapshot/save frame
                         
                                case 'k': this.navigateToNextMap(); e.preventDefault(); break;
                                case 'j': this.navigateToPrevMap(); e.preventDefault(); break;
                                case 'f': App.events.toggleCanvasFocusMode(); e.preventDefault(); break;
                                case 'c': 
                                    if (App.license.isPremium()) { 
                                        this.colorManager.rotateSchemes(); 
                                        this.renderAllMindmaps(); 
                                    } else { 
                                        App.ui.showAscensionModal(); 
                                    }
                                    e.preventDefault();
                                    break;
                                case 'escape': 
                                    if (document.body.classList.contains('canvas-focus-mode')) {
                                        App.events.toggleCanvasFocusMode();
                                    } else {
                                        const searchInput = document.getElementById('mindmap-search-input'); 
                                        searchInput.value = ''; this.searchNodes(''); searchInput.blur(); 
                                    }
                                    e.preventDefault(); 
                                    break;
                            }
                        }
                    } else if (e.key === 'Enter' && document.activeElement === document.getElementById('mindmap-search-input')) {
                        e.preventDefault();
                        this.findNextSearchResult();
                    }
                };
                
                const snapshots = App.state.mindMapState.snapshots || [];
                if (snapshots.length > 0) this.loadSnapshot(snapshots[snapshots.length - 1]);
                else this.renderAllMindmaps();

                this.resizeObserver = new ResizeObserver(entries => {
                    if (entries[0].contentRect.width < 1) return;
                    this.width = entries[0].contentRect.width;
                    this.height = entries[0].contentRect.height;
                    this.svg.attr("viewBox", [-this.width / 2, -this.height / 2, this.width, this.height]);
                    if(this.simulation) this.simulation.force("center", d3.forceCenter(0,0)).alpha(0.3).restart();
                });
                this.resizeObserver.observe(container);
            },
            
            triggerResize() {
                const container = document.getElementById('mindmap-container');
                if (!container || !this.resizeObserver) return;
                // Temporarily disconnect to avoid infinite loops, manually trigger, then reconnect
                this.resizeObserver.disconnect();
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                if (newWidth > 0 && newHeight > 0) {
                    this.width = newWidth;
                    this.height = newHeight;
                    this.svg.attr("viewBox", [-this.width / 2, -this.height / 2, this.width, this.height]);
                    if(this.simulation) this.simulation.force("center", d3.forceCenter(0,0)).alpha(0.3).restart();
                }
                this.resizeObserver.observe(container);
            },

            destroy() {
                if (this.simulation) this.simulation.stop();
                if (this.resizeObserver) this.resizeObserver.disconnect();
                d3.select("#mindmap-container > svg").remove();
                this.svg = this.g = this.zoom = this.simulation = this.resizeObserver = null;
            },

            initControls() {
                // Free Controls
                document.getElementById('mindmap-find-next-btn').onclick = () => this.findNextSearchResult();
                document.getElementById('mindmap-next-btn').onclick = () => this.navigateToNextMap();
                document.getElementById('mindmap-prev-btn').onclick = () => this.navigateToPrevMap();
                document.getElementById('mindmap-zoom-in-btn').onclick = () => this.zoomIn();
                document.getElementById('mindmap-zoom-out-btn').onclick = () => this.zoomOut();
                document.getElementById('mindmap-reset-view-btn').onclick = () => this.zoomToFit();
                document.getElementById('mm-focus-line').onclick = () => App.events.toggleCanvasFocusMode();

                // Search listeners
                const searchInput = document.getElementById('mindmap-search-input');
                searchInput.oninput = (e) => this.searchNodes(e.target.value);
                searchInput.onkeydown = (e) => { if(e.key === 'Enter') { e.preventDefault(); this.findNextSearchResult(); }};

                // Premium Feature Gates
                document.getElementById('mindmap-expand-all').onclick = () => {
                    if (App.license.isPremium()) { this.nodeStates = {}; this.renderAllMindmaps(); }
                    else App.ui.showAscensionModal();
                };
                document.getElementById('mindmap-collapse-all').onclick = () => {
                    if (App.license.isPremium()) {
                        this.mindmapRoots.forEach(root => this.nodeStates[root.id] = { collapsed: true });
                        this.renderAllMindmaps();
                    } else App.ui.showAscensionModal();
                };
                document.getElementById('mindmap-gather-nodes-btn').onclick = () => {
                    if (App.license.isPremium()) this.gatherNodes(); else App.ui.showAscensionModal();
                };
                const layoutToggle = document.getElementById('mindmap-layout-toggle');
                layoutToggle.innerHTML = ICON_MINDMAP_FORCE;
                layoutToggle.onclick = () => {
                    if (App.license.isPremium()) this.toggleLayout(); else App.ui.showAscensionModal();
                };
                document.getElementById('mindmap-rotate-colors').onclick = () => {
                    if (App.license.isPremium()) { this.colorManager.rotateSchemes(); this.renderAllMindmaps(); }
                    else App.ui.showAscensionModal();
                };
                document.getElementById('mindmap-snapshot-btn').onclick = () => {
                    if (App.license.isPremium()) this.saveSnapshotAndExport(); else App.ui.showAscensionModal();
                };
                document.getElementById('mindmap-toggle-snapshots-btn').onclick = () => {
                    if (App.license.isPremium()) this.cycleSnapshots(); else App.ui.showAscensionModal();
                };
                document.getElementById('mindmap-delete-snapshots-btn').onclick = () => {
                    if (App.license.isPremium()) this.deleteOldSnapshots(); else App.ui.showAscensionModal();
                };
            },

            toggleLayout() {
                this.layoutMode = this.layoutMode === 'Force' ? 'Radial' : 'Force';
                const btn = document.getElementById('mindmap-layout-toggle');
                btn.innerHTML = this.layoutMode === 'Force' ? ICON_MINDMAP_FORCE : ICON_MINDMAP_RADIAL;
                if (this.simulation) this.simulation.alpha(0.3).restart();
            },
            
            prepareAllMindmapData() {
                const nodes = [], links = [];
                this.mindmapRoots = [];
                
                Object.entries(App.state.dataCache.mindMapSnippets).forEach(([articleId, snippetsData], index) => {
                    if (snippetsData.length === 0) return;

                    const article = App.storage.getArticle(articleId);
                    if (!article) return;
                    const colorScheme = this.colorManager.getSchemeFor(articleId, index);
                    
                    const rootDims = this.calculateNodeDimensions(article.title || 'Untitled', 'root');
                    const rootNode = { id: articleId, mindmapId: articleId, text: article.title || 'Untitled', type: 'root', colorScheme, ...rootDims };
                    nodes.push(rootNode);
                    this.mindmapRoots.push(rootNode);

                    if (!this.nodeStates[rootNode.id]?.collapsed) {
                        snippetsData.forEach((snippet) => {
                            // Use clean <img> for images, and clean text for snippets
                            const nodeText = snippet.isImage ? `<img src="${snippet.src}">` : snippet.text;
                            const childDims = this.calculateNodeDimensions(nodeText, 'child');
                            
                            nodes.push({
                                id: snippet.id,
                                articleId: articleId,
                                mindmapId: articleId,
                                text: nodeText,
                                type: 'child',
                                colorScheme,
                                ...childDims
                            });
                            links.push({ source: rootNode.id, target: snippet.id });
                        });
                    }
                });
                this.mindmapRoots.sort((a,b) => a.text.localeCompare(b.text));
                return { nodes, links };
            },

            calculateNodeDimensions(text, type) {
                
                if (typeof text === 'string' && text.trim().startsWith('<img')) {
                    return { width: 180, height: 140, needsCustomScroll: false, lineHeight: 0 };
                }

                const measurer = document.getElementById('text-measurer');
                if (!measurer) return { width: 288, height: 112, needsCustomScroll: false, lineHeight: 18 };

                const isRoot = type === 'root';
                measurer.style.fontSize = isRoot ? '14px' : '12px';
                measurer.style.fontWeight = isRoot ? '600' : 'normal';
                measurer.style.lineHeight = '1.5';
                measurer.style.width = 'auto';
                measurer.style.display = 'inline-block';
                measurer.innerHTML = text;
                
               const maxWidth = 250, maxHeight = 150, horizontalPadding = 28, verticalPadding = 20;
                let contentWidth = measurer.offsetWidth;
                let finalWidth = Math.min(maxWidth, contentWidth + horizontalPadding);
                measurer.style.width = `${finalWidth - horizontalPadding}px`;
                let contentHeight = measurer.scrollHeight;
                const needsCustomScroll = contentHeight > (maxHeight - verticalPadding);
                let finalHeight = needsCustomScroll ? maxHeight : Math.max(50, contentHeight + verticalPadding);
                measurer.style.display = 'block';
                
                return { width: finalWidth, height: finalHeight, needsCustomScroll, lineHeight: (isRoot ? 14 : 12) * 1.5 };
            },

            render() {
                const container = d3.select("#mindmap-container");
                container.selectAll("*").remove();
                this.width = container.node().clientWidth;
                this.height = container.node().clientHeight;
                this.svg = container.append("svg").attr("viewBox", [-this.width / 2, -this.height / 2, this.width, this.height]);
                this.g = this.svg.append("g");
                this.zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", (e) => this.g.attr("transform", e.transform));
                this.svg.call(this.zoom);
            },

            /* For Loading MindMap Quickly we use renderState & renderBatch */
            _renderState: {
                allRootNodes: [],
                fullNodes: [],
                fullLinks: [],
                renderedNodeIds: new Set(),
                renderIndex: 0,
                isRendering: false,
                batchSize: 25, // Render 25 complete mind maps per batch
                renderHandle: null
            },

            
           _renderNextMindMapBatch() {
                if (!this._renderState.isRendering) return;
                const { allRootNodes, fullNodes, fullLinks, batchSize } = this._renderState;
                const { renderIndex } = this._renderState;
                const rootsToRender = allRootNodes.slice(renderIndex, renderIndex + batchSize);
                const rootIdsToRender = new Set(rootsToRender.map(r => r.id));
                const nodesForThisBatch = fullNodes.filter(n => rootIdsToRender.has(n.mindmapId));
                const linksForThisBatch = fullLinks.filter(l => rootIdsToRender.has(l.source.mindmapId || l.source));
                const currentNodes = this.simulation.nodes();
                const newNodes = [...currentNodes, ...nodesForThisBatch];
                this.simulation.nodes(newNodes);
                this.simulation.force("link").links([...this.simulation.force("link").links(), ...linksForThisBatch]);
                const link = this.g.selectAll(".mindmap-link").data(this.simulation.force("link").links(), d => `${d.source.id}-${d.target.id}`);
                link.enter().append("path").attr("class", "mindmap-link").style("stroke", d => `var(--mindmap-${d.source.colorScheme}-root)`).attr("opacity", 0).transition().duration(500).attr("opacity", 0.8);
                const node = this.g.selectAll(".mindmap-node").data(newNodes, d => d.id);
                
                const nodeEnter = node.enter().append("g").attr("class", d => `mindmap-node mindmap-${d.type}`).attr("opacity", 0);
                nodeEnter.append("rect");
                nodeEnter.append('foreignObject');

                nodeEnter.append("title").text(d => d.text.includes('<img') ? null : d.text);
                
                const allNodes = nodeEnter.merge(node);
                
                allNodes.raise();

                allNodes.call(this.drag(this.simulation))
                    .on("contextmenu", (event, d) => {
                        event.preventDefault();
                        // Simplified: All nodes (root or child) will open the source article.
                        const articleId = d.type === 'root' ? d.id : d.articleId;
                        App.router.navigateTo('article', { id: articleId, mode: 'read' });
                    })
                    .on("click", (event, d) => {
                        if (event.target.closest('.scroll-button-line')) return;
                        event.stopPropagation();
                        if (d.type === 'root') {
                            this.nodeStates[d.id] = { collapsed: !this.nodeStates[d.id]?.collapsed };
                            this.renderAllMindmaps({ shouldZoomToFit: false, isInteraction: true });
                        } else {
                            const nodeEl = d3.select(event.currentTarget);
                            const isFaded = nodeEl.classed('faded');
                            nodeEl.classed('faded', !isFaded);
                            this.g.selectAll('.mindmap-link').filter(l => l.target.id === d.id).classed('faded', !isFaded);
                        }
                    });
                allNodes.select("rect").attr("width", d => d.width).attr("height", d => d.height).attr("x", d => -d.width / 2).attr("y", d => -d.height / 2).style("fill", d => d.type === 'root' ? `var(--mindmap-${d.colorScheme}-root)` : `var(--mindmap-${d.colorScheme}-child-bg)`).style("stroke", d => d.type === 'root' ? `var(--mindmap-${d.colorScheme}-root)` : 'var(--border-color)');
                allNodes.select('foreignObject').attr('width', d => d.width).attr('height', d => d.height).attr('x', d => -d.width / 2).attr('y', d => -d.height / 2).html(d => `<div class="node-content-wrapper"><div class="node-html-content ${d.needsCustomScroll ? 'has-custom-scroll' : ''}" style="color: ${d.type === 'child' ? `var(--mindmap-${d.colorScheme}-child-text)` : `var(--text-on-primary)`}">${d.text}</div></div>`);
                allNodes.transition().duration(500).attr("opacity", 1);
                this.simulation.alpha(0.4).restart();
                this._renderState.renderIndex += batchSize;
                if (this.isInitialLoad) {
                    const progressPercent = Math.round((this._renderState.renderIndex / allRootNodes.length) * 100);
                    App.ui.showToast(`Loading map... ${Math.min(100, progressPercent)}%`, { type: 'info', duration: 2000 });
                }
                if (this._renderState.renderIndex < allRootNodes.length) {
                    this._renderState.renderHandle = requestIdleCallback(() => this._renderNextMindMapBatch());
                } else {
                    this._renderState.isRendering = false;
                    if (this.isInitialLoad) App.ui.showToast('Map ready!', { type: 'success' });
                    this.isInitialLoad = false;
                }
            },

           renderAllMindmaps(options = {}) {
                const { shouldZoomToFit = true, isInteraction = false } = typeof options === 'boolean' ? { shouldZoomToFit: options } : options;

                if (this._renderState.isRendering && this._renderState.renderHandle) {
                    cancelIdleCallback(this._renderState.renderHandle);
                }

                const oldNodePositions = new Map();
                if (this.simulation) {
                    this.simulation.nodes().forEach(node => {
                        oldNodePositions.set(node.id, { x: node.x, y: node.y, fx: node.fx, fy: node.fy });
                    });
                }

                const { nodes, links } = this.prepareAllMindmapData();
                const allRootNodes = this.mindmapRoots;

                nodes.forEach(node => {
                    if (oldNodePositions.has(node.id)) {
                        const pos = oldNodePositions.get(node.id);
                        node.x = pos.x; node.y = pos.y; node.fx = pos.fx; node.fy = pos.fy;
                    }
                });

                // This new logic distinguishes between the initial load and subsequent interactions
                if (!isInteraction && allRootNodes.length > this._renderState.batchSize) {
                    this._renderState.allRootNodes = allRootNodes; this._renderState.fullNodes = nodes; this._renderState.fullLinks = links; this._renderState.renderIndex = 0; this._renderState.isRendering = true;
                    
                    this.g.selectAll("*").remove(); // Clear only on initial full load
                    
                    this.simulation = d3.forceSimulation().force("link", d3.forceLink().id(d => d.id).distance(d => d.source.width / 2 + d.target.width / 2 + 40).strength(0.5)).force("charge", d3.forceManyBody().strength(-1200)).force("center", d3.forceCenter(0, 0)).force("collide", d3.forceCollide().radius(d => Math.max(d.width, d.height) / 2 + 15));
                    this.simulation.on("tick", () => { const nodeMap = new Map(this.simulation.nodes().map(n => [n.id, n])); this.g.selectAll(".mindmap-link").attr("d", d => { const sourceNode = typeof d.source === 'string' ? nodeMap.get(d.source) : d.source; const targetNode = typeof d.target === 'string' ? nodeMap.get(d.target) : d.target; if(!sourceNode || !targetNode) return null; const sourcePoint = this.calculateEdgePoint(sourceNode, targetNode); const targetPoint = this.calculateEdgePoint(targetNode, sourceNode); return `M${sourcePoint.x},${sourcePoint.y}C${sourcePoint.x},${(sourcePoint.y + targetPoint.y) / 2} ${targetPoint.x},${(sourcePoint.y + targetPoint.y) / 2} ${targetPoint.x},${targetPoint.y}`; }); this.g.selectAll(".mindmap-node").attr("transform", d => `translate(${d.x},${d.y})`); });
                    
                    this._renderNextMindMapBatch();
                } else {
                    // This is the flicker-free path for small maps and ALL interactions on large maps
                    this._renderState.isRendering = false;
                    if (!this.simulation) {
                         this.simulation = d3.forceSimulation().force("link", d3.forceLink().id(d => d.id).distance(d => d.source.width / 2 + d.target.width / 2 + 40).strength(0.5)).force("charge", d3.forceManyBody().strength(-1200)).force("center", d3.forceCenter(0, 0)).force("collide", d3.forceCollide().radius(d => Math.max(d.width, d.height) / 2 + 15));
                         this.simulation.on("tick", () => { const nodeMap = new Map(this.simulation.nodes().map(n => [n.id, n])); this.g.selectAll(".mindmap-link").attr("d", d => { const sourceNode = typeof d.source === 'string' ? nodeMap.get(d.source) : d.source; const targetNode = typeof d.target === 'string' ? nodeMap.get(d.target) : d.target; if(!sourceNode || !targetNode) return null; const sourcePoint = this.calculateEdgePoint(sourceNode, targetNode); const targetPoint = this.calculateEdgePoint(targetNode, sourceNode); return `M${sourcePoint.x},${sourcePoint.y}C${sourcePoint.x},${(sourcePoint.y + targetPoint.y) / 2} ${targetPoint.x},${(sourcePoint.y + targetPoint.y) / 2} ${targetPoint.x},${targetPoint.y}`; }); this.g.selectAll(".mindmap-node").attr("transform", d => `translate(${d.x},${d.y})`); });
                    }
                    this.simulation.nodes(nodes);
                    this.simulation.force("link").links(links);
                    
                    const link = this.g.selectAll(".mindmap-link").data(links, d => `${d.source.id}-${d.target.id}`);
                    link.join(
                        enter => enter.append("path").attr("class", "mindmap-link").style("stroke", d => `var(--mindmap-${d.source.colorScheme}-root)`).attr("opacity", 0).transition().duration(500).attr("opacity", 0.8),
                        update => update,
                        exit => exit.transition().duration(300).attr("opacity", 0).remove()
                    );
                    
                    const node = this.g.selectAll(".mindmap-node").data(nodes, d => d.id);
                    node.join(
                         enter => {
                            const g = enter.append("g").attr("class", d => `mindmap-node mindmap-${d.type} ${d.text.includes('<img') ? 'image-node' : ''}`).attr("opacity", 0);
                            g.append("rect"); g.append('foreignObject');
                            g.append("title").text(d => d.text.includes('<img') ? null : d.text);
                            g.call(this.drag(this.simulation))
                                .on("contextmenu", (event, d) => {
                                    event.preventDefault();
                                    if (d.type === 'root') {
                                        App.router.navigateTo('article', { id: d.id, mode: 'read' });
                                    } else { // It's a child node (snippet)
                                        App.router.navigateTo('article', { id: d.articleId, mode: 'read', scrollToSnippetId: d.id });
                                    }
                                })
                                
                                .on("click", (event, d) => {
                                    if (event.target.closest('.scroll-button-line')) return;
                                    event.stopPropagation();
                                    if (d.type === 'root') {
                                        if (this.simulation) { this.simulation.nodes().forEach(nodeData => { if (nodeData.type === 'root' && nodeData.id !== d.id) { nodeData.fx = nodeData.x; nodeData.fy = nodeData.y; } }); }
                                        this.nodeStates[d.id] = { collapsed: !this.nodeStates[d.id]?.collapsed };
                                        this.renderAllMindmaps({ shouldZoomToFit: false, isInteraction: true });
                                        setTimeout(() => { if (!this.simulation) return; this.simulation.nodes().forEach(nodeData => { if (nodeData.type === 'root' && nodeData.id !== d.id) { nodeData.fx = null; nodeData.fy = null; } }); }, 2000);
                                    } else {
                                        const nodeEl = d3.select(event.currentTarget);
                                        const isFaded = nodeEl.classed('faded');
                                        nodeEl.classed('faded', !isFaded);
                                        this.g.selectAll('.mindmap-link').filter(l => l.target.id === d.id).classed('faded', !isFaded);
                                    }
                                });
                            g.transition().duration(500).attr("opacity", 1);
                            return g;
                        },
                        update => update,
                        exit => exit.transition().duration(300).attr("opacity", 0).remove()
                    );
                    
                    this.g.selectAll(".mindmap-node").call(el => {
                        el.select("rect")
                            .attr("width", d => d.width).attr("height", d => d.height)
                            .attr("x", d => -d.width / 2).attr("y", d => -d.height / 2)
                            .style("fill", d => {
                                // For image nodes, use the app's secondary background for the mat effect
                                if (d.text.includes('<img')) return 'var(--bg-secondary)';
                                return d.type === 'root' ? `var(--mindmap-${d.colorScheme}-root)` : `var(--mindmap-${d.colorScheme}-child-bg)`;
                            })
                            .style("stroke", d => {
                                // For image nodes, use a subtle border for a crisp edge
                                if (d.text.includes('<img')) return 'var(--border-color)';
                                return d.type === 'root' ? `var(--mindmap-${d.colorScheme}-root)`: 'var(--border-color)';
                            })
                            // Remove the custom filter and border-radius; let the main stylesheet handle it
                            .style("filter", null)
                            .style("border-radius", null);
                            
                        el.select('foreignObject')
                            .attr('width', d => d.width).attr('height', d => d.height)
                            .attr('x', d => -d.width / 2).attr('y', d => -d.height / 2)
                            .html(d => {
                                const content = d.text;
                                return `<div class="node-content-wrapper"><div class="node-html-content ${d.needsCustomScroll ? 'has-custom-scroll' : ''}" style="color: ${d.type === 'child' ? `var(--mindmap-${d.colorScheme}-child-text)` : `var(--text-on-primary)`}">${content}</div></div>`
                            });
                        el.filter(d => d.needsCustomScroll)
                            .select('.node-content-wrapper')
                            .append('xhtml:div')
                            .attr('class', 'scroll-button-line')
                            .style('background-color', d => {
                                const theme = document.documentElement.getAttribute('data-theme');
                                if (d.type === 'root') return 'rgba(255, 255, 255, 0.5)';
                                return theme === 'light' ? 'rgba(0, 0, 0, 0.3)' : `var(--mindmap-${d.colorScheme}-root)`;
                            })
                            .on('click', function(event, d) {
                                event.stopPropagation();
                                const container = this.parentNode.querySelector('.node-html-content');
                                if (!container) return;

                                const scrollAmount = 100; // A consistent scroll amount in pixels is more reliable
                                const currentTop = container.scrollTop;
                                const maxScroll = container.scrollHeight - container.clientHeight;
                                
                                let targetScrollTop;
                                if (currentTop >= maxScroll - 5) {
                                    targetScrollTop = 0;
                                } else {
                                
                                    targetScrollTop = Math.min(maxScroll, currentTop + scrollAmount);
                                }
                                
                                container.scrollTo({ top: targetScrollTop, behavior: 'smooth' });
                            })

                        el.select("title").text(d => d.text.includes('<img') ? null : d.text);
                    });

                    this.simulation.alpha(0.3).restart();
                    if (shouldZoomToFit) setTimeout(() => this.zoomToFit(), 100);
                }
            },



            searchNodes(term) {
                this.currentMindmapSearchResults = []; this.currentMindmapSearchIndex = -1;
                const resultsList = document.getElementById('mindmap-search-results');
                const termLower = term.toLowerCase().trim();
                this.g.selectAll('.mindmap-node').classed('mindmap-search-highlight', false);
                resultsList.innerHTML = ''; resultsList.style.display = 'none';
                if (!termLower) return;
                const results = this.g.selectAll('.mindmap-node').filter(d => d.text.toLowerCase().includes(termLower));
                if (!results.empty()) {
                    results.classed('mindmap-search-highlight', true);
                    const resultsData = results.data();

                    // FIX: Sort the results to prioritize master nodes over children nodes.
                    resultsData.sort((a, b) => {
                        // If a is a root and b is a child, a comes first (-1).
                        if (a.type === 'root' && b.type !== 'root') {
                            return -1;
                        }
                        // If b is a root and a is a child, b comes first (1).
                        if (a.type !== 'root' && b.type === 'root') {
                            return 1;
                        }
                        // If both are the same type, sort them alphabetically.
                        return a.text.localeCompare(b.text);
                    });

                    this.currentMindmapSearchResults = resultsData;
                    const ul = document.createElement('ul');
                    resultsData.forEach(d => {
                        const li = document.createElement('li'); const a = document.createElement('a'); a.href = '#'; a.textContent = `${d.type === 'root' ? 'Article:' : 'Snippet:'} ${d.text.slice(0, 30)}...`;
                        a.onclick = (e) => { e.preventDefault(); this.zoomToNode(d); resultsList.style.display = 'none'; };
                        li.appendChild(a); ul.appendChild(li);
                    });
                    resultsList.appendChild(ul); resultsList.style.display = 'block';

                    this.findNextSearchResult(); 
                }
            },
            findNextSearchResult() {
                if (!this.currentMindmapSearchResults || this.currentMindmapSearchResults.length === 0) { const searchTerm = document.getElementById('mindmap-search-input').value; if (searchTerm) { this.searchNodes(searchTerm); if (!this.currentMindmapSearchResults || this.currentMindmapSearchResults.length === 0) { App.ui.showToast("No results found.", {type: 'error'}); return; } } else { App.ui.showToast("Nothing to search for.", {type: 'error'}); return; } }
                this.currentMindmapSearchIndex = (this.currentMindmapSearchIndex + 1) % this.currentMindmapSearchResults.length;
                const targetNodeData = this.currentMindmapSearchResults[this.currentMindmapSearchIndex];
                if (targetNodeData) { this.zoomToNode(targetNodeData); this.g.selectAll('.mindmap-node').filter(d => d.id === targetNodeData.id).select('rect').transition().duration(200).style('stroke', 'var(--danger-color)').style('stroke-width', '4px').transition().duration(1500).style('stroke', 'var(--border-color)').style('stroke-width', '1.5px'); }
            },
            navigateToNextMap() { if (this.mindmapRoots.length === 0) return; this.currentMindmapIndex = (this.currentMindmapIndex + 1) % this.mindmapRoots.length; this.zoomToNode(this.mindmapRoots[this.currentMindmapIndex]); App.ui.showToast(`Mind Map ${this.currentMindmapIndex + 1} of ${this.mindmapRoots.length}`); },
            navigateToPrevMap() { if (this.mindmapRoots.length === 0) return; this.currentMindmapIndex--; if (this.currentMindmapIndex < 0) this.currentMindmapIndex = this.mindmapRoots.length - 1; this.zoomToNode(this.mindmapRoots[this.currentMindmapIndex]); App.ui.showToast(`Mind Map ${this.currentMindmapIndex + 1} of ${this.mindmapRoots.length}`); },
            cycleSnapshots() { const snapshots = App.state.mindMapState.snapshots; if (!snapshots || snapshots.length === 0) { App.ui.showToast('No snapshots saved.'); return; } this.currentSnapshotIndex = (this.currentSnapshotIndex + 1) % snapshots.length; const snapshotToLoad = snapshots[snapshots.length - 1 - this.currentSnapshotIndex]; this.loadSnapshot(snapshotToLoad); App.ui.showToast(`Snapshot ${this.currentSnapshotIndex + 1}/${snapshots.length} ${this.currentSnapshotIndex === 0 ? '(Latest)' : ''}`); },
            deleteOldSnapshots() { const snapshots = App.state.mindMapState.snapshots; if (!snapshots || snapshots.length === 0) { App.ui.showToast('No snapshots to delete.', {type: 'error'}); return; } snapshots.shift(); this.currentSnapshotIndex = -1; App.fs.write('mind-map-state.json', App.state.mindMapState); App.ui.showToast(`Oldest Snapshot Deleted.`); },
            loadSnapshot(snapshot) {
                if (!snapshot) return; this.nodeStates = snapshot.nodeStates || {}; this.renderAllMindmaps(false);
                if (snapshot.nodePositions && this.simulation) {
                    const positionMap = new Map(snapshot.nodePositions.map(p => [p.id, p]));
                    this.simulation.nodes().forEach(node => { const savedPos = positionMap.get(node.id); if (savedPos) { node.x = savedPos.x; node.y = savedPos.y; node.fx = savedPos.fx; node.fy = savedPos.fy; } });
                }
                if (snapshot.transform) { const { x, y, k } = snapshot.transform; this.svg.transition().duration(750).call(this.zoom.transform, d3.zoomIdentity.translate(x, y).scale(k)); }
            },
            async saveSnapshotAndExport() {
                const btn = document.getElementById('mindmap-snapshot-btn'); btn.style.color = 'var(--primary-color)';
                const transform = d3.zoomTransform(this.svg.node());
                const nodePositions = this.simulation ? this.simulation.nodes().map(n => ({ id: n.id, x: n.x, y: n.y, fx: n.fx, fy: n.fy })) : [];
                const newSnapshot = { transform: { x: transform.x, y: transform.y, k: transform.k }, nodeStates: JSON.parse(JSON.stringify(this.nodeStates)), nodePositions, timestamp: new Date().toISOString() };
                App.state.mindMapState.snapshots.push(newSnapshot);
                if (App.state.mindMapState.snapshots.length > 10) App.state.mindMapState.snapshots.shift();
                await App.fs.write('mind-map-state.json', App.state.mindMapState);
                try {
                    const container = document.getElementById('mindmap-container');
                    const blob = await htmlToImage.toBlob(container, { backgroundColor: getComputedStyle(container).backgroundColor });
                    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
                    App.ui.showToast('Snapshot saved & image copied!');
                } catch (e) { console.error("Mind map copy failed", e); App.ui.showToast('Snapshot saved (image copy failed).', {type: 'error'}); }
                setTimeout(() => { btn.style.color = ''; }, 1000);
            },
            zoomToNode(nodeData) {
                if (!nodeData || typeof nodeData.x !== 'number') return;
                const scale = 1.2; const x = -nodeData.x * scale; const y = -nodeData.y * scale;
                const transform = d3.zoomIdentity.translate(x, y).scale(scale);
                const currentTransform = d3.zoomTransform(this.svg.node());
                if (Math.abs(currentTransform.k - transform.k) < 0.01 && Math.abs(currentTransform.x - transform.x) < 1 && Math.abs(currentTransform.y - transform.y) < 1) return;
                this.svg.transition().duration(750).call(this.zoom.transform, transform);
            },
            zoomToFit() {
                 if (!this.g.node() || this.g.selectAll('.mindmap-node').empty()) return;
                 const bounds = this.g.node().getBBox(); if (bounds.width === 0 || bounds.height === 0) return;
                 const { x, y, width, height } = bounds;
                 const scale = Math.min(1.5, 0.8 / Math.max(width / this.width, height / this.height));
                 const transform = d3.zoomIdentity.translate(-x * scale - (width*scale/2), -y*scale - (height*scale/2)).scale(scale);
                 this.svg.transition().duration(750).call(this.zoom.transform, transform);
            },
            zoomIn() { this.zoom && this.svg.transition().duration(750).call(this.zoom.scaleBy, 1.3); },
            zoomOut() { this.zoom && this.svg.transition().duration(750).call(this.zoom.scaleBy, 1 / 1.3); },
            gatherNodes() {
                if (!this.simulation) return;
                this.simulation.nodes().forEach(node => {
                    if (node.type === 'root') {
                        node.fx = null;
                        node.fy = null;
                    }
                });

                this.simulation
                    .force("x_gather", d3.forceX(0).strength(d => d.type === 'root' ? 0.15 : 0))
                    .force("y_gather", d3.forceY(0).strength(d => d.type === 'root' ? 0.15 : 0));

                this.simulation.alpha(1).restart();

                setTimeout(() => {
                    if (!this.simulation) return;
                    this.simulation.force("x_gather", null)
                                .force("y_gather", null);
                }, 3000);
            },
                    
            drag(simulation) {
                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.1).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                    d3.select(this).classed('dragging', true);
                }
                function dragended(event, d) {
                    // Reheat the simulation briefly to settle forces, then cool it down.
                    if (!event.active) {
                        simulation.alphaTarget(0.1).restart();
                        setTimeout(() => simulation.alphaTarget(0), 100);
                    }
                    d3.select(this).classed('dragging', false);

                    if (d.type === 'root') {
                        // Pin the root node to its final location.
                        d.fx = d.x;
                        d.fy = d.y;
                    } else {
                        // Un-pin child nodes to allow them to follow the parent.
                        d.fx = null;
                        d.fy = null;
                    }
                }
                return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
            },
        },
        
        // ==========================================================================
        // 3.18. VISUAL MAP MODULE (v2 - REBUILT FROM PROTOTAGS)
        // ==========================================================================
        visualMap: {
            svg: null, g: null, zoom: null, simulation: null, link: null, node: null, width: 0, height: 0, resizeObserver: null,
            currentFilter: 'all', currentCategoryIndex: -1, nodeStates: {}, layoutMode: 'Force',
            selectedNodes: new Set(), currentZoom: { k: 1, x: 0, y: 0 },
            currentSearchResults: [], currentSearchIndex: -1,
            isLassoActive: false, lassoPoints: [], lassoSelection: null,
            colorPalettes: {
                category: ["#d90429", "#f77f00", "#ef476f", "#c71f37", "#ff85a1", "#ffafcc"],
                tag: ["#4361ee", "#3a0ca3", "#7209b7", "#00b4d8", "#5e60ce", "#64dfdf", "#9d4edd", "#0077b6", "#ade8f4", "#480ca8"],
                article: ["#55a630", "#80b918", "#aacc00", "#f4e409", "#ffbe0b", "#008000", "#70e000", "#b5e48c", "#d4d700", "#eeef20"],
                orphan: ["#6c757d", "#adb5bd", "#495057", "#ced4da"]
            },
            
            initEventListeners() {
                document.getElementById('zoom-in-btn').onclick = () => this.zoomIn();
                document.getElementById('zoom-out-btn').onclick = () => this.zoomOut();
                document.getElementById('reset-view-btn').onclick = () => this.zoomToFit();
                document.getElementById('cycle-category-btn').onclick = () => this.cycleCategoryFocus();
                document.getElementById('revert-color-btn').onclick = () => this.setDefaultNodeColors();
                document.getElementById('gather-nodes-btn').onclick = () => this.gatherNodes();
                document.getElementById('filter-all-btn').onclick = () => this.setNodeStates('expand-all');
                document.getElementById('filter-tags-btn').onclick = () => this.setNodeStates('collapse-to-tags');
                document.getElementById('filter-orphans-btn').onclick = () => this.setNodeStates('orphans');
                document.getElementById('vm-focus-line').onclick = () => App.events.toggleCanvasFocusMode();

                // Premium Feature Gates
                document.getElementById('random-color-btn').onclick = () => {
                    if (App.license.isPremium()) this.randomizeNodeColors(); else App.ui.showAscensionModal();
                };
                document.getElementById('visual-map-layout-toggle').onclick = () => {
                    if (App.license.isPremium()) this.toggleLayout(); else App.ui.showAscensionModal();
                };
                document.getElementById('visual-map-snapshot-btn').onclick = () => {
                    if (App.license.isPremium()) this.exportAndSave(); else App.ui.showAscensionModal();
                };
                document.getElementById('toggle-snapshots-btn').onclick = () => {
                    if (App.license.isPremium()) this.cycleSnapshots(); else App.ui.showAscensionModal();
                };
                document.getElementById('delete-snapshots-btn').onclick = () => {
                    if (App.license.isPremium()) this.deleteOldSnapshots(); else App.ui.showAscensionModal();
                };
                 document.getElementById('lasso-btn').onclick = () => {
                    if (App.license.isPremium()) this.toggleLasso(); else App.ui.showAscensionModal();
                };
                document.getElementById('expand-selection-btn').onclick = () => {
                    if (App.license.isPremium()) this.modifySelection('expand'); else App.ui.showAscensionModal();
                };
                document.getElementById('collapse-selection-btn').onclick = () => {
                    if (App.license.isPremium()) this.modifySelection('collapse'); else App.ui.showAscensionModal();
                };

                // Search listeners
                const searchInput = document.getElementById('graph-search-input');
                searchInput.oninput = (e) => this.searchNodes(e.target.value);
                searchInput.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); this.findNextSearchResult(); }};
                document.getElementById('find-next-btn').onclick = () => this.findNextSearchResult();

                const layoutBtn = document.getElementById('visual-map-layout-toggle');
                if(layoutBtn) layoutBtn.innerHTML = ICON_FORCE;
            },

            init() {
                // If the view is already set up, just update the data
                if (this.svg) {
                    this.updateGraph();
                    return;
                }
                
                // If it's the first time, render the canvas, then set up all listeners.
                this.render(); 
                this.initEventListeners();
                
                const container = document.getElementById('visual-map-container');
                container.focus();
                
                // ... (rest of the original function from this point onwards)
                container.onkeydown = (e) => {
                    if (document.activeElement.tagName !== 'INPUT') {
                        if (e.key === ' ' && e.shiftKey) { this.zoomOut(); e.preventDefault(); }
                        else if (e.key === ' ') { this.zoomIn(); e.preventDefault(); }
                        else {
                            switch (e.key.toLowerCase()) {
                                case 'arrowup': this.pan(0, 1); e.preventDefault(); break;
                                case 'arrowdown': this.pan(0, -1); e.preventDefault(); break;
                                case 'arrowleft': this.pan(1, 0); e.preventDefault(); break;
                                case 'arrowright': this.pan(-1, 0); e.preventDefault(); break;
                                case 't': this.cycleCategoryFocus(); e.preventDefault(); break;
                                case 'c': 
                                    if (App.license.isPremium()) this.randomizeNodeColors(); 
                                    else App.ui.showAscensionModal();
                                    e.preventDefault(); 
                                    break;
                                case 'f': App.events.toggleCanvasFocusMode(); e.preventDefault(); break; 
                                // --- SHORTCUT SWAP ---
                                case 's': document.getElementById('graph-search-input')?.focus(); e.preventDefault(); break; // 'S' is now for Search
                                case 'p': this.exportAndSave(); e.preventDefault(); break; // 'F' is now for snapshot/save frame
                                // --- END SWAP ---
                                case 'l': this.toggleLasso(); e.preventDefault(); break;
                                case 'r': this.zoomToFit(); e.preventDefault(); break;
                                case 'escape': 
                                    if (document.body.classList.contains('canvas-focus-mode')) {
                                        App.events.toggleCanvasFocusMode();
                                    } else if (this.isLassoActive) { 
                                        this.toggleLasso(); 
                                    } else { 
                                        const searchInput = document.getElementById('graph-search-input'); 
                                        if(searchInput) {searchInput.value = ''; this.searchNodes(''); searchInput.blur(); }
                                    }
                                    e.preventDefault(); 
                                    break;
                                case '+': case '=': this.zoomIn(); e.preventDefault(); break;
                                case '-': this.zoomOut(); e.preventDefault(); break;
                            }
                        }
                    }
                };

                const snapshots = App.state.visualMapState.snapshots || [];
                if (snapshots.length > 0) {
                    this.loadSnapshot(snapshots[snapshots.length - 1]);
                } else {
                    this.zoomToFit();
                }
                
                this.resizeObserver = new ResizeObserver(entries => {
                    const { width, height } = entries[0].contentRect;
                    if ((width === this.width && height === this.height) || width < 1) return;
                    this.width = width;
                    this.height = height;
                    this.svg.attr("viewBox", [0, 0, this.width, this.height]);
                    this.simulation.force("center", d3.forceCenter(this.width / 2, this.height / 2)).alpha(0.3).restart();
                });
                this.resizeObserver.observe(container);
                
                container.addEventListener('wheel', e => e.preventDefault(), { passive: false });
            },

            triggerResize() {
                const container = document.getElementById('visual-map-container');
                if (!container || !this.resizeObserver) return;
                this.resizeObserver.disconnect();
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                if (newWidth > 0 && newHeight > 0) {
                    this.width = newWidth;
                    this.height = newHeight;
                    this.svg.attr("viewBox", [0, 0, this.width, this.height]);
                    this.simulation.force("center", d3.forceCenter(this.width / 2, this.height / 2)).alpha(0.3).restart();
                }
                this.resizeObserver.observe(container);
            },
            
            destroy() {
                if (this.simulation) this.simulation.stop();
                if (this.resizeObserver) this.resizeObserver.disconnect();
                d3.select("#visual-map-container > svg").remove();
                d3.select("#visual-map-container > #sticky-note-layer").remove();
                this.svg = this.g = this.zoom = this.simulation = this.resizeObserver = null;
            },
            // Located in App.visualMap
            render() {
                const container = d3.select("#visual-map-container");
                container.selectAll("*").remove();
                if (this.simulation) this.simulation.stop();
                const rect = container.node().getBoundingClientRect();
                this.width = Math.max(10, Math.floor(rect.width));
                this.height = Math.max(10, Math.floor(rect.height));
                if (this.width < 10 || this.height < 10) {
                requestAnimationFrame(() => this.render());
                return;
                }

                const stickyNoteLayer = container.append("div").attr("id", "sticky-note-layer");
                this.svg = container.append("svg").attr("viewBox", [0, 0, this.width, this.height]);
                const defs = this.svg.append("defs");
                defs.append("radialGradient").attr("id", "node-gradient").append("stop").attr("offset", "0%").attr("stop-color", "white").attr("stop-opacity", 0.3).select(function() { return this.parentNode; }).append("stop").attr("offset", "100%").attr("stop-color", "white").attr("stop-opacity", 0);
                const dropShadow = defs.append("filter").attr("id", "drop-shadow").attr("height", "130%");
                dropShadow.append("feGaussianBlur").attr("in", "SourceAlpha").attr("stdDeviation", 1);
                dropShadow.append("feOffset").attr("dx", 1).attr("dy", 1).attr("result", "offsetblur");
                const feMerge = dropShadow.append("feMerge");
                feMerge.append("feMergeNode"); feMerge.append("feMergeNode").attr("in", "SourceGraphic");
                this.g = this.svg.append("g");
                this.g.append('rect').attr('class', 'background-rect').attr('width', '140%').attr('height', '140%').attr('x', '-20%').attr('y', '-20%').attr('fill', 'var(--bg-secondary)');
                this.link = this.g.append("g").attr("class", "links").selectAll("line");
                this.node = this.g.append("g").attr("class", "nodes").selectAll("g.node-group");
                this.simulation = d3.forceSimulation()
                    .force("charge", d3.forceManyBody().strength(-300))
                    .force("center", d3.forceCenter(this.width / 2, this.height / 2).strength(1))
                    .force("collision", d3.forceCollide().radius(d => d.type === 'category' ? 30 : 20))
                    .force("link", d3.forceLink().id(d => d.id).distance(80).strength(1))
                    .force("x", d3.forceX(this.width / 2).strength(0.05))
                    .force("y", d3.forceY(this.height / 2).strength(0.05))
                    .alphaDecay(0.0228)
                    .velocityDecay(0.4);
                
                this.updateGraph();
                
                // FIX: The "tick" handler is simplified to remove the node constraints.
                this.simulation.on("tick", () => {
                    this.node.attr("transform", d => `translate(${d.x},${d.y})`);
                    this.link.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                });

                this.zoom = d3.zoom().scaleExtent([0.1, 4])
                    .filter(event => !event.target.closest('.node-group'))
                    .on("zoom", (e) => {
                        this.currentZoom = e.transform;
                        this.g.attr("transform", e.transform);
                        stickyNoteLayer.style("transform", `translate(${e.transform.x}px, ${e.transform.y}px) scale(${e.transform.k})`);
                        this.g.selectAll('.node-text').classed('lod-hidden', e.transform.k < 0.6);
                });
                this.svg.call(this.zoom).on("dblclick.zoom", null);
            },
            
            
            /* Fix for Large DataSets for Map */
            _renderState: {
                fullNodes: [],
                fullLinks: [],
                renderIndex: 0,
                isRendering: false,
                batchSize: 150, // Render 150 nodes per batch
                renderHandle: null
            },
            // Located in App.visualMap - REPLACE the entire function
            _renderNextBatch() {
                if (!this._renderState.isRendering) return;

                const { fullNodes, fullLinks, batchSize } = this._renderState;
                let { renderIndex } = this._renderState;

                const nodesBatch = fullNodes.slice(0, renderIndex + batchSize);
                
                const renderedNodeIds = new Set(nodesBatch.map(n => n.id));
                const linksBatch = fullLinks.filter(l => renderedNodeIds.has(l.source.id || l.source) && renderedNodeIds.has(l.target.id || l.target));

                this.simulation.nodes(nodesBatch);
                this.simulation.force("link").links(linksBatch);

                this.link = this.g.select(".links").selectAll("line").data(linksBatch, d => d.id);
                this.link.enter().append("line").attr('class', 'link').attr("stroke-opacity", 0).merge(this.link)
                    .attr("stroke-width", 1.5).attr("stroke", d => {
                        if (d.source.type === 'category' && d.target.type === 'tag') return 'var(--node-category)';
                        if (d.source.type === 'tag' && d.target.type === 'article') return 'var(--node-tag)';
                        return 'var(--border-color)';
                    }).transition().duration(500).attr("stroke-opacity", 0.6);
                this.link.exit().remove();

                this.node = this.g.select(".nodes").selectAll("g.node-group").data(nodesBatch, d => d.id);
                const nodeEnter = this.node.enter().append("g").attr("class", "node-group").attr("opacity", 0);
                
                nodeEnter.append("title").text(d => {
                    if (d.type === 'article' || d.type === 'orphan') { const article = App.storage.getArticle(d.realId); if (!article) return d.label; const tempDiv = document.createElement('div'); tempDiv.innerHTML = article.content; const excerpt = (tempDiv.textContent || "").substring(0, 150); return `${article.title}\n\n${excerpt}...`; } return d.label;
                });
                nodeEnter.append("circle").attr("class", "node-main-body").attr("r", d => d.type === 'category' ? 15 : (d.type === 'tag' || d.type === 'orphan') ? 10 : 8).style("fill", d => d.isDuplicate ? `var(--node-article-duplicate)`: `var(--node-${d.type})`).style("filter", "url(#drop-shadow)");
                nodeEnter.append("circle").attr("class", "node-highlight").attr("r", d => d.type === 'category' ? 15 : (d.type === 'tag' || d.type === 'orphan') ? 10 : 8).attr("fill", "url(#node-gradient)");
                nodeEnter.append("text").attr("class", d => `node-text ${this.currentZoom.k < 0.6 ? 'lod-hidden' : ''}`).text(d => d.label).attr("fill", "var(--node-text-color)").attr("x", d => d.type === 'category' ? 20 : 15).attr("y", 4).style("pointer-events", "none");
                nodeEnter.call(this.drag(this.simulation));
                
                
                nodeEnter.on("click", (event, d) => {
                    if (event.defaultPrevented) return;
                    event.stopPropagation();
                    if (event.shiftKey) {
                        this.toggleNodeSelection(d.id);
                    } else {
                        if (d.type === 'article') {
                            this.stickyNotes.create(d);
                        } else if (d.type === 'orphan') {
                            App.router.navigateTo('article', {id: d.realId, mode: 'read'});
                        } else {
                            // This is the logic that handles collapsing for Categories and Tags
                            this.nodeStates[d.id] = { collapsed: !(this.nodeStates[d.id]?.collapsed) };
                            this.updateGraph(); // This re-runs the main render function with the new state
                        }
                    }
                });
                

                this.node = nodeEnter.merge(this.node);
                this.node.exit().transition().duration(300).attr("opacity", 0).remove();
                this.node.raise().transition().duration(500).attr("opacity", 1);
                
                this.simulation.alpha(0.3).restart();

                this._renderState.renderIndex += batchSize;
                
                const progressPercent = Math.round((this._renderState.renderIndex / fullNodes.length) * 100);
                App.ui.showToast(`Loading graph... ${Math.min(100, progressPercent)}%`, { type: 'info', duration: 2000 });

                if (this._renderState.renderIndex < fullNodes.length) {
                    this._renderState.renderHandle = requestIdleCallback(() => this._renderNextBatch());
                } else {
                    this._renderState.isRendering = false;
                    App.ui.showToast('Graph loaded!', { type: 'success' });
                }
            },
            
            
            updateGraph() {
                if (this._renderState.isRendering && this._renderState.renderHandle) {
                    cancelIdleCallback(this._renderState.renderHandle);
                }
                
                const { nodes, links } = this.prepareGraphData(this.currentFilter);

                if (nodes.length <= this._renderState.batchSize) {
                    this._renderState.isRendering = false;
                    this.simulation.nodes(nodes);
                    this.simulation.force("link").links(links);
                    
                    this.link = this.g.select(".links").selectAll("line").data(links, d => d.id).join( enter => enter.append("line").attr('class', 'link').attr("stroke-opacity", 0), u => u, exit => exit.transition().duration(300).attr("stroke-opacity", 0).remove());
                    this.node = this.g.select(".nodes").selectAll("g.node-group").data(nodes, d => d.id).join( enter => { const nodeEnter = enter.append("g").attr("class", "node-group").attr("opacity", 0); nodeEnter.append("title").text(d => { if (d.type === 'article' || d.type === 'orphan') { const article = App.storage.getArticle(d.realId); if (!article) return d.label; const tempDiv = document.createElement('div'); tempDiv.innerHTML = article.content; const excerpt = (tempDiv.textContent || "").substring(0, 150); return `${article.title}\n\n${excerpt}...`; } return d.label; }); nodeEnter.append("circle").attr("class", "node-main-body").attr("r", d => d.type === 'category' ? 15 : (d.type === 'tag' || d.type === 'orphan') ? 10 : 8).style("fill", d => d.isDuplicate ? `var(--node-article-duplicate)`: `var(--node-${d.type})`).style("filter", "url(#drop-shadow)"); nodeEnter.append("circle").attr("class", "node-highlight").attr("r", d => d.type === 'category' ? 15 : (d.type === 'tag' || d.type === 'orphan') ? 10 : 8).attr("fill", "url(#node-gradient)"); nodeEnter.append("text").attr("class", d => `node-text ${this.currentZoom.k < 0.6 ? 'lod-hidden' : ''}`).text(d => d.label).attr("font-size", "10px").attr("fill", "var(--node-text-color)").attr("x", d => d.type === 'category' ? 20 : 15).attr("y", 4).style("pointer-events", "none"); nodeEnter.call(this.drag(this.simulation)); nodeEnter.on("click", (event, d) => { if (event.defaultPrevented) return; event.stopPropagation(); if (event.shiftKey) { this.toggleNodeSelection(d.id); } else { if (d.type === 'article') { this.stickyNotes.create(d); } else if (d.type === 'orphan') { App.router.navigateTo('article', {id: d.realId, mode: 'read'}); } else { this.nodeStates[d.id] = { collapsed: !(this.nodeStates[d.id]?.collapsed) }; this.updateGraph(); } } }); return nodeEnter; }, u => u, exit => exit.transition().duration(300).attr("opacity", 0).remove());
                    this.link.attr("stroke-width", 1.5).attr("stroke", d => { if (d.source.type === 'category' && d.target.type === 'tag') return 'var(--node-category)'; if (d.source.type === 'tag' && d.target.type === 'article') return 'var(--node-tag)'; return 'var(--border-color)'; }); 
                    this.node.raise(); 
                    this.node.transition().duration(500).attr("opacity", 1); 
                    this.link.transition().duration(500).attr("stroke-opacity", 0.6); 
                    const numNodes = this.simulation.nodes().length; 
                    this.simulation.force("charge").strength(-250 - numNodes * 5); 
                    this.simulation.force("link").distance(d => (d.source.type === 'category' ? 100 : 60) + (numNodes / 4)); 
                    this.simulation.alpha(0.3).restart();

                } else {
                    this._renderState.fullNodes = nodes;
                    this._renderState.fullLinks = links;
                    this._renderState.renderIndex = 0;
                    this._renderState.isRendering = true;
                    
                    this.simulation.nodes([]);
                    this.simulation.force("link").links([]);
                    this.g.select(".nodes").selectAll("g.node-group").remove();
                    this.g.select(".links").selectAll("line").remove();
                    
                    this._renderNextBatch();
                }
            },
            
            
            
            prepareGraphData(filter) {
                const articles = App.state.articles;
                if (filter === 'orphans') {
                    const orphanNodes = articles.filter(a => !a.tags || a.tags.length === 0)
                        .map(a => ({ id: a.id, realId: a.id, label: a.title || 'Untitled', type: 'orphan', isDuplicate: false }));
                    return { nodes: orphanNodes, links: [] };
                }

        
                const categoryNodes = new Map();
                App.settings.get('userCategories').forEach(catObj => {
                    // We now correctly use catObj.name for both the ID and for getting the display name.
                    categoryNodes.set(catObj.name, { id: catObj.name, type: 'category', label: App.util.getCategoryDisplayName(catObj.name) });
                });
           

                const tagNodes = new Map();
                const articleIdToTags = new Map();
                const tagToCategories = new Map();
                const articleIdCounts = new Map();

                articles.forEach(article => {
                    if (!article.tags || article.tags.length === 0) return;

                    articleIdToTags.set(article.id, article.tags);

                    article.tags.forEach(tagId => {
                        articleIdCounts.set(article.id, (articleIdCounts.get(article.id) || 0) + 1);
                        if (!tagNodes.has(tagId)) {
                            tagNodes.set(tagId, { id: tagId, type: 'tag', label: App.state.tags[tagId]?.displayName || tagId });
                        }
                        if (article.category) {
                            if (!tagToCategories.has(tagId)) tagToCategories.set(tagId, new Set());
                            tagToCategories.get(tagId).add(article.category);
                        }
                    });
                });

                const collapsedCategoryIds = new Set(Object.keys(this.nodeStates).filter(id => this.nodeStates[id]?.collapsed));
                const visibleTagIds = new Set();
                tagNodes.forEach((tagNode, tagId) => {
                    const parentCategories = tagToCategories.get(tagId) || new Set();
                    const isVisible = Array.from(parentCategories).some(catId => !collapsedCategoryIds.has(catId));
                    if (isVisible) {
                        visibleTagIds.add(tagId);
                    }
                });

                const finalNodes = [...categoryNodes.values()];
                const finalLinks = [];
                const collapsedTagIds = new Set(Object.keys(this.nodeStates).filter(id => this.nodeStates[id]?.collapsed));

                visibleTagIds.forEach(tagId => finalNodes.push(tagNodes.get(tagId)));

                tagToCategories.forEach((categories, tagId) => {
                    if (visibleTagIds.has(tagId)) {
                        categories.forEach(catId => {
                            if (!collapsedCategoryIds.has(catId)) {
                                finalLinks.push({ id: `${catId}-${tagId}`, source: catId, target: tagId });
                            }
                        });
                    }
                });

                articleIdToTags.forEach((tags, articleId) => {
                    const article = App.storage.getArticle(articleId);
                    tags.forEach(tagId => {
                        if (visibleTagIds.has(tagId) && !collapsedTagIds.has(tagId)) {
                            const articleNodeId = `${articleId}-${tagId}`;
                            const isDuplicate = (articleIdCounts.get(articleId) || 0) > 1;
                            finalNodes.push({ id: articleNodeId, realId: articleId, label: article.title || 'Untitled', type: 'article', tagId: tagId, isDuplicate });
                            finalLinks.push({ id: `${tagId}-${articleNodeId}`, source: tagId, target: articleNodeId });
                        }
                    });
                });

                return { nodes: finalNodes, links: finalLinks };
            },
                    
           
           
            searchNodes(term) {
                if (!this.simulation) return; this.currentSearchResults = []; this.currentSearchIndex = -1;
                const termLower = term.toLowerCase().trim();
                const allNodes = this.g.selectAll('.node-group'); const allLinks = this.g.selectAll('.link'); const allText = this.g.selectAll('.node-text');
                allNodes.classed('faded', false); allLinks.classed('faded', false);
                allText.each(function (d) { d3.select(this).text(d.label).selectAll('tspan').remove(); });
                if (!termLower) return;

                if (this.currentFilter === 'orphans') {
                    const spotlightIds = new Set();
                    this.simulation.nodes().forEach(d => { if (d.label && d.label.toLowerCase().includes(termLower)) spotlightIds.add(d.id); });
                    this.currentSearchResults = Array.from(spotlightIds);
                    allNodes.classed('faded', d => !spotlightIds.has(d.id));
                    allText.filter(d => spotlightIds.has(d.id)).html(d => { const regex = new RegExp(term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'); return d.label.replace(regex, `<tspan class="search-highlight">$&</tspan>`); });
                    // Auto-focus the first orphan result
                    if(this.currentSearchResults.length > 0) this.findNextSearchResult();
                    return;
                }

                const spotlightIds = new Set(); const directMatchIds = new Set();
                const simulationNodes = this.simulation.nodes();
                simulationNodes.forEach(d => { if (d.label && d.label.toLowerCase().includes(termLower)) { spotlightIds.add(d.id); directMatchIds.add(d.id); if (d.type === 'article' && d.tagId) spotlightIds.add(d.tagId); if (d.type === 'tag' && d.categoryIds) { d.categoryIds.forEach(catId => spotlightIds.add(catId)); simulationNodes.forEach(node => { if (node.tagId === d.id) spotlightIds.add(node.id); }); } if (d.type === 'category' && d.tagIds) { d.tagIds.forEach(tagId => spotlightIds.add(tagId)); } } });
                
                // --- START OF HIERARCHICAL SEARCH FIX ---
                const allNodesMap = new Map(simulationNodes.map(n => [n.id, n]));
                const matchingNodeObjects = Array.from(directMatchIds).map(id => allNodesMap.get(id)).filter(Boolean);
                
                const priority = { 'category': 1, 'tag': 2, 'article': 3, 'orphan': 3 };

                matchingNodeObjects.sort((a, b) => {
                    const priorityA = priority[a.type] || 4;
                    const priorityB = priority[b.type] || 4;
                    if (priorityA !== priorityB) {
                        return priorityA - priorityB;
                    }
                    return a.label.localeCompare(b.label);
                });
                
                this.currentSearchResults = matchingNodeObjects.map(n => n.id);
                // --- END OF HIERARCHICAL SEARCH FIX ---

                allNodes.classed('faded', d => !spotlightIds.has(d.id));
                allLinks.classed('faded', l => !spotlightIds.has(l.source.id) || !spotlightIds.has(l.target.id));
                allText.filter(d => directMatchIds.has(d.id)).html(d => { const regex = new RegExp(term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'); return d.label.replace(regex, `<tspan class="search-highlight">$&</tspan>`); });
                
                // Auto-focus the first result
                if (this.currentSearchResults.length > 0) {
                    this.findNextSearchResult();
                }
            },


            findNextSearchResult() {
                if (!this.currentSearchResults || this.currentSearchResults.length === 0) { App.ui.showToast("No search results to cycle through."); return; }
                this.currentSearchIndex = (this.currentSearchIndex + 1) % this.currentSearchResults.length;
                const targetNodeId = this.currentSearchResults[this.currentSearchIndex]; const targetNode = this.simulation.nodes().find(n => n.id === targetNodeId);
                if (targetNode) {
                    const scale = this.currentZoom.k > 1.5 ? this.currentZoom.k : 1.5; const x = this.width / 2 - targetNode.x * scale; const y = this.height / 2 - targetNode.y * scale;
                    this.svg.transition().duration(750).ease(d3.easeCubicInOut).call(this.zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
                    this.node.selectAll('.node-main-body').style('stroke', null).style('stroke-width', null);
                    this.node.filter(d => d.id === targetNodeId).select('.node-main-body').transition().duration(200).style('stroke', 'var(--danger-color)').style('stroke-width', '4px').transition().duration(1500).style('stroke', null).style('stroke-width', null);
                }
            },
            focusOnStickyNote(noteId) {
                // CORRECTED: Uses App.state
                const noteState = App.state.visualMapState.stickyNotes[noteId];
                if (!noteState || !this.svg) return;
                const noteCenterX = noteState.x + (noteState.width / 2), noteCenterY = noteState.y + (noteState.height / 2);
                const viewportCenterX = this.width / 2, viewportCenterY = this.height / 2;
                const desiredScale = Math.min(2, Math.min(this.width / (noteState.width * 2), this.height / (noteState.height * 2)));
                const newX = viewportCenterX - (noteCenterX * desiredScale), newY = viewportCenterY - (noteCenterY * desiredScale);
                this.svg.transition().duration(750).ease(d3.easeCubicInOut).call(this.zoom.transform, d3.zoomIdentity.translate(newX, newY).scale(desiredScale));
            },
            cycleCategoryFocus() { if (!this.simulation) return; const categoryNodes = this.simulation.nodes().filter(n => n.type === 'category'); if (categoryNodes.length === 0) return; this.currentCategoryIndex = (this.currentCategoryIndex + 1) % categoryNodes.length; const targetNode = categoryNodes[this.currentCategoryIndex]; if (typeof targetNode.x !== 'number') return; const scale = 1.5; const x = this.width / 2 - targetNode.x * scale; const y = this.height / 2 - targetNode.y * scale; this.svg.transition().duration(1000).ease(d3.easeCubicInOut).call(this.zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale)); },
            
            
            setNodeStates(mode) { 
                document.querySelectorAll('#visual-map-controls .control-btn.active').forEach(b => b.classList.remove('active')); 
                if (mode === 'expand-all') { this.nodeStates = {}; this.currentFilter = 'all'; document.getElementById('filter-all-btn')?.classList.add('active'); } 
                // CORRECTED: Uses App.state
                else if (mode === 'collapse-to-tags') { this.nodeStates = {}; Object.values(App.state.tags).forEach(t => this.nodeStates[t.id] = { collapsed: true }); this.currentFilter = 'all'; document.getElementById('filter-tags-btn')?.classList.add('active'); } 
                else if (mode === 'orphans') { this.currentFilter = 'orphans'; document.getElementById('filter-orphans-btn')?.classList.add('active'); } 
                this.updateGraph(); this.zoomToFit(); 
                const currentSearchTerm = document.getElementById('graph-search-input').value; if (currentSearchTerm) this.searchNodes(currentSearchTerm);
            },
            currentSnapshotIndex: -1,
            cycleSnapshots() {
                // CORRECTED: Uses App.state
                const snapshots = App.state.visualMapState.snapshots; if (!snapshots || snapshots.length === 0) { App.ui.showToast('No snapshots saved.'); return; }
                this.currentSnapshotIndex = (this.currentSnapshotIndex + 1) % snapshots.length;
                const snapshotToLoad = snapshots[snapshots.length - 1 - this.currentSnapshotIndex]; this.loadSnapshot(snapshotToLoad); App.ui.showToast(`Snapshot ${this.currentSnapshotIndex + 1}/${snapshots.length} ${this.currentSnapshotIndex === 0 ? '(Latest)' : ''}`);
            },
            deleteOldSnapshots() {
                const snapshots = App.state.visualMapState.snapshots; if (!snapshots || snapshots.length === 0) { App.ui.showToast('No snapshots to delete.', {type: 'error'}); return; }
                App.state.visualMapState.snapshots.shift(); this.currentSnapshotIndex = -1; 
                // CORRECTED: Uses App.fs
                App.fs.write('visual-map-state.json', App.state.visualMapState); App.ui.showToast(`Oldest Snapshot Deleted.`);
            },
            loadSnapshot(snapshot) {
                if (!snapshot) return; d3.select('#sticky-note-layer').selectAll('*').remove();
                this.nodeStates = (snapshot.collapsedNodes || []).reduce((acc, id) => { acc[id] = { collapsed: true }; return acc; }, {}); this.updateGraph();
                if (snapshot.transform) { const { x, y, k } = snapshot.transform; this.svg.transition().duration(750).call(this.zoom.transform, d3.zoomIdentity.translate(x, y).scale(k)); }
                if (snapshot.openStickyNotes) { snapshot.openStickyNotes.forEach(noteStateInSnapshot => { if (App.storage.getArticle(noteStateInSnapshot.articleId)) { App.state.visualMapState.stickyNotes[noteStateInSnapshot.id] = noteStateInSnapshot; this.stickyNotes.render(noteStateInSnapshot.id); } }); }
            },
            async exportAndSave() { 
                const btn = document.getElementById('visual-map-snapshot-btn'); btn.style.color = 'var(--primary-color)'; const container = document.getElementById('visual-map-container'); 
                try { 
                    const blob = await htmlToImage.toBlob(container, { backgroundColor: getComputedStyle(container).backgroundColor, width: container.clientWidth, height: container.clientHeight }); 
                    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]); App.ui.showToast('Snapshot saved & image copied!'); 
                } catch (e) { console.error("Image copy failed", e); App.ui.showToast('Snapshot saved (image copy failed).'); } 
                const transform = d3.zoomTransform(this.svg.node()); 
                const collapsedNodes = Object.keys(this.nodeStates).filter(k => this.nodeStates[k].collapsed); 
                const openStickyNotes = Array.from(document.querySelectorAll('#sticky-note-layer .sticky-note-tile')).map(el => App.state.visualMapState.stickyNotes[el.id]).filter(Boolean);
                const newSnapshot = { transform: { x: transform.x, y: transform.y, k: transform.k }, collapsedNodes, openStickyNotes, timestamp: new Date().toISOString() }; 
                App.state.visualMapState.snapshots.push(newSnapshot); 
                if (App.state.visualMapState.snapshots.length > 10) App.state.visualMapState.snapshots.shift();
                await App.fs.write('visual-map-state.json', App.state.visualMapState); 
                setTimeout(() => { btn.style.color = ''; }, 1000); 
            },
            zoomToFit() {
                setTimeout(() => {
                    if (!this.g || !this.simulation || this.simulation.nodes().length === 0) return;
                    const bounds = this.g.node().getBBox(); if (bounds.width === 0 || bounds.height === 0) return;
                    const { x, y, width, height } = bounds;
                    const scale = Math.min(1.5, 0.9 / Math.max(width / this.width, height / this.height));
                    const translate = [this.width / 2 - scale * (x + width / 2), this.height / 2 - scale * (y + height / 2)];
                    const transform = d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale);
                    this.svg.transition().duration(750).call(this.zoom.transform, transform);
                }, 150);
            },
            zoomIn() { this.zoom && this.zoom.scaleBy(this.svg.transition().duration(750), 1.5); },
            zoomOut() { this.zoom && this.zoom.scaleBy(this.svg.transition().duration(750), 1 / 1.5); },
            pan(dx, dy) { if (!this.zoom) return; const panX = dx * (this.width / 4); const panY = dy * (this.height / 4); this.zoom.translateBy(this.svg.transition().duration(600), -panX, -panY); },
            
            
            setDefaultNodeColors() {
                if (!this.node) return;
                this.node.selectAll(".node-main-body").transition().duration(750)
                    .style("fill", d => d.isDuplicate ? `var(--node-article-duplicate)` : `var(--node-${d.type})`);
            },
            gatherNodes() {
                if (!this.simulation) return;
                // Temporarily increase the strength of centering forces
                this.simulation.force("center").strength(1.5);
                this.simulation.force("x").strength(0.5);
                this.simulation.force("y").strength(0.5);
                // "Reheat" the simulation to make nodes move
                this.simulation.alpha(1).restart();
                // Reset strengths back to normal after 2 seconds
                setTimeout(() => {
                    if (!this.simulation) return;
                    this.simulation.force("center").strength(1);
                    this.simulation.force("x").strength(0.05);
                    this.simulation.force("y").strength(0.05);
                }, 2000);
            },
            toggleLayout() {
                if (!this.simulation) return;
                this.layoutMode = this.layoutMode === 'Force' ? 'Radial' : 'Force';
                const btn = document.getElementById('visual-map-layout-toggle');
                btn.innerHTML = this.layoutMode === 'Force' ? ICON_FORCE : ICON_RADIAL;

                if (this.layoutMode === 'Radial') {
                    // Apply radial forces
                    this.simulation.force("x", null).force("y", null); // Remove X and Y forces
                    this.simulation.force("radial", d3.forceRadial(d => d.type === 'category' ? 0 : (d.type === 'tag' ? 150 : 250), this.width / 2, this.height / 2).strength(0.8));
                } else {
                    // Apply standard X and Y forces
                    this.simulation.force("radial", null); // Remove radial force
                    this.simulation.force("x", d3.forceX(this.width / 2).strength(0.05));
                    this.simulation.force("y", d3.forceY(this.height / 2).strength(0.05));
                }
                this.simulation.alpha(1).restart();
            },


            randomizeNodeColors() {
                if (!this.node) return; const articleColorMap = {};
                this.node.selectAll(".node-main-body").each((d, i, nodes) => {
                    let color; const palette = this.colorPalettes[d.type]; if (!palette) return;
                    if (d.type === 'article' || d.type === 'orphan') { if (!articleColorMap[d.realId]) articleColorMap[d.realId] = palette[Math.floor(Math.random() * palette.length)]; color = articleColorMap[d.realId]; } 
                    else color = palette[Math.floor(Math.random() * palette.length)];
                    d3.select(nodes[i]).transition().duration(750).style("fill", color);
                });
            },
            drag(simulation) { 
                function dragstarted(e, d) { if (!e.active) simulation.alphaTarget(0.1).restart(); d.fx = d.x; d.fy = d.y; } 
                function dragged(e, d) { d.fx = e.x; d.fy = e.y; } 
                function dragended(e, d) { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; } 
                return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended); 
            },
            pointInPolygon(point, polygon) { let x = point[0], y = point[1]; let inside = false; for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) { let xi = polygon[i][0], yi = polygon[i][1]; let xj = polygon[j][0], yj = polygon[j][1]; let intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi); if (intersect) inside = !inside; } return inside; },
            toggleLasso() {
                this.isLassoActive = !this.isLassoActive; const btn = document.getElementById('lasso-btn'); const container = document.getElementById('visual-map-container');
                if (this.isLassoActive) { btn.classList.add('active'); container.style.cursor = 'crosshair'; this.clearSelection(); this.svg.on('.zoom', null); this.svg.on('mousedown.lasso', (e) => this.lassoStart(e)).on('mousemove.lasso', (e) => this.lassoDraw(e)).on('mouseup.lasso', (e) => this.lassoEnd(e)); } 
                else { btn.classList.remove('active'); container.style.cursor = 'grab'; if (this.lassoSelection) this.lassoSelection.remove(); this.lassoSelection = null; this.svg.on('.lasso', null); this.svg.call(this.zoom); this.clearSelection(); }
            },
            clearSelection() { this.selectedNodes.clear(); this.node.classed('selected', false); document.getElementById('expand-selection-btn').style.display = 'none'; document.getElementById('collapse-selection-btn').style.display = 'none'; },
            modifySelection(action) {
                if (this.selectedNodes.size === 0) return;
                this.selectedNodes.forEach(nodeId => {
                    const nodeData = this.simulation.nodes().find(n => n.id === nodeId);
                    if (nodeData && (nodeData.type === 'category' || nodeData.type === 'tag')) { if (action === 'collapse') this.nodeStates[nodeId] = { collapsed: true }; else if (this.nodeStates[nodeId]) delete this.nodeStates[nodeId]; }
                });
                this.updateGraph(); this.toggleLasso(); 
            },
            lassoStart(event) { if (!this.isLassoActive) return; this.clearSelection(); this.lassoPoints = []; if (this.lassoSelection) this.lassoSelection.remove(); this.lassoSelection = this.g.append("path").style('fill', 'rgba(0, 123, 255, 0.1)').style('stroke', 'var(--primary-color)').style('stroke-width', '1.5px'); },
            lassoDraw(event) { if (!this.isLassoActive || this.lassoPoints === null) return; const [x, y] = d3.pointer(event, this.g.node()); this.lassoPoints.push([x, y]); this.lassoSelection.attr("d", "M" + this.lassoPoints.join("L") + "Z"); },
            lassoEnd(event) {
                if (!this.isLassoActive || !this.lassoPoints || this.lassoPoints.length < 3) { if (this.lassoSelection) this.lassoSelection.remove(); this.lassoSelection = null; this.lassoPoints = null; return; }
                this.node.each(d => { if (this.pointInPolygon([d.x, d.y], this.lassoPoints)) this.selectedNodes.add(d.id); });
                if (this.selectedNodes.size > 0) { this.node.classed('selected', d => this.selectedNodes.has(d.id)); document.getElementById('expand-selection-btn').style.display = 'flex'; document.getElementById('collapse-selection-btn').style.display = 'flex'; }
                this.lassoPoints = null; setTimeout(() => { if (this.lassoSelection) this.lassoSelection.remove(); this.lassoSelection = null; }, 500); 
            },

            stickyNotes: {
                extractSmartSnippet(articleId, tagId) {
                    const article = App.storage.getArticle(articleId);
                    if (!article || !article.content) return { html: "<p>Content unavailable.</p>", snippetId: null };

                    const tempDiv = document.createElement('div'); 
                    tempDiv.innerHTML = article.content;
                    const tagElement = tempDiv.querySelector(`.rendered-tag[data-tag="${tagId}"]`);

                    if (tagElement) {
                        const parentBlock = tagElement.closest('p, ul, ol, blockquote, h1, h2, h3, h4, h5, h6, li');
                        if (parentBlock) {
                           
                            return { html: parentBlock.outerHTML, snippetId: tagElement.id };
                        }
                    }
            
                    const firstP = tempDiv.querySelector('p');
                    const fallbackHtml = firstP ? firstP.outerHTML : `<p>${article.content.substring(0, 250)}...</p>`;
                    return { html: fallbackHtml, snippetId: null };
                },
                create(nodeData) {
                    const noteId = `note-${nodeData.realId}-${nodeData.tagId}`;
                    if (!App.state.visualMapState.stickyNotes[noteId]) {
                        const article = App.storage.getArticle(nodeData.realId);
                        if (!article) return;
                        // This new logic correctly fetches AND stores the snippetId
                        const snippetData = this.extractSmartSnippet(nodeData.realId, nodeData.tagId);
                        const noteState = { id: noteId, articleId: nodeData.realId, tagId: nodeData.tagId, snippetId: snippetData.snippetId, x: nodeData.x + 40, y: nodeData.y - 40, width: 280, height: 240, sizeIndex: 3, color: 'default', title: article.title || 'Untitled' };
                        App.state.visualMapState.stickyNotes[noteId] = noteState;
                    }
                    if (!document.getElementById(noteId)) { this.render(noteId); } 
                    else { 
                        App.visualMap.focusOnStickyNote(noteId);
                        const el = document.getElementById(noteId); el.classList.remove('spawn'); void el.offsetWidth; el.classList.add('spawn'); d3.select(el).raise();
                    }
                    App.fs.write('visual-map-state.json', App.state.visualMapState);
                },
                render(noteId) {
                    const noteState = App.state.visualMapState.stickyNotes[noteId];
                    if (!noteState) return;

                    // UPDATED: Ensure size properties exist, providing new, larger defaults if not.
                    noteState.width = noteState.width || 280;
                    noteState.height = noteState.height || 240;
                    noteState.sizeIndex = noteState.sizeIndex === undefined ? 3 : noteState.sizeIndex;

                    const noteLayer = d3.select('#sticky-note-layer');
                    const snippetData = this.extractSmartSnippet(noteState.articleId, noteState.tagId);
                    const sanitizedSnippet = App.util.sanitizeHTML(snippetData.html);

                    const noteHTML = `
                        <div class="sticky-note-header">
                            <h5 data-article-id="${noteState.articleId}" data-tag-id="${noteState.tagId}">${noteState.title}</h5>
                        </div>
                        <div class="sticky-note-content">${sanitizedSnippet}</div>
                        <div class="sticky-note-controls">
                            <button class="btn-icon color-btn" title="Cycle color">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"/></svg>
                            </button>
                            <button class="btn-icon scroll-btn" title="Scroll content">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="m7 15 5 5 5-5M7 9l5-5 5 5"/></svg>
                            </button>
                            <button class="btn-icon resize-btn" title="Cycle size">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M20.25 20.25v-4.5m0 4.5h-4.5m4.5 0L15 15" /></svg>
                            </button>
                            <button class="btn-icon close-btn" title="Close">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </button>
                        </div>
                    `;

                    const note = noteLayer.append('div')
                        .attr('id', noteId)
                        .attr('class', `sticky-note-tile color-${noteState.color} spawn`)
                        .style('left', `${noteState.x}px`)
                        .style('top', `${noteState.y}px`)
                        .style('width', `${noteState.width}px`)
                        .style('height', `${noteState.height}px`)
                        .html(noteHTML);

                    note.select('.close-btn').on('mousedown', (e) => { e.stopPropagation(); this.remove(noteId); });
                    note.select('h5').on('click', (e) => { 
                        e.stopPropagation(); 
                        App.router.navigateTo('article', {id: noteState.articleId, mode: 'read', scrollToSnippetId: noteState.snippetId}) 
                    });
                    note.select('.color-btn').on('click', (e) => { e.stopPropagation(); this.cycleColor(noteId); });
                    note.select('.resize-btn').on('click', (e) => { e.stopPropagation(); this.cycleSize(noteId); });
                    note.select('.scroll-btn').on('click', (e) => { e.stopPropagation(); this.scrollContent(noteId); });

                    const dragMove = d3.drag()
                        .filter(event => !event.target.closest('.sticky-note-controls'))
                        .on("start", (e) => note.raise().classed('dragging', true))
                        .on("drag", (e) => {
                            noteState.x += e.dx / App.visualMap.currentZoom.k;
                            noteState.y += e.dy / App.visualMap.currentZoom.k;
                            note.style('left', `${noteState.x}px`).style('top', `${noteState.y}px`);
                        }).on("end", () => { 
                            note.classed('dragging', false); 
                            App.fs.write('visual-map-state.json', App.state.visualMapState); 
                        });

                    note.call(dragMove);
                },
             
                cycleSize(noteId) {
                    const noteState = App.state.visualMapState.stickyNotes[noteId];
                    if (!noteState) return;

                    const sizes = [
                        { w: 180, h: 140 }, // 1. X-Small
                        { w: 210, h: 170 }, // 2. Small
                        { w: 240, h: 200 }, // 3. Compact
                        { w: 280, h: 240 }, // 4. Default
                        { w: 340, h: 280 }, // 5. Large
                        { w: 400, h: 320 }, // 6. X-Large
                        { w: 460, h: 360 }  // 7. XX-Large
                    ];

                    noteState.sizeIndex = ((noteState.sizeIndex || 0) + 1) % sizes.length;
                    const newSize = sizes[noteState.sizeIndex];
                    
                    noteState.width = newSize.w;
                    noteState.height = newSize.h;

                    const noteEl = d3.select(`#${noteId}`);
                    noteEl.transition().duration(250)
                        .style('width', `${noteState.width}px`)
                        .style('height', `${noteState.height}px`);
                    
                    App.fs.write('visual-map-state.json', App.state.visualMapState);
                },

                scrollContent(noteId) {
                    const noteEl = document.getElementById(noteId);
                    if (!noteEl) return;
                    const contentEl = noteEl.querySelector('.sticky-note-content');
                    if (!contentEl) return;

                    const currentTop = contentEl.scrollTop;
                    const maxScroll = contentEl.scrollHeight - contentEl.clientHeight;
                    const pageHeight = contentEl.clientHeight * 0.8; 

                    if (currentTop >= maxScroll - 5) {
                        contentEl.scrollTo({ top: 0, behavior: 'smooth' });
                    } else {
                        contentEl.scrollTo({ top: Math.min(maxScroll, currentTop + pageHeight), behavior: 'smooth' });
                    }
                },

                remove(noteId) { 
                    d3.select(`#${noteId}`).remove(); 
                    delete App.state.visualMapState.stickyNotes[noteId]; 
                    App.fs.write('visual-map-state.json', App.state.visualMapState);
                },
                cycleColor(noteId) {
                    const noteState = App.state.visualMapState.stickyNotes[noteId];
                    if (!noteState) return;
                    const noteEl = d3.select(`#${noteId}`);
                    noteEl.classed(`color-${noteState.color}`, false);
                    const currentIndex = App.config.stickyNoteColors.indexOf(noteState.color);
                    noteState.color = App.config.stickyNoteColors[(currentIndex + 1) % App.config.stickyNoteColors.length];
                    noteEl.classed(`color-${noteState.color}`, true);
                    App.fs.write('visual-map-state.json', App.state.visualMapState);
                },
            },
        },

        // ==========================================================================
        // 3.20. AUDIO MODULE (NEW)
        // ==========================================================================
        audio: {
            isRecording: false,
            isTranscribing: false,
            recorder: null,
            transcriptionWorker: null,
            audioChunks: [],
            activePlayer: null,
            transcriptionToasts: new Map(),
            audioContext: null,
            analyser: null,
            animationFrameId: null,
            recordingToast: null,
            modelDB: null,

            async init() {
                try {
                    const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1');
                } catch(e) { console.warn("Could not preload transcription library.") }
                await this.openModelDB();
            },

            async openModelDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('WhisperModelsDB', 1);
                    request.onerror = (e) => { console.error("IndexedDB error:", e); reject("DB Error"); };
                    request.onsuccess = (e) => { this.modelDB = e.target.result; resolve(); };
                    request.onupgradeneeded = (e) => { e.target.result.createObjectStore('models', { keyPath: 'id' }); };
                });
            },

            async saveModel(id, data) {
                if (!this.modelDB) await this.openModelDB();
                return new Promise((resolve, reject) => {
                    const transaction = this.modelDB.transaction(['models'], 'readwrite');
                    const store = transaction.objectStore('models');
                    const request = store.put({ id, data });
                    request.onsuccess = () => resolve();
                    request.onerror = (e) => { console.error("Failed to save model to DB", e); reject("Save Error"); };
                });
            },

            async getModel(id) {
                if (!this.modelDB) await this.openModelDB();
                return new Promise((resolve) => {
                    const transaction = this.modelDB.transaction(['models'], 'readonly');
                    const store = transaction.objectStore('models');
                    const request = store.get(id);
                    request.onsuccess = (e) => resolve(e.target.result ? e.target.result.data : null);
                    request.onerror = () => resolve(null);
                });
            },

            async deleteTranscriptionModels() {
                if (!this.modelDB) await this.openModelDB();
                return new Promise((resolve) => {
                    const transaction = this.modelDB.transaction(['models'], 'readwrite');
                    const store = transaction.objectStore('models');
                    store.clear().onsuccess = async () => {
                        await App.settings.set('transcriptionModel', null);
                        this.updateModelStatusUI();
                        App.ui.showToast('Offline models deleted.', 'info');
                        resolve();
                    };
                });
            },

            async downloadTranscriptionModel(modelId) {
                const btn = document.getElementById(`download-model-${modelId.split('-')[1]}`);
                if (btn) {
                    btn.textContent = 'Preparing...';
                    btn.disabled = true;
                }
                try {
                    const { pipeline, env } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1');
                    await pipeline('automatic-speech-recognition', modelId, {
                        progress_callback: (progress) => {
                            if (!btn) return;
                            let progressText = progress.file ? progress.file.split('.')[0] : 'Initializing';
                            if (typeof progress.progress === 'number') {
                                progressText += `: ${progress.progress.toFixed(0)}%`;
                            }
                            btn.textContent = progressText;
                        }
                    });
                    await App.settings.set('transcriptionModel', modelId);
                    App.ui.showToast(`Model "${modelId.split('/')[1]}" is ready!`, { type: 'success' });
                } catch (e) {
                    console.error("Model download failed", e);
                    App.ui.showToast('Model download failed. Check console.', 'error');
                } finally {
                    this.updateModelStatusUI();
                }
            },

            async updateModelStatusUI() {
                const statusEl = document.getElementById('transcription-model-status');
                const deleteBtn = document.getElementById('delete-models-btn');
                const selectedModel = App.settings.get('transcriptionModel');
                if (statusEl) {
                    statusEl.textContent = selectedModel ? `Selected: ${selectedModel.split('/')[1]}` : 'No model selected.';
                }
                document.querySelectorAll('[id^="download-model-"]').forEach(btn => {
                    const modelId = `Xenova/whisper-${btn.id.split('-')[2]}`;
                    if (modelId === selectedModel) {
                        btn.textContent = 'Selected';
                        btn.disabled = true;
                        btn.classList.remove('btn-secondary');
                        btn.classList.add('btn-primary');
                    } else {
                        btn.textContent = 'Select';
                        btn.disabled = false;
                        btn.classList.remove('btn-primary');
                        btn.classList.add('btn-secondary');
                    }
                });
                if (deleteBtn) {
                    deleteBtn.style.display = selectedModel ? 'inline-flex' : 'none';
                }
            },

            async toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    await this.startRecording();
                }
            },

            async startRecording() {
                if (this.isRecording) return;
                const modelName = App.settings.get('transcriptionModel');
                this.isTranscribing = !!modelName;

                const stream = await this.requestPermission();
                if (!stream) return;

                this.isRecording = true;
                this.audioChunks = [];
                this.recorder = new MediaRecorder(stream, { audioBitsPerSecond: App.settings.get('audioBitrate') });

                this.recorder.addEventListener("stop", async () => {
                    const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        this.insertPlayer(reader.result, crypto.randomUUID());
                    };
                    reader.readAsDataURL(audioBlob);
                });

                this.recorder.addEventListener("dataavailable", event => this.audioChunks.push(event.data));
                this.recorder.start();
                this._startVisualizer(stream);

                const articleForControls = App.storage.getArticle(App.state.activeArticleId) || { category: 'General' };
                App.ui.renderArticleControls(articleForControls);

                // THE FIX: Create a beautiful, animated toast message instead of static text.
                const toastMessageHTML = `
                    <div class="toast-wave-container">
                        <div class="toast-wave-visualizer">
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                        </div>
                        <span>Recording...</span>
                    </div>`;
                this.recordingToast = App.ui.showToast(toastMessageHTML, { type: 'info', duration: 0 });
            },

            stopRecording() {
                if (!this.isRecording || !this.recorder) return;
                this.recorder.stop();
                this.isRecording = false;
                this._stopVisualizer();

                const articleForControls = App.state.activeArticleId === 'temp_new_article'
                    ? { category: 'General', readCount: 0, tags: [] }
                    : App.storage.getArticle(App.state.activeArticleId);
                App.ui.renderArticleControls(articleForControls);

                if (this.recordingToast) App.ui.hideToast(this.recordingToast);
                this.recordingToast = null;
            },

            runTranscription(audioData, modelName, transcriptionId) {
                if (this.transcriptionWorker) {
                    this.transcriptionWorker.terminate();
                }

                const workerBlob = new Blob([document.getElementById('transcription-worker-script').textContent], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(workerBlob);
                
                // **THIS IS THE FIX**: We create the worker as a 'module' so it can use `import`.
                this.transcriptionWorker = new Worker(workerUrl, { type: 'module' });

                const transcribingToast = App.ui.showToast('Transcribing...', { type: 'info', duration: 0 });
                this.transcriptionToasts.set(transcriptionId, transcribingToast);

                this.transcriptionWorker.onmessage = (event) => {
                    const { status, text, data, playerId: returnedId } = event.data;
                    const toastToHide = this.transcriptionToasts.get(returnedId);
                    if (toastToHide) {
                        App.ui.hideToast(toastToHide);
                        this.transcriptionToasts.delete(returnedId);
                    }
                    if (status === 'complete') {
                        this.insertTranscriptionAsTile(text, returnedId);
                    } else if (status === 'error') {
                        App.ui.showToast(`Transcription failed: ${data}`, { type: 'error' });
                    }
                    this.transcriptionWorker.terminate();
                    this.transcriptionWorker = null;
                };

                this.transcriptionWorker.onerror = (e) => {
                    console.error('Worker error:', e);
                    const toastToHide = this.transcriptionToasts.get(transcriptionId);
                    if (toastToHide) App.ui.hideToast(toastToHide);
                    App.ui.showToast('A critical worker error occurred.', 'error');
                };

                this.transcriptionWorker.postMessage({ audioData, modelName, playerId: transcriptionId });
            },

            insertTranscriptionAsTile(text, transcriptionId) {
                if (!text || !text.trim() || !transcriptionId) return;
                navigator.clipboard.writeText(text.trim()).then(() => {
                    App.ui.showToast('Transcription complete & copied!', { type: 'success' });
                });
                const tileHTML = `<div class="nk-text-tile color-default" contenteditable="false" data-color="default">
                    <span class="nk-text-tile-icon">ðŸŽ™ï¸</span>
                    <div class="nk-text-tile-color-cycler" title="Cycle Color"><i class="fa-solid fa-palette fa-xs"></i></div>
                    <div class="nk-text-tile-content" contenteditable="true">${App.util.escapeHtml(text.trim())}</div>
                </div>`;
                
                const placeholderContainer = document.getElementById(transcriptionId);
                if (placeholderContainer) {
                    placeholderContainer.outerHTML = tileHTML;
                } else {
                    console.warn("Could not find transcription placeholder container for ID:", transcriptionId);
                    // Fallback just in case, inserts at the end of the article.
                    document.getElementById('article-content').insertAdjacentHTML('beforeend', tileHTML + '<p><br></p>');
                }
                App.state.isArticleDirty = true;
            },

            insertPlayer(base64Url, transcriptionId) {
                const playerId = `audio-player-${transcriptionId}`;

                const transcribeButtonHTML = `
                    <div class="nk-transcribe-container" id="transcribe-container-${transcriptionId}">
                    <button class="btn btn-secondary btn-gradient-text">Transcribe Audio</button>
                    </div>`;

                const playerHTML = `
                    <div class="nk-audio-block">
                        <div class="nk-audio-player" id="${playerId}" contenteditable="false">
                            <button class="audio-play-pause-btn" aria-label="Play"></button>
                            <div class="audio-progress-bar-container">
                                <input type="range" class="audio-progress-bar" value="0" min="0" max="100" step="0.1">
                            </div>
                            <div class="audio-time-display">0:00 / 0:00</div>
                            <button class="btn btn-secondary audio-speed-btn" data-speed="1" title="Playback Speed">1x</button>
                            <audio src="${base64Url}" preload="metadata" data-speed="1"></audio>
                        </div>
                        ${transcribeButtonHTML}
                    </div>`;

                App.util.insertGuardianBlock(playerHTML);

                setTimeout(() => {
                    const newPlayer = document.getElementById(playerId);
                    if (newPlayer) this._initializeSinglePlayer(newPlayer);
                }, 100);
                App.state.isArticleDirty = true;
            },

            initializePlayersIn(container) {
                container.querySelectorAll('.nk-audio-player').forEach(player => { if (player.dataset.initialized) return; this._initializeSinglePlayer(player); });
            },

            _initializeSinglePlayer(player) {
                const audio = player.querySelector('audio'); const playPauseBtn = player.querySelector('.audio-play-pause-btn'); const progressBar = player.querySelector('.audio-progress-bar'); const timeDisplay = player.querySelector('.audio-time-display');
                if (!audio || !playPauseBtn || !progressBar || !timeDisplay) return;
                const formatTime = (seconds) => `${Math.floor(seconds / 60)}:${Math.floor(seconds % 60).toString().padStart(2, '0')}`;
                const updateDisplay = () => { if (!audio.duration) return; progressBar.value = audio.currentTime; timeDisplay.textContent = `${formatTime(audio.currentTime)} / ${formatTime(audio.duration || 0)}`; };
                playPauseBtn.classList.remove('playing');
                audio.addEventListener('loadedmetadata', () => { progressBar.max = audio.duration; updateDisplay(); });
                audio.addEventListener('timeupdate', updateDisplay);
                audio.addEventListener('play', () => { playPauseBtn.classList.add('playing'); this.activePlayer = audio; });
                audio.addEventListener('pause', () => { playPauseBtn.classList.remove('playing'); if (this.activePlayer === audio) this.activePlayer = null; });
                audio.addEventListener('ended', () => { playPauseBtn.classList.remove('playing'); audio.currentTime = 0; updateDisplay(); if (this.activePlayer === audio) this.activePlayer = null; });
                progressBar.addEventListener('input', () => { audio.currentTime = progressBar.value; updateDisplay(); });
                player.dataset.initialized = 'true';
            },

            async transcribeAudioBlock(buttonEl) {
                const container = buttonEl.parentElement;
                const audioPlayer = container.previousElementSibling;
                if (!audioPlayer || !audioPlayer.classList.contains('nk-audio-player')) {
                    App.ui.showToast("Could not find the associated audio player.", 'error');
                    return;
                }

                const audioEl = audioPlayer.querySelector('audio');
                const modelName = App.settings.get('transcriptionModel');
                if (!audioEl || !audioEl.src || !modelName) {
                    App.ui.showToast("Audio source or transcription model not found.", 'error');
                    return;
                }

                // Show feedback to the user immediately
                container.innerHTML = `<p id="${container.id}" class="transcript-placeholder" style="color:var(--text-secondary); font-style:italic;">Transcribing, wait for a moment ...</p>`;

                try {
                    // Convert the base64 data URL back into an ArrayBuffer the AI can use
                    const audioBlob = App.util.dataURLtoBlob(audioEl.src);
                    if (!audioBlob) throw new Error("Could not convert audio data.");
                    
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    // Use a temporary AudioContext for this one-off task
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    const audioDataForTranscription = audioBuffer.getChannelData(0);

                    // The container's ID is our unique key for this transcription job
                    const transcriptionId = container.id;
                    this.runTranscription(audioDataForTranscription, modelName, transcriptionId);
                    
                } catch (error) {
                    console.error("Error preparing audio for transcription:", error);
                    App.ui.showToast("Failed to process audio for transcription.", 'error');
                    // Restore the button if processing fails
                    container.innerHTML = `<button class="btn btn-secondary" onclick="App.audio.transcribeAudioBlock(this)">Transcribe Audio</button>`;
                }
            },

            handlePlayPause(button) {
                const player = button.closest('.nk-audio-player'); if (!player) return; const audio = player.querySelector('audio');
                if (this.activePlayer && this.activePlayer !== audio) this.activePlayer.pause();
                if (audio.paused) audio.play(); else audio.pause();
            },

            // NEW FUNCTION
            handleSpeedChange(button) {
                const player = button.closest('.nk-audio-player');
                if (!player) return;
                const audio = player.querySelector('audio');
                if (!audio) return;

                const speeds = [1, 1.25, 1.5, 1.75, 2];
                const currentSpeed = parseFloat(button.dataset.speed || "1");
                const currentIndex = speeds.indexOf(currentSpeed);
                const nextIndex = (currentIndex + 1) % speeds.length;
                const newSpeed = speeds[nextIndex];

                audio.playbackRate = newSpeed;
                button.dataset.speed = newSpeed;
                button.textContent = `${newSpeed}x`;
                button.title = `Playback Speed: ${newSpeed}x`;
            },

            async requestPermission() {
                try { if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Error('InsecureContext'); return await navigator.mediaDevices.getUserMedia({ audio: true }); }
                catch (err) { let msg = 'An unknown error occurred.'; if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') msg = 'Microphone permission was denied.'; else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') msg = 'No microphone was found on this device.'; else if (err.message === 'InsecureContext') msg = 'Microphone access requires a secure (https:// or localhost) connection.'; App.ui.showToast(msg, 'error'); console.error("Mic error:", err.name, err.message); return null; }
            },

            _startVisualizer(stream) {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); this.analyser = this.audioContext.createAnalyser(); const source = this.audioContext.createMediaStreamSource(stream); source.connect(this.analyser); this.analyser.fftSize = 256; const bufferLength = this.analyser.frequencyBinCount; const dataArray = new Uint8Array(bufferLength); const canvas = document.getElementById('recording-visualizer-canvas'); if (!canvas) return; const canvasCtx = canvas.getContext('2d');
                const draw = () => { this.animationFrameId = requestAnimationFrame(draw); this.analyser.getByteTimeDomainData(dataArray); canvasCtx.clearRect(0, 0, canvas.width, canvas.height); canvasCtx.lineWidth = 2; canvasCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--danger-color'); canvasCtx.beginPath(); const sliceWidth = canvas.width * 1.0 / bufferLength; let x = 0; for (let i = 0; i < bufferLength; i++) { const v = dataArray[i] / 128.0; const y = v * canvas.height / 2; if (i === 0) canvasCtx.moveTo(x, y); else canvasCtx.lineTo(x, y); x += sliceWidth; } canvasCtx.lineTo(canvas.width, canvas.height / 2); canvasCtx.stroke(); }; draw();
            },

            _stopVisualizer() {
                if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId); if (this.audioContext) this.audioContext.close(); this.animationFrameId = null; this.audioContext = null; const canvas = document.getElementById('recording-visualizer-canvas'); if (canvas) canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
            }
        },


        // ==========================================================================
        // 3.21. PDF MODULE (NEW - STABLE IMPLEMENTATION)
        // ==========================================================================
        
        annotationEngine: {
            state: {
                context: null,
                isActive: false,
                isDrawing: false,
                tool: 'rect',
                colors: ['#ef4444', '#f97316', '#f0b70c', '#00ff00', '#22c55e', '#06b6d4', '#0000ff', '#8b5cf6', '#ff00ff', '#8b4513', '#64748b', '#7fffd4'],
                thicknesses: [1, 2, 3, 5, 6, 8, 10, 12, 15, 22],
                colorIndex: 0,
                thicknessIndex: 0,
                lastPos: { x: 0, y: 0 },
                currentPath: null, 
            },

            init() {
                this.state = { ...this.state, context: null, isActive: false, isDrawing: false, tool: 'rect', currentPath: null };
            },

            getCanvasAndContext() {
                const canvas = (this.state.context === 'pdf')
                    ? document.getElementById('annotation-layer')
                    : document.getElementById('annotation-canvas');
                return { canvas, ctx: canvas ? canvas.getContext('2d') : null };
            },

            
            toggle(context) {
                if (this.state.isActive && this.state.context !== context) {
                    this.toggle(this.state.context);
                }

                this.state.context = context;
                this.state.isActive = !this.state.isActive;
                const isPdf = context === 'pdf';

                const container = isPdf ? document.getElementById('pdf-viewer-container') : document.querySelector('.focus-mode-overlay');
                const toolbar = isPdf ? document.getElementById('pdf-annotation-toolbar') : document.getElementById('annotation-toolbar');
                const toggleBtn = isPdf ? document.getElementById('pdf-annotate-toggle') : container?.querySelector('.annotation-btn');
                const { canvas } = this.getCanvasAndContext();

                if (!canvas || !container || !toolbar || !toggleBtn) {
                    this.init();
                    return;
                }

                container.classList.toggle('annotation-active', this.state.isActive);
                toggleBtn.classList.toggle('active', this.state.isActive);
                toolbar.style.display = this.state.isActive ? 'flex' : 'none';
                if (isPdf) toolbar.classList.toggle('hidden', !this.state.isActive);

                const newCanvas = canvas.cloneNode(true);
                canvas.parentNode.replaceChild(newCanvas, canvas);

                if (this.state.isActive) {
                    if (context === 'focus') {
                        const bodyEl = container.querySelector('.focus-mode-body');
                        newCanvas.width = bodyEl.scrollWidth;
                        newCanvas.height = bodyEl.scrollHeight;
                        this.redrawPageAnnotations();
                    } else if (context === 'pdf') {
                        this.redrawPageAnnotations(App.pdf.state.pageNum);
                    }

                    this.updateToolbarUI();
                    newCanvas.addEventListener('mousedown', this.startDrawing.bind(this));
                    newCanvas.addEventListener('mousemove', this.draw.bind(this));
                    newCanvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                    newCanvas.addEventListener('mouseleave', this.stopDrawing.bind(this));
                    newCanvas.addEventListener('touchstart', (e) => this.startDrawing(e.touches[0]), { passive: false });
                    newCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); this.draw(e.touches[0]); }, { passive: false });
                    newCanvas.addEventListener('touchend', (e) => this.stopDrawing(e.changedTouches[0]));
                } else {
                    // NEW: Save logic for Stage Mode annotations.
                    if (context === 'focus') {
                        const session = App.state.focusSession;
                        const article = session.articles[session.currentIndex];
                        if (article) {
                            const articleInState = App.storage.getArticle(article.id);
                            if (articleInState) {
                                const currentAnnotationsJSON = JSON.stringify(articleInState.stageAnnotations || {});
                                const newAnnotationsJSON = JSON.stringify(session.annotations);

                                if (currentAnnotationsJSON !== newAnnotationsJSON) {
                                    App.storage.updateArticle(article.id, { stageAnnotations: session.annotations });
                                    App.ui.showToast('Stage annotations saved!', { type: 'success' });
                                }
                            }
                        }
                    }
                    // END NEW
                    this.init(); // Full reset
                }
            },
                        
            updateToolbarUI() {
                const isPDF = this.state.context === 'pdf';
                const toolPrefix = isPDF ? 'pdf-tool-' : 'focus-tool-';
                const colorCyclerId = isPDF ? 'pdf-color-cycler' : 'focus-color-cycler';
                const thicknessBtnId = isPDF ? 'pdf-thickness-cycler' : 'focus-thickness-cycler';

                ['pen', 'rect', 'eraser'].forEach(t => {
                    const btn = document.getElementById(`${toolPrefix}${t}`);
                    if (btn) btn.classList.toggle('active', this.state.tool === t);
                });
                const colorCyclerBtn = document.getElementById(colorCyclerId);
                if (colorCyclerBtn) {
                    colorCyclerBtn.innerHTML = '<div class="color-cycler-inner"></div>';
                    const inner = colorCyclerBtn.querySelector('.color-cycler-inner');
                    if (inner) {
                        inner.style.backgroundColor = this.state.colors[this.state.colorIndex];
                        const isDark = ['#212529'].includes(this.state.colors[this.state.colorIndex]);
                        inner.style.border = isDark ? '2px solid var(--border-color)' : 'none';
                    }
                }
                const thicknessBtn = document.getElementById(thicknessBtnId);
                if (thicknessBtn) {
                    const r = this.state.thicknesses[this.state.thicknessIndex];
                    const circle = thicknessBtn.querySelector('svg circle');
                    if (circle) circle.setAttribute('r', r * 0.5 + 1);
                }
            },

            cycleColor() {
                this.state.colorIndex = (this.state.colorIndex + 1) % this.state.colors.length;
                this.updateToolbarUI();
                App.ui.showToast(`Color changed`, { duration: 1500 });
            },
            setTool(tool) { this.state.tool = tool; this.updateToolbarUI(); },
            cycleThickness() {
                this.state.thicknessIndex = (this.state.thicknessIndex + 1) % this.state.thicknesses.length;
                this.updateToolbarUI();
                App.ui.showToast(`Thickness changed`, { duration: 1500 });
            },
            _getDataStore() {
                if (this.state.context === 'pdf') {
                    return { pageKey: App.pdf.state.pageNum, data: App.pdf.state.annotationsByPage };
                }
                if (this.state.context === 'focus') {
                    return { pageKey: App.state.focusSession.currentSlideIndex, data: App.state.focusSession.annotations };
                }
                return { pageKey: null, data: null };
            },

            redrawPageAnnotations() {
                const { canvas, ctx } = this.getCanvasAndContext();
                const { pageKey, data } = this._getDataStore();
                if (!ctx || pageKey === null || !data) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const annotations = data[pageKey] || [];
                const scrollTop = this.state.context === 'focus' ? document.querySelector('.focus-mode-body').scrollTop : 0;

                annotations.forEach(annotation => {
                    ctx.lineWidth = annotation.thickness;
                    ctx.strokeStyle = annotation.color;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    if (annotation.type === 'pen' && annotation.points.length > 1) {
                        // Pen logic is UNCHANGED and will work correctly.
                        ctx.beginPath();
                        ctx.moveTo(annotation.points[0][0] * canvas.width, (annotation.points[0][1] * canvas.scrollHeight) - scrollTop);
                        for (let i = 1; i < annotation.points.length; i++) {
                            ctx.lineTo(annotation.points[i][0] * canvas.width, (annotation.points[i][1] * canvas.scrollHeight) - scrollTop);
                        }
                        ctx.stroke();
                    } else if (annotation.type === 'rect') {
                      
                        ctx.fillStyle = App.util.hexToRgba(annotation.color, 0.2);   // Softer, more beautiful fill
                        ctx.strokeStyle = App.util.hexToRgba(annotation.color, 0.35);  // Subtle, translucent border

                        const b = annotation.bounds;
                        const x = b.x * canvas.width;
                        const y = (b.y * canvas.scrollHeight) - scrollTop;
                        const w = b.w * canvas.width;
                        const h = b.h * canvas.scrollHeight;
                        
                        ctx.beginPath();
                        ctx.roundRect(x, y, w, h, 8); // 8px radius for a modern look
                        ctx.fill();
                        ctx.stroke();
                    
                    }
                });
            },

         
            startDrawing(e) {
                const { canvas, ctx } = this.getCanvasAndContext();
                const { pageKey, data } = this._getDataStore();
                if (!ctx || !this.state.isActive || pageKey === null || !data) return;

                this.state.isDrawing = true;
                const rect = canvas.getBoundingClientRect();

                // FIX: Conditionally add scroll position ONLY for focus mode.
                const scrollTop = this.state.context === 'focus' ? document.querySelector('.focus-mode-body').scrollTop : 0;
                const pos = { x: e.clientX - rect.left, y: e.clientY - rect.top + scrollTop };
                this.state.lastPos = pos;

                if (!data[pageKey]) data[pageKey] = [];

                if (this.state.tool === 'eraser') {
                    // Eraser logic... (remains unchanged and safe)
                    const annotations = data[pageKey];
                    let deleted = false;
                    for (let i = annotations.length - 1; i >= 0; i--) {
                        const annotation = annotations[i];
                        const relPos = { x: pos.x / canvas.width, y: pos.y / canvas.height };
                        let inBounds = false;
                        if (annotation.type === 'pen') {
                            const minX = Math.min(...annotation.points.map(p => p[0])), maxX = Math.max(...annotation.points.map(p => p[0])),
                                minY = Math.min(...annotation.points.map(p => p[1])), maxY = Math.max(...annotation.points.map(p => p[1]));
                            if (relPos.x >= minX && relPos.x <= maxX && relPos.y >= minY && relPos.y <= maxY) inBounds = true;
                        } else if (annotation.type === 'rect') {
                            const b = annotation.bounds;
                            if (relPos.x >= b.x && relPos.x <= b.x + b.w && relPos.y >= b.y && relPos.y <= b.y + b.h) inBounds = true;
                        }
                        if (inBounds) { annotations.splice(i, 1); deleted = true; break; }
                    }
                    if (deleted) this.redrawPageAnnotations();
                    this.state.isDrawing = false;
                } else {
                    this.state.currentPath = { type: this.state.tool, color: this.state.colors[this.state.colorIndex], thickness: this.state.thicknesses[this.state.thicknessIndex] };
                    if (this.state.tool === 'pen') this.state.currentPath.points = [[pos.x / canvas.width, pos.y / canvas.height]];
                    else if (this.state.tool === 'rect') this.state.currentPath.bounds = { x: pos.x / canvas.width, y: pos.y / canvas.height, w: 0, h: 0 };
                }
            },

            draw(e) {
                if (!this.state.isDrawing || !this.state.currentPath) return;
                const { canvas, ctx } = this.getCanvasAndContext();
                if (!ctx) return;
                const rect = canvas.getBoundingClientRect();
                const scrollTop = this.state.context === 'focus' ? document.querySelector('.focus-mode-body').scrollTop : 0;
                const currentPos = { x: e.clientX - rect.left, y: e.clientY - rect.top + scrollTop };

                this.redrawPageAnnotations();

                ctx.lineWidth = this.state.currentPath.thickness;
                ctx.strokeStyle = this.state.currentPath.color;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                if (this.state.tool === 'pen') {
                    
                    this.state.currentPath.points.push([currentPos.x / canvas.scrollWidth, currentPos.y / canvas.scrollHeight]);
                    ctx.beginPath();
                    const pathPoints = this.state.currentPath.points;
                    ctx.moveTo(pathPoints[0][0] * canvas.width, (pathPoints[0][1] * canvas.scrollHeight) - scrollTop);
                    for(let i = 1; i < pathPoints.length; i++) {
                        ctx.lineTo(pathPoints[i][0] * canvas.width, (pathPoints[i][1] * canvas.scrollHeight) - scrollTop);
                    }
                    ctx.stroke();
                } else if (this.state.tool === 'rect') {
                    ctx.fillStyle = App.util.hexToRgba(this.state.currentPath.color, 0.25);
                    ctx.strokeStyle = App.util.hexToRgba(this.state.currentPath.color, 0.75);
                    
                    const startX = this.state.lastPos.x;
                    const startY = this.state.lastPos.y - scrollTop;
                    const width = currentPos.x - startX;
                    const height = (currentPos.y - scrollTop) - startY;

                    ctx.beginPath();
                    ctx.roundRect(startX, startY, width, height, 8);
                    ctx.fill();
                    ctx.stroke();
                    
                }
            },

            stopDrawing(e) {
                if (!this.state.isDrawing || !this.state.currentPath) return;
                this.state.isDrawing = false;
                const { canvas } = this.getCanvasAndContext();
                if(!canvas) return;
                const { pageKey, data } = this._getDataStore();
                const rect = canvas.getBoundingClientRect();

                // FIX: Conditionally add scroll position ONLY for focus mode.
                const scrollTop = this.state.context === 'focus' ? document.querySelector('.focus-mode-body').scrollTop : 0;
                const currentPos = { x: e.clientX - rect.left, y: e.clientY - rect.top + scrollTop };

                if (this.state.tool === 'rect') {
                    const startX = this.state.lastPos.x / canvas.scrollWidth;
                    const startY = this.state.lastPos.y / canvas.scrollHeight;
                    const endX = currentPos.x / canvas.scrollWidth;
                    const endY = currentPos.y / canvas.scrollHeight;
                    this.state.currentPath.bounds = { x: Math.min(startX, endX), y: Math.min(startY, endY), w: Math.abs(endX - startX), h: Math.abs(endY - startY) };
                }

                if ((this.state.currentPath.type === 'pen' && this.state.currentPath.points.length > 1) || (this.state.currentPath.type === 'rect' && this.state.currentPath.bounds.w > 0)) {
                    data[pageKey].push(this.state.currentPath);
                }
                this.state.currentPath = null;
                this.redrawPageAnnotations();
            },

            undo() {
                const { pageKey, data } = this._getDataStore();
                if (data && data[pageKey] && data[pageKey].length > 0) {
                    data[pageKey].pop();
                    this.redrawPageAnnotations();
                }
            },
            clearCurrentPage() {
                const { pageKey, data } = this._getDataStore();
                if (data) {
                    data[pageKey] = [];
                    this.redrawPageAnnotations();
                    App.ui.showToast('Annotations for this view cleared.', 'info');
                }
            },
        },
        
        pdf: {
            state: {
                isInitialized: false,
                pdfDoc: null,
                currentPageText: null,
                pageNum: 1,
                pageRendering: false,
                pageNumPending: null,
                scale: 1.5,
                currentAttachment: null, 
                annotationsByPage: {},  
            },

            // --- NEW: PDF HIGHLIGHTS SUB-MODULE ---
            highlights: {
                add(text, className) {
                    const article = App.storage.getArticle(App.state.activeArticleId);
                    const attachment = App.pdf.state.currentAttachment;
                    if (!article || !attachment) return;

                    const attachmentIndex = article.attachments.findIndex(att => att.id === attachment.id);
                    if (attachmentIndex === -1) return;

                    if (!article.attachments[attachmentIndex].highlights) {
                        article.attachments[attachmentIndex].highlights = [];
                    }

                    const exists = article.attachments[attachmentIndex].highlights.some(h => 
                        h.page === App.pdf.state.pageNum && h.text === text && h.class === className
                    );

                    if (!exists) {
                        article.attachments[attachmentIndex].highlights.push({
                            page: App.pdf.state.pageNum,
                            text: text,
                            class: className
                        });
                        App.state.isArticleDirty = true; // Mark the main article for autosave
                    }
                },

                apply() {
                    const article = App.storage.getArticle(App.state.activeArticleId);
                    const attachment = App.pdf.state.currentAttachment;
                    const textContentDiv = document.getElementById('pdf-text-view-content');
                    const preElement = textContentDiv ? textContentDiv.querySelector('pre') : null;

                    if (!article || !attachment || !preElement || !attachment.highlights) return;

                    const pageHighlights = attachment.highlights.filter(h => h.page === App.pdf.state.pageNum);
                    if (pageHighlights.length === 0) return;

                    let content = preElement.textContent;

                    pageHighlights.forEach(highlight => {
                        if (!highlight.text) return;
                        const regex = new RegExp(App.util.escapeRegex(highlight.text), 'g');
                        const escapedHighlightText = App.util.escapeHtml(highlight.text);
                        content = content.replace(regex, `<span class="${highlight.class}">${escapedHighlightText}</span>`);
                    });
                    
                    preElement.innerHTML = content;
                },

                async copyPage() {
                    App.pdf.viewer.toggleMoreMenu(true);
                    const article = App.storage.getArticle(App.state.activeArticleId);
                    const attachment = App.pdf.state.currentAttachment;
                    if (!article || !attachment || !attachment.highlights) {
                        App.ui.showToast('No snips to copy.', 'info');
                        return;
                    }
                    const pageHighlights = attachment.highlights.filter(h => h.page === App.pdf.state.pageNum);
                    if (pageHighlights.length === 0) {
                        App.ui.showToast('No snips on this page to copy.', 'info');
                        return;
                    }

                    const textToCopy = pageHighlights.map(h => `â€¢ ${h.text}`).join('\n');
                    navigator.clipboard.writeText(textToCopy);
                    App.ui.showToast(`Copied ${pageHighlights.length} snip(s) from page ${App.pdf.state.pageNum}.`, 'success');

                    try {
                        const pdfName = App.util.escapeHtml(attachment.name.replace(/\.pdf$/i, ''));
                        const pageNum = App.pdf.state.pageNum;
                        const highlightsHtml = pageHighlights.map(h => `<li>${App.util.escapeHtml(h.text)}</li>`).join('');
                        const snippetHtml = `<blockquote><ul>${highlightsHtml}</ul><footer><small>â€” Snips extracted from page ${pageNum} of "${pdfName}"</small></footer></blockquote><p><br></p>`;
                        const updatedContent = article.content + snippetHtml;

                        const result = await App.storage.updateArticle(article.id, { content: updatedContent });
                        
                        if (result.success) {
                            App.ui.showToast('Page snips also added to your note!', 'success');
                        } else {
                            throw new Error('Failed to update the article.');
                        }
                    } catch (e) {
                        console.error('Failed to append page snips to article:', e);
                        App.ui.showToast('Could not add snips to note.', 'error');
                    }
                },

                async copyAll() {
                    App.pdf.viewer.toggleMoreMenu(true);
                    const article = App.storage.getArticle(App.state.activeArticleId);
                    const attachment = App.pdf.state.currentAttachment;
                    if (!article || !attachment || !attachment.highlights || attachment.highlights.length === 0) {
                        App.ui.showToast('No snips in this document to copy.', 'info');
                        return;
                    }

                    const highlightsByPage = attachment.highlights.reduce((acc, h) => {
                        (acc[h.page] = acc[h.page] || []).push(h.text);
                        return acc;
                    }, {});

                    let textToCopy = `Highlights from "${attachment.name.replace(/\.pdf$/i, '')}"\n\n`;
                    Object.keys(highlightsByPage).sort((a, b) => a - b).forEach(pageNum => {
                        textToCopy += `--- Page ${pageNum} ---\n`;
                        textToCopy += highlightsByPage[pageNum].map(text => `â€¢ ${text}`).join('\n') + '\n\n';
                    });
                    navigator.clipboard.writeText(textToCopy.trim());
                    App.ui.showToast(`Copied all ${attachment.highlights.length} snip(s).`, 'success');

                    try {
                        const pdfName = App.util.escapeHtml(attachment.name.replace(/\.pdf$/i, ''));
                        let allHighlightsHtml = '';
                        Object.keys(highlightsByPage).sort((a, b) => a - b).forEach(pageNum => {
                            allHighlightsHtml += `<p><b>Page ${pageNum}:</b></p><ul>`;
                            allHighlightsHtml += highlightsByPage[pageNum].map(text => `<li>${App.util.escapeHtml(text)}</li>`).join('');
                            allHighlightsHtml += '</ul>';
                        });

                        const snippetHtml = `<blockquote>${allHighlightsHtml}<footer><small>â€” All snips extracted from "${pdfName}"</small></footer></blockquote><p><br></p>`;
                        const updatedContent = article.content + snippetHtml;

                        const result = await App.storage.updateArticle(article.id, { content: updatedContent });

                        if (result.success) {
                            App.ui.showToast('All snips also added to your note!', 'success');
                        } else {
                            throw new Error('Failed to update the article.');
                        }
                    } catch (e) {
                        console.error('Failed to append all snips to article:', e);
                        App.ui.showToast('Could not add all snips to note.', 'error');
                    }
                },

                async clearPage() {
                    App.pdf.viewer.toggleMoreMenu(true); // Close the menu immediately

                    const article = App.storage.getArticle(App.state.activeArticleId);
                    const attachment = App.pdf.state.currentAttachment;
                    if (!article || !attachment || !attachment.highlights) {
                        App.ui.showToast('No highlights to clear on this page.', 'info');
                        return;
                    }

                    const attachmentIndex = article.attachments.findIndex(att => att.id === attachment.id);
                    if (attachmentIndex === -1) return;

                    const highlightsOnPage = article.attachments[attachmentIndex].highlights.some(h => h.page === App.pdf.state.pageNum);
                    if (!highlightsOnPage) {
                        App.ui.showToast('No highlights to clear on this page.', 'info');
                        return;
                    }
                    const highlightsToKeep = article.attachments[attachmentIndex].highlights.filter(h => h.page !== App.pdf.state.pageNum);

                    article.attachments[attachmentIndex].highlights = highlightsToKeep;

                    await App.events.saveArticle({ isAutosave: true });
                    await App.pdf.viewer.renderTextViewForPage(App.pdf.state.pageNum);
                    App.ui.showToast(`Page Snips Cleared`, 'success');
                },
            },
            

            init() {
                if (window.pdfjsLib) {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;
                }
                const input = document.getElementById('pdf-import-input');
                if (input) {
                    input.addEventListener('change', (e) => this.handleFileSelect(e));
                }
            },

            triggerImport() {
                if (!this.state.isInitialized) {
                    this.init();
                    this.state.isInitialized = true;
                }
                const input = document.getElementById('pdf-import-input');
                if (input) {
                    input.click();
                } else {
                    App.ui.showToast("PDF import feature is not properly configured.", "error");
                }
            },

            async handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file || file.type !== 'application/pdf') return;
                const toastId = App.ui.showToast('Attaching PDF...', { type: 'info', duration: 0 });
                try {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const fileData = {
                            id: 'pdf_' + crypto.randomUUID(),
                            name: file.name,
                            type: file.type,
                            data: e.target.result 
                        };
                        await this.saveAttachment(fileData);
                        this.insertAttachmentPill(fileData);
                        App.ui.hideToast(toastId);
                        App.ui.showToast(`Attached "${file.name}"`, 'success');
                    };
                    reader.readAsDataURL(file);
                } catch (err) {
                    App.ui.hideToast(toastId);
                    App.ui.showToast('Error attaching PDF.', 'error');
                } finally {
                    event.target.value = null;
                }
            },

            insertAttachmentPill(fileData) {
                const displayName = fileData.name.replace(/\.pdf$/i, '');
                const isWriteMode = App.state.currentMode === 'write';
                const pillHTML = `
                    <span class="pdf-attachment-pill" data-pdf-id="${fileData.id}" data-original-name="${App.util.escapeHtml(fileData.name)}">
                        <span class="pdf-attachment-name" contenteditable="${isWriteMode}">${App.util.escapeHtml(displayName)}</span>
                    </span>`;
                App.util.insertGuardianBlock(pillHTML);
            },

            async saveAttachment(fileData) {
                const articleId = App.state.activeArticleId;
                if (!articleId || articleId === 'temp_new_article') {
                    App.ui.showToast("Please save the note before attaching files.", 'warning');
                    return;
                }
                const article = App.storage.getArticle(articleId);
                if (!article) {
                    App.ui.showToast("Could not find the current article to save to.", 'error');
                    return;
                }
                const attachments = article.attachments || [];
                attachments.push(fileData);
                await App.storage.updateArticle(articleId, { attachments });
            },

            viewer: {
                toggleMoreMenu(forceClose = false) {
                    const menu = document.getElementById('pdf-more-menu');
                    if (!menu) return;
                    const closeHandler = (event) => {
                        const isClickInside = menu.contains(event.target) || event.target.closest('#pdf-more-btn');
                        if (!isClickInside) { this.toggleMoreMenu(true); }
                    };
                    if (forceClose || menu.classList.contains('visible')) {
                        menu.classList.remove('visible');
                        document.removeEventListener('click', closeHandler, true);
                    } else {
                        menu.classList.add('visible');
                        setTimeout(() => { document.addEventListener('click', closeHandler, { capture: true, once: true }); }, 0);
                    }
                },

                cycleTextViewFontSize() {
                    const fontSizes = ['0.9rem', '1.1rem', '1.3rem', '1.5rem', '1.7rem','1.8rem','2rem','2.2rem','2.5rem','2.8rem','3rem'];
                    const currentSize = App.settings.get('pdfTextViewFontSize') || '1.1rem';
                    const currentIndex = fontSizes.indexOf(currentSize);
                    const nextIndex = (currentIndex + 1) % fontSizes.length;
                    const newSize = fontSizes[nextIndex];
                    App.settings.set('pdfTextViewFontSize', newSize);
                    this.applyTextViewFontSize();
                    App.ui.showToast(`Font size: ${newSize}`, { duration: 1500 });
                },

                applyTextViewFontSize() {
                    const size = App.settings.get('pdfTextViewFontSize');
                    const textContentDiv = document.getElementById('pdf-text-view-content');
                    if (textContentDiv) { textContentDiv.style.fontSize = size; }
                },

                cycleTextViewTheme() {
                    const themes = App.events.presentation.themes;
                    const currentTheme = App.settings.get('pdfTextViewTheme') || 'default';
                    const currentIndex = themes.indexOf(currentTheme);
                    const nextIndex = (currentIndex + 1) % themes.length;
                    const newTheme = themes[nextIndex];
                    App.settings.set('pdfTextViewTheme', newTheme);
                    this.applyTextViewTheme();
                    const themeName = newTheme.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    App.ui.showToast(`${themeName} Theme`, { type: 'info', duration: 1500 });
                },

                applyTextViewTheme() {
                    const theme = App.settings.get('pdfTextViewTheme');
                    const container = document.getElementById('pdf-viewer-container');
                    if (!container) return;
                    container.className = container.className.replace(/\bambiance-\S+/g, '').trim();
                    if (theme && theme !== 'default') {
                        container.classList.add(`ambiance-${theme}`);
                    }
                },

                applyTextViewHighlight() {
                    const selection = window.getSelection();
                    if (!selection || selection.isCollapsed) {
                        App.ui.showToast('Please select text to highlight.', 'warning');
                        return;
                    }
                    const textToHighlight = selection.toString();
                    if (!textToHighlight) return;

                    App.pdf.highlights.add(textToHighlight, 'highlight-1');
                    this.renderTextViewForPage(App.pdf.state.pageNum);
                    selection.removeAllRanges();
                },

                toggleTextView() {
                    const container = document.getElementById('pdf-viewer-container');
                    const toggleBtn = document.getElementById('pdf-text-view-toggle');
                    if (!container || !toggleBtn) return;

                    if (App.annotationEngine.state.isActive) {
                        App.annotationEngine.toggle('pdf');
                    }

                    const isActive = container.classList.toggle('text-view-active');

                    if (isActive) {
                        toggleBtn.innerHTML = App.util.icons.pdf;
                        toggleBtn.title = 'Switch to PDF View';
                        toggleBtn.classList.add('active');
                        App.ui.showToast('Text View Enabled', { type: 'info' });
                    } else {
                        toggleBtn.innerHTML = App.util.icons.textView;
                        toggleBtn.title = 'Switch to Text View';
                        toggleBtn.classList.remove('active');
                        App.ui.showToast('PDF View Enabled', { type: 'info' });
                    }
                    this.queueRenderPage(App.pdf.state.pageNum);

                    this.toggleMoreMenu(true);
                },
                
                async capturePage() {
                    this.toggleMoreMenu(true);
                    const container = document.getElementById('pdf-viewer-container');
                    if (!container) return;

                    if (container.classList.contains('text-view-active')) {
                        const textContentDiv = document.getElementById('pdf-text-view-content');
                        if (!textContentDiv) { App.ui.showToast("Cannot find text content to copy.", "error"); return; }
                        try {
                            const htmlBlob = new Blob([textContentDiv.innerHTML], { type: 'text/html' });
                            const textBlob = new Blob([textContentDiv.innerText], { type: 'text/plain' });
                            await navigator.clipboard.write([ new ClipboardItem({ 'text/html': htmlBlob, 'text/plain': textBlob }) ]);
                            App.ui.showToast('Text view content copied!', 'success');
                        } catch (err) {
                            console.error('Failed to copy text content:', err);
                            App.ui.showToast('Could not copy text. Check browser permissions.', 'error');
                        }
                    } else {
                        if (typeof htmlToImage === 'undefined') { App.ui.showToast("Capture library is not available.", "error"); return; }
                        
                        const pageContainer = document.querySelector('.pdf-page-container');
                        if (!pageContainer) { App.ui.showToast("Cannot find PDF page to capture.", "error"); return; }
                        
                        const toastId = App.ui.showToast('Capturing page...', { type: 'info', duration: 0 });
                        try {
                            const blob = await htmlToImage.toBlob(pageContainer, { pixelRatio: window.devicePixelRatio || 2 });
                            await navigator.clipboard.write([ new ClipboardItem({ 'image/png': blob }) ]);
                            App.ui.hideToast(toastId);
                            App.ui.showToast('Page image with annotations copied to clipboard!', 'success');
                        } catch (err) {
                            App.ui.hideToast(toastId);
                            console.error('Failed to copy PDF page to clipboard:', err);
                            App.ui.showToast('Could not copy image. Check browser permissions.', 'error');
                        }
                    }
                },

                open(attachmentId) {
                    document.getElementById('kash-copilot-toggle').style.display = 'flex'; // <-- ADD THIS LINE
                    this.applyTextViewTheme();
                    const article = App.storage.getArticle(App.state.activeArticleId);
                    const attachment = article?.attachments?.find(att => att.id === attachmentId);
                    if (!attachment) { App.ui.showToast('Could not find attached PDF data.', 'error'); return; }

                    // Load existing annotations into the in-memory store
                    App.pdf.state.currentAttachment = attachment;
                    App.pdf.state.annotationsByPage = attachment.annotations ? JSON.parse(JSON.stringify(attachment.annotations)) : {};

                    App.annotationEngine.init();

                    document.body.classList.add('pdf-viewer-active');
                    const container = document.getElementById('pdf-viewer-container');
                    container.classList.add('visible');
                    const displayName = attachment.name.replace(/\.pdf$/i, '');

                    container.innerHTML = `
                        <div class="pdf-viewer-header">
                            <div class="pdf-viewer-controls">
                                <button id="pdf-thumbnails-toggle" class="btn-icon" title="Toggle Page Thumbnails (T)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M3 3h8v8H3V3m0 10h8v8H3v-8m10-10h8v8h-8V3m0 10h8v8h-8v-8z"/></svg></button>
                                <div class="control-divider"></div>
                                <button id="pdf-annotate-toggle" class="btn-icon" title="Toggle Annotation Mode (A)"></button>

                                <div id="pdf-annotation-toolbar" class="pdf-viewer-controls hidden">
                                    <div class="control-divider"></div>
                                    <button id="pdf-tool-rect" class="btn-icon" title="Rectangle Tool (R)"></button>
                                    <button id="pdf-tool-pen" class="btn-icon" title="Pen Tool (P)"></button>
                                    
                                    <button id="pdf-tool-eraser" class="btn-icon" title="Eraser Tool (E)"></button>
                                    <div class="control-divider"></div>
                                    <button id="pdf-color-cycler" class="btn-icon" style="border-radius: 50%;" title="Cycle Color (C)"></button>
                                    <button id="pdf-thickness-cycler" class="btn-icon" title="Cycle Thickness (T)"></button>
                                    <div class="control-divider"></div>
                                    <button id="pdf-undo-btn" class="btn-icon" title="Undo Last Annotation (U)">${App.util.icons.reset}</button>
                                    <button class="btn-icon" title="Clear Annotations on Page">${App.util.icons.trash}</button>
                                </div>
                            </div>
                            <span class="pdf-viewer-title" title="${App.util.escapeHtml(attachment.name)}">${App.util.escapeHtml(displayName)}</span>
                            <div class="pdf-viewer-controls">
                                <button id="pdf-prev" class="btn-icon" title="Previous Page (â†)"></button>
                                <span class="pdf-page-indicator"><input type="number" id="pdf-page-num" min="1"> &nbsp;of&nbsp; <span id="pdf-page-count"></span></span>
                                <button id="pdf-next" class="btn-icon" title="Next Page (â†’)"></button>
                                <div class="control-divider"></div>
                                <button id="pdf-text-highlight-btn" class="btn-icon text-view-only-btn"></button>
                                <button id="pdf-text-view-toggle" class="btn-icon" title="Switch to Text View"></button>
                                <button id="pdf-fullscreen-toggle" class="btn-icon" title="Toggle Fullscreen (F)"></button>
                                <div class="pdf-more-menu-container">
                                    <button id="pdf-more-btn" class="btn-icon" title="More Options"></button>
                                    <div id="pdf-more-menu" class="pdf-more-menu"></div>
                                </div>
                                <button id="pdf-close" class="btn-icon" title="Close Viewer (Esc)"></button>
                            </div>
                        </div>
                        <div class="pdf-viewer-main">
                            <div id="pdf-thumbnails-bar"></div>
                            <div class="pdf-viewer-canvas-wrapper">
                                <div class="pdf-page-container"><canvas id="pdf-viewer-canvas"></canvas></div>
                                <div id="pdf-text-view-content" class="ui-card"></div>
                            </div>
                        </div>`;

                    // Re-populate icons and re-attach listeners
                    const header = container.querySelector('.pdf-viewer-header');
                    header.querySelector('#pdf-annotate-toggle').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L6.832 19.82a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125" /></svg>`;
                    header.querySelector('#pdf-tool-pen').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 15c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/></svg>`;
                    header.querySelector('#pdf-tool-rect').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 7.5A2.25 2.25 0 017.5 5.25h9a2.25 2.25 0 012.25 2.25v9a2.25 2.25 0 01-2.25 2.25h-9a2.25 2.25 0 01-2.25-2.25v-9z" /></svg>`;
                    header.querySelector('#pdf-tool-eraser').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M11.25 4.5l7.5 7.5-7.5 7.5" /><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`;
                    header.querySelector('#pdf-thickness-cycler').innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3" fill="currentColor"/></svg>`;

                    header.querySelector('#pdf-prev').innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>';
                    header.querySelector('#pdf-next').innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>';
                    header.querySelector('#pdf-text-highlight-btn').innerHTML = App.util.icons.pen;
                    header.querySelector('#pdf-text-view-toggle').innerHTML = App.util.icons.textView;
                    header.querySelector('#pdf-fullscreen-toggle').innerHTML = App.util.icons.expand;
                    header.querySelector('#pdf-more-btn').innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>';
                    header.querySelector('#pdf-close').innerHTML = App.util.icons.close;
                    header.querySelector('#pdf-more-menu').innerHTML = `
                        <button class="btn btn-secondary mobile-only-btn" onclick="App.pdf.viewer.toggleThumbnails()"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M3 3h8v8H3V3m0 10h8v8H3v-8m10-10h8v8h-8V3m0 10h8v8h-8v-8z"/></svg> Page Snips</button>
                        <button class="btn btn-secondary mobile-only-btn" onclick="App.pdf.viewer.toggleFullscreen()">${App.util.icons.expand} Fullscreen</button>
                        <div class="control-divider mobile-only-btn" style="margin: 4px 8px; height: auto; width: calc(100% - 16px);"></div>
                        <button class="btn btn-secondary" id="pdf-zoom-out" title="Zoom Out (-)">${App.util.icons.zoomOut} Zoom Out</button>
                        <button class="btn btn-secondary" id="pdf-zoom-percent" title="Reset Zoom">100%</button>
                        <button class="btn btn-secondary" id="pdf-zoom-in" title="Zoom In (+)">${App.util.icons.zoomIn} Zoom In</button>
                        <div class="control-divider text-view-only-btn" style="margin: 4px 8px; height: auto; width: calc(100% - 16px);"></div>
                        <button id="pdf-text-font-size-toggle" class="btn btn-secondary text-view-only-btn" onclick="App.pdf.viewer.cycleTextViewFontSize()" title="Cycle Font Size">${App.util.icons.actions} Font Size</button>
                        <button id="pdf-text-theme-toggle" class="btn btn-secondary text-view-only-btn" onclick="App.pdf.viewer.cycleTextViewTheme()" title="Cycle Ambiance Theme">${App.util.icons.theme} Color Ambiance</button>
                        <button class="btn btn-secondary text-view-only-btn" onclick="App.pdf.highlights.copyPage()" title="Copy highlights from this page">${App.util.icons.copy} Page Snips</button>
                        <button class="btn btn-secondary text-view-only-btn" onclick="App.pdf.highlights.copyAll()" title="Copy all highlights from this document">${App.util.icons.copy} All Snips</button>
                        <button class="btn btn-danger text-view-only-btn" onclick="App.pdf.highlights.clearPage()" title="Permanently remove all highlights from this page">${App.util.icons.trash} Clear Snips</button>
                        <div class="control-divider" style="margin: 4px 8px; height: auto; width: calc(100% - 16px);"></div>
                        <button id="pdf-capture-btn" class="btn btn-secondary" onclick="App.pdf.viewer.capturePage()">${App.util.icons.save} Capture</button>
                        <button id="pdf-share" class="btn btn-secondary">${App.util.icons.actions} Share</button>
                    `;

                    document.getElementById('pdf-thumbnails-toggle').onclick = () => App.pdf.viewer.toggleThumbnails();
                    document.getElementById('pdf-prev').onclick = () => App.pdf.viewer.onPrevPage();
                    document.getElementById('pdf-next').onclick = () => App.pdf.viewer.onNextPage();
                    document.getElementById('pdf-page-num').addEventListener('change', (e) => App.pdf.viewer.goToPage(parseInt(e.target.value, 10)));
                    document.getElementById('pdf-zoom-in').onclick = () => App.pdf.viewer.zoom(0.1);
                    document.getElementById('pdf-zoom-out').onclick = () => App.pdf.viewer.zoom(-0.1);
                    document.getElementById('pdf-zoom-percent').onclick = () => App.pdf.viewer.zoom(0);
                    document.getElementById('pdf-text-view-toggle').onclick = () => App.pdf.viewer.toggleTextView();
                    document.getElementById('pdf-text-highlight-btn').onclick = () => App.pdf.viewer.applyTextViewHighlight();
                    document.getElementById('pdf-fullscreen-toggle').onclick = () => App.pdf.viewer.toggleFullscreen();
                    document.getElementById('pdf-more-btn').onclick = () => App.pdf.viewer.toggleMoreMenu();
                    document.getElementById('pdf-close').onclick = () => App.pdf.viewer.close();
                    document.getElementById('pdf-capture-btn').onclick = () => App.pdf.viewer.capturePage();
                    document.getElementById('pdf-text-font-size-toggle').onclick = () => App.pdf.viewer.cycleTextViewFontSize();
                    document.getElementById('pdf-text-theme-toggle').onclick = () => App.pdf.viewer.cycleTextViewTheme();

                    if (navigator.share) { 
                        document.getElementById('pdf-share').onclick = () => App.pdf.viewer.share(); 
                    } else { 
                        const shareBtn = document.getElementById('pdf-share');
                        if(shareBtn) shareBtn.style.display = 'none'; 
                    }

                    document.getElementById('pdf-annotate-toggle').onclick = () => App.annotationEngine.toggle('pdf');
                    document.getElementById('pdf-tool-pen').onclick = () => App.annotationEngine.setTool('pen');
                    document.getElementById('pdf-tool-rect').onclick = () => App.annotationEngine.setTool('rect');
                    document.getElementById('pdf-tool-eraser').onclick = () => App.annotationEngine.setTool('eraser');
                    document.getElementById('pdf-color-cycler').onclick = () => App.annotationEngine.cycleColor();
                    document.getElementById('pdf-thickness-cycler').onclick = () => App.annotationEngine.cycleThickness();
                    document.getElementById('pdf-undo-btn').onclick = () => App.annotationEngine.undo();
                    header.querySelector('button[title="Clear Annotations on Page"]').onclick = () => App.annotationEngine.clearCurrentPage();
                    document.addEventListener('keydown', this.handleKeyDown);

                    const pdfData = atob(attachment.data.substring(attachment.data.indexOf(',') + 1));
                    pdfjsLib.getDocument({ data: pdfData }).promise.then(pdfDoc_ => {
                        App.pdf.state.pdfDoc = pdfDoc_;
                        document.getElementById('pdf-page-count').textContent = App.pdf.state.pdfDoc.numPages;
                        document.getElementById('pdf-page-num').max = App.pdf.state.pdfDoc.numPages;
                        App.pdf.state.pageNum = 1;
                        this.renderPage(App.pdf.state.pageNum);
                        this.buildThumbnails();
                    });
                },

                async renderTextViewForPage(pageNum) {
                    if (!App.pdf.state.pdfDoc) return;
                    try {
                        const page = await App.pdf.state.pdfDoc.getPage(pageNum);
                        const textContent = await page.getTextContent();

                        const pageText = textContent.items.map(item => item.str).join(' ');
                        App.pdf.state.currentPageText = pageText;
                      
                        this.renderTextViewContent(textContent);
                    } catch (error) {
                        console.error(`Failed to render text view for page ${pageNum}:`, error);
                        App.pdf.state.currentPageText = null; // Clear text on error
                        const textContentDiv = document.getElementById('pdf-text-view-content');
                        if (textContentDiv) textContentDiv.innerHTML = '<p>Error loading text content for this page.</p>';
                    }
                },

                async getTextContentForPage(pageNum) {
                    if (!App.pdf.state.pdfDoc || pageNum < 1 || pageNum > App.pdf.state.pdfDoc.numPages) {
                        return "";
                    }
                    try {
                        const page = await App.pdf.state.pdfDoc.getPage(pageNum);
                        await page.getOperatorList(); 

                        const textContent = await page.getTextContent();
                        return textContent.items.map(item => item.str).join(' ');
                    } catch (error) {
                        console.error(`Failed to get text content for page ${pageNum}:`, error);
                        return "";
                    }
                },

                renderPage(num) {
                    App.pdf.state.pageRendering = true;
                    const container = document.getElementById('pdf-viewer-container');
                    const isInTextView = container.classList.contains('text-view-active');

                    App.pdf.state.pdfDoc.getPage(num).then(page => {
                        const pageContainer = document.querySelector('.pdf-page-container');
                        // Clear any old annotation layer to prevent duplicates
                        if (pageContainer.querySelector('#annotation-layer')) {
                            pageContainer.querySelector('#annotation-layer').remove();
                        }

                        if (!isInTextView) {
                            const canvas = document.getElementById('pdf-viewer-canvas');
                            const scale = App.pdf.state.scale;
                            const viewport = page.getViewport({ scale: scale });
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;

                            // Create a fresh annotation layer for the new page
                            const annotationLayer = document.createElement('canvas');
                            annotationLayer.id = 'annotation-layer';
                            annotationLayer.width = canvas.width;
                            annotationLayer.height = canvas.height;
                            pageContainer.appendChild(annotationLayer);

                            page.render({
                                canvasContext: canvas.getContext('2d'),
                                viewport: viewport
                            }).promise.then(() => {
                                App.pdf.state.pageRendering = false;
                                

                                App.annotationEngine.redrawPageAnnotations(num);
                                
                                if (App.annotationEngine.state.isActive) {
                                    const newCanvas = annotationLayer.cloneNode(true);
                                    annotationLayer.parentNode.replaceChild(newCanvas, annotationLayer);
                                    newCanvas.addEventListener('mousedown', App.annotationEngine.startDrawing.bind(App.annotationEngine));
                                    newCanvas.addEventListener('mousemove', App.annotationEngine.draw.bind(App.annotationEngine));
                                    newCanvas.addEventListener('mouseup', App.annotationEngine.stopDrawing.bind(App.annotationEngine));
                                    newCanvas.addEventListener('mouseleave', App.annotationEngine.stopDrawing.bind(App.annotationEngine));
                                    newCanvas.addEventListener('touchstart', (e) => App.annotationEngine.startDrawing(e.touches[0]), { passive: false });
                                    newCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); App.annotationEngine.draw(e.touches[0]); }, { passive: false });
                                    newCanvas.addEventListener('touchend', (e) => App.annotationEngine.stopDrawing(e.changedTouches[0]));
                                }
                                
                                if (App.pdf.state.pageNumPending !== null) {
                                    this.renderPage(App.pdf.state.pageNumPending);
                                    App.pdf.state.pageNumPending = null;
                                }
                            });
                        }

                        // The text view rendering remains unchanged.
                        this.renderTextViewForPage(num);

                        if (isInTextView) {
                            App.pdf.state.pageRendering = false;
                            if (App.pdf.state.pageNumPending !== null) {
                                this.renderPage(App.pdf.state.pageNumPending);
                                App.pdf.state.pageNumPending = null;
                            }
                        }
                    });

                    document.getElementById('pdf-page-num').value = num;
                    document.getElementById('pdf-zoom-percent').textContent = `${Math.round(App.pdf.state.scale * 100)}%`;
                    const thumbnailsBar = document.getElementById('pdf-thumbnails-bar');
                    if (thumbnailsBar) {
                        thumbnailsBar.querySelectorAll('.pdf-thumbnail.active').forEach(t => t.classList.remove('active'));
                        const activeThumbnail = thumbnailsBar.querySelector(`.pdf-thumbnail[data-page-num="${num}"]`);
                        if (activeThumbnail) {
                            activeThumbnail.classList.add('active');
                            activeThumbnail.scrollIntoView({ block: 'nearest' });
                        }
                    }
                },

                renderTextViewContent(textContent) {
                    const textContentDiv = document.getElementById('pdf-text-view-content');
                    if (!textContentDiv) return;

                    this.applyTextViewFontSize();
                    textContentDiv.innerHTML = '';

                    if (!textContent || textContent.items.length === 0) {
                        textContentDiv.innerHTML = '<p style="text-align: center; padding: 2rem;">No text content found on this page.</p>';
                        return;
                    }

                    const items = textContent.items;
                    let finalHtml = '';
                    let lastY = -1;
                    let lastX = -1;
                    const lineThreshold = 5;

                    const sortedItems = [...items].sort((a, b) => {
                        const yA = a.transform[5];
                        const yB = b.transform[5];
                        if (Math.abs(yA - yB) > lineThreshold) return yB - yA;
                        return a.transform[4] - b.transform[4];
                    });

                    sortedItems.forEach(item => {
                        if (!item.str.trim()) return;
                        const currentY = item.transform[5];
                        const currentX = item.transform[4];

                        if (lastY !== -1 && Math.abs(currentY - lastY) > lineThreshold) {
                            finalHtml += '\n';
                        }

                        if (lastY !== -1 && Math.abs(currentY - lastY) <= lineThreshold) {
                            const spaceWidth = 8;
                            const itemWidth = items.find(i => i.transform[4] === lastX)?.width || 0;
                            const gap = currentX - (lastX + itemWidth);
                            if (gap > spaceWidth) {
                                finalHtml += ' '.repeat(Math.round(gap / spaceWidth));
                            } else {
                                finalHtml += ' ';
                            }
                        }
                        
                        finalHtml += item.str;
                        lastY = currentY;
                        lastX = currentX;
                    });

                    const pre = document.createElement('pre');
                    pre.textContent = finalHtml.trim();
                    textContentDiv.appendChild(pre);

                    App.pdf.highlights.apply();
                },

                queueRenderPage(num) { if (App.pdf.state.pageRendering) { App.pdf.state.pageNumPending = num; } else { this.renderPage(num); } },
                onPrevPage() { if (App.pdf.state.pageNum <= 1) return; App.pdf.state.pageNum--; this.queueRenderPage(App.pdf.state.pageNum); },
                onNextPage() { if (App.pdf.state.pageNum >= App.pdf.state.pdfDoc.numPages) return; App.pdf.state.pageNum++; this.queueRenderPage(App.pdf.state.pageNum); },
                goToPage(num) {
                    const pageNum = Math.max(1, Math.min(App.pdf.state.pdfDoc.numPages, num));
                    if (pageNum !== App.pdf.state.pageNum) { App.pdf.state.pageNum = pageNum; this.queueRenderPage(pageNum); }
                },
                zoom(amount) {
                    if (amount === 0) App.pdf.state.scale = 1.0;
                    else App.pdf.state.scale = Math.max(0.5, Math.min(3, App.pdf.state.scale + amount));
                    this.queueRenderPage(App.pdf.state.pageNum);
                },
                toggleFullscreen() {
                    const container = document.getElementById('pdf-viewer-container');
                    if (!container) return;
                    container.classList.toggle('pdf-fullscreen-active');
                },

                handleKeyDown: (e) => {
                    if (App.coPilot.state.isOpen) return; 

                    if (e.target.id === 'pdf-page-num') return;
                    const isAnnotationActive = App.annotationEngine.state.isActive && App.annotationEngine.state.context === 'pdf';

                    switch (e.key.toLowerCase()) {
                        case 'escape': App.pdf.viewer.close(); break;
                        case 'arrowleft': if (!isAnnotationActive) App.pdf.viewer.onPrevPage(); break;
                        case 'arrowright': if (!isAnnotationActive) App.pdf.viewer.onNextPage(); break;
                        case '+': case '=': if (!isAnnotationActive) { App.pdf.viewer.zoom(0.1); e.preventDefault(); } break;
                        case '-': if (!isAnnotationActive) { App.pdf.viewer.zoom(-0.1); e.preventDefault(); } break;
                        case 't':
                            if (isAnnotationActive) App.annotationEngine.cycleThickness();
                            else App.pdf.viewer.toggleThumbnails();
                            break;
                        case 'f': App.pdf.viewer.toggleFullscreen(); break;
                        case 'a': App.annotationEngine.toggle('pdf'); break;
                        case 'p': if(isAnnotationActive) { App.annotationEngine.setTool('pen'); e.preventDefault(); } break;
                        case 'r': if(isAnnotationActive) { App.annotationEngine.setTool('rect'); e.preventDefault(); } break;
                        case 'e': if(isAnnotationActive) { App.annotationEngine.setTool('eraser'); e.preventDefault(); } break;
                    }
                },

                async share() {
                    const attachment = App.pdf.state.currentAttachment; if (!attachment || !navigator.share) return;
                    try {
                        const blob = App.util.dataURLtoBlob(attachment.data); if (!blob) throw new Error("Could not convert PDF data.");
                        const file = new File([blob], attachment.name, { type: blob.type });
                        if (navigator.canShare && navigator.canShare({ files: [file] })) { await navigator.share({ files: [file], title: attachment.name }); } 
                        else { App.ui.showToast("Cannot share this file type.", 'warning'); }
                    } catch (err) { if (err.name !== 'AbortError') App.ui.showToast("Could not share PDF.", 'error'); }
                },
                toggleThumbnails() {
                    const main = document.querySelector('.pdf-viewer-main'); const btn = document.getElementById('pdf-thumbnails-toggle');
                    if (main && btn) { main.classList.toggle('thumbnails-active'); btn.classList.toggle('active'); }
                },
                async buildThumbnails() {
                    const bar = document.getElementById('pdf-thumbnails-bar'); const doc = App.pdf.state.pdfDoc; bar.innerHTML = '';
                    for (let i = 1; i <= doc.numPages; i++) {
                        const page = await doc.getPage(i); const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); const viewport = page.getViewport({ scale: 0.2 });
                        canvas.width = viewport.width; canvas.height = viewport.height;
                        await page.render({ canvasContext: ctx, viewport: viewport, backgroundColor: '#FFFFFF' }).promise;
                        const thumbDiv = document.createElement('div'); thumbDiv.className = 'pdf-thumbnail'; thumbDiv.dataset.pageNum = i; thumbDiv.appendChild(canvas);
                        const pageLabel = document.createElement('span'); pageLabel.textContent = i; thumbDiv.appendChild(pageLabel);
                        thumbDiv.onclick = () => this.goToPage(i); bar.appendChild(thumbDiv);
                    }
                },

                async close() {
                    document.getElementById('kash-copilot-toggle').style.display = 'none';
                    if (App.coPilot.state.isOpen) App.coPilot.toggle();

                    if (App.annotationEngine.state.isActive) {
                        App.annotationEngine.toggle('pdf');
                    }

                
                    const annotationsWereChanged = this.saveAnnotationsToAttachment();

                    if (annotationsWereChanged) {
                        await App.events.saveArticle({ isAutosave: true });
                    }

                    const container = document.getElementById('pdf-viewer-container');
                    container.classList.remove('visible', 'text-view-active', 'annotation-active');
                    container.innerHTML = '';
                    document.removeEventListener('keydown', this.handleKeyDown);

                    App.pdf.state.pdfDoc = null;
                    App.pdf.state.pageNum = 1;
                    App.pdf.state.pageRendering = false;
                    App.pdf.state.pageNumPending = null;
                    App.pdf.state.currentAttachment = null;
                    App.pdf.state.annotationsByPage = {};
                    container.classList.remove('pdf-fullscreen-active');
                    document.body.classList.remove('pdf-viewer-active');
                },

                saveAnnotationsToAttachment() {
                    const article = App.storage.getArticle(App.state.activeArticleId);
                    const attachment = App.pdf.state.currentAttachment;
                    if (!article || !attachment) return false;

                    const attachmentIndex = article.attachments.findIndex(att => att.id === attachment.id);
                    if (attachmentIndex === -1) return false;

                    const currentAnnotations = JSON.stringify(article.attachments[attachmentIndex].annotations || {});
                    const newAnnotations = JSON.stringify(App.pdf.state.annotationsByPage);

                    if (currentAnnotations !== newAnnotations) {
                        article.attachments[attachmentIndex].annotations = JSON.parse(newAnnotations);
                        App.state.isArticleDirty = true;
                        App.ui.showToast('PDF annotations saved!', { type: 'success', duration: 1500 });
                        return true; 
                    }
                    return false; 
                },
            }
        },



        // ==========================================================================
        // 3.22. GLOBAL SEARCH MODULE (v2)
        // ==========================================================================
        globalSearch: {
            fuse: null,
            searchableData: [],
            selectedIndex: -1,
            results: [],
            isInitialized: false,

            els: {
                overlay: null, modal: null, input: null,
                resultsContainer: null, searchBtn: null,
            },

            commandRegistry: [
                { name: 'note', keywords: ['note', 'n'] },
                { name: 'task', keywords: ['task', 't'] }
            ],

            init() {
                this.els.overlay = document.getElementById('global-search-overlay');
                this.els.modal = document.getElementById('global-search-modal');
                this.els.input = document.getElementById('global-search-input');
                this.els.resultsContainer = document.getElementById('global-search-results');
                this.els.searchBtn = document.getElementById('global-search-btn');

                this.els.searchBtn.addEventListener('click', () => this.openSearch());
                this.els.overlay.addEventListener('click', (e) => { if (e.target === this.els.overlay) this.closeSearch(); });
                this.els.input.addEventListener('input', () => this.handleInput());
                document.addEventListener('keydown', (e) => this._handleKeyDown(e));
            },

            openSearch() {
                if (!this.isInitialized) this.buildIndex();
                this.els.overlay.classList.remove('hidden');
                this.els.input.value = '';
                this.els.resultsContainer.innerHTML = '';
                this.els.input.focus();
                this.els.input.style.height = 'auto';
                this.buildIndex();
            },

            closeSearch() {
                this.els.overlay.classList.add('hidden');
                this.els.modal.classList.remove('expanded-input');
            },
            
            handleInput() {
                this.selectedIndex = -1;
                const query = this.els.input.value;
                this.els.input.classList.toggle('expanded', query.includes('>>'));

                const lowerQuery = query.trim().toLowerCase();

                // NEW: Handle the "kashask:" command hint
                if (lowerQuery.startsWith('kashask')) {
                    let hintItem;
                    if (lowerQuery === 'kashask') {
                        hintItem = {
                            type: 'suggestion',
                            displayText: 'Add a colon and type your question...',
                            categoryText: 'e.g., kashask: who invented the lightbulb?'
                        };
                    } else if (lowerQuery === 'kashask:') {
                        hintItem = {
                            type: 'suggestion',
                            displayText: 'Type your question for the AI...',
                            categoryText: 'Press Enter to ask'
                        };
                    } else if (lowerQuery.startsWith('kashask:')) {
                        const promptText = query.substring(8).trim();
                        hintItem = {
                            type: 'suggestion',
                            displayText: `Ask AI: "${promptText}"`,
                            categoryText: 'Ready to ask...'
                        };
                    }
                    if (hintItem) {
                        this.results = [hintItem];
                        this._renderResults(this.results);
                        return; 
                    }
                }

                // 1. Handle Navigation Commands (%)
                if (lowerQuery.startsWith('%')) {
                    const navTerm = lowerQuery.substring(1);
                    const navCommands = [
                        { id: 'library', name: 'Go to Library', icon: 'ðŸ“š' },
                        { id: 'all-snippets', name: 'View All Snippets', icon: 'ðŸŒ' },
                        { id: 'new', name: 'Create New Article', icon: 'ðŸ“' },
                        { id: 'task', name: 'Go to Task Window', icon: 'âœ…' },
                        { id: 'study', name: 'Start Study Session', icon: 'ðŸ§‘â€ðŸŽ“' },
                        { id: 'quiz', name: 'Start a Quiz', icon: 'â“' },
                        { id: 'visual-map', name: 'Go to Visual Map', icon: 'ðŸ•¸ï¸' },
                        { id: 'mindmap', name: 'Go to Mind Map', icon: 'ðŸ§ ' },
                        { id: 'flashcard', name: 'Go to Flashcards', icon: 'ðŸ“‡' },
                        { id: 'stats-dashboard', name: 'Go to Stats', icon: 'ðŸ“Š' },
                        { id: 'tags', name: 'Go to Tags View', icon: 'ðŸ·ï¸' },
                        { id: 'settings', name: 'Go to Settings', icon: 'âš™ï¸' }
                    ];

                    const categoryCommands = App.config.categories.map(cat => ({
                        id: cat,
                        name: `Go to Category: ${App.util.getCategoryDisplayName(cat)}`,
                        icon: 'ðŸ“‚',
                        isCategory: true
                    }));

                    const flashcardCategoryCommands = App.config.categories.map(cat => ({
                        id: `flashcard-${cat.toLowerCase()}`,
                        name: `Go to Flashcard Deck: ${App.util.getCategoryDisplayName(cat)}`,
                        icon: 'ðŸ“‡',
                        isFlashcardCategory: true,
                        category: cat
                    }));

                    const allCommands = [...navCommands, ...categoryCommands, ...flashcardCategoryCommands];


                    if (navTerm === '') { // User just typed "%"
                        this.results = allCommands.map(cmd => ({ type: 'navigate', ...cmd }));
                    } else { // User is typing a command
                        this.results = allCommands
                            .filter(cmd => cmd.id.toLowerCase().startsWith(navTerm) || App.util.getCategoryDisplayName(cmd.id).toLowerCase().startsWith(navTerm))
                            .map(cmd => ({ type: 'navigate', ...cmd }));
                    }
                    this._renderResults(this.results);
                    return;
                }
                
                // New logic for the image filter
                if (lowerQuery.startsWith('image')) {
                    const searchTerm = lowerQuery.replace(/^image:?\s*/, '');
                    let itemsToSearch = this.searchableData.filter(item => item.type === 'image');

                    if (searchTerm.trim()) {
                        const fuse = new Fuse(itemsToSearch, { keys: ['title'], threshold: 0.4, includeScore: true });
                        this.results = fuse.search(searchTerm).map(r => r.item);
                    } else {
                        this.results = itemsToSearch;
                    }
                    this._renderResults(this.results);
                    return;
                }

                if (lowerQuery.startsWith('pdf')) {
                    const searchTerm = lowerQuery.replace(/^pdf:?\s*/, '');
                    let itemsToSearch = this.searchableData.filter(item => item.type === 'pdf');
                    if (searchTerm.trim()) {
                        const fuse = new Fuse(itemsToSearch, { keys: ['title', 'content'], threshold: 0.4, includeScore: true });
                        this.results = fuse.search(searchTerm).map(r => r.item);
                    } else {
                        this.results = itemsToSearch;
                    }
                    this._renderResults(this.results);
                    return;
                }

                const filterMatch = lowerQuery.match(/^(title|flashcard|snip|tag):\s*(.*)/);
                if (filterMatch) {
                    const typeMap = { snip: 'snippet', title: 'note' };
                    const searchType = typeMap[filterMatch[1]] || filterMatch[1];
                    const searchTerm = filterMatch[2];
                    
                    let itemsToSearch = this.searchableData.filter(item => item.type === searchType);
                    
                    if (searchTerm.trim()) {
                        const keys = searchType === 'note' ? ['title'] : ['title', 'content'];
                        const fuse = new Fuse(itemsToSearch, { keys: keys, threshold: 0.4, includeScore: true });
                        this.results = fuse.search(searchTerm).map(r => r.item);
                    } else {
                        this.results = itemsToSearch;
                    }
                    this._renderResults(this.results);
                    return;
                }

                const genericSearches = {
                    'title': { type: 'note', hint: 'Filter by title with "title: [term]"' },
                    'task': { type: 'task', hint: 'Create new: "task: your task name"' },
                    'flashcard': { type: 'flashcard', hint: 'Filter with "flashcard: [term]"' },
                    'tag': { type: 'tag', hint: 'Filter tags with "tag: [term]" or view snippets with "snip: [term]"' },
                    'snip': { type: 'snippet', hint: 'Filter snippets with "snip: [term]"' }
                };
                if (genericSearches[lowerQuery]) {
                    const config = genericSearches[lowerQuery];
                    const allItems = this.searchableData.filter(item => item.type === config.type);
                    const suggestion = {
                        type: 'suggestion',
                        displayText: config.hint,
                        categoryText: 'Command Hint'
                    };
                    this.results = [suggestion, ...allItems];
                    this._renderResults(this.results);
                    return;
                }

                const commandPrefix = this.commandRegistry.find(cmd => cmd.keywords.some(kw => lowerQuery.startsWith(kw + ':')));
                if (commandPrefix && !query.includes('>>')) {
                    let hint = '';
                    if (commandPrefix.name === 'note') {
                        hint = 'Syntax: `note:[category]: Title >> Content`';
                    } else if (commandPrefix.name === 'task') {
                        hint = 'Syntax: `task:[category]: Task Name #priority`';
                    }
                    this.results = [{ type: 'suggestion', displayText: hint, categoryText: 'Command Syntax Hint' }];
                    this._renderResults(this.results);
                    return;
                }

                const commandAction = this.parseCommand(query);
                if (commandAction) {
                    this.results = [commandAction];
                    this._renderResults(this.results);
                    return;
                }

                this.results = this.search(query);
                this._renderResults(this.results);
            },

            parseCommand(query) {
                const trimmedQuery = query.trim();
                const lowerQuery = trimmedQuery.toLowerCase();

                const command = this.commandRegistry.find(cmd => cmd.keywords.some(kw => lowerQuery.startsWith(kw + ':') || lowerQuery.startsWith(kw + ' ')));
                if (!command) return null;

                const findCategory = (catIdentifier) => {
                    
                    if (!catIdentifier) {
                        const defaultCat = App.settings.get('userCategories').find(c => c.isDefault);
                        return defaultCat ? defaultCat.name : 'General';
                    }
                    const lowerCat = catIdentifier.toLowerCase();
                    const userCategories = App.settings.get('userCategories');
                    const exactMatch = userCategories.find(c =>
                        (c.displayName && c.displayName.toLowerCase() === lowerCat) ||
                        c.name.toLowerCase() === lowerCat
                    );
                    if (exactMatch) return exactMatch.name;
                    const partialMatch = userCategories.find(c =>
                        (c.displayName && c.displayName.toLowerCase().startsWith(lowerCat)) ||
                        c.name.toLowerCase().startsWith(lowerCat)
                    );
                    if (partialMatch) return partialMatch.name;

                    const defaultCat = userCategories.find(c => c.isDefault);
                    return defaultCat ? defaultCat.name : 'General';
                };
                let action = { type: 'command', command: command.name };

                if (command.name === 'note') {
                    const noteRegex = /^(?:note|n):?(?:([^:]+):)?\s*(.*?)\s*>>\s*(.*)$/s;
                    const match = trimmedQuery.match(noteRegex);
                    if (!match) return null;
                    let [, category, title, content] = match;
                    if (!title.trim() && !content?.trim()) return null;
                    action.title = title.trim();
                    action.category = findCategory(category);
                    action.content = content ? App.util.textToHtml(content.trim()) : '<p><br></p>';
                    action.displayText = `Create Note: "${action.title}"`;
                    action.categoryText = `in ${App.util.getCategoryDisplayName(action.category)}`;
                } else if (command.name === 'task') {
                    const taskRegex = /^(?:task|t):?(?:([\w-]+):)?\s*(.*?)(?:\s*#(\w+))?$/;
                    const match = trimmedQuery.match(taskRegex);
                    if (!match) return null;
                    let [, category, title, priority] = match;
                    if (!title.trim()) return null;
                    action.title = title.trim().replace(/#(\w+)$/, '').trim();
                    action.category = findCategory(category);
                    const priorities = ['low', 'medium', 'high'];
                    action.priority = priorities.find(p => p.startsWith(priority?.toLowerCase())) || 'low';
                    action.displayText = `Create Task: "${action.title}"`;
                    action.categoryText = `Priority: ${action.priority}`;
                }
                return action;
            },

            buildIndex() {
                if (!App.state || (!App.state.articles && !App.state.tasks)) return;
                this.searchableData = [];
                
                (App.state.articles || []).forEach(note => this.searchableData.push({ id: note.id, type: 'note', title: note.title, content: note.content.substring(0, 100), action: 'openNote' }));
                (App.hub.state.tasks || []).forEach(task => this.searchableData.push({ id: task.id, type: 'task', title: task.title, action: 'openTask' }));
                
                
                (App.util.getAllFlashcards() || []).forEach(card => {
                    let title = '';
                    let content = '';

                    // Intelligently determine the primary text based on flashcard type
                    if (card.type === 'mcq') {
                        title = card.question || '';
                        content = (card.options || []).map(opt => opt.text).join(' ');
                    } else if (card.type === 'collapsible') {
                        title = card.frontText || '';
                        content = card.backText || '';
                    } else { // Default to cloze
                        title = card.fullText || '';
                    }

                    this.searchableData.push({ 
                        id: card.id, 
                        type: 'flashcard', 
                        title: title, 
                        content: content, 
                        action: 'openFlashcard', 
                        category: card.category 
                    });
                });
                
                Object.values(App.state.tags || {}).forEach(tag => this.searchableData.push({ id: tag.id, type: 'tag', title: tag.displayName, action: 'filterNotesByTag' }));

                const allSnippets = App.util.extractSnippets(null, ['highlight', 'tag']);

                
                // Process snippets, separating text from images
                allSnippets.forEach(snip => {
                    const article = App.storage.getArticle(snip.articleId);
                    if (!article) return;

                    if (snip.isImage) {
                        // This is our new logic to add images as a distinct type
                        this.searchableData.push({
                            ...snip,
                            type: 'image',
                            title: snip.text, // The caption is the searchable text
                            content: `In: ${article.title}`,
                            action: 'openImage' // A new action we will create
                        });
                    } else {
                        // This is the existing logic for text snippets
                        this.searchableData.push({
                            ...snip,
                            type: 'snippet',
                            title: snip.text,
                            content: `In: ${article.title}`,
                            action: 'openSnippet'
                        });
                    }
                });
                (App.state.articles || []).forEach(note => {
                    if (note.attachments && note.attachments.length > 0) {
                        note.attachments.forEach(attachment => {
                            if (attachment.type === 'application/pdf') {
                                this.searchableData.push({
                                    id: attachment.id,
                                    type: 'pdf',
                                    title: attachment.name.replace(/\.pdf$/i, ''),
                                    content: `In: ${note.title}`,
                                    action: 'openPdfArticle',
                                    articleId: note.id
                                });
                            }
                        });
                    }
                });

                const options = { includeScore: true, keys: ['title', 'content'], threshold: 0.4 };
                this.fuse = new Fuse(this.searchableData, options);
                this.isInitialized = true;
            },

            search(query) {
                if (!query || !this.fuse) { this.results = []; return []; }
                this.results = this.fuse.search(query).map(result => result.item);
                return this.results;
            },

            async executeAction(item) {
                if (!item) return;
                if (item.type === 'suggestion') return;

                if (item.type !== 'command') {
                    this.closeSearch();
                }

                switch (item.type) {
                    case 'navigate':
                        switch (item.id) {
                            case 'all-snippets':
                                App.router.navigateTo('category', 'All');
                                break;                
                            case 'flashcard':
                                await App.settings.set('flashcardCategory', 'All');
                                App.router.navigateTo('flashcard');
                                break;
                            case 'study':
                                App.events.study.start();
                                break;
                            case 'quiz':
                                App.quiz.start();
                                break;
                            case 'settings':
                                App.ui.showSettingsModal();
                                break;
                            case 'new':
                                App.events.createNewArticle();
                                break;
                            case 'task':
                                App.hub.ui.showProductivityModal();
                                break;
                            default:
                                if (item.isFlashcardCategory) {
                                    await App.settings.set('flashcardCategory', item.category);
                                    App.router.navigateTo('flashcard');
                                } else {
                                    const destination = item.isCategory ? 'category' : item.id;
                                    const data = item.isCategory ? item.id : null;
                                    App.router.navigateTo(destination, data);
                                }
                                break;
                             }
                    break;

                    case 'command':
                        switch (item.command) {
                            case 'note':
                                if (!App.license.isPremium() && App.state.articles.length >= App.config.sparkTierLimit) {
                                    App.ui.showAscensionModal();
                                    App.ui.showToast('Note limit reached. Go Premium for unlimited notes.', 'warning');
                                    this.closeSearch();
                                    return; // Stop execution
                                }
                                const noteData = { title: item.title, content: item.content, category: item.category };
                                const newNote = await App.storage.createArticle(noteData);
                                if (newNote) {
                                    App.ui.showToast(`Note "${newNote.title}" created!`, { type: 'success' });
                                    this.closeSearch();
                                    App.router.navigateTo('article', { id: newNote.id, mode: 'write' });
                                }
                                break;
                            case 'task':
                                App.hub.tasks.state.composer = { title: item.title, category: item.category, priority: item.priority, due: App.hub.util.getTodayISO(), pomodoroGoal: 0 };
                                await App.hub.tasks.add();
                                App.ui.showToast(`Task "${item.title}" created!`, {type: 'success'});
                                this.closeSearch();
                                break;
                        }
                        break;

                    default:
                        switch(item.action) {
                            case 'openNote':
                                App.router.navigateTo('article', {id: item.id, mode: 'read'});
                                break;
                            case 'openTask':
                                const task = App.hub.state.tasks.find(t => t.id === item.id);
                                if (task) {
                                    App.hub.pomodoro.startCycle(task);
                                    App.hub.ui.showProductivityModal();
                                }
                                break;
                            case 'openSnippet':
                                App.router.navigateTo('article', { id: item.articleId, mode: 'read', scrollToSnippetId: item.id });
                                break;
                            case 'openImage':
                                App.router.navigateTo('article', { id: item.articleId, mode: 'read', scrollToSnippetId: item.id });
                                break;
                            
                            case 'openPdfArticle':
                                App.router.navigateTo('article', { id: item.articleId, mode: 'read', scrollToSnippetId: item.id });
                                break;
                            case 'openFlashcard':
                                await App.settings.set('flashcardCategory', item.category);
                                App.router.navigateTo('flashcard');
                                break;
                            case 'filterNotesByTag':
                                App.events.showTagModal(item.id);
                                break;
                        }
                        break;
                }
            },
            
            _renderResults(results) {
                this.els.resultsContainer.innerHTML = '';

                const isPremium = App.license.isPremium();
                const searchLimit = 5;

                // RATIONALE: Changed from .push() to .unshift() to make the premium message the FIRST item.
                if (!isPremium && results.length > searchLimit) {
                    results = results.slice(0, searchLimit);
                    results.unshift({
                        type: 'premium-upsell',
                        title: 'Unlock Ultimate Search',
                        category: App.util.getRandomMessage(App.util.wittyDeveloperMessages),
                        icon: App.util.getTierBadgeHTML('Diamond', 24)
                    });
                }

                if (this.els.input.value && results.length === 0) {
                    this.els.resultsContainer.innerHTML = `<div class="no-results-item">No results found.</div>`; return;
                }

                
                results.forEach((item, index) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'search-result-item';
                    itemEl.dataset.index = index;

                    let icon, title, category;
                    if (item.type === 'ai_result') {
                        icon = item.icon;
                        title = `<div style="white-space: pre-wrap; line-height: 1.6;">${item.title}</div>`; // <-- The fix is removing App.util.escapeHtml()
                        category = item.category;
                        itemEl.addEventListener('click', () => {
                            this._saveKashAskResult(item.prompt, item.response);
                        });
                    } else if (item.type === 'command' || item.type === 'suggestion') {
                        icon = item.type === 'command' ? 'âš¡ï¸' : 'ðŸ’¡';
                        title = item.displayText;
                        category = item.categoryText;
                    } else if (item.type === 'premium-upsell') {
                        icon = item.icon;
                        title = item.title;
                        category = item.category;
                    } else if (item.type === 'navigate') {
                        icon = item.icon;
                        title = item.name;
                        category = 'Navigation Command';
                    } else {
                        const icons = {
                            note: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>`,
                            pdf: App.util.icons.pdf,
                            task: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><path d="m9 12 2 2 4-4"></path></svg>`,
                            flashcard: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg>`,
                            tag: `<svg viewBox="0 0 16 16" fill="currentColor"><path d="M2 2v4.586a1 1 0 0 0 .293.707l7 7a1 1 0 0 0 1.414 0l4.586-4.586a1 1 0 0 0 0-1.414l-7-7A1 1 0 0 0 7.586 2H2zm1 5.586 7 7L15.586 9l-7-7H3v4.586z"></path><path d="M5 5a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"></path></svg>`,
                            'tag-snippet': `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12.586 2.586a2 2 0 0 0-2.828 0L2.172 10.172a2 2 0 0 0 0 2.828l7.414 7.414a2 2 0 0 0 2.828 0l7.414-7.414a2 2 0 0 0 0-2.828L12.586 2.586z"></path><line x1="9" y1="9" x2="9.01" y2="9"></line></svg>`,
                            snippet: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 21h18M7 12v4h10v-4M5 12V3h14v9M11 3h2"></path></svg>`,
                            image: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>`
                        };
                        icon = icons[item.type] || 'ðŸ”';
                        category = (item.type === 'image' || item.type === 'tag-snippet') 
                            ? `Image in: ${App.storage.getArticle(item.articleId)?.title || 'Unknown'}`
                            : item.type;

                        if (item.type === 'image') {
                            title = `<div class="search-result-image-wrapper">
                                        <img src="${item.src}" alt="Image snippet">
                                        ${item.title ? `<div class="search-result-caption">${App.util.escapeHtml(item.title)}</div>` : ''}
                                    </div>`;
                        } else if ((item.type === 'snippet' || item.type === 'tag-snippet') && item.html) {
                            title = item.html;
                        } else if (item.type === 'tag') {
                            title = `<span class="rendered-tag">${item.title}</span>`;
                        } else if (item.type === 'flashcard') {
                            // Use our new cleaning utility for a beautiful display
                            title = App.util.escapeHtml(App.util.cleanFlashcardTextForDisplay(item.title));
                        } else {
                            title = App.util.escapeHtml(item.title);
                        }
                    }

                    itemEl.innerHTML = `<div class="result-icon">${icon}</div><div class="result-content"><div class="result-text">${title}</div><div class="result-category">${category}</div></div>`;

                    if (item.type === 'premium-upsell') {
                        itemEl.classList.add('selected'); 
                        itemEl.addEventListener('click', () => { App.ui.showAscensionModal(); this.closeSearch(); });
                    } else if (item.type !== 'suggestion') {
                        itemEl.addEventListener('click', () => { this.selectedIndex = index; this.executeAction(this.results[this.selectedIndex]); });
                    } else {
                        itemEl.style.opacity = '0.7';
                        itemEl.style.cursor = 'default';
                    }
                    this.els.resultsContainer.appendChild(itemEl);
                });

                if(results.length > 0){
                    this.selectedIndex = 0;
                    this._updateSelection();
                }
            },

            _handleKeyDown(e) {
                if (this.els.overlay.classList.contains('hidden')) return;

                // NEW: kashask logic takes priority on Enter key
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const query = this.els.input.value.trim();
                    if (query.toLowerCase().startsWith('kashask:')) {
                        this._executeKashAsk(query);
                        return; 
                    }
                }
                if (e.key === 'Tab') {
                    if (this.selectedIndex !== -1 && this.results[this.selectedIndex]?.type === 'ai_result') {
                        e.preventDefault(); // Prevent default browser behavior for Tab
                        const selectedItem = this.results[this.selectedIndex];
                        this._saveKashAskResult(selectedItem.prompt, selectedItem.response);
                        return;
                    }
                }

                if (e.key === 'Escape') { this.closeSearch(); }
                else if (e.key === 'ArrowDown') { e.preventDefault(); if (this.selectedIndex < this.results.length - 1) { this.selectedIndex++; this._updateSelection(); } }
                else if (e.key === 'ArrowUp') { e.preventDefault(); if (this.selectedIndex > 0) { this.selectedIndex--; this._updateSelection(); } }
                else if (e.key === 'Enter') { // This part remains for other searches
                    e.preventDefault();
                    if (this.selectedIndex !== -1 && this.results[this.selectedIndex]) {
                        this.executeAction(this.results[this.selectedIndex]);
                    }
                }
            },

            _executeKashAsk: async function(fullQuery) {
                const prompt = fullQuery.substring(8).trim();
                if (!prompt) {
                    App.ui.showToast("Please enter a question after 'kashask:'.", "warning");
                    return;
                }

                this.results = [{ type: 'suggestion', displayText: 'Your Second Brain is thinking...', categoryText: 'Please wait a moment.' }];
                this._renderResults(this.results);

                try {
                    const systemPrompt = "You are a knowledgeable and adaptive assistant. Analyze the userâ€™s prompt/question/query carefully and respond while Acting as Subject Expert of that field.  Use clear, natural language that fits the userâ€™s intent â€” concise for short factual queries, detailed for conceptual or how-to questions. You may freely choose the best structure (<p>, <b>, <i>, <ul>, <ol>, <li>, <small>) depending on context, you can also use revision tables (in html) wherever required and other things too. Always keep answers accurate, readable, in-depth and directly Useful. The final output must be reliable, stylish looking HTML ready for display. CRITICAL RULE: Your entire response must ONLY be HTML content itself. DO NOT include ```html, markdown fences, or any text outside of the HTML tags..";
                    const aiResponse = await App.services.ai.queryGenerativeAI(systemPrompt, prompt);

                    if (!aiResponse || !aiResponse.trim()) {
                        throw new Error("AI returned an empty response.");
                    }

                    const cleanedResponse = aiResponse.trim().replace(/(\r\n|\n|\r)/gm, "");

                    this.results = [{
                        type: 'ai_result',
                        title: cleanedResponse, // <-- Use the cleaned response
                        category: 'Click or Press Tab to save as New Note',
                        icon: 'âœ¨',
                        prompt: prompt,
                        response: cleanedResponse // <-- Use the cleaned response here too
                    }];
                    this._renderResults(this.results);
                    this.selectedIndex = 0;
                    this._updateSelection();

                } catch (error) {
                    console.error("KashAsk execution error:", error);
                    App.ui.showToast(`AI query failed: ${error.message}`, "error");
                    this.results = [{ type: 'suggestion', displayText: 'Sorry, the AI query failed.', categoryText: 'Please check your API key or try again.' }];
                    this._renderResults(this.results);
                }
            },

            _saveKashAskResult: async function(prompt, response) {
                try {
                    const category = (App.settings.get('userCategories').find(c => c.isDefault) || { name: 'General' }).name;
                    const noteData = {
                        title: prompt,
                        content: `<p>${response.replace(/\n/g, '</p><p>')}</p>`, // Convert newlines to paragraphs
                        category: category
                    };
                    const newNote = await App.storage.createArticle(noteData);
                    if (newNote) {
                        App.ui.showToast('Saved Article', 'success');
                        
                        if (App.router.getActiveView() === 'library') {
                            App.ui.filterAndRenderArticles();
                        }
                        
                        this.closeSearch();
                        
                    } else {
                        throw new Error("Failed to create the article file.");
                    }
                } catch (error) {
                    console.error("Failed to save KashAsk result:", error);
                    App.ui.showToast('Error saving the note.', 'error');
                }
            },

            _updateSelection() {
                const items = this.els.resultsContainer.querySelectorAll('.search-result-item');
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === this.selectedIndex);
                    if (index === this.selectedIndex) item.scrollIntoView({ block: 'nearest' });
                });
            },
        },


    };

    document.addEventListener('DOMContentLoaded', () => {
        App.init();
        App.globalSearch.init();
        App.commandPalette.init();
        App.coPilot.init();
        App.ui.aiMagic.init();
    });

    
    </script>

    <div id="global-search-overlay" class="hidden">
        <div id="global-search-modal">
            <div class="search-input-wrapper">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                <textarea id="global-search-input" placeholder="Search or create notes, tasks, flashcards and tags..." rows="1"></textarea>
            </div>
            <div id="global-search-results"></div>
            <div class="search-footer">
                <span>â†‘â†“ to navigate</span>
                <span>â†© to select</span>
                <span>ESC to close</span>
            </div>
     </div>
    </div>
    <div id="command-palette" role="dialog" aria-modal="true" style="display: none;">
        <div id="command-palette-input-wrapper">
            <input type="text" id="command-palette-input" placeholder="Type a command or search..." autocomplete="off">
        </div>
        <div id="command-palette-list"></div>
    </div>
    <div id="ascension-modal-backdrop" class="modal-backdrop" style="display: none;">
        <div class="modal-content ascension-modal ui-card">
            <button class="modal-close-btn" onclick="App.ui.closeAscensionModal()">&times;</button>
            <div id="ascension-witty-message" class="witty-gradient-text"></div>
            
            <h4>Choose Your Ascension</h4>
            <div class="ascension-badges-container">
                </div>
            
            <div class="ascension-features">
                <h5>Unlock Your Full Potential:</h5>
                <ul>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-circle-fill" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/></svg> Unlimited Notes & Flashcards</li>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-circle-fill" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/></svg> Unlimited Search Results</li>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-circle-fill" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/></svg> Advanced Pro Commands</li>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-circle-fill" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/></svg> All Export Options (PDF, MD)</li>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-circle-fill" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/></svg> All Themes & Fonts</li>
                    <li><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-circle-fill" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/></svg> Automatic Cloud Sync</li>
                </ul>
            </div>
            <div class="ascension-footer">
                <a href="#" id="ascension-contact-link">Prefer to Donate or Get the Discount? Contact me directly.</a>
            </div>
        </div>
    </div>
    <button id="kash-copilot-toggle" class="btn-icon" title="Toggle Kash Co-Pilot (Alt+A)" style="display: none;">
        </button>
    <div id="kash-copilot-sidebar" class="ui-card" style="display: none;">
        <div id="copilot-header">
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <button class="btn-icon" onclick="App.coPilot.clearConversation()" title="Clear Conversation">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M2.5 1a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1H3v9a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V4h.5a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H10a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1H2.5zM8 5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7A.5.5 0 0 1 8 5zm3 .5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 1 0z"/></svg>
                </button>
                <button class="btn-icon" onclick="App.coPilot.saveConversationAsNote()" title="Save Conversation as New Note">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8.5 6.5a.5.5 0 0 0-1 0V8H6a.5.5 0 0 0 0 1h1.5v1.5a.5.5 0 0 0 1 0V9H10a.5.5 0 0 0 0-1H8.5V6.5z"/><path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z"/></svg>
                </button>
            </div>
            <span class="witty-gradient-text">NoteKash AI</span>
            <button class="btn-icon" onclick="App.coPilot.toggle()" title="Close Co-Pilot (Esc)">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
        </div>
        <div id="copilot-conversation-area">
            </div>
        <div id="copilot-input-container">
            <div id="copilot-command-list" class="context-menu" style="display: none; bottom: 100%; width: 95%; left: 2.5%; margin-bottom: 5px;"></div>
            <textarea id="copilot-input" placeholder="Ask anything, or give a command..." rows="1"></textarea>
            <button id="copilot-send-btn" class="btn-icon btn-primary" title="Send (Enter)">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16"><path d="M15.854.146a.5.5 0 0 1 .11.54l-5.819 14.547a.75.75 0 0 1-1.329.124l-3.178-4.995L.643 7.184a.75.75 0 0 1 .124-1.33L15.314.037a.5.5 0 0 1 .54.11zM6.636 10.07l2.761 4.338L14.13 2.576 6.636 10.07zm6.787-8.201L1.591 6.602l4.339 2.76 7.494-7.493z"/></svg>
            </button>
        </div>
    </div>

</body>
</html>
